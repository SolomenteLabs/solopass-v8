import {
  require_pako,
  require_query as require_query14,
  require_tx as require_tx15,
  require_types
} from "./chunk-FLSA4DPH.js";
import {
  require_abci,
  require_auth,
  require_browser,
  require_gov,
  require_keys,
  require_keys2,
  require_keys3,
  require_libsodium_wrappers,
  require_pagination,
  require_query,
  require_query10,
  require_query11,
  require_query12,
  require_query13,
  require_query2,
  require_query3,
  require_query4,
  require_query5,
  require_query6,
  require_query7,
  require_query8,
  require_query9,
  require_ripemd160,
  require_service,
  require_sha3,
  require_tendermint,
  require_tx as require_tx2,
  require_tx10 as require_tx11,
  require_tx11 as require_tx12,
  require_tx12 as require_tx13,
  require_tx13 as require_tx14,
  require_tx2 as require_tx3,
  require_tx3 as require_tx4,
  require_tx4 as require_tx5,
  require_tx5 as require_tx6,
  require_tx6 as require_tx7,
  require_tx7 as require_tx8,
  require_tx8 as require_tx9,
  require_tx9 as require_tx10,
  require_vesting,
  require_xstream
} from "./chunk-P5FOV5JM.js";
import {
  require_any,
  require_coin,
  require_multisig,
  require_signing,
  require_tx
} from "./chunk-VL4JX4WA.js";
import {
  require_bech32,
  require_bn,
  require_crypto,
  require_hmac,
  require_pbkdf2,
  require_sha2,
  require_sha256,
  require_sha512,
  require_utils
} from "./chunk-2OGY5FFR.js";
import {
  require_base64_js
} from "./chunk-N6KZBFW2.js";
import {
  __commonJS
} from "./chunk-JE6AHIQZ.js";

// ../../node_modules/.pnpm/@cosmjs+encoding@0.34.0/node_modules/@cosmjs/encoding/build/ascii.js
var require_ascii = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+encoding@0.34.0/node_modules/@cosmjs/encoding/build/ascii.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.toAscii = toAscii;
    exports.fromAscii = fromAscii;
    function toAscii(input) {
      const toNums = (str) => str.split("").map((x) => {
        const charCode = x.charCodeAt(0);
        if (charCode < 32 || charCode > 126) {
          throw new Error("Cannot encode character that is out of printable ASCII range: " + charCode);
        }
        return charCode;
      });
      return Uint8Array.from(toNums(input));
    }
    function fromAscii(data) {
      const fromNums = (listOfNumbers) => listOfNumbers.map((x) => {
        if (x < 32 || x > 126) {
          throw new Error("Cannot decode character that is out of printable ASCII range: " + x);
        }
        return String.fromCharCode(x);
      });
      return fromNums(Array.from(data)).join("");
    }
  }
});

// ../../node_modules/.pnpm/@cosmjs+encoding@0.34.0/node_modules/@cosmjs/encoding/build/base64.js
var require_base64 = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+encoding@0.34.0/node_modules/@cosmjs/encoding/build/base64.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function() {
      var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o2) {
          var ar = [];
          for (var k in o2)
            if (Object.prototype.hasOwnProperty.call(o2, k))
              ar[ar.length] = k;
          return ar;
        };
        return ownKeys(o);
      };
      return function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k = ownKeys(mod), i = 0; i < k.length; i++)
            if (k[i] !== "default")
              __createBinding(result, mod, k[i]);
        }
        __setModuleDefault(result, mod);
        return result;
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.toBase64 = toBase64;
    exports.fromBase64 = fromBase64;
    var base64js = __importStar(require_base64_js());
    function toBase64(data) {
      return base64js.fromByteArray(data);
    }
    function fromBase64(base64String) {
      if (!base64String.match(/^[a-zA-Z0-9+/]*={0,2}$/)) {
        throw new Error("Invalid base64 string format");
      }
      return base64js.toByteArray(base64String);
    }
  }
});

// ../../node_modules/.pnpm/@cosmjs+encoding@0.34.0/node_modules/@cosmjs/encoding/build/bech32.js
var require_bech322 = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+encoding@0.34.0/node_modules/@cosmjs/encoding/build/bech32.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function() {
      var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o2) {
          var ar = [];
          for (var k in o2)
            if (Object.prototype.hasOwnProperty.call(o2, k))
              ar[ar.length] = k;
          return ar;
        };
        return ownKeys(o);
      };
      return function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k = ownKeys(mod), i = 0; i < k.length; i++)
            if (k[i] !== "default")
              __createBinding(result, mod, k[i]);
        }
        __setModuleDefault(result, mod);
        return result;
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.toBech32 = toBech32;
    exports.fromBech32 = fromBech32;
    exports.normalizeBech32 = normalizeBech32;
    var bech32 = __importStar(require_bech32());
    function toBech32(prefix, data, limit) {
      const address = bech32.encode(prefix, bech32.toWords(data), limit);
      return address;
    }
    function fromBech32(address, limit = Infinity) {
      const decodedAddress = bech32.decode(address, limit);
      return {
        prefix: decodedAddress.prefix,
        data: new Uint8Array(bech32.fromWords(decodedAddress.words))
      };
    }
    function normalizeBech32(address) {
      const { prefix, data } = fromBech32(address);
      return toBech32(prefix, data);
    }
  }
});

// ../../node_modules/.pnpm/@cosmjs+encoding@0.34.0/node_modules/@cosmjs/encoding/build/hex.js
var require_hex = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+encoding@0.34.0/node_modules/@cosmjs/encoding/build/hex.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.toHex = toHex;
    exports.fromHex = fromHex;
    function toHex(data) {
      let out = "";
      for (const byte of data) {
        out += ("0" + byte.toString(16)).slice(-2);
      }
      return out;
    }
    function fromHex(hexstring) {
      if (hexstring.length % 2 !== 0) {
        throw new Error("hex string length must be a multiple of 2");
      }
      const out = new Uint8Array(hexstring.length / 2);
      for (let i = 0; i < out.length; i++) {
        const j = 2 * i;
        const hexByteAsString = hexstring.slice(j, j + 2);
        if (!hexByteAsString.match(/[0-9a-f]{2}/i)) {
          throw new Error("hex string contains invalid characters");
        }
        out[i] = parseInt(hexByteAsString, 16);
      }
      return out;
    }
  }
});

// ../../node_modules/.pnpm/@cosmjs+encoding@0.34.0/node_modules/@cosmjs/encoding/build/rfc3339.js
var require_rfc3339 = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+encoding@0.34.0/node_modules/@cosmjs/encoding/build/rfc3339.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.fromRfc3339 = fromRfc3339;
    exports.toRfc3339 = toRfc3339;
    var rfc3339Matcher = /^(\d{4})-(\d{2})-(\d{2})[T ](\d{2}):(\d{2}):(\d{2})(\.\d{1,9})?((?:[+-]\d{2}:\d{2})|Z)$/;
    function padded(integer, length = 2) {
      return integer.toString().padStart(length, "0");
    }
    function fromRfc3339(str) {
      const matches = rfc3339Matcher.exec(str);
      if (!matches) {
        throw new Error("Date string is not in RFC3339 format");
      }
      const year = +matches[1];
      const month = +matches[2];
      const day = +matches[3];
      const hour = +matches[4];
      const minute = +matches[5];
      const second = +matches[6];
      const milliSeconds = matches[7] ? Math.floor(+matches[7] * 1e3) : 0;
      let tzOffsetSign;
      let tzOffsetHours;
      let tzOffsetMinutes;
      if (matches[8] === "Z") {
        tzOffsetSign = 1;
        tzOffsetHours = 0;
        tzOffsetMinutes = 0;
      } else {
        tzOffsetSign = matches[8].substring(0, 1) === "-" ? -1 : 1;
        tzOffsetHours = +matches[8].substring(1, 3);
        tzOffsetMinutes = +matches[8].substring(4, 6);
      }
      const tzOffset = tzOffsetSign * (tzOffsetHours * 60 + tzOffsetMinutes) * 60;
      const date = /* @__PURE__ */ new Date();
      date.setUTCFullYear(year, month - 1, day);
      date.setUTCHours(hour, minute, second, milliSeconds);
      return new Date(date.getTime() - tzOffset * 1e3);
    }
    function toRfc3339(date) {
      const year = date.getUTCFullYear();
      const month = padded(date.getUTCMonth() + 1);
      const day = padded(date.getUTCDate());
      const hour = padded(date.getUTCHours());
      const minute = padded(date.getUTCMinutes());
      const second = padded(date.getUTCSeconds());
      const ms = padded(date.getUTCMilliseconds(), 3);
      return `${year}-${month}-${day}T${hour}:${minute}:${second}.${ms}Z`;
    }
  }
});

// ../../node_modules/.pnpm/@cosmjs+encoding@0.34.0/node_modules/@cosmjs/encoding/build/utf8.js
var require_utf8 = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+encoding@0.34.0/node_modules/@cosmjs/encoding/build/utf8.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.toUtf8 = toUtf8;
    exports.fromUtf8 = fromUtf8;
    function toUtf8(str) {
      return new TextEncoder().encode(str);
    }
    function fromUtf8(data, lossy = false) {
      const fatal = !lossy;
      return new TextDecoder("utf-8", { fatal }).decode(data);
    }
  }
});

// ../../node_modules/.pnpm/@cosmjs+encoding@0.34.0/node_modules/@cosmjs/encoding/build/index.js
var require_build = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+encoding@0.34.0/node_modules/@cosmjs/encoding/build/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.toUtf8 = exports.fromUtf8 = exports.toRfc3339 = exports.fromRfc3339 = exports.toHex = exports.fromHex = exports.toBech32 = exports.normalizeBech32 = exports.fromBech32 = exports.toBase64 = exports.fromBase64 = exports.toAscii = exports.fromAscii = void 0;
    var ascii_1 = require_ascii();
    Object.defineProperty(exports, "fromAscii", { enumerable: true, get: function() {
      return ascii_1.fromAscii;
    } });
    Object.defineProperty(exports, "toAscii", { enumerable: true, get: function() {
      return ascii_1.toAscii;
    } });
    var base64_1 = require_base64();
    Object.defineProperty(exports, "fromBase64", { enumerable: true, get: function() {
      return base64_1.fromBase64;
    } });
    Object.defineProperty(exports, "toBase64", { enumerable: true, get: function() {
      return base64_1.toBase64;
    } });
    var bech32_1 = require_bech322();
    Object.defineProperty(exports, "fromBech32", { enumerable: true, get: function() {
      return bech32_1.fromBech32;
    } });
    Object.defineProperty(exports, "normalizeBech32", { enumerable: true, get: function() {
      return bech32_1.normalizeBech32;
    } });
    Object.defineProperty(exports, "toBech32", { enumerable: true, get: function() {
      return bech32_1.toBech32;
    } });
    var hex_1 = require_hex();
    Object.defineProperty(exports, "fromHex", { enumerable: true, get: function() {
      return hex_1.fromHex;
    } });
    Object.defineProperty(exports, "toHex", { enumerable: true, get: function() {
      return hex_1.toHex;
    } });
    var rfc3339_1 = require_rfc3339();
    Object.defineProperty(exports, "fromRfc3339", { enumerable: true, get: function() {
      return rfc3339_1.fromRfc3339;
    } });
    Object.defineProperty(exports, "toRfc3339", { enumerable: true, get: function() {
      return rfc3339_1.toRfc3339;
    } });
    var utf8_1 = require_utf8();
    Object.defineProperty(exports, "fromUtf8", { enumerable: true, get: function() {
      return utf8_1.fromUtf8;
    } });
    Object.defineProperty(exports, "toUtf8", { enumerable: true, get: function() {
      return utf8_1.toUtf8;
    } });
  }
});

// ../../node_modules/.pnpm/@cosmjs+math@0.34.0/node_modules/@cosmjs/math/build/decimal.js
var require_decimal = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+math@0.34.0/node_modules/@cosmjs/math/build/decimal.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Decimal = void 0;
    var bn_js_1 = __importDefault(require_bn());
    var maxFractionalDigits = 100;
    var Decimal = class _Decimal {
      static fromUserInput(input, fractionalDigits) {
        _Decimal.verifyFractionalDigits(fractionalDigits);
        const badCharacter = input.match(/[^0-9.]/);
        if (badCharacter) {
          throw new Error(`Invalid character at position ${badCharacter.index + 1}`);
        }
        let whole;
        let fractional;
        if (input === "") {
          whole = "0";
          fractional = "";
        } else if (input.search(/\./) === -1) {
          whole = input;
          fractional = "";
        } else {
          const parts = input.split(".");
          switch (parts.length) {
            case 0:
            case 1:
              throw new Error("Fewer than two elements in split result. This must not happen here.");
            case 2:
              if (!parts[1])
                throw new Error("Fractional part missing");
              whole = parts[0];
              fractional = parts[1].replace(/0+$/, "");
              break;
            default:
              throw new Error("More than one separator found");
          }
        }
        if (fractional.length > fractionalDigits) {
          throw new Error("Got more fractional digits than supported");
        }
        const quantity = `${whole}${fractional.padEnd(fractionalDigits, "0")}`;
        return new _Decimal(quantity, fractionalDigits);
      }
      static fromAtomics(atomics, fractionalDigits) {
        _Decimal.verifyFractionalDigits(fractionalDigits);
        return new _Decimal(atomics, fractionalDigits);
      }
      /**
       * Creates a Decimal with value 0.0 and the given number of fractial digits.
       *
       * Fractional digits are not relevant for the value but needed to be able
       * to perform arithmetic operations with other decimals.
       */
      static zero(fractionalDigits) {
        _Decimal.verifyFractionalDigits(fractionalDigits);
        return new _Decimal("0", fractionalDigits);
      }
      /**
       * Creates a Decimal with value 1.0 and the given number of fractial digits.
       *
       * Fractional digits are not relevant for the value but needed to be able
       * to perform arithmetic operations with other decimals.
       */
      static one(fractionalDigits) {
        _Decimal.verifyFractionalDigits(fractionalDigits);
        return new _Decimal("1" + "0".repeat(fractionalDigits), fractionalDigits);
      }
      static verifyFractionalDigits(fractionalDigits) {
        if (!Number.isInteger(fractionalDigits))
          throw new Error("Fractional digits is not an integer");
        if (fractionalDigits < 0)
          throw new Error("Fractional digits must not be negative");
        if (fractionalDigits > maxFractionalDigits) {
          throw new Error(`Fractional digits must not exceed ${maxFractionalDigits}`);
        }
      }
      static compare(a, b) {
        if (a.fractionalDigits !== b.fractionalDigits)
          throw new Error("Fractional digits do not match");
        return a.data.atomics.cmp(new bn_js_1.default(b.atomics));
      }
      get atomics() {
        return this.data.atomics.toString();
      }
      get fractionalDigits() {
        return this.data.fractionalDigits;
      }
      constructor(atomics, fractionalDigits) {
        if (!atomics.match(/^[0-9]+$/)) {
          throw new Error("Invalid string format. Only non-negative integers in decimal representation supported.");
        }
        this.data = {
          atomics: new bn_js_1.default(atomics),
          fractionalDigits
        };
      }
      /** Creates a new instance with the same value */
      clone() {
        return new _Decimal(this.atomics, this.fractionalDigits);
      }
      /** Returns the greatest decimal <= this which has no fractional part (rounding down) */
      floor() {
        const factor = new bn_js_1.default(10).pow(new bn_js_1.default(this.data.fractionalDigits));
        const whole = this.data.atomics.div(factor);
        const fractional = this.data.atomics.mod(factor);
        if (fractional.isZero()) {
          return this.clone();
        } else {
          return _Decimal.fromAtomics(whole.mul(factor).toString(), this.fractionalDigits);
        }
      }
      /** Returns the smallest decimal >= this which has no fractional part (rounding up) */
      ceil() {
        const factor = new bn_js_1.default(10).pow(new bn_js_1.default(this.data.fractionalDigits));
        const whole = this.data.atomics.div(factor);
        const fractional = this.data.atomics.mod(factor);
        if (fractional.isZero()) {
          return this.clone();
        } else {
          return _Decimal.fromAtomics(whole.addn(1).mul(factor).toString(), this.fractionalDigits);
        }
      }
      toString() {
        const factor = new bn_js_1.default(10).pow(new bn_js_1.default(this.data.fractionalDigits));
        const whole = this.data.atomics.div(factor);
        const fractional = this.data.atomics.mod(factor);
        if (fractional.isZero()) {
          return whole.toString();
        } else {
          const fullFractionalPart = fractional.toString().padStart(this.data.fractionalDigits, "0");
          const trimmedFractionalPart = fullFractionalPart.replace(/0+$/, "");
          return `${whole.toString()}.${trimmedFractionalPart}`;
        }
      }
      /**
       * Returns an approximation as a float type. Only use this if no
       * exact calculation is required.
       */
      toFloatApproximation() {
        const out = Number(this.toString());
        if (Number.isNaN(out))
          throw new Error("Conversion to number failed");
        return out;
      }
      /**
       * a.plus(b) returns a+b.
       *
       * Both values need to have the same fractional digits.
       */
      plus(b) {
        if (this.fractionalDigits !== b.fractionalDigits)
          throw new Error("Fractional digits do not match");
        const sum = this.data.atomics.add(new bn_js_1.default(b.atomics));
        return new _Decimal(sum.toString(), this.fractionalDigits);
      }
      /**
       * a.minus(b) returns a-b.
       *
       * Both values need to have the same fractional digits.
       * The resulting difference needs to be non-negative.
       */
      minus(b) {
        if (this.fractionalDigits !== b.fractionalDigits)
          throw new Error("Fractional digits do not match");
        const difference = this.data.atomics.sub(new bn_js_1.default(b.atomics));
        if (difference.ltn(0))
          throw new Error("Difference must not be negative");
        return new _Decimal(difference.toString(), this.fractionalDigits);
      }
      /**
       * a.multiply(b) returns a*b.
       *
       * We only allow multiplication by unsigned integers to avoid rounding errors.
       */
      multiply(b) {
        const product = this.data.atomics.mul(new bn_js_1.default(b.toString()));
        return new _Decimal(product.toString(), this.fractionalDigits);
      }
      equals(b) {
        return _Decimal.compare(this, b) === 0;
      }
      isLessThan(b) {
        return _Decimal.compare(this, b) < 0;
      }
      isLessThanOrEqual(b) {
        return _Decimal.compare(this, b) <= 0;
      }
      isGreaterThan(b) {
        return _Decimal.compare(this, b) > 0;
      }
      isGreaterThanOrEqual(b) {
        return _Decimal.compare(this, b) >= 0;
      }
    };
    exports.Decimal = Decimal;
  }
});

// ../../node_modules/.pnpm/@cosmjs+math@0.34.0/node_modules/@cosmjs/math/build/integers.js
var require_integers = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+math@0.34.0/node_modules/@cosmjs/math/build/integers.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Uint64 = exports.Uint53 = exports.Int53 = exports.Uint32 = void 0;
    var bn_js_1 = __importDefault(require_bn());
    var uint64MaxValue = new bn_js_1.default("18446744073709551615", 10, "be");
    var Uint32 = class _Uint32 {
      /** @deprecated use Uint32.fromBytes */
      static fromBigEndianBytes(bytes) {
        return _Uint32.fromBytes(bytes);
      }
      /**
       * Creates a Uint32 from a fixed length byte array.
       *
       * @param bytes a list of exactly 4 bytes
       * @param endianess defaults to big endian
       */
      static fromBytes(bytes, endianess = "be") {
        if (bytes.length !== 4) {
          throw new Error("Invalid input length. Expected 4 bytes.");
        }
        for (let i = 0; i < bytes.length; ++i) {
          if (!Number.isInteger(bytes[i]) || bytes[i] > 255 || bytes[i] < 0) {
            throw new Error("Invalid value in byte. Found: " + bytes[i]);
          }
        }
        const beBytes = endianess === "be" ? bytes : Array.from(bytes).reverse();
        return new _Uint32(beBytes[0] * 2 ** 24 + beBytes[1] * 2 ** 16 + beBytes[2] * 2 ** 8 + beBytes[3]);
      }
      static fromString(str) {
        if (!str.match(/^[0-9]+$/)) {
          throw new Error("Invalid string format");
        }
        return new _Uint32(Number.parseInt(str, 10));
      }
      constructor(input) {
        if (Number.isNaN(input)) {
          throw new Error("Input is not a number");
        }
        if (!Number.isInteger(input)) {
          throw new Error("Input is not an integer");
        }
        if (input < 0 || input > 4294967295) {
          throw new Error("Input not in uint32 range: " + input.toString());
        }
        this.data = input;
      }
      toBytesBigEndian() {
        return new Uint8Array([
          Math.floor(this.data / 2 ** 24) & 255,
          Math.floor(this.data / 2 ** 16) & 255,
          Math.floor(this.data / 2 ** 8) & 255,
          Math.floor(this.data / 2 ** 0) & 255
        ]);
      }
      toBytesLittleEndian() {
        return new Uint8Array([
          Math.floor(this.data / 2 ** 0) & 255,
          Math.floor(this.data / 2 ** 8) & 255,
          Math.floor(this.data / 2 ** 16) & 255,
          Math.floor(this.data / 2 ** 24) & 255
        ]);
      }
      toNumber() {
        return this.data;
      }
      toBigInt() {
        return BigInt(this.toNumber());
      }
      toString() {
        return this.data.toString();
      }
    };
    exports.Uint32 = Uint32;
    var Int53 = class _Int53 {
      static fromString(str) {
        if (!str.match(/^-?[0-9]+$/)) {
          throw new Error("Invalid string format");
        }
        return new _Int53(Number.parseInt(str, 10));
      }
      constructor(input) {
        if (Number.isNaN(input)) {
          throw new Error("Input is not a number");
        }
        if (!Number.isInteger(input)) {
          throw new Error("Input is not an integer");
        }
        if (input < Number.MIN_SAFE_INTEGER || input > Number.MAX_SAFE_INTEGER) {
          throw new Error("Input not in int53 range: " + input.toString());
        }
        this.data = input;
      }
      toNumber() {
        return this.data;
      }
      toBigInt() {
        return BigInt(this.toNumber());
      }
      toString() {
        return this.data.toString();
      }
    };
    exports.Int53 = Int53;
    var Uint53 = class _Uint53 {
      static fromString(str) {
        const signed = Int53.fromString(str);
        return new _Uint53(signed.toNumber());
      }
      constructor(input) {
        const signed = new Int53(input);
        if (signed.toNumber() < 0) {
          throw new Error("Input is negative");
        }
        this.data = signed;
      }
      toNumber() {
        return this.data.toNumber();
      }
      toBigInt() {
        return BigInt(this.toNumber());
      }
      toString() {
        return this.data.toString();
      }
    };
    exports.Uint53 = Uint53;
    var Uint64 = class _Uint64 {
      /** @deprecated use Uint64.fromBytes */
      static fromBytesBigEndian(bytes) {
        return _Uint64.fromBytes(bytes);
      }
      /**
       * Creates a Uint64 from a fixed length byte array.
       *
       * @param bytes a list of exactly 8 bytes
       * @param endianess defaults to big endian
       */
      static fromBytes(bytes, endianess = "be") {
        if (bytes.length !== 8) {
          throw new Error("Invalid input length. Expected 8 bytes.");
        }
        for (let i = 0; i < bytes.length; ++i) {
          if (!Number.isInteger(bytes[i]) || bytes[i] > 255 || bytes[i] < 0) {
            throw new Error("Invalid value in byte. Found: " + bytes[i]);
          }
        }
        const beBytes = endianess === "be" ? Array.from(bytes) : Array.from(bytes).reverse();
        return new _Uint64(new bn_js_1.default(beBytes));
      }
      static fromString(str) {
        if (!str.match(/^[0-9]+$/)) {
          throw new Error("Invalid string format");
        }
        return new _Uint64(new bn_js_1.default(str, 10, "be"));
      }
      static fromNumber(input) {
        if (Number.isNaN(input)) {
          throw new Error("Input is not a number");
        }
        if (!Number.isInteger(input)) {
          throw new Error("Input is not an integer");
        }
        let bigint;
        try {
          bigint = new bn_js_1.default(input);
        } catch {
          throw new Error("Input is not a safe integer");
        }
        return new _Uint64(bigint);
      }
      constructor(data) {
        if (data.isNeg()) {
          throw new Error("Input is negative");
        }
        if (data.gt(uint64MaxValue)) {
          throw new Error("Input exceeds uint64 range");
        }
        this.data = data;
      }
      toBytesBigEndian() {
        return Uint8Array.from(this.data.toArray("be", 8));
      }
      toBytesLittleEndian() {
        return Uint8Array.from(this.data.toArray("le", 8));
      }
      toString() {
        return this.data.toString(10);
      }
      toBigInt() {
        return BigInt(this.toString());
      }
      toNumber() {
        return this.data.toNumber();
      }
    };
    exports.Uint64 = Uint64;
  }
});

// ../../node_modules/.pnpm/@cosmjs+math@0.34.0/node_modules/@cosmjs/math/build/index.js
var require_build2 = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+math@0.34.0/node_modules/@cosmjs/math/build/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Uint64 = exports.Uint53 = exports.Uint32 = exports.Int53 = exports.Decimal = void 0;
    var decimal_1 = require_decimal();
    Object.defineProperty(exports, "Decimal", { enumerable: true, get: function() {
      return decimal_1.Decimal;
    } });
    var integers_1 = require_integers();
    Object.defineProperty(exports, "Int53", { enumerable: true, get: function() {
      return integers_1.Int53;
    } });
    Object.defineProperty(exports, "Uint32", { enumerable: true, get: function() {
      return integers_1.Uint32;
    } });
    Object.defineProperty(exports, "Uint53", { enumerable: true, get: function() {
      return integers_1.Uint53;
    } });
    Object.defineProperty(exports, "Uint64", { enumerable: true, get: function() {
      return integers_1.Uint64;
    } });
  }
});

// ../../node_modules/.pnpm/@cosmjs+proto-signing@0.34.0/node_modules/@cosmjs/proto-signing/build/decode.js
var require_decode = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+proto-signing@0.34.0/node_modules/@cosmjs/proto-signing/build/decode.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.decodeTxRaw = decodeTxRaw;
    var tx_1 = require_tx();
    function decodeTxRaw(tx) {
      const txRaw = tx_1.TxRaw.decode(tx);
      return {
        authInfo: tx_1.AuthInfo.decode(txRaw.authInfoBytes),
        body: tx_1.TxBody.decode(txRaw.bodyBytes),
        signatures: txRaw.signatures
      };
    }
  }
});

// ../../node_modules/.pnpm/@cosmjs+utils@0.34.0/node_modules/@cosmjs/utils/build/arrays.js
var require_arrays = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+utils@0.34.0/node_modules/@cosmjs/utils/build/arrays.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.arrayContentEquals = arrayContentEquals;
    exports.arrayContentStartsWith = arrayContentStartsWith;
    function arrayContentEquals(a, b) {
      if (a.length !== b.length)
        return false;
      for (let i = 0; i < a.length; ++i) {
        if (a[i] !== b[i])
          return false;
      }
      return true;
    }
    function arrayContentStartsWith(a, b) {
      if (a.length < b.length)
        return false;
      for (let i = 0; i < b.length; ++i) {
        if (a[i] !== b[i])
          return false;
      }
      return true;
    }
  }
});

// ../../node_modules/.pnpm/@cosmjs+utils@0.34.0/node_modules/@cosmjs/utils/build/assert.js
var require_assert = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+utils@0.34.0/node_modules/@cosmjs/utils/build/assert.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.assert = assert;
    exports.assertDefined = assertDefined;
    exports.assertDefinedAndNotNull = assertDefinedAndNotNull;
    function assert(condition, msg) {
      if (!condition) {
        throw new Error(msg || "condition is not truthy");
      }
    }
    function assertDefined(value, msg) {
      if (value === void 0) {
        throw new Error(msg ?? "value is undefined");
      }
    }
    function assertDefinedAndNotNull(value, msg) {
      if (value === void 0 || value === null) {
        throw new Error(msg ?? "value is undefined or null");
      }
    }
  }
});

// ../../node_modules/.pnpm/@cosmjs+utils@0.34.0/node_modules/@cosmjs/utils/build/sleep.js
var require_sleep = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+utils@0.34.0/node_modules/@cosmjs/utils/build/sleep.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.sleep = sleep;
    async function sleep(ms) {
      return new Promise((resolve) => setTimeout(resolve, ms));
    }
  }
});

// ../../node_modules/.pnpm/@cosmjs+utils@0.34.0/node_modules/@cosmjs/utils/build/typechecks.js
var require_typechecks = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+utils@0.34.0/node_modules/@cosmjs/utils/build/typechecks.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isNonNullObject = isNonNullObject;
    exports.isUint8Array = isUint8Array;
    exports.isDefined = isDefined;
    function isNonNullObject(data) {
      return typeof data === "object" && data !== null;
    }
    function isUint8Array(data) {
      if (!isNonNullObject(data))
        return false;
      if (Object.prototype.toString.call(data) !== "[object Uint8Array]")
        return false;
      if (typeof Buffer !== "undefined" && typeof Buffer.isBuffer !== "undefined") {
        if (Buffer.isBuffer(data))
          return false;
      }
      return true;
    }
    function isDefined(value) {
      return value !== void 0;
    }
  }
});

// ../../node_modules/.pnpm/@cosmjs+utils@0.34.0/node_modules/@cosmjs/utils/build/index.js
var require_build3 = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+utils@0.34.0/node_modules/@cosmjs/utils/build/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isUint8Array = exports.isNonNullObject = exports.isDefined = exports.sleep = exports.assertDefinedAndNotNull = exports.assertDefined = exports.assert = exports.arrayContentStartsWith = exports.arrayContentEquals = void 0;
    var arrays_1 = require_arrays();
    Object.defineProperty(exports, "arrayContentEquals", { enumerable: true, get: function() {
      return arrays_1.arrayContentEquals;
    } });
    Object.defineProperty(exports, "arrayContentStartsWith", { enumerable: true, get: function() {
      return arrays_1.arrayContentStartsWith;
    } });
    var assert_1 = require_assert();
    Object.defineProperty(exports, "assert", { enumerable: true, get: function() {
      return assert_1.assert;
    } });
    Object.defineProperty(exports, "assertDefined", { enumerable: true, get: function() {
      return assert_1.assertDefined;
    } });
    Object.defineProperty(exports, "assertDefinedAndNotNull", { enumerable: true, get: function() {
      return assert_1.assertDefinedAndNotNull;
    } });
    var sleep_1 = require_sleep();
    Object.defineProperty(exports, "sleep", { enumerable: true, get: function() {
      return sleep_1.sleep;
    } });
    var typechecks_1 = require_typechecks();
    Object.defineProperty(exports, "isDefined", { enumerable: true, get: function() {
      return typechecks_1.isDefined;
    } });
    Object.defineProperty(exports, "isNonNullObject", { enumerable: true, get: function() {
      return typechecks_1.isNonNullObject;
    } });
    Object.defineProperty(exports, "isUint8Array", { enumerable: true, get: function() {
      return typechecks_1.isUint8Array;
    } });
  }
});

// ../../node_modules/.pnpm/@cosmjs+crypto@0.34.0/node_modules/@cosmjs/crypto/build/pbkdf2.js
var require_pbkdf22 = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+crypto@0.34.0/node_modules/@cosmjs/crypto/build/pbkdf2.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function() {
      var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o2) {
          var ar = [];
          for (var k in o2)
            if (Object.prototype.hasOwnProperty.call(o2, k))
              ar[ar.length] = k;
          return ar;
        };
        return ownKeys(o);
      };
      return function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k = ownKeys(mod), i = 0; i < k.length; i++)
            if (k[i] !== "default")
              __createBinding(result, mod, k[i]);
        }
        __setModuleDefault(result, mod);
        return result;
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getNodeCrypto = getNodeCrypto;
    exports.getSubtle = getSubtle;
    exports.pbkdf2Sha512Subtle = pbkdf2Sha512Subtle;
    exports.pbkdf2Sha512NodeCrypto = pbkdf2Sha512NodeCrypto;
    exports.pbkdf2Sha512Noble = pbkdf2Sha512Noble;
    exports.pbkdf2Sha512 = pbkdf2Sha512;
    var utils_1 = require_build3();
    var pbkdf2_1 = require_pbkdf2();
    var sha512_1 = require_sha512();
    async function getNodeCrypto() {
      try {
        const nodeCrypto = await Promise.resolve().then(() => __importStar(require_crypto()));
        if (typeof nodeCrypto === "object" && Object.keys(nodeCrypto).length <= 1) {
          return void 0;
        }
        return nodeCrypto;
      } catch {
        return void 0;
      }
    }
    async function getSubtle() {
      var _a, _b, _c;
      let subtle = (_a = globalThis == null ? void 0 : globalThis.crypto) == null ? void 0 : _a.subtle;
      if (!subtle)
        subtle = (_c = (_b = globalThis == null ? void 0 : globalThis.crypto) == null ? void 0 : _b.webcrypto) == null ? void 0 : _c.subtle;
      return subtle;
    }
    async function pbkdf2Sha512Subtle(subtle, secret, salt, iterations, keylen) {
      (0, utils_1.assert)(subtle, "Argument subtle is falsy");
      (0, utils_1.assert)(typeof subtle === "object", "Argument subtle is not of type object");
      (0, utils_1.assert)(typeof subtle.importKey === "function", "subtle.importKey is not a function");
      (0, utils_1.assert)(typeof subtle.deriveBits === "function", "subtle.deriveBits is not a function");
      return subtle.importKey("raw", secret, { name: "PBKDF2" }, false, ["deriveBits"]).then((key) => subtle.deriveBits({
        name: "PBKDF2",
        salt,
        iterations,
        hash: { name: "SHA-512" }
      }, key, keylen * 8).then((buffer) => new Uint8Array(buffer)));
    }
    async function pbkdf2Sha512NodeCrypto(nodeCrypto, secret, salt, iterations, keylen) {
      (0, utils_1.assert)(nodeCrypto, "Argument nodeCrypto is falsy");
      (0, utils_1.assert)(typeof nodeCrypto === "object", "Argument nodeCrypto is not of type object");
      (0, utils_1.assert)(typeof nodeCrypto.pbkdf2 === "function", "nodeCrypto.pbkdf2 is not a function");
      return new Promise((resolve, reject) => {
        nodeCrypto.pbkdf2(secret, salt, iterations, keylen, "sha512", (error, result) => {
          if (error) {
            reject(error);
          } else {
            resolve(Uint8Array.from(result));
          }
        });
      });
    }
    async function pbkdf2Sha512Noble(secret, salt, iterations, keylen) {
      return (0, pbkdf2_1.pbkdf2Async)(sha512_1.sha512, secret, salt, { c: iterations, dkLen: keylen });
    }
    async function pbkdf2Sha512(secret, salt, iterations, keylen) {
      const subtle = await getSubtle();
      if (subtle) {
        return pbkdf2Sha512Subtle(subtle, secret, salt, iterations, keylen);
      } else {
        const nodeCrypto = await getNodeCrypto();
        if (nodeCrypto) {
          return pbkdf2Sha512NodeCrypto(nodeCrypto, secret, salt, iterations, keylen);
        } else {
          return pbkdf2Sha512Noble(secret, salt, iterations, keylen);
        }
      }
    }
  }
});

// ../../node_modules/.pnpm/@cosmjs+crypto@0.34.0/node_modules/@cosmjs/crypto/build/utils.js
var require_utils2 = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+crypto@0.34.0/node_modules/@cosmjs/crypto/build/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.toRealUint8Array = toRealUint8Array;
    function toRealUint8Array(data) {
      if (data instanceof Uint8Array)
        return data;
      else
        return Uint8Array.from(data);
    }
  }
});

// ../../node_modules/.pnpm/@cosmjs+crypto@0.34.0/node_modules/@cosmjs/crypto/build/sha.js
var require_sha = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+crypto@0.34.0/node_modules/@cosmjs/crypto/build/sha.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Sha512 = exports.Sha256 = void 0;
    exports.sha256 = sha256;
    exports.sha512 = sha512;
    var sha256_1 = require_sha256();
    var sha512_1 = require_sha512();
    var utils_1 = require_utils2();
    var Sha256 = class {
      constructor(firstData) {
        this.blockSize = 512 / 8;
        this.impl = sha256_1.sha256.create();
        if (firstData) {
          this.update(firstData);
        }
      }
      update(data) {
        this.impl.update((0, utils_1.toRealUint8Array)(data));
        return this;
      }
      digest() {
        return this.impl.digest();
      }
    };
    exports.Sha256 = Sha256;
    function sha256(data) {
      return new Sha256(data).digest();
    }
    var Sha512 = class {
      constructor(firstData) {
        this.blockSize = 1024 / 8;
        this.impl = sha512_1.sha512.create();
        if (firstData) {
          this.update(firstData);
        }
      }
      update(data) {
        this.impl.update((0, utils_1.toRealUint8Array)(data));
        return this;
      }
      digest() {
        return this.impl.digest();
      }
    };
    exports.Sha512 = Sha512;
    function sha512(data) {
      return new Sha512(data).digest();
    }
  }
});

// ../../node_modules/.pnpm/@cosmjs+crypto@0.34.0/node_modules/@cosmjs/crypto/build/bip39.js
var require_bip39 = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+crypto@0.34.0/node_modules/@cosmjs/crypto/build/bip39.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Bip39 = exports.EnglishMnemonic = void 0;
    exports.entropyToMnemonic = entropyToMnemonic;
    exports.mnemonicToEntropy = mnemonicToEntropy;
    var encoding_1 = require_build();
    var pbkdf2_1 = require_pbkdf22();
    var sha_1 = require_sha();
    var wordlist = [
      "abandon",
      "ability",
      "able",
      "about",
      "above",
      "absent",
      "absorb",
      "abstract",
      "absurd",
      "abuse",
      "access",
      "accident",
      "account",
      "accuse",
      "achieve",
      "acid",
      "acoustic",
      "acquire",
      "across",
      "act",
      "action",
      "actor",
      "actress",
      "actual",
      "adapt",
      "add",
      "addict",
      "address",
      "adjust",
      "admit",
      "adult",
      "advance",
      "advice",
      "aerobic",
      "affair",
      "afford",
      "afraid",
      "again",
      "age",
      "agent",
      "agree",
      "ahead",
      "aim",
      "air",
      "airport",
      "aisle",
      "alarm",
      "album",
      "alcohol",
      "alert",
      "alien",
      "all",
      "alley",
      "allow",
      "almost",
      "alone",
      "alpha",
      "already",
      "also",
      "alter",
      "always",
      "amateur",
      "amazing",
      "among",
      "amount",
      "amused",
      "analyst",
      "anchor",
      "ancient",
      "anger",
      "angle",
      "angry",
      "animal",
      "ankle",
      "announce",
      "annual",
      "another",
      "answer",
      "antenna",
      "antique",
      "anxiety",
      "any",
      "apart",
      "apology",
      "appear",
      "apple",
      "approve",
      "april",
      "arch",
      "arctic",
      "area",
      "arena",
      "argue",
      "arm",
      "armed",
      "armor",
      "army",
      "around",
      "arrange",
      "arrest",
      "arrive",
      "arrow",
      "art",
      "artefact",
      "artist",
      "artwork",
      "ask",
      "aspect",
      "assault",
      "asset",
      "assist",
      "assume",
      "asthma",
      "athlete",
      "atom",
      "attack",
      "attend",
      "attitude",
      "attract",
      "auction",
      "audit",
      "august",
      "aunt",
      "author",
      "auto",
      "autumn",
      "average",
      "avocado",
      "avoid",
      "awake",
      "aware",
      "away",
      "awesome",
      "awful",
      "awkward",
      "axis",
      "baby",
      "bachelor",
      "bacon",
      "badge",
      "bag",
      "balance",
      "balcony",
      "ball",
      "bamboo",
      "banana",
      "banner",
      "bar",
      "barely",
      "bargain",
      "barrel",
      "base",
      "basic",
      "basket",
      "battle",
      "beach",
      "bean",
      "beauty",
      "because",
      "become",
      "beef",
      "before",
      "begin",
      "behave",
      "behind",
      "believe",
      "below",
      "belt",
      "bench",
      "benefit",
      "best",
      "betray",
      "better",
      "between",
      "beyond",
      "bicycle",
      "bid",
      "bike",
      "bind",
      "biology",
      "bird",
      "birth",
      "bitter",
      "black",
      "blade",
      "blame",
      "blanket",
      "blast",
      "bleak",
      "bless",
      "blind",
      "blood",
      "blossom",
      "blouse",
      "blue",
      "blur",
      "blush",
      "board",
      "boat",
      "body",
      "boil",
      "bomb",
      "bone",
      "bonus",
      "book",
      "boost",
      "border",
      "boring",
      "borrow",
      "boss",
      "bottom",
      "bounce",
      "box",
      "boy",
      "bracket",
      "brain",
      "brand",
      "brass",
      "brave",
      "bread",
      "breeze",
      "brick",
      "bridge",
      "brief",
      "bright",
      "bring",
      "brisk",
      "broccoli",
      "broken",
      "bronze",
      "broom",
      "brother",
      "brown",
      "brush",
      "bubble",
      "buddy",
      "budget",
      "buffalo",
      "build",
      "bulb",
      "bulk",
      "bullet",
      "bundle",
      "bunker",
      "burden",
      "burger",
      "burst",
      "bus",
      "business",
      "busy",
      "butter",
      "buyer",
      "buzz",
      "cabbage",
      "cabin",
      "cable",
      "cactus",
      "cage",
      "cake",
      "call",
      "calm",
      "camera",
      "camp",
      "can",
      "canal",
      "cancel",
      "candy",
      "cannon",
      "canoe",
      "canvas",
      "canyon",
      "capable",
      "capital",
      "captain",
      "car",
      "carbon",
      "card",
      "cargo",
      "carpet",
      "carry",
      "cart",
      "case",
      "cash",
      "casino",
      "castle",
      "casual",
      "cat",
      "catalog",
      "catch",
      "category",
      "cattle",
      "caught",
      "cause",
      "caution",
      "cave",
      "ceiling",
      "celery",
      "cement",
      "census",
      "century",
      "cereal",
      "certain",
      "chair",
      "chalk",
      "champion",
      "change",
      "chaos",
      "chapter",
      "charge",
      "chase",
      "chat",
      "cheap",
      "check",
      "cheese",
      "chef",
      "cherry",
      "chest",
      "chicken",
      "chief",
      "child",
      "chimney",
      "choice",
      "choose",
      "chronic",
      "chuckle",
      "chunk",
      "churn",
      "cigar",
      "cinnamon",
      "circle",
      "citizen",
      "city",
      "civil",
      "claim",
      "clap",
      "clarify",
      "claw",
      "clay",
      "clean",
      "clerk",
      "clever",
      "click",
      "client",
      "cliff",
      "climb",
      "clinic",
      "clip",
      "clock",
      "clog",
      "close",
      "cloth",
      "cloud",
      "clown",
      "club",
      "clump",
      "cluster",
      "clutch",
      "coach",
      "coast",
      "coconut",
      "code",
      "coffee",
      "coil",
      "coin",
      "collect",
      "color",
      "column",
      "combine",
      "come",
      "comfort",
      "comic",
      "common",
      "company",
      "concert",
      "conduct",
      "confirm",
      "congress",
      "connect",
      "consider",
      "control",
      "convince",
      "cook",
      "cool",
      "copper",
      "copy",
      "coral",
      "core",
      "corn",
      "correct",
      "cost",
      "cotton",
      "couch",
      "country",
      "couple",
      "course",
      "cousin",
      "cover",
      "coyote",
      "crack",
      "cradle",
      "craft",
      "cram",
      "crane",
      "crash",
      "crater",
      "crawl",
      "crazy",
      "cream",
      "credit",
      "creek",
      "crew",
      "cricket",
      "crime",
      "crisp",
      "critic",
      "crop",
      "cross",
      "crouch",
      "crowd",
      "crucial",
      "cruel",
      "cruise",
      "crumble",
      "crunch",
      "crush",
      "cry",
      "crystal",
      "cube",
      "culture",
      "cup",
      "cupboard",
      "curious",
      "current",
      "curtain",
      "curve",
      "cushion",
      "custom",
      "cute",
      "cycle",
      "dad",
      "damage",
      "damp",
      "dance",
      "danger",
      "daring",
      "dash",
      "daughter",
      "dawn",
      "day",
      "deal",
      "debate",
      "debris",
      "decade",
      "december",
      "decide",
      "decline",
      "decorate",
      "decrease",
      "deer",
      "defense",
      "define",
      "defy",
      "degree",
      "delay",
      "deliver",
      "demand",
      "demise",
      "denial",
      "dentist",
      "deny",
      "depart",
      "depend",
      "deposit",
      "depth",
      "deputy",
      "derive",
      "describe",
      "desert",
      "design",
      "desk",
      "despair",
      "destroy",
      "detail",
      "detect",
      "develop",
      "device",
      "devote",
      "diagram",
      "dial",
      "diamond",
      "diary",
      "dice",
      "diesel",
      "diet",
      "differ",
      "digital",
      "dignity",
      "dilemma",
      "dinner",
      "dinosaur",
      "direct",
      "dirt",
      "disagree",
      "discover",
      "disease",
      "dish",
      "dismiss",
      "disorder",
      "display",
      "distance",
      "divert",
      "divide",
      "divorce",
      "dizzy",
      "doctor",
      "document",
      "dog",
      "doll",
      "dolphin",
      "domain",
      "donate",
      "donkey",
      "donor",
      "door",
      "dose",
      "double",
      "dove",
      "draft",
      "dragon",
      "drama",
      "drastic",
      "draw",
      "dream",
      "dress",
      "drift",
      "drill",
      "drink",
      "drip",
      "drive",
      "drop",
      "drum",
      "dry",
      "duck",
      "dumb",
      "dune",
      "during",
      "dust",
      "dutch",
      "duty",
      "dwarf",
      "dynamic",
      "eager",
      "eagle",
      "early",
      "earn",
      "earth",
      "easily",
      "east",
      "easy",
      "echo",
      "ecology",
      "economy",
      "edge",
      "edit",
      "educate",
      "effort",
      "egg",
      "eight",
      "either",
      "elbow",
      "elder",
      "electric",
      "elegant",
      "element",
      "elephant",
      "elevator",
      "elite",
      "else",
      "embark",
      "embody",
      "embrace",
      "emerge",
      "emotion",
      "employ",
      "empower",
      "empty",
      "enable",
      "enact",
      "end",
      "endless",
      "endorse",
      "enemy",
      "energy",
      "enforce",
      "engage",
      "engine",
      "enhance",
      "enjoy",
      "enlist",
      "enough",
      "enrich",
      "enroll",
      "ensure",
      "enter",
      "entire",
      "entry",
      "envelope",
      "episode",
      "equal",
      "equip",
      "era",
      "erase",
      "erode",
      "erosion",
      "error",
      "erupt",
      "escape",
      "essay",
      "essence",
      "estate",
      "eternal",
      "ethics",
      "evidence",
      "evil",
      "evoke",
      "evolve",
      "exact",
      "example",
      "excess",
      "exchange",
      "excite",
      "exclude",
      "excuse",
      "execute",
      "exercise",
      "exhaust",
      "exhibit",
      "exile",
      "exist",
      "exit",
      "exotic",
      "expand",
      "expect",
      "expire",
      "explain",
      "expose",
      "express",
      "extend",
      "extra",
      "eye",
      "eyebrow",
      "fabric",
      "face",
      "faculty",
      "fade",
      "faint",
      "faith",
      "fall",
      "false",
      "fame",
      "family",
      "famous",
      "fan",
      "fancy",
      "fantasy",
      "farm",
      "fashion",
      "fat",
      "fatal",
      "father",
      "fatigue",
      "fault",
      "favorite",
      "feature",
      "february",
      "federal",
      "fee",
      "feed",
      "feel",
      "female",
      "fence",
      "festival",
      "fetch",
      "fever",
      "few",
      "fiber",
      "fiction",
      "field",
      "figure",
      "file",
      "film",
      "filter",
      "final",
      "find",
      "fine",
      "finger",
      "finish",
      "fire",
      "firm",
      "first",
      "fiscal",
      "fish",
      "fit",
      "fitness",
      "fix",
      "flag",
      "flame",
      "flash",
      "flat",
      "flavor",
      "flee",
      "flight",
      "flip",
      "float",
      "flock",
      "floor",
      "flower",
      "fluid",
      "flush",
      "fly",
      "foam",
      "focus",
      "fog",
      "foil",
      "fold",
      "follow",
      "food",
      "foot",
      "force",
      "forest",
      "forget",
      "fork",
      "fortune",
      "forum",
      "forward",
      "fossil",
      "foster",
      "found",
      "fox",
      "fragile",
      "frame",
      "frequent",
      "fresh",
      "friend",
      "fringe",
      "frog",
      "front",
      "frost",
      "frown",
      "frozen",
      "fruit",
      "fuel",
      "fun",
      "funny",
      "furnace",
      "fury",
      "future",
      "gadget",
      "gain",
      "galaxy",
      "gallery",
      "game",
      "gap",
      "garage",
      "garbage",
      "garden",
      "garlic",
      "garment",
      "gas",
      "gasp",
      "gate",
      "gather",
      "gauge",
      "gaze",
      "general",
      "genius",
      "genre",
      "gentle",
      "genuine",
      "gesture",
      "ghost",
      "giant",
      "gift",
      "giggle",
      "ginger",
      "giraffe",
      "girl",
      "give",
      "glad",
      "glance",
      "glare",
      "glass",
      "glide",
      "glimpse",
      "globe",
      "gloom",
      "glory",
      "glove",
      "glow",
      "glue",
      "goat",
      "goddess",
      "gold",
      "good",
      "goose",
      "gorilla",
      "gospel",
      "gossip",
      "govern",
      "gown",
      "grab",
      "grace",
      "grain",
      "grant",
      "grape",
      "grass",
      "gravity",
      "great",
      "green",
      "grid",
      "grief",
      "grit",
      "grocery",
      "group",
      "grow",
      "grunt",
      "guard",
      "guess",
      "guide",
      "guilt",
      "guitar",
      "gun",
      "gym",
      "habit",
      "hair",
      "half",
      "hammer",
      "hamster",
      "hand",
      "happy",
      "harbor",
      "hard",
      "harsh",
      "harvest",
      "hat",
      "have",
      "hawk",
      "hazard",
      "head",
      "health",
      "heart",
      "heavy",
      "hedgehog",
      "height",
      "hello",
      "helmet",
      "help",
      "hen",
      "hero",
      "hidden",
      "high",
      "hill",
      "hint",
      "hip",
      "hire",
      "history",
      "hobby",
      "hockey",
      "hold",
      "hole",
      "holiday",
      "hollow",
      "home",
      "honey",
      "hood",
      "hope",
      "horn",
      "horror",
      "horse",
      "hospital",
      "host",
      "hotel",
      "hour",
      "hover",
      "hub",
      "huge",
      "human",
      "humble",
      "humor",
      "hundred",
      "hungry",
      "hunt",
      "hurdle",
      "hurry",
      "hurt",
      "husband",
      "hybrid",
      "ice",
      "icon",
      "idea",
      "identify",
      "idle",
      "ignore",
      "ill",
      "illegal",
      "illness",
      "image",
      "imitate",
      "immense",
      "immune",
      "impact",
      "impose",
      "improve",
      "impulse",
      "inch",
      "include",
      "income",
      "increase",
      "index",
      "indicate",
      "indoor",
      "industry",
      "infant",
      "inflict",
      "inform",
      "inhale",
      "inherit",
      "initial",
      "inject",
      "injury",
      "inmate",
      "inner",
      "innocent",
      "input",
      "inquiry",
      "insane",
      "insect",
      "inside",
      "inspire",
      "install",
      "intact",
      "interest",
      "into",
      "invest",
      "invite",
      "involve",
      "iron",
      "island",
      "isolate",
      "issue",
      "item",
      "ivory",
      "jacket",
      "jaguar",
      "jar",
      "jazz",
      "jealous",
      "jeans",
      "jelly",
      "jewel",
      "job",
      "join",
      "joke",
      "journey",
      "joy",
      "judge",
      "juice",
      "jump",
      "jungle",
      "junior",
      "junk",
      "just",
      "kangaroo",
      "keen",
      "keep",
      "ketchup",
      "key",
      "kick",
      "kid",
      "kidney",
      "kind",
      "kingdom",
      "kiss",
      "kit",
      "kitchen",
      "kite",
      "kitten",
      "kiwi",
      "knee",
      "knife",
      "knock",
      "know",
      "lab",
      "label",
      "labor",
      "ladder",
      "lady",
      "lake",
      "lamp",
      "language",
      "laptop",
      "large",
      "later",
      "latin",
      "laugh",
      "laundry",
      "lava",
      "law",
      "lawn",
      "lawsuit",
      "layer",
      "lazy",
      "leader",
      "leaf",
      "learn",
      "leave",
      "lecture",
      "left",
      "leg",
      "legal",
      "legend",
      "leisure",
      "lemon",
      "lend",
      "length",
      "lens",
      "leopard",
      "lesson",
      "letter",
      "level",
      "liar",
      "liberty",
      "library",
      "license",
      "life",
      "lift",
      "light",
      "like",
      "limb",
      "limit",
      "link",
      "lion",
      "liquid",
      "list",
      "little",
      "live",
      "lizard",
      "load",
      "loan",
      "lobster",
      "local",
      "lock",
      "logic",
      "lonely",
      "long",
      "loop",
      "lottery",
      "loud",
      "lounge",
      "love",
      "loyal",
      "lucky",
      "luggage",
      "lumber",
      "lunar",
      "lunch",
      "luxury",
      "lyrics",
      "machine",
      "mad",
      "magic",
      "magnet",
      "maid",
      "mail",
      "main",
      "major",
      "make",
      "mammal",
      "man",
      "manage",
      "mandate",
      "mango",
      "mansion",
      "manual",
      "maple",
      "marble",
      "march",
      "margin",
      "marine",
      "market",
      "marriage",
      "mask",
      "mass",
      "master",
      "match",
      "material",
      "math",
      "matrix",
      "matter",
      "maximum",
      "maze",
      "meadow",
      "mean",
      "measure",
      "meat",
      "mechanic",
      "medal",
      "media",
      "melody",
      "melt",
      "member",
      "memory",
      "mention",
      "menu",
      "mercy",
      "merge",
      "merit",
      "merry",
      "mesh",
      "message",
      "metal",
      "method",
      "middle",
      "midnight",
      "milk",
      "million",
      "mimic",
      "mind",
      "minimum",
      "minor",
      "minute",
      "miracle",
      "mirror",
      "misery",
      "miss",
      "mistake",
      "mix",
      "mixed",
      "mixture",
      "mobile",
      "model",
      "modify",
      "mom",
      "moment",
      "monitor",
      "monkey",
      "monster",
      "month",
      "moon",
      "moral",
      "more",
      "morning",
      "mosquito",
      "mother",
      "motion",
      "motor",
      "mountain",
      "mouse",
      "move",
      "movie",
      "much",
      "muffin",
      "mule",
      "multiply",
      "muscle",
      "museum",
      "mushroom",
      "music",
      "must",
      "mutual",
      "myself",
      "mystery",
      "myth",
      "naive",
      "name",
      "napkin",
      "narrow",
      "nasty",
      "nation",
      "nature",
      "near",
      "neck",
      "need",
      "negative",
      "neglect",
      "neither",
      "nephew",
      "nerve",
      "nest",
      "net",
      "network",
      "neutral",
      "never",
      "news",
      "next",
      "nice",
      "night",
      "noble",
      "noise",
      "nominee",
      "noodle",
      "normal",
      "north",
      "nose",
      "notable",
      "note",
      "nothing",
      "notice",
      "novel",
      "now",
      "nuclear",
      "number",
      "nurse",
      "nut",
      "oak",
      "obey",
      "object",
      "oblige",
      "obscure",
      "observe",
      "obtain",
      "obvious",
      "occur",
      "ocean",
      "october",
      "odor",
      "off",
      "offer",
      "office",
      "often",
      "oil",
      "okay",
      "old",
      "olive",
      "olympic",
      "omit",
      "once",
      "one",
      "onion",
      "online",
      "only",
      "open",
      "opera",
      "opinion",
      "oppose",
      "option",
      "orange",
      "orbit",
      "orchard",
      "order",
      "ordinary",
      "organ",
      "orient",
      "original",
      "orphan",
      "ostrich",
      "other",
      "outdoor",
      "outer",
      "output",
      "outside",
      "oval",
      "oven",
      "over",
      "own",
      "owner",
      "oxygen",
      "oyster",
      "ozone",
      "pact",
      "paddle",
      "page",
      "pair",
      "palace",
      "palm",
      "panda",
      "panel",
      "panic",
      "panther",
      "paper",
      "parade",
      "parent",
      "park",
      "parrot",
      "party",
      "pass",
      "patch",
      "path",
      "patient",
      "patrol",
      "pattern",
      "pause",
      "pave",
      "payment",
      "peace",
      "peanut",
      "pear",
      "peasant",
      "pelican",
      "pen",
      "penalty",
      "pencil",
      "people",
      "pepper",
      "perfect",
      "permit",
      "person",
      "pet",
      "phone",
      "photo",
      "phrase",
      "physical",
      "piano",
      "picnic",
      "picture",
      "piece",
      "pig",
      "pigeon",
      "pill",
      "pilot",
      "pink",
      "pioneer",
      "pipe",
      "pistol",
      "pitch",
      "pizza",
      "place",
      "planet",
      "plastic",
      "plate",
      "play",
      "please",
      "pledge",
      "pluck",
      "plug",
      "plunge",
      "poem",
      "poet",
      "point",
      "polar",
      "pole",
      "police",
      "pond",
      "pony",
      "pool",
      "popular",
      "portion",
      "position",
      "possible",
      "post",
      "potato",
      "pottery",
      "poverty",
      "powder",
      "power",
      "practice",
      "praise",
      "predict",
      "prefer",
      "prepare",
      "present",
      "pretty",
      "prevent",
      "price",
      "pride",
      "primary",
      "print",
      "priority",
      "prison",
      "private",
      "prize",
      "problem",
      "process",
      "produce",
      "profit",
      "program",
      "project",
      "promote",
      "proof",
      "property",
      "prosper",
      "protect",
      "proud",
      "provide",
      "public",
      "pudding",
      "pull",
      "pulp",
      "pulse",
      "pumpkin",
      "punch",
      "pupil",
      "puppy",
      "purchase",
      "purity",
      "purpose",
      "purse",
      "push",
      "put",
      "puzzle",
      "pyramid",
      "quality",
      "quantum",
      "quarter",
      "question",
      "quick",
      "quit",
      "quiz",
      "quote",
      "rabbit",
      "raccoon",
      "race",
      "rack",
      "radar",
      "radio",
      "rail",
      "rain",
      "raise",
      "rally",
      "ramp",
      "ranch",
      "random",
      "range",
      "rapid",
      "rare",
      "rate",
      "rather",
      "raven",
      "raw",
      "razor",
      "ready",
      "real",
      "reason",
      "rebel",
      "rebuild",
      "recall",
      "receive",
      "recipe",
      "record",
      "recycle",
      "reduce",
      "reflect",
      "reform",
      "refuse",
      "region",
      "regret",
      "regular",
      "reject",
      "relax",
      "release",
      "relief",
      "rely",
      "remain",
      "remember",
      "remind",
      "remove",
      "render",
      "renew",
      "rent",
      "reopen",
      "repair",
      "repeat",
      "replace",
      "report",
      "require",
      "rescue",
      "resemble",
      "resist",
      "resource",
      "response",
      "result",
      "retire",
      "retreat",
      "return",
      "reunion",
      "reveal",
      "review",
      "reward",
      "rhythm",
      "rib",
      "ribbon",
      "rice",
      "rich",
      "ride",
      "ridge",
      "rifle",
      "right",
      "rigid",
      "ring",
      "riot",
      "ripple",
      "risk",
      "ritual",
      "rival",
      "river",
      "road",
      "roast",
      "robot",
      "robust",
      "rocket",
      "romance",
      "roof",
      "rookie",
      "room",
      "rose",
      "rotate",
      "rough",
      "round",
      "route",
      "royal",
      "rubber",
      "rude",
      "rug",
      "rule",
      "run",
      "runway",
      "rural",
      "sad",
      "saddle",
      "sadness",
      "safe",
      "sail",
      "salad",
      "salmon",
      "salon",
      "salt",
      "salute",
      "same",
      "sample",
      "sand",
      "satisfy",
      "satoshi",
      "sauce",
      "sausage",
      "save",
      "say",
      "scale",
      "scan",
      "scare",
      "scatter",
      "scene",
      "scheme",
      "school",
      "science",
      "scissors",
      "scorpion",
      "scout",
      "scrap",
      "screen",
      "script",
      "scrub",
      "sea",
      "search",
      "season",
      "seat",
      "second",
      "secret",
      "section",
      "security",
      "seed",
      "seek",
      "segment",
      "select",
      "sell",
      "seminar",
      "senior",
      "sense",
      "sentence",
      "series",
      "service",
      "session",
      "settle",
      "setup",
      "seven",
      "shadow",
      "shaft",
      "shallow",
      "share",
      "shed",
      "shell",
      "sheriff",
      "shield",
      "shift",
      "shine",
      "ship",
      "shiver",
      "shock",
      "shoe",
      "shoot",
      "shop",
      "short",
      "shoulder",
      "shove",
      "shrimp",
      "shrug",
      "shuffle",
      "shy",
      "sibling",
      "sick",
      "side",
      "siege",
      "sight",
      "sign",
      "silent",
      "silk",
      "silly",
      "silver",
      "similar",
      "simple",
      "since",
      "sing",
      "siren",
      "sister",
      "situate",
      "six",
      "size",
      "skate",
      "sketch",
      "ski",
      "skill",
      "skin",
      "skirt",
      "skull",
      "slab",
      "slam",
      "sleep",
      "slender",
      "slice",
      "slide",
      "slight",
      "slim",
      "slogan",
      "slot",
      "slow",
      "slush",
      "small",
      "smart",
      "smile",
      "smoke",
      "smooth",
      "snack",
      "snake",
      "snap",
      "sniff",
      "snow",
      "soap",
      "soccer",
      "social",
      "sock",
      "soda",
      "soft",
      "solar",
      "soldier",
      "solid",
      "solution",
      "solve",
      "someone",
      "song",
      "soon",
      "sorry",
      "sort",
      "soul",
      "sound",
      "soup",
      "source",
      "south",
      "space",
      "spare",
      "spatial",
      "spawn",
      "speak",
      "special",
      "speed",
      "spell",
      "spend",
      "sphere",
      "spice",
      "spider",
      "spike",
      "spin",
      "spirit",
      "split",
      "spoil",
      "sponsor",
      "spoon",
      "sport",
      "spot",
      "spray",
      "spread",
      "spring",
      "spy",
      "square",
      "squeeze",
      "squirrel",
      "stable",
      "stadium",
      "staff",
      "stage",
      "stairs",
      "stamp",
      "stand",
      "start",
      "state",
      "stay",
      "steak",
      "steel",
      "stem",
      "step",
      "stereo",
      "stick",
      "still",
      "sting",
      "stock",
      "stomach",
      "stone",
      "stool",
      "story",
      "stove",
      "strategy",
      "street",
      "strike",
      "strong",
      "struggle",
      "student",
      "stuff",
      "stumble",
      "style",
      "subject",
      "submit",
      "subway",
      "success",
      "such",
      "sudden",
      "suffer",
      "sugar",
      "suggest",
      "suit",
      "summer",
      "sun",
      "sunny",
      "sunset",
      "super",
      "supply",
      "supreme",
      "sure",
      "surface",
      "surge",
      "surprise",
      "surround",
      "survey",
      "suspect",
      "sustain",
      "swallow",
      "swamp",
      "swap",
      "swarm",
      "swear",
      "sweet",
      "swift",
      "swim",
      "swing",
      "switch",
      "sword",
      "symbol",
      "symptom",
      "syrup",
      "system",
      "table",
      "tackle",
      "tag",
      "tail",
      "talent",
      "talk",
      "tank",
      "tape",
      "target",
      "task",
      "taste",
      "tattoo",
      "taxi",
      "teach",
      "team",
      "tell",
      "ten",
      "tenant",
      "tennis",
      "tent",
      "term",
      "test",
      "text",
      "thank",
      "that",
      "theme",
      "then",
      "theory",
      "there",
      "they",
      "thing",
      "this",
      "thought",
      "three",
      "thrive",
      "throw",
      "thumb",
      "thunder",
      "ticket",
      "tide",
      "tiger",
      "tilt",
      "timber",
      "time",
      "tiny",
      "tip",
      "tired",
      "tissue",
      "title",
      "toast",
      "tobacco",
      "today",
      "toddler",
      "toe",
      "together",
      "toilet",
      "token",
      "tomato",
      "tomorrow",
      "tone",
      "tongue",
      "tonight",
      "tool",
      "tooth",
      "top",
      "topic",
      "topple",
      "torch",
      "tornado",
      "tortoise",
      "toss",
      "total",
      "tourist",
      "toward",
      "tower",
      "town",
      "toy",
      "track",
      "trade",
      "traffic",
      "tragic",
      "train",
      "transfer",
      "trap",
      "trash",
      "travel",
      "tray",
      "treat",
      "tree",
      "trend",
      "trial",
      "tribe",
      "trick",
      "trigger",
      "trim",
      "trip",
      "trophy",
      "trouble",
      "truck",
      "true",
      "truly",
      "trumpet",
      "trust",
      "truth",
      "try",
      "tube",
      "tuition",
      "tumble",
      "tuna",
      "tunnel",
      "turkey",
      "turn",
      "turtle",
      "twelve",
      "twenty",
      "twice",
      "twin",
      "twist",
      "two",
      "type",
      "typical",
      "ugly",
      "umbrella",
      "unable",
      "unaware",
      "uncle",
      "uncover",
      "under",
      "undo",
      "unfair",
      "unfold",
      "unhappy",
      "uniform",
      "unique",
      "unit",
      "universe",
      "unknown",
      "unlock",
      "until",
      "unusual",
      "unveil",
      "update",
      "upgrade",
      "uphold",
      "upon",
      "upper",
      "upset",
      "urban",
      "urge",
      "usage",
      "use",
      "used",
      "useful",
      "useless",
      "usual",
      "utility",
      "vacant",
      "vacuum",
      "vague",
      "valid",
      "valley",
      "valve",
      "van",
      "vanish",
      "vapor",
      "various",
      "vast",
      "vault",
      "vehicle",
      "velvet",
      "vendor",
      "venture",
      "venue",
      "verb",
      "verify",
      "version",
      "very",
      "vessel",
      "veteran",
      "viable",
      "vibrant",
      "vicious",
      "victory",
      "video",
      "view",
      "village",
      "vintage",
      "violin",
      "virtual",
      "virus",
      "visa",
      "visit",
      "visual",
      "vital",
      "vivid",
      "vocal",
      "voice",
      "void",
      "volcano",
      "volume",
      "vote",
      "voyage",
      "wage",
      "wagon",
      "wait",
      "walk",
      "wall",
      "walnut",
      "want",
      "warfare",
      "warm",
      "warrior",
      "wash",
      "wasp",
      "waste",
      "water",
      "wave",
      "way",
      "wealth",
      "weapon",
      "wear",
      "weasel",
      "weather",
      "web",
      "wedding",
      "weekend",
      "weird",
      "welcome",
      "west",
      "wet",
      "whale",
      "what",
      "wheat",
      "wheel",
      "when",
      "where",
      "whip",
      "whisper",
      "wide",
      "width",
      "wife",
      "wild",
      "will",
      "win",
      "window",
      "wine",
      "wing",
      "wink",
      "winner",
      "winter",
      "wire",
      "wisdom",
      "wise",
      "wish",
      "witness",
      "wolf",
      "woman",
      "wonder",
      "wood",
      "wool",
      "word",
      "work",
      "world",
      "worry",
      "worth",
      "wrap",
      "wreck",
      "wrestle",
      "wrist",
      "write",
      "wrong",
      "yard",
      "year",
      "yellow",
      "you",
      "young",
      "youth",
      "zebra",
      "zero",
      "zone",
      "zoo"
    ];
    function bytesToBitstring(bytes) {
      return Array.from(bytes).map((byte) => byte.toString(2).padStart(8, "0")).join("");
    }
    function deriveChecksumBits(entropy) {
      const entropyLengthBits = entropy.length * 8;
      const checksumLengthBits = entropyLengthBits / 32;
      const hash = (0, sha_1.sha256)(entropy);
      return bytesToBitstring(hash).slice(0, checksumLengthBits);
    }
    function bitstringToByte(bin) {
      return parseInt(bin, 2);
    }
    var allowedEntropyLengths = [16, 20, 24, 28, 32];
    var allowedWordLengths = [12, 15, 18, 21, 24];
    function entropyToMnemonic(entropy) {
      if (allowedEntropyLengths.indexOf(entropy.length) === -1) {
        throw new Error("invalid input length");
      }
      const entropyBits = bytesToBitstring(entropy);
      const checksumBits = deriveChecksumBits(entropy);
      const bits = entropyBits + checksumBits;
      const chunks = bits.match(/(.{11})/g);
      const words = chunks.map((binary) => {
        const index = bitstringToByte(binary);
        return wordlist[index];
      });
      return words.join(" ");
    }
    var invalidNumberOfWords = "Invalid number of words";
    var wordNotInWordlist = "Found word that is not in the wordlist";
    var invalidEntropy = "Invalid entropy";
    var invalidChecksum = "Invalid mnemonic checksum";
    function normalize(str) {
      return str.normalize("NFKD");
    }
    function mnemonicToEntropy(mnemonic) {
      const words = normalize(mnemonic).split(" ");
      if (!allowedWordLengths.includes(words.length)) {
        throw new Error(invalidNumberOfWords);
      }
      const bits = words.map((word) => {
        const index = wordlist.indexOf(word);
        if (index === -1) {
          throw new Error(wordNotInWordlist);
        }
        return index.toString(2).padStart(11, "0");
      }).join("");
      const dividerIndex = Math.floor(bits.length / 33) * 32;
      const entropyBits = bits.slice(0, dividerIndex);
      const checksumBits = bits.slice(dividerIndex);
      const entropyBytes = entropyBits.match(/(.{1,8})/g).map(bitstringToByte);
      if (entropyBytes.length < 16 || entropyBytes.length > 32 || entropyBytes.length % 4 !== 0) {
        throw new Error(invalidEntropy);
      }
      const entropy = Uint8Array.from(entropyBytes);
      const newChecksum = deriveChecksumBits(entropy);
      if (newChecksum !== checksumBits) {
        throw new Error(invalidChecksum);
      }
      return entropy;
    }
    var EnglishMnemonic = class _EnglishMnemonic {
      constructor(mnemonic) {
        if (!_EnglishMnemonic.mnemonicMatcher.test(mnemonic)) {
          throw new Error("Invalid mnemonic format");
        }
        const words = mnemonic.split(" ");
        const allowedWordsLengths = [12, 15, 18, 21, 24];
        if (allowedWordsLengths.indexOf(words.length) === -1) {
          throw new Error(`Invalid word count in mnemonic (allowed: ${allowedWordsLengths} got: ${words.length})`);
        }
        for (const word of words) {
          if (_EnglishMnemonic.wordlist.indexOf(word) === -1) {
            throw new Error("Mnemonic contains invalid word");
          }
        }
        mnemonicToEntropy(mnemonic);
        this.data = mnemonic;
      }
      toString() {
        return this.data;
      }
    };
    exports.EnglishMnemonic = EnglishMnemonic;
    EnglishMnemonic.wordlist = wordlist;
    EnglishMnemonic.mnemonicMatcher = /^[a-z]+( [a-z]+)*$/;
    var Bip39 = class {
      /**
       * Encodes raw entropy of length 16, 20, 24, 28 or 32 bytes as an English mnemonic between 12 and 24 words.
       *
       * | Entropy            | Words |
       * |--------------------|-------|
       * | 128 bit (16 bytes) |    12 |
       * | 160 bit (20 bytes) |    15 |
       * | 192 bit (24 bytes) |    18 |
       * | 224 bit (28 bytes) |    21 |
       * | 256 bit (32 bytes) |    24 |
       *
       *
       * @see https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki#generating-the-mnemonic
       * @param entropy The entropy to be encoded. This must be cryptographically secure.
       */
      static encode(entropy) {
        return new EnglishMnemonic(entropyToMnemonic(entropy));
      }
      static decode(mnemonic) {
        return mnemonicToEntropy(mnemonic.toString());
      }
      static async mnemonicToSeed(mnemonic, password) {
        const mnemonicBytes = (0, encoding_1.toUtf8)(normalize(mnemonic.toString()));
        const salt = "mnemonic" + (password ? normalize(password) : "");
        const saltBytes = (0, encoding_1.toUtf8)(salt);
        return (0, pbkdf2_1.pbkdf2Sha512)(mnemonicBytes, saltBytes, 2048, 64);
      }
    };
    exports.Bip39 = Bip39;
  }
});

// ../../node_modules/.pnpm/@cosmjs+crypto@0.34.0/node_modules/@cosmjs/crypto/build/hmac.js
var require_hmac2 = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+crypto@0.34.0/node_modules/@cosmjs/crypto/build/hmac.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Hmac = void 0;
    var Hmac = class {
      constructor(hashFunctionConstructor, originalKey) {
        const blockSize = new hashFunctionConstructor().blockSize;
        this.hash = (data) => new hashFunctionConstructor().update(data).digest();
        let key = originalKey;
        if (key.length > blockSize) {
          key = this.hash(key);
        }
        if (key.length < blockSize) {
          const zeroPadding = new Uint8Array(blockSize - key.length);
          key = new Uint8Array([...key, ...zeroPadding]);
        }
        this.oKeyPad = key.map((keyByte) => keyByte ^ 92);
        this.iKeyPad = key.map((keyByte) => keyByte ^ 54);
        this.messageHasher = new hashFunctionConstructor();
        this.blockSize = blockSize;
        this.update(this.iKeyPad);
      }
      update(data) {
        this.messageHasher.update(data);
        return this;
      }
      digest() {
        const innerHash = this.messageHasher.digest();
        return this.hash(new Uint8Array([...this.oKeyPad, ...innerHash]));
      }
    };
    exports.Hmac = Hmac;
  }
});

// ../../node_modules/.pnpm/@cosmjs+crypto@0.34.0/node_modules/@cosmjs/crypto/build/keccak.js
var require_keccak = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+crypto@0.34.0/node_modules/@cosmjs/crypto/build/keccak.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Keccak256 = void 0;
    exports.keccak256 = keccak256;
    var sha3_1 = require_sha3();
    var utils_1 = require_utils2();
    var Keccak256 = class {
      constructor(firstData) {
        this.blockSize = 512 / 8;
        this.impl = sha3_1.keccak_256.create();
        if (firstData) {
          this.update(firstData);
        }
      }
      update(data) {
        this.impl.update((0, utils_1.toRealUint8Array)(data));
        return this;
      }
      digest() {
        return this.impl.digest();
      }
    };
    exports.Keccak256 = Keccak256;
    function keccak256(data) {
      return new Keccak256(data).digest();
    }
  }
});

// ../../node_modules/.pnpm/@cosmjs+crypto@0.34.0/node_modules/@cosmjs/crypto/build/libsodium.js
var require_libsodium = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+crypto@0.34.0/node_modules/@cosmjs/crypto/build/libsodium.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Xchacha20poly1305Ietf = exports.xchacha20NonceLength = exports.Ed25519 = exports.Ed25519Keypair = exports.Argon2id = void 0;
    exports.isArgon2idOptions = isArgon2idOptions;
    var utils_1 = require_build3();
    var libsodium_wrappers_sumo_1 = __importDefault(require_libsodium_wrappers());
    function isArgon2idOptions(thing) {
      if (!(0, utils_1.isNonNullObject)(thing))
        return false;
      if (typeof thing.outputLength !== "number")
        return false;
      if (typeof thing.opsLimit !== "number")
        return false;
      if (typeof thing.memLimitKib !== "number")
        return false;
      return true;
    }
    var Argon2id = class {
      static async execute(password, salt, options) {
        await libsodium_wrappers_sumo_1.default.ready;
        return libsodium_wrappers_sumo_1.default.crypto_pwhash(
          options.outputLength,
          password,
          salt,
          // libsodium only supports 16 byte salts and will throw when you don't respect that
          options.opsLimit,
          options.memLimitKib * 1024,
          libsodium_wrappers_sumo_1.default.crypto_pwhash_ALG_ARGON2ID13
        );
      }
    };
    exports.Argon2id = Argon2id;
    var Ed25519Keypair = class _Ed25519Keypair {
      // a libsodium privkey has the format `<ed25519 privkey> + <ed25519 pubkey>`
      static fromLibsodiumPrivkey(libsodiumPrivkey) {
        if (libsodiumPrivkey.length !== 64) {
          throw new Error(`Unexpected key length ${libsodiumPrivkey.length}. Must be 64.`);
        }
        return new _Ed25519Keypair(libsodiumPrivkey.slice(0, 32), libsodiumPrivkey.slice(32, 64));
      }
      constructor(privkey, pubkey) {
        this.privkey = privkey;
        this.pubkey = pubkey;
      }
      toLibsodiumPrivkey() {
        return new Uint8Array([...this.privkey, ...this.pubkey]);
      }
    };
    exports.Ed25519Keypair = Ed25519Keypair;
    var Ed25519 = class {
      /**
       * Generates a keypair deterministically from a given 32 bytes seed.
       *
       * This seed equals the Ed25519 private key.
       * For implementation details see crypto_sign_seed_keypair in
       * https://download.libsodium.org/doc/public-key_cryptography/public-key_signatures.html
       * and diagram on https://blog.mozilla.org/warner/2011/11/29/ed25519-keys/
       */
      static async makeKeypair(seed) {
        await libsodium_wrappers_sumo_1.default.ready;
        const keypair = libsodium_wrappers_sumo_1.default.crypto_sign_seed_keypair(seed);
        return Ed25519Keypair.fromLibsodiumPrivkey(keypair.privateKey);
      }
      static async createSignature(message, keyPair) {
        await libsodium_wrappers_sumo_1.default.ready;
        return libsodium_wrappers_sumo_1.default.crypto_sign_detached(message, keyPair.toLibsodiumPrivkey());
      }
      static async verifySignature(signature, message, pubkey) {
        await libsodium_wrappers_sumo_1.default.ready;
        return libsodium_wrappers_sumo_1.default.crypto_sign_verify_detached(signature, message, pubkey);
      }
    };
    exports.Ed25519 = Ed25519;
    exports.xchacha20NonceLength = 24;
    var Xchacha20poly1305Ietf = class {
      static async encrypt(message, key, nonce) {
        await libsodium_wrappers_sumo_1.default.ready;
        const additionalData = null;
        return libsodium_wrappers_sumo_1.default.crypto_aead_xchacha20poly1305_ietf_encrypt(
          message,
          additionalData,
          null,
          // secret nonce: unused and should be null (https://download.libsodium.org/doc/secret-key_cryptography/aead/chacha20-poly1305/xchacha20-poly1305_construction)
          nonce,
          key
        );
      }
      static async decrypt(ciphertext, key, nonce) {
        await libsodium_wrappers_sumo_1.default.ready;
        const additionalData = null;
        return libsodium_wrappers_sumo_1.default.crypto_aead_xchacha20poly1305_ietf_decrypt(
          null,
          // secret nonce: unused and should be null (https://download.libsodium.org/doc/secret-key_cryptography/aead/chacha20-poly1305/xchacha20-poly1305_construction)
          ciphertext,
          additionalData,
          nonce,
          key
        );
      }
    };
    exports.Xchacha20poly1305Ietf = Xchacha20poly1305Ietf;
  }
});

// ../../node_modules/.pnpm/@cosmjs+crypto@0.34.0/node_modules/@cosmjs/crypto/build/random.js
var require_random = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+crypto@0.34.0/node_modules/@cosmjs/crypto/build/random.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Random = void 0;
    var Random = class {
      /**
       * Returns `count` cryptographically secure random bytes
       */
      static getBytes(count) {
        try {
          const globalObject = typeof window === "object" ? window : self;
          const cryptoApi = typeof globalObject.crypto !== "undefined" ? globalObject.crypto : globalObject.msCrypto;
          const out = new Uint8Array(count);
          cryptoApi.getRandomValues(out);
          return out;
        } catch {
          try {
            const crypto = require_crypto();
            return new Uint8Array([...crypto.randomBytes(count)]);
          } catch {
            throw new Error("No secure random number generator found");
          }
        }
      }
    };
    exports.Random = Random;
  }
});

// ../../node_modules/.pnpm/@cosmjs+crypto@0.34.0/node_modules/@cosmjs/crypto/build/ripemd.js
var require_ripemd = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+crypto@0.34.0/node_modules/@cosmjs/crypto/build/ripemd.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Ripemd160 = void 0;
    exports.ripemd160 = ripemd160;
    var ripemd160_1 = require_ripemd160();
    var utils_1 = require_utils2();
    var Ripemd160 = class {
      constructor(firstData) {
        this.blockSize = 512 / 8;
        this.impl = ripemd160_1.ripemd160.create();
        if (firstData) {
          this.update(firstData);
        }
      }
      update(data) {
        this.impl.update((0, utils_1.toRealUint8Array)(data));
        return this;
      }
      digest() {
        return this.impl.digest();
      }
    };
    exports.Ripemd160 = Ripemd160;
    function ripemd160(data) {
      return new Ripemd160(data).digest();
    }
  }
});

// ../../node_modules/.pnpm/@noble+curves@1.9.4/node_modules/@noble/curves/utils.js
var require_utils3 = __commonJS({
  "../../node_modules/.pnpm/@noble+curves@1.9.4/node_modules/@noble/curves/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.notImplemented = exports.bitMask = exports.utf8ToBytes = exports.randomBytes = exports.isBytes = exports.hexToBytes = exports.concatBytes = exports.bytesToUtf8 = exports.bytesToHex = exports.anumber = exports.abytes = void 0;
    exports.abool = abool;
    exports.numberToHexUnpadded = numberToHexUnpadded;
    exports.hexToNumber = hexToNumber;
    exports.bytesToNumberBE = bytesToNumberBE;
    exports.bytesToNumberLE = bytesToNumberLE;
    exports.numberToBytesBE = numberToBytesBE;
    exports.numberToBytesLE = numberToBytesLE;
    exports.numberToVarBytesBE = numberToVarBytesBE;
    exports.ensureBytes = ensureBytes;
    exports.equalBytes = equalBytes;
    exports.inRange = inRange;
    exports.aInRange = aInRange;
    exports.bitLen = bitLen;
    exports.bitGet = bitGet;
    exports.bitSet = bitSet;
    exports.createHmacDrbg = createHmacDrbg;
    exports.validateObject = validateObject;
    exports.isHash = isHash;
    exports._validateObject = _validateObject;
    exports.memoized = memoized;
    var utils_js_1 = require_utils();
    var utils_js_2 = require_utils();
    Object.defineProperty(exports, "abytes", { enumerable: true, get: function() {
      return utils_js_2.abytes;
    } });
    Object.defineProperty(exports, "anumber", { enumerable: true, get: function() {
      return utils_js_2.anumber;
    } });
    Object.defineProperty(exports, "bytesToHex", { enumerable: true, get: function() {
      return utils_js_2.bytesToHex;
    } });
    Object.defineProperty(exports, "bytesToUtf8", { enumerable: true, get: function() {
      return utils_js_2.bytesToUtf8;
    } });
    Object.defineProperty(exports, "concatBytes", { enumerable: true, get: function() {
      return utils_js_2.concatBytes;
    } });
    Object.defineProperty(exports, "hexToBytes", { enumerable: true, get: function() {
      return utils_js_2.hexToBytes;
    } });
    Object.defineProperty(exports, "isBytes", { enumerable: true, get: function() {
      return utils_js_2.isBytes;
    } });
    Object.defineProperty(exports, "randomBytes", { enumerable: true, get: function() {
      return utils_js_2.randomBytes;
    } });
    Object.defineProperty(exports, "utf8ToBytes", { enumerable: true, get: function() {
      return utils_js_2.utf8ToBytes;
    } });
    var _0n = BigInt(0);
    var _1n = BigInt(1);
    function abool(title, value) {
      if (typeof value !== "boolean")
        throw new Error(title + " boolean expected, got " + value);
    }
    function numberToHexUnpadded(num) {
      const hex = num.toString(16);
      return hex.length & 1 ? "0" + hex : hex;
    }
    function hexToNumber(hex) {
      if (typeof hex !== "string")
        throw new Error("hex string expected, got " + typeof hex);
      return hex === "" ? _0n : BigInt("0x" + hex);
    }
    function bytesToNumberBE(bytes) {
      return hexToNumber((0, utils_js_1.bytesToHex)(bytes));
    }
    function bytesToNumberLE(bytes) {
      (0, utils_js_1.abytes)(bytes);
      return hexToNumber((0, utils_js_1.bytesToHex)(Uint8Array.from(bytes).reverse()));
    }
    function numberToBytesBE(n, len) {
      return (0, utils_js_1.hexToBytes)(n.toString(16).padStart(len * 2, "0"));
    }
    function numberToBytesLE(n, len) {
      return numberToBytesBE(n, len).reverse();
    }
    function numberToVarBytesBE(n) {
      return (0, utils_js_1.hexToBytes)(numberToHexUnpadded(n));
    }
    function ensureBytes(title, hex, expectedLength) {
      let res;
      if (typeof hex === "string") {
        try {
          res = (0, utils_js_1.hexToBytes)(hex);
        } catch (e) {
          throw new Error(title + " must be hex string or Uint8Array, cause: " + e);
        }
      } else if ((0, utils_js_1.isBytes)(hex)) {
        res = Uint8Array.from(hex);
      } else {
        throw new Error(title + " must be hex string or Uint8Array");
      }
      const len = res.length;
      if (typeof expectedLength === "number" && len !== expectedLength)
        throw new Error(title + " of length " + expectedLength + " expected, got " + len);
      return res;
    }
    function equalBytes(a, b) {
      if (a.length !== b.length)
        return false;
      let diff = 0;
      for (let i = 0; i < a.length; i++)
        diff |= a[i] ^ b[i];
      return diff === 0;
    }
    var isPosBig = (n) => typeof n === "bigint" && _0n <= n;
    function inRange(n, min, max) {
      return isPosBig(n) && isPosBig(min) && isPosBig(max) && min <= n && n < max;
    }
    function aInRange(title, n, min, max) {
      if (!inRange(n, min, max))
        throw new Error("expected valid " + title + ": " + min + " <= n < " + max + ", got " + n);
    }
    function bitLen(n) {
      let len;
      for (len = 0; n > _0n; n >>= _1n, len += 1)
        ;
      return len;
    }
    function bitGet(n, pos) {
      return n >> BigInt(pos) & _1n;
    }
    function bitSet(n, pos, value) {
      return n | (value ? _1n : _0n) << BigInt(pos);
    }
    var bitMask = (n) => (_1n << BigInt(n)) - _1n;
    exports.bitMask = bitMask;
    function createHmacDrbg(hashLen, qByteLen, hmacFn) {
      if (typeof hashLen !== "number" || hashLen < 2)
        throw new Error("hashLen must be a number");
      if (typeof qByteLen !== "number" || qByteLen < 2)
        throw new Error("qByteLen must be a number");
      if (typeof hmacFn !== "function")
        throw new Error("hmacFn must be a function");
      const u8n = (len) => new Uint8Array(len);
      const u8of = (byte) => Uint8Array.of(byte);
      let v = u8n(hashLen);
      let k = u8n(hashLen);
      let i = 0;
      const reset = () => {
        v.fill(1);
        k.fill(0);
        i = 0;
      };
      const h = (...b) => hmacFn(k, v, ...b);
      const reseed = (seed = u8n(0)) => {
        k = h(u8of(0), seed);
        v = h();
        if (seed.length === 0)
          return;
        k = h(u8of(1), seed);
        v = h();
      };
      const gen = () => {
        if (i++ >= 1e3)
          throw new Error("drbg: tried 1000 values");
        let len = 0;
        const out = [];
        while (len < qByteLen) {
          v = h();
          const sl = v.slice();
          out.push(sl);
          len += v.length;
        }
        return (0, utils_js_1.concatBytes)(...out);
      };
      const genUntil = (seed, pred) => {
        reset();
        reseed(seed);
        let res = void 0;
        while (!(res = pred(gen())))
          reseed();
        reset();
        return res;
      };
      return genUntil;
    }
    var validatorFns = {
      bigint: (val) => typeof val === "bigint",
      function: (val) => typeof val === "function",
      boolean: (val) => typeof val === "boolean",
      string: (val) => typeof val === "string",
      stringOrUint8Array: (val) => typeof val === "string" || (0, utils_js_1.isBytes)(val),
      isSafeInteger: (val) => Number.isSafeInteger(val),
      array: (val) => Array.isArray(val),
      field: (val, object) => object.Fp.isValid(val),
      hash: (val) => typeof val === "function" && Number.isSafeInteger(val.outputLen)
    };
    function validateObject(object, validators, optValidators = {}) {
      const checkField = (fieldName, type, isOptional) => {
        const checkVal = validatorFns[type];
        if (typeof checkVal !== "function")
          throw new Error("invalid validator function");
        const val = object[fieldName];
        if (isOptional && val === void 0)
          return;
        if (!checkVal(val, object)) {
          throw new Error("param " + String(fieldName) + " is invalid. Expected " + type + ", got " + val);
        }
      };
      for (const [fieldName, type] of Object.entries(validators))
        checkField(fieldName, type, false);
      for (const [fieldName, type] of Object.entries(optValidators))
        checkField(fieldName, type, true);
      return object;
    }
    function isHash(val) {
      return typeof val === "function" && Number.isSafeInteger(val.outputLen);
    }
    function _validateObject(object, fields, optFields = {}) {
      if (!object || typeof object !== "object")
        throw new Error("expected valid options object");
      function checkField(fieldName, expectedType, isOpt) {
        const val = object[fieldName];
        if (isOpt && val === void 0)
          return;
        const current = typeof val;
        if (current !== expectedType || val === null)
          throw new Error(`param "${fieldName}" is invalid: expected ${expectedType}, got ${current}`);
      }
      Object.entries(fields).forEach(([k, v]) => checkField(k, v, false));
      Object.entries(optFields).forEach(([k, v]) => checkField(k, v, true));
    }
    var notImplemented = () => {
      throw new Error("not implemented");
    };
    exports.notImplemented = notImplemented;
    function memoized(fn) {
      const map = /* @__PURE__ */ new WeakMap();
      return (arg, ...args) => {
        const val = map.get(arg);
        if (val !== void 0)
          return val;
        const computed = fn(arg, ...args);
        map.set(arg, computed);
        return computed;
      };
    }
  }
});

// ../../node_modules/.pnpm/@noble+curves@1.9.4/node_modules/@noble/curves/abstract/modular.js
var require_modular = __commonJS({
  "../../node_modules/.pnpm/@noble+curves@1.9.4/node_modules/@noble/curves/abstract/modular.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isNegativeLE = void 0;
    exports.mod = mod;
    exports.pow = pow;
    exports.pow2 = pow2;
    exports.invert = invert;
    exports.tonelliShanks = tonelliShanks;
    exports.FpSqrt = FpSqrt;
    exports.validateField = validateField;
    exports.FpPow = FpPow;
    exports.FpInvertBatch = FpInvertBatch;
    exports.FpDiv = FpDiv;
    exports.FpLegendre = FpLegendre;
    exports.FpIsSquare = FpIsSquare;
    exports.nLength = nLength;
    exports.Field = Field;
    exports.FpSqrtOdd = FpSqrtOdd;
    exports.FpSqrtEven = FpSqrtEven;
    exports.hashToPrivateScalar = hashToPrivateScalar;
    exports.getFieldBytesLength = getFieldBytesLength;
    exports.getMinHashLength = getMinHashLength;
    exports.mapHashToField = mapHashToField;
    var utils_ts_1 = require_utils3();
    var _0n = BigInt(0);
    var _1n = BigInt(1);
    var _2n = BigInt(2);
    var _3n = BigInt(3);
    var _4n = BigInt(4);
    var _5n = BigInt(5);
    var _7n = BigInt(7);
    var _8n = BigInt(8);
    var _9n = BigInt(9);
    var _16n = BigInt(16);
    function mod(a, b) {
      const result = a % b;
      return result >= _0n ? result : b + result;
    }
    function pow(num, power, modulo) {
      return FpPow(Field(modulo), num, power);
    }
    function pow2(x, power, modulo) {
      let res = x;
      while (power-- > _0n) {
        res *= res;
        res %= modulo;
      }
      return res;
    }
    function invert(number, modulo) {
      if (number === _0n)
        throw new Error("invert: expected non-zero number");
      if (modulo <= _0n)
        throw new Error("invert: expected positive modulus, got " + modulo);
      let a = mod(number, modulo);
      let b = modulo;
      let x = _0n, y = _1n, u = _1n, v = _0n;
      while (a !== _0n) {
        const q = b / a;
        const r = b % a;
        const m = x - u * q;
        const n = y - v * q;
        b = a, a = r, x = u, y = v, u = m, v = n;
      }
      const gcd = b;
      if (gcd !== _1n)
        throw new Error("invert: does not exist");
      return mod(x, modulo);
    }
    function assertIsSquare(Fp, root, n) {
      if (!Fp.eql(Fp.sqr(root), n))
        throw new Error("Cannot find square root");
    }
    function sqrt3mod4(Fp, n) {
      const p1div4 = (Fp.ORDER + _1n) / _4n;
      const root = Fp.pow(n, p1div4);
      assertIsSquare(Fp, root, n);
      return root;
    }
    function sqrt5mod8(Fp, n) {
      const p5div8 = (Fp.ORDER - _5n) / _8n;
      const n2 = Fp.mul(n, _2n);
      const v = Fp.pow(n2, p5div8);
      const nv = Fp.mul(n, v);
      const i = Fp.mul(Fp.mul(nv, _2n), v);
      const root = Fp.mul(nv, Fp.sub(i, Fp.ONE));
      assertIsSquare(Fp, root, n);
      return root;
    }
    function sqrt9mod16(P) {
      const Fp_ = Field(P);
      const tn = tonelliShanks(P);
      const c1 = tn(Fp_, Fp_.neg(Fp_.ONE));
      const c2 = tn(Fp_, c1);
      const c3 = tn(Fp_, Fp_.neg(c1));
      const c4 = (P + _7n) / _16n;
      return (Fp, n) => {
        let tv1 = Fp.pow(n, c4);
        let tv2 = Fp.mul(tv1, c1);
        const tv3 = Fp.mul(tv1, c2);
        const tv4 = Fp.mul(tv1, c3);
        const e1 = Fp.eql(Fp.sqr(tv2), n);
        const e2 = Fp.eql(Fp.sqr(tv3), n);
        tv1 = Fp.cmov(tv1, tv2, e1);
        tv2 = Fp.cmov(tv4, tv3, e2);
        const e3 = Fp.eql(Fp.sqr(tv2), n);
        const root = Fp.cmov(tv1, tv2, e3);
        assertIsSquare(Fp, root, n);
        return root;
      };
    }
    function tonelliShanks(P) {
      if (P < _3n)
        throw new Error("sqrt is not defined for small field");
      let Q = P - _1n;
      let S = 0;
      while (Q % _2n === _0n) {
        Q /= _2n;
        S++;
      }
      let Z = _2n;
      const _Fp = Field(P);
      while (FpLegendre(_Fp, Z) === 1) {
        if (Z++ > 1e3)
          throw new Error("Cannot find square root: probably non-prime P");
      }
      if (S === 1)
        return sqrt3mod4;
      let cc = _Fp.pow(Z, Q);
      const Q1div2 = (Q + _1n) / _2n;
      return function tonelliSlow(Fp, n) {
        if (Fp.is0(n))
          return n;
        if (FpLegendre(Fp, n) !== 1)
          throw new Error("Cannot find square root");
        let M = S;
        let c = Fp.mul(Fp.ONE, cc);
        let t = Fp.pow(n, Q);
        let R = Fp.pow(n, Q1div2);
        while (!Fp.eql(t, Fp.ONE)) {
          if (Fp.is0(t))
            return Fp.ZERO;
          let i = 1;
          let t_tmp = Fp.sqr(t);
          while (!Fp.eql(t_tmp, Fp.ONE)) {
            i++;
            t_tmp = Fp.sqr(t_tmp);
            if (i === M)
              throw new Error("Cannot find square root");
          }
          const exponent = _1n << BigInt(M - i - 1);
          const b = Fp.pow(c, exponent);
          M = i;
          c = Fp.sqr(b);
          t = Fp.mul(t, c);
          R = Fp.mul(R, b);
        }
        return R;
      };
    }
    function FpSqrt(P) {
      if (P % _4n === _3n)
        return sqrt3mod4;
      if (P % _8n === _5n)
        return sqrt5mod8;
      if (P % _16n === _9n)
        return sqrt9mod16(P);
      return tonelliShanks(P);
    }
    var isNegativeLE = (num, modulo) => (mod(num, modulo) & _1n) === _1n;
    exports.isNegativeLE = isNegativeLE;
    var FIELD_FIELDS = [
      "create",
      "isValid",
      "is0",
      "neg",
      "inv",
      "sqrt",
      "sqr",
      "eql",
      "add",
      "sub",
      "mul",
      "pow",
      "div",
      "addN",
      "subN",
      "mulN",
      "sqrN"
    ];
    function validateField(field) {
      const initial = {
        ORDER: "bigint",
        MASK: "bigint",
        BYTES: "number",
        BITS: "number"
      };
      const opts = FIELD_FIELDS.reduce((map, val) => {
        map[val] = "function";
        return map;
      }, initial);
      (0, utils_ts_1._validateObject)(field, opts);
      return field;
    }
    function FpPow(Fp, num, power) {
      if (power < _0n)
        throw new Error("invalid exponent, negatives unsupported");
      if (power === _0n)
        return Fp.ONE;
      if (power === _1n)
        return num;
      let p = Fp.ONE;
      let d = num;
      while (power > _0n) {
        if (power & _1n)
          p = Fp.mul(p, d);
        d = Fp.sqr(d);
        power >>= _1n;
      }
      return p;
    }
    function FpInvertBatch(Fp, nums, passZero = false) {
      const inverted = new Array(nums.length).fill(passZero ? Fp.ZERO : void 0);
      const multipliedAcc = nums.reduce((acc, num, i) => {
        if (Fp.is0(num))
          return acc;
        inverted[i] = acc;
        return Fp.mul(acc, num);
      }, Fp.ONE);
      const invertedAcc = Fp.inv(multipliedAcc);
      nums.reduceRight((acc, num, i) => {
        if (Fp.is0(num))
          return acc;
        inverted[i] = Fp.mul(acc, inverted[i]);
        return Fp.mul(acc, num);
      }, invertedAcc);
      return inverted;
    }
    function FpDiv(Fp, lhs, rhs) {
      return Fp.mul(lhs, typeof rhs === "bigint" ? invert(rhs, Fp.ORDER) : Fp.inv(rhs));
    }
    function FpLegendre(Fp, n) {
      const p1mod2 = (Fp.ORDER - _1n) / _2n;
      const powered = Fp.pow(n, p1mod2);
      const yes = Fp.eql(powered, Fp.ONE);
      const zero = Fp.eql(powered, Fp.ZERO);
      const no = Fp.eql(powered, Fp.neg(Fp.ONE));
      if (!yes && !zero && !no)
        throw new Error("invalid Legendre symbol result");
      return yes ? 1 : zero ? 0 : -1;
    }
    function FpIsSquare(Fp, n) {
      const l = FpLegendre(Fp, n);
      return l === 1;
    }
    function nLength(n, nBitLength) {
      if (nBitLength !== void 0)
        (0, utils_ts_1.anumber)(nBitLength);
      const _nBitLength = nBitLength !== void 0 ? nBitLength : n.toString(2).length;
      const nByteLength = Math.ceil(_nBitLength / 8);
      return { nBitLength: _nBitLength, nByteLength };
    }
    function Field(ORDER, bitLenOrOpts, isLE = false, opts = {}) {
      if (ORDER <= _0n)
        throw new Error("invalid field: expected ORDER > 0, got " + ORDER);
      let _nbitLength = void 0;
      let _sqrt = void 0;
      let modOnDecode = false;
      let allowedLengths = void 0;
      if (typeof bitLenOrOpts === "object" && bitLenOrOpts != null) {
        if (opts.sqrt || isLE)
          throw new Error("cannot specify opts in two arguments");
        const _opts = bitLenOrOpts;
        if (_opts.BITS)
          _nbitLength = _opts.BITS;
        if (_opts.sqrt)
          _sqrt = _opts.sqrt;
        if (typeof _opts.isLE === "boolean")
          isLE = _opts.isLE;
        if (typeof _opts.modOnDecode === "boolean")
          modOnDecode = _opts.modOnDecode;
        allowedLengths = _opts.allowedLengths;
      } else {
        if (typeof bitLenOrOpts === "number")
          _nbitLength = bitLenOrOpts;
        if (opts.sqrt)
          _sqrt = opts.sqrt;
      }
      const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, _nbitLength);
      if (BYTES > 2048)
        throw new Error("invalid field: expected ORDER of <= 2048 bytes");
      let sqrtP;
      const f = Object.freeze({
        ORDER,
        isLE,
        BITS,
        BYTES,
        MASK: (0, utils_ts_1.bitMask)(BITS),
        ZERO: _0n,
        ONE: _1n,
        allowedLengths,
        create: (num) => mod(num, ORDER),
        isValid: (num) => {
          if (typeof num !== "bigint")
            throw new Error("invalid field element: expected bigint, got " + typeof num);
          return _0n <= num && num < ORDER;
        },
        is0: (num) => num === _0n,
        // is valid and invertible
        isValidNot0: (num) => !f.is0(num) && f.isValid(num),
        isOdd: (num) => (num & _1n) === _1n,
        neg: (num) => mod(-num, ORDER),
        eql: (lhs, rhs) => lhs === rhs,
        sqr: (num) => mod(num * num, ORDER),
        add: (lhs, rhs) => mod(lhs + rhs, ORDER),
        sub: (lhs, rhs) => mod(lhs - rhs, ORDER),
        mul: (lhs, rhs) => mod(lhs * rhs, ORDER),
        pow: (num, power) => FpPow(f, num, power),
        div: (lhs, rhs) => mod(lhs * invert(rhs, ORDER), ORDER),
        // Same as above, but doesn't normalize
        sqrN: (num) => num * num,
        addN: (lhs, rhs) => lhs + rhs,
        subN: (lhs, rhs) => lhs - rhs,
        mulN: (lhs, rhs) => lhs * rhs,
        inv: (num) => invert(num, ORDER),
        sqrt: _sqrt || ((n) => {
          if (!sqrtP)
            sqrtP = FpSqrt(ORDER);
          return sqrtP(f, n);
        }),
        toBytes: (num) => isLE ? (0, utils_ts_1.numberToBytesLE)(num, BYTES) : (0, utils_ts_1.numberToBytesBE)(num, BYTES),
        fromBytes: (bytes, skipValidation = true) => {
          if (allowedLengths) {
            if (!allowedLengths.includes(bytes.length) || bytes.length > BYTES) {
              throw new Error("Field.fromBytes: expected " + allowedLengths + " bytes, got " + bytes.length);
            }
            const padded = new Uint8Array(BYTES);
            padded.set(bytes, isLE ? 0 : padded.length - bytes.length);
            bytes = padded;
          }
          if (bytes.length !== BYTES)
            throw new Error("Field.fromBytes: expected " + BYTES + " bytes, got " + bytes.length);
          let scalar = isLE ? (0, utils_ts_1.bytesToNumberLE)(bytes) : (0, utils_ts_1.bytesToNumberBE)(bytes);
          if (modOnDecode)
            scalar = mod(scalar, ORDER);
          if (!skipValidation) {
            if (!f.isValid(scalar))
              throw new Error("invalid field element: outside of range 0..ORDER");
          }
          return scalar;
        },
        // TODO: we don't need it here, move out to separate fn
        invertBatch: (lst) => FpInvertBatch(f, lst),
        // We can't move this out because Fp6, Fp12 implement it
        // and it's unclear what to return in there.
        cmov: (a, b, c) => c ? b : a
      });
      return Object.freeze(f);
    }
    function FpSqrtOdd(Fp, elm) {
      if (!Fp.isOdd)
        throw new Error("Field doesn't have isOdd");
      const root = Fp.sqrt(elm);
      return Fp.isOdd(root) ? root : Fp.neg(root);
    }
    function FpSqrtEven(Fp, elm) {
      if (!Fp.isOdd)
        throw new Error("Field doesn't have isOdd");
      const root = Fp.sqrt(elm);
      return Fp.isOdd(root) ? Fp.neg(root) : root;
    }
    function hashToPrivateScalar(hash, groupOrder, isLE = false) {
      hash = (0, utils_ts_1.ensureBytes)("privateHash", hash);
      const hashLen = hash.length;
      const minLen = nLength(groupOrder).nByteLength + 8;
      if (minLen < 24 || hashLen < minLen || hashLen > 1024)
        throw new Error("hashToPrivateScalar: expected " + minLen + "-1024 bytes of input, got " + hashLen);
      const num = isLE ? (0, utils_ts_1.bytesToNumberLE)(hash) : (0, utils_ts_1.bytesToNumberBE)(hash);
      return mod(num, groupOrder - _1n) + _1n;
    }
    function getFieldBytesLength(fieldOrder) {
      if (typeof fieldOrder !== "bigint")
        throw new Error("field order must be bigint");
      const bitLength = fieldOrder.toString(2).length;
      return Math.ceil(bitLength / 8);
    }
    function getMinHashLength(fieldOrder) {
      const length = getFieldBytesLength(fieldOrder);
      return length + Math.ceil(length / 2);
    }
    function mapHashToField(key, fieldOrder, isLE = false) {
      const len = key.length;
      const fieldLen = getFieldBytesLength(fieldOrder);
      const minLen = getMinHashLength(fieldOrder);
      if (len < 16 || len < minLen || len > 1024)
        throw new Error("expected " + minLen + "-1024 bytes of input, got " + len);
      const num = isLE ? (0, utils_ts_1.bytesToNumberLE)(key) : (0, utils_ts_1.bytesToNumberBE)(key);
      const reduced = mod(num, fieldOrder - _1n) + _1n;
      return isLE ? (0, utils_ts_1.numberToBytesLE)(reduced, fieldLen) : (0, utils_ts_1.numberToBytesBE)(reduced, fieldLen);
    }
  }
});

// ../../node_modules/.pnpm/@noble+curves@1.9.4/node_modules/@noble/curves/abstract/curve.js
var require_curve = __commonJS({
  "../../node_modules/.pnpm/@noble+curves@1.9.4/node_modules/@noble/curves/abstract/curve.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.wNAF = void 0;
    exports.negateCt = negateCt;
    exports.normalizeZ = normalizeZ;
    exports.mulEndoUnsafe = mulEndoUnsafe;
    exports.pippenger = pippenger;
    exports.precomputeMSMUnsafe = precomputeMSMUnsafe;
    exports.validateBasic = validateBasic;
    exports._createCurveFields = _createCurveFields;
    var utils_ts_1 = require_utils3();
    var modular_ts_1 = require_modular();
    var _0n = BigInt(0);
    var _1n = BigInt(1);
    function negateCt(condition, item) {
      const neg = item.negate();
      return condition ? neg : item;
    }
    function normalizeZ(c, points) {
      const invertedZs = (0, modular_ts_1.FpInvertBatch)(c.Fp, points.map((p) => p.Z));
      return points.map((p, i) => c.fromAffine(p.toAffine(invertedZs[i])));
    }
    function validateW(W, bits) {
      if (!Number.isSafeInteger(W) || W <= 0 || W > bits)
        throw new Error("invalid window size, expected [1.." + bits + "], got W=" + W);
    }
    function calcWOpts(W, scalarBits) {
      validateW(W, scalarBits);
      const windows = Math.ceil(scalarBits / W) + 1;
      const windowSize = 2 ** (W - 1);
      const maxNumber = 2 ** W;
      const mask = (0, utils_ts_1.bitMask)(W);
      const shiftBy = BigInt(W);
      return { windows, windowSize, mask, maxNumber, shiftBy };
    }
    function calcOffsets(n, window2, wOpts) {
      const { windowSize, mask, maxNumber, shiftBy } = wOpts;
      let wbits = Number(n & mask);
      let nextN = n >> shiftBy;
      if (wbits > windowSize) {
        wbits -= maxNumber;
        nextN += _1n;
      }
      const offsetStart = window2 * windowSize;
      const offset = offsetStart + Math.abs(wbits) - 1;
      const isZero = wbits === 0;
      const isNeg = wbits < 0;
      const isNegF = window2 % 2 !== 0;
      const offsetF = offsetStart;
      return { nextN, offset, isZero, isNeg, isNegF, offsetF };
    }
    function validateMSMPoints(points, c) {
      if (!Array.isArray(points))
        throw new Error("array expected");
      points.forEach((p, i) => {
        if (!(p instanceof c))
          throw new Error("invalid point at index " + i);
      });
    }
    function validateMSMScalars(scalars, field) {
      if (!Array.isArray(scalars))
        throw new Error("array of scalars expected");
      scalars.forEach((s, i) => {
        if (!field.isValid(s))
          throw new Error("invalid scalar at index " + i);
      });
    }
    var pointPrecomputes = /* @__PURE__ */ new WeakMap();
    var pointWindowSizes = /* @__PURE__ */ new WeakMap();
    function getW(P) {
      return pointWindowSizes.get(P) || 1;
    }
    function assert0(n) {
      if (n !== _0n)
        throw new Error("invalid wNAF");
    }
    var wNAF = class {
      // Parametrized with a given Point class (not individual point)
      constructor(Point, bits) {
        this.BASE = Point.BASE;
        this.ZERO = Point.ZERO;
        this.Fn = Point.Fn;
        this.bits = bits;
      }
      // non-const time multiplication ladder
      _unsafeLadder(elm, n, p = this.ZERO) {
        let d = elm;
        while (n > _0n) {
          if (n & _1n)
            p = p.add(d);
          d = d.double();
          n >>= _1n;
        }
        return p;
      }
      /**
       * Creates a wNAF precomputation window. Used for caching.
       * Default window size is set by `utils.precompute()` and is equal to 8.
       * Number of precomputed points depends on the curve size:
       * 2^(𝑊−1) * (Math.ceil(𝑛 / 𝑊) + 1), where:
       * - 𝑊 is the window size
       * - 𝑛 is the bitlength of the curve order.
       * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
       * @param point Point instance
       * @param W window size
       * @returns precomputed point tables flattened to a single array
       */
      precomputeWindow(point, W) {
        const { windows, windowSize } = calcWOpts(W, this.bits);
        const points = [];
        let p = point;
        let base = p;
        for (let window2 = 0; window2 < windows; window2++) {
          base = p;
          points.push(base);
          for (let i = 1; i < windowSize; i++) {
            base = base.add(p);
            points.push(base);
          }
          p = base.double();
        }
        return points;
      }
      /**
       * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
       * More compact implementation:
       * https://github.com/paulmillr/noble-secp256k1/blob/47cb1669b6e506ad66b35fe7d76132ae97465da2/index.ts#L502-L541
       * @returns real and fake (for const-time) points
       */
      wNAF(W, precomputes, n) {
        if (!this.Fn.isValid(n))
          throw new Error("invalid scalar");
        let p = this.ZERO;
        let f = this.BASE;
        const wo = calcWOpts(W, this.bits);
        for (let window2 = 0; window2 < wo.windows; window2++) {
          const { nextN, offset, isZero, isNeg, isNegF, offsetF } = calcOffsets(n, window2, wo);
          n = nextN;
          if (isZero) {
            f = f.add(negateCt(isNegF, precomputes[offsetF]));
          } else {
            p = p.add(negateCt(isNeg, precomputes[offset]));
          }
        }
        assert0(n);
        return { p, f };
      }
      /**
       * Implements ec unsafe (non const-time) multiplication using precomputed tables and w-ary non-adjacent form.
       * @param acc accumulator point to add result of multiplication
       * @returns point
       */
      wNAFUnsafe(W, precomputes, n, acc = this.ZERO) {
        const wo = calcWOpts(W, this.bits);
        for (let window2 = 0; window2 < wo.windows; window2++) {
          if (n === _0n)
            break;
          const { nextN, offset, isZero, isNeg } = calcOffsets(n, window2, wo);
          n = nextN;
          if (isZero) {
            continue;
          } else {
            const item = precomputes[offset];
            acc = acc.add(isNeg ? item.negate() : item);
          }
        }
        assert0(n);
        return acc;
      }
      getPrecomputes(W, point, transform) {
        let comp = pointPrecomputes.get(point);
        if (!comp) {
          comp = this.precomputeWindow(point, W);
          if (W !== 1) {
            if (typeof transform === "function")
              comp = transform(comp);
            pointPrecomputes.set(point, comp);
          }
        }
        return comp;
      }
      cached(point, scalar, transform) {
        const W = getW(point);
        return this.wNAF(W, this.getPrecomputes(W, point, transform), scalar);
      }
      unsafe(point, scalar, transform, prev) {
        const W = getW(point);
        if (W === 1)
          return this._unsafeLadder(point, scalar, prev);
        return this.wNAFUnsafe(W, this.getPrecomputes(W, point, transform), scalar, prev);
      }
      // We calculate precomputes for elliptic curve point multiplication
      // using windowed method. This specifies window size and
      // stores precomputed values. Usually only base point would be precomputed.
      createCache(P, W) {
        validateW(W, this.bits);
        pointWindowSizes.set(P, W);
        pointPrecomputes.delete(P);
      }
      hasCache(elm) {
        return getW(elm) !== 1;
      }
    };
    exports.wNAF = wNAF;
    function mulEndoUnsafe(Point, point, k1, k2) {
      let acc = point;
      let p1 = Point.ZERO;
      let p2 = Point.ZERO;
      while (k1 > _0n || k2 > _0n) {
        if (k1 & _1n)
          p1 = p1.add(acc);
        if (k2 & _1n)
          p2 = p2.add(acc);
        acc = acc.double();
        k1 >>= _1n;
        k2 >>= _1n;
      }
      return { p1, p2 };
    }
    function pippenger(c, fieldN, points, scalars) {
      validateMSMPoints(points, c);
      validateMSMScalars(scalars, fieldN);
      const plength = points.length;
      const slength = scalars.length;
      if (plength !== slength)
        throw new Error("arrays of points and scalars must have equal length");
      const zero = c.ZERO;
      const wbits = (0, utils_ts_1.bitLen)(BigInt(plength));
      let windowSize = 1;
      if (wbits > 12)
        windowSize = wbits - 3;
      else if (wbits > 4)
        windowSize = wbits - 2;
      else if (wbits > 0)
        windowSize = 2;
      const MASK = (0, utils_ts_1.bitMask)(windowSize);
      const buckets = new Array(Number(MASK) + 1).fill(zero);
      const lastBits = Math.floor((fieldN.BITS - 1) / windowSize) * windowSize;
      let sum = zero;
      for (let i = lastBits; i >= 0; i -= windowSize) {
        buckets.fill(zero);
        for (let j = 0; j < slength; j++) {
          const scalar = scalars[j];
          const wbits2 = Number(scalar >> BigInt(i) & MASK);
          buckets[wbits2] = buckets[wbits2].add(points[j]);
        }
        let resI = zero;
        for (let j = buckets.length - 1, sumI = zero; j > 0; j--) {
          sumI = sumI.add(buckets[j]);
          resI = resI.add(sumI);
        }
        sum = sum.add(resI);
        if (i !== 0)
          for (let j = 0; j < windowSize; j++)
            sum = sum.double();
      }
      return sum;
    }
    function precomputeMSMUnsafe(c, fieldN, points, windowSize) {
      validateW(windowSize, fieldN.BITS);
      validateMSMPoints(points, c);
      const zero = c.ZERO;
      const tableSize = 2 ** windowSize - 1;
      const chunks = Math.ceil(fieldN.BITS / windowSize);
      const MASK = (0, utils_ts_1.bitMask)(windowSize);
      const tables = points.map((p) => {
        const res = [];
        for (let i = 0, acc = p; i < tableSize; i++) {
          res.push(acc);
          acc = acc.add(p);
        }
        return res;
      });
      return (scalars) => {
        validateMSMScalars(scalars, fieldN);
        if (scalars.length > points.length)
          throw new Error("array of scalars must be smaller than array of points");
        let res = zero;
        for (let i = 0; i < chunks; i++) {
          if (res !== zero)
            for (let j = 0; j < windowSize; j++)
              res = res.double();
          const shiftBy = BigInt(chunks * windowSize - (i + 1) * windowSize);
          for (let j = 0; j < scalars.length; j++) {
            const n = scalars[j];
            const curr = Number(n >> shiftBy & MASK);
            if (!curr)
              continue;
            res = res.add(tables[j][curr - 1]);
          }
        }
        return res;
      };
    }
    function validateBasic(curve) {
      (0, modular_ts_1.validateField)(curve.Fp);
      (0, utils_ts_1.validateObject)(curve, {
        n: "bigint",
        h: "bigint",
        Gx: "field",
        Gy: "field"
      }, {
        nBitLength: "isSafeInteger",
        nByteLength: "isSafeInteger"
      });
      return Object.freeze({
        ...(0, modular_ts_1.nLength)(curve.n, curve.nBitLength),
        ...curve,
        ...{ p: curve.Fp.ORDER }
      });
    }
    function createField(order, field) {
      if (field) {
        if (field.ORDER !== order)
          throw new Error("Field.ORDER must match order: Fp == p, Fn == n");
        (0, modular_ts_1.validateField)(field);
        return field;
      } else {
        return (0, modular_ts_1.Field)(order);
      }
    }
    function _createCurveFields(type, CURVE, curveOpts = {}) {
      if (!CURVE || typeof CURVE !== "object")
        throw new Error(`expected valid ${type} CURVE object`);
      for (const p of ["p", "n", "h"]) {
        const val = CURVE[p];
        if (!(typeof val === "bigint" && val > _0n))
          throw new Error(`CURVE.${p} must be positive bigint`);
      }
      const Fp = createField(CURVE.p, curveOpts.Fp);
      const Fn = createField(CURVE.n, curveOpts.Fn);
      const _b = type === "weierstrass" ? "b" : "d";
      const params = ["Gx", "Gy", "a", _b];
      for (const p of params) {
        if (!Fp.isValid(CURVE[p]))
          throw new Error(`CURVE.${p} must be valid field element of CURVE.Fp`);
      }
      return { Fp, Fn };
    }
  }
});

// ../../node_modules/.pnpm/@noble+curves@1.9.4/node_modules/@noble/curves/abstract/weierstrass.js
var require_weierstrass = __commonJS({
  "../../node_modules/.pnpm/@noble+curves@1.9.4/node_modules/@noble/curves/abstract/weierstrass.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DER = exports.DERErr = void 0;
    exports._splitEndoScalar = _splitEndoScalar;
    exports._legacyHelperEquat = _legacyHelperEquat;
    exports._normFnElement = _normFnElement;
    exports.weierstrassN = weierstrassN;
    exports.weierstrassPoints = weierstrassPoints;
    exports.SWUFpSqrtRatio = SWUFpSqrtRatio;
    exports.mapToCurveSimpleSWU = mapToCurveSimpleSWU;
    exports.ecdsa = ecdsa;
    exports.weierstrass = weierstrass;
    var hmac_js_1 = require_hmac();
    var utils_1 = require_utils();
    var utils_ts_1 = require_utils3();
    var curve_ts_1 = require_curve();
    var modular_ts_1 = require_modular();
    var divNearest = (num, den) => (num + (num >= 0 ? den : -den) / _2n) / den;
    function _splitEndoScalar(k, basis, n) {
      const [[a1, b1], [a2, b2]] = basis;
      const c1 = divNearest(b2 * k, n);
      const c2 = divNearest(-b1 * k, n);
      let k1 = k - c1 * a1 - c2 * a2;
      let k2 = -c1 * b1 - c2 * b2;
      const k1neg = k1 < _0n;
      const k2neg = k2 < _0n;
      if (k1neg)
        k1 = -k1;
      if (k2neg)
        k2 = -k2;
      const MAX_NUM = (0, utils_ts_1.bitMask)(Math.ceil((0, utils_ts_1.bitLen)(n) / 2)) + _1n;
      if (k1 < _0n || k1 >= MAX_NUM || k2 < _0n || k2 >= MAX_NUM) {
        throw new Error("splitScalar (endomorphism): failed, k=" + k);
      }
      return { k1neg, k1, k2neg, k2 };
    }
    function validateSigVerOpts(opts) {
      if (opts.lowS !== void 0)
        (0, utils_ts_1.abool)("lowS", opts.lowS);
      if (opts.prehash !== void 0)
        (0, utils_ts_1.abool)("prehash", opts.prehash);
    }
    var DERErr = class extends Error {
      constructor(m = "") {
        super(m);
      }
    };
    exports.DERErr = DERErr;
    exports.DER = {
      // asn.1 DER encoding utils
      Err: DERErr,
      // Basic building block is TLV (Tag-Length-Value)
      _tlv: {
        encode: (tag, data) => {
          const { Err: E } = exports.DER;
          if (tag < 0 || tag > 256)
            throw new E("tlv.encode: wrong tag");
          if (data.length & 1)
            throw new E("tlv.encode: unpadded data");
          const dataLen = data.length / 2;
          const len = (0, utils_ts_1.numberToHexUnpadded)(dataLen);
          if (len.length / 2 & 128)
            throw new E("tlv.encode: long form length too big");
          const lenLen = dataLen > 127 ? (0, utils_ts_1.numberToHexUnpadded)(len.length / 2 | 128) : "";
          const t = (0, utils_ts_1.numberToHexUnpadded)(tag);
          return t + lenLen + len + data;
        },
        // v - value, l - left bytes (unparsed)
        decode(tag, data) {
          const { Err: E } = exports.DER;
          let pos = 0;
          if (tag < 0 || tag > 256)
            throw new E("tlv.encode: wrong tag");
          if (data.length < 2 || data[pos++] !== tag)
            throw new E("tlv.decode: wrong tlv");
          const first = data[pos++];
          const isLong = !!(first & 128);
          let length = 0;
          if (!isLong)
            length = first;
          else {
            const lenLen = first & 127;
            if (!lenLen)
              throw new E("tlv.decode(long): indefinite length not supported");
            if (lenLen > 4)
              throw new E("tlv.decode(long): byte length is too big");
            const lengthBytes = data.subarray(pos, pos + lenLen);
            if (lengthBytes.length !== lenLen)
              throw new E("tlv.decode: length bytes not complete");
            if (lengthBytes[0] === 0)
              throw new E("tlv.decode(long): zero leftmost byte");
            for (const b of lengthBytes)
              length = length << 8 | b;
            pos += lenLen;
            if (length < 128)
              throw new E("tlv.decode(long): not minimal encoding");
          }
          const v = data.subarray(pos, pos + length);
          if (v.length !== length)
            throw new E("tlv.decode: wrong value length");
          return { v, l: data.subarray(pos + length) };
        }
      },
      // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,
      // since we always use positive integers here. It must always be empty:
      // - add zero byte if exists
      // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)
      _int: {
        encode(num) {
          const { Err: E } = exports.DER;
          if (num < _0n)
            throw new E("integer: negative integers are not allowed");
          let hex = (0, utils_ts_1.numberToHexUnpadded)(num);
          if (Number.parseInt(hex[0], 16) & 8)
            hex = "00" + hex;
          if (hex.length & 1)
            throw new E("unexpected DER parsing assertion: unpadded hex");
          return hex;
        },
        decode(data) {
          const { Err: E } = exports.DER;
          if (data[0] & 128)
            throw new E("invalid signature integer: negative");
          if (data[0] === 0 && !(data[1] & 128))
            throw new E("invalid signature integer: unnecessary leading zero");
          return (0, utils_ts_1.bytesToNumberBE)(data);
        }
      },
      toSig(hex) {
        const { Err: E, _int: int, _tlv: tlv } = exports.DER;
        const data = (0, utils_ts_1.ensureBytes)("signature", hex);
        const { v: seqBytes, l: seqLeftBytes } = tlv.decode(48, data);
        if (seqLeftBytes.length)
          throw new E("invalid signature: left bytes after parsing");
        const { v: rBytes, l: rLeftBytes } = tlv.decode(2, seqBytes);
        const { v: sBytes, l: sLeftBytes } = tlv.decode(2, rLeftBytes);
        if (sLeftBytes.length)
          throw new E("invalid signature: left bytes after parsing");
        return { r: int.decode(rBytes), s: int.decode(sBytes) };
      },
      hexFromSig(sig) {
        const { _tlv: tlv, _int: int } = exports.DER;
        const rs = tlv.encode(2, int.encode(sig.r));
        const ss = tlv.encode(2, int.encode(sig.s));
        const seq = rs + ss;
        return tlv.encode(48, seq);
      }
    };
    var _0n = BigInt(0);
    var _1n = BigInt(1);
    var _2n = BigInt(2);
    var _3n = BigInt(3);
    var _4n = BigInt(4);
    function _legacyHelperEquat(Fp, a, b) {
      function weierstrassEquation(x) {
        const x2 = Fp.sqr(x);
        const x3 = Fp.mul(x2, x);
        return Fp.add(Fp.add(x3, Fp.mul(x, a)), b);
      }
      return weierstrassEquation;
    }
    function _normFnElement(Fn, key) {
      const { BYTES: expected } = Fn;
      let num;
      if (typeof key === "bigint") {
        num = key;
      } else {
        let bytes = (0, utils_ts_1.ensureBytes)("private key", key);
        try {
          num = Fn.fromBytes(bytes);
        } catch (error) {
          throw new Error(`invalid private key: expected ui8a of size ${expected}, got ${typeof key}`);
        }
      }
      if (!Fn.isValidNot0(num))
        throw new Error("invalid private key: out of range [1..N-1]");
      return num;
    }
    function weierstrassN(CURVE, curveOpts = {}) {
      const { Fp, Fn } = (0, curve_ts_1._createCurveFields)("weierstrass", CURVE, curveOpts);
      const { h: cofactor, n: CURVE_ORDER } = CURVE;
      (0, utils_ts_1._validateObject)(curveOpts, {}, {
        allowInfinityPoint: "boolean",
        clearCofactor: "function",
        isTorsionFree: "function",
        fromBytes: "function",
        toBytes: "function",
        endo: "object",
        wrapPrivateKey: "boolean"
      });
      const { endo } = curveOpts;
      if (endo) {
        if (!Fp.is0(CURVE.a) || typeof endo.beta !== "bigint" || !Array.isArray(endo.basises)) {
          throw new Error('invalid endo: expected "beta": bigint and "basises": array');
        }
      }
      function assertCompressionIsSupported() {
        if (!Fp.isOdd)
          throw new Error("compression is not supported: Field does not have .isOdd()");
      }
      function pointToBytes(_c, point, isCompressed) {
        const { x, y } = point.toAffine();
        const bx = Fp.toBytes(x);
        (0, utils_ts_1.abool)("isCompressed", isCompressed);
        if (isCompressed) {
          assertCompressionIsSupported();
          const hasEvenY = !Fp.isOdd(y);
          return (0, utils_ts_1.concatBytes)(pprefix(hasEvenY), bx);
        } else {
          return (0, utils_ts_1.concatBytes)(Uint8Array.of(4), bx, Fp.toBytes(y));
        }
      }
      function pointFromBytes(bytes) {
        (0, utils_ts_1.abytes)(bytes);
        const L = Fp.BYTES;
        const LC = L + 1;
        const LU = 2 * L + 1;
        const length = bytes.length;
        const head = bytes[0];
        const tail = bytes.subarray(1);
        if (length === LC && (head === 2 || head === 3)) {
          const x = Fp.fromBytes(tail);
          if (!Fp.isValid(x))
            throw new Error("bad point: is not on curve, wrong x");
          const y2 = weierstrassEquation(x);
          let y;
          try {
            y = Fp.sqrt(y2);
          } catch (sqrtError) {
            const err = sqrtError instanceof Error ? ": " + sqrtError.message : "";
            throw new Error("bad point: is not on curve, sqrt error" + err);
          }
          assertCompressionIsSupported();
          const isYOdd = Fp.isOdd(y);
          const isHeadOdd = (head & 1) === 1;
          if (isHeadOdd !== isYOdd)
            y = Fp.neg(y);
          return { x, y };
        } else if (length === LU && head === 4) {
          const x = Fp.fromBytes(tail.subarray(L * 0, L * 1));
          const y = Fp.fromBytes(tail.subarray(L * 1, L * 2));
          if (!isValidXY(x, y))
            throw new Error("bad point: is not on curve");
          return { x, y };
        } else {
          throw new Error(`bad point: got length ${length}, expected compressed=${LC} or uncompressed=${LU}`);
        }
      }
      const toBytes = curveOpts.toBytes || pointToBytes;
      const fromBytes = curveOpts.fromBytes || pointFromBytes;
      const weierstrassEquation = _legacyHelperEquat(Fp, CURVE.a, CURVE.b);
      function isValidXY(x, y) {
        const left = Fp.sqr(y);
        const right = weierstrassEquation(x);
        return Fp.eql(left, right);
      }
      if (!isValidXY(CURVE.Gx, CURVE.Gy))
        throw new Error("bad curve params: generator point");
      const _4a3 = Fp.mul(Fp.pow(CURVE.a, _3n), _4n);
      const _27b2 = Fp.mul(Fp.sqr(CURVE.b), BigInt(27));
      if (Fp.is0(Fp.add(_4a3, _27b2)))
        throw new Error("bad curve params: a or b");
      function acoord(title, n, banZero = false) {
        if (!Fp.isValid(n) || banZero && Fp.is0(n))
          throw new Error(`bad point coordinate ${title}`);
        return n;
      }
      function aprjpoint(other) {
        if (!(other instanceof Point))
          throw new Error("ProjectivePoint expected");
      }
      function splitEndoScalarN(k) {
        if (!endo || !endo.basises)
          throw new Error("no endo");
        return _splitEndoScalar(k, endo.basises, Fn.ORDER);
      }
      const toAffineMemo = (0, utils_ts_1.memoized)((p, iz) => {
        const { X, Y, Z } = p;
        if (Fp.eql(Z, Fp.ONE))
          return { x: X, y: Y };
        const is0 = p.is0();
        if (iz == null)
          iz = is0 ? Fp.ONE : Fp.inv(Z);
        const x = Fp.mul(X, iz);
        const y = Fp.mul(Y, iz);
        const zz = Fp.mul(Z, iz);
        if (is0)
          return { x: Fp.ZERO, y: Fp.ZERO };
        if (!Fp.eql(zz, Fp.ONE))
          throw new Error("invZ was invalid");
        return { x, y };
      });
      const assertValidMemo = (0, utils_ts_1.memoized)((p) => {
        if (p.is0()) {
          if (curveOpts.allowInfinityPoint && !Fp.is0(p.Y))
            return;
          throw new Error("bad point: ZERO");
        }
        const { x, y } = p.toAffine();
        if (!Fp.isValid(x) || !Fp.isValid(y))
          throw new Error("bad point: x or y not field elements");
        if (!isValidXY(x, y))
          throw new Error("bad point: equation left != right");
        if (!p.isTorsionFree())
          throw new Error("bad point: not in prime-order subgroup");
        return true;
      });
      function finishEndo(endoBeta, k1p, k2p, k1neg, k2neg) {
        k2p = new Point(Fp.mul(k2p.X, endoBeta), k2p.Y, k2p.Z);
        k1p = (0, curve_ts_1.negateCt)(k1neg, k1p);
        k2p = (0, curve_ts_1.negateCt)(k2neg, k2p);
        return k1p.add(k2p);
      }
      class Point {
        /** Does NOT validate if the point is valid. Use `.assertValidity()`. */
        constructor(X, Y, Z) {
          this.X = acoord("x", X);
          this.Y = acoord("y", Y, true);
          this.Z = acoord("z", Z);
          Object.freeze(this);
        }
        /** Does NOT validate if the point is valid. Use `.assertValidity()`. */
        static fromAffine(p) {
          const { x, y } = p || {};
          if (!p || !Fp.isValid(x) || !Fp.isValid(y))
            throw new Error("invalid affine point");
          if (p instanceof Point)
            throw new Error("projective point not allowed");
          if (Fp.is0(x) && Fp.is0(y))
            return Point.ZERO;
          return new Point(x, y, Fp.ONE);
        }
        get x() {
          return this.toAffine().x;
        }
        get y() {
          return this.toAffine().y;
        }
        // TODO: remove
        get px() {
          return this.X;
        }
        get py() {
          return this.X;
        }
        get pz() {
          return this.Z;
        }
        static normalizeZ(points) {
          return (0, curve_ts_1.normalizeZ)(Point, points);
        }
        static fromBytes(bytes) {
          (0, utils_ts_1.abytes)(bytes);
          return Point.fromHex(bytes);
        }
        /** Converts hash string or Uint8Array to Point. */
        static fromHex(hex) {
          const P = Point.fromAffine(fromBytes((0, utils_ts_1.ensureBytes)("pointHex", hex)));
          P.assertValidity();
          return P;
        }
        /** Multiplies generator point by privateKey. */
        static fromPrivateKey(privateKey) {
          return Point.BASE.multiply(_normFnElement(Fn, privateKey));
        }
        // TODO: remove
        static msm(points, scalars) {
          return (0, curve_ts_1.pippenger)(Point, Fn, points, scalars);
        }
        _setWindowSize(windowSize) {
          this.precompute(windowSize);
        }
        /**
         *
         * @param windowSize
         * @param isLazy true will defer table computation until the first multiplication
         * @returns
         */
        precompute(windowSize = 8, isLazy = true) {
          wnaf.createCache(this, windowSize);
          if (!isLazy)
            this.multiply(_3n);
          return this;
        }
        // TODO: return `this`
        /** A point on curve is valid if it conforms to equation. */
        assertValidity() {
          assertValidMemo(this);
        }
        hasEvenY() {
          const { y } = this.toAffine();
          if (!Fp.isOdd)
            throw new Error("Field doesn't support isOdd");
          return !Fp.isOdd(y);
        }
        /** Compare one point to another. */
        equals(other) {
          aprjpoint(other);
          const { X: X1, Y: Y1, Z: Z1 } = this;
          const { X: X2, Y: Y2, Z: Z2 } = other;
          const U1 = Fp.eql(Fp.mul(X1, Z2), Fp.mul(X2, Z1));
          const U2 = Fp.eql(Fp.mul(Y1, Z2), Fp.mul(Y2, Z1));
          return U1 && U2;
        }
        /** Flips point to one corresponding to (x, -y) in Affine coordinates. */
        negate() {
          return new Point(this.X, Fp.neg(this.Y), this.Z);
        }
        // Renes-Costello-Batina exception-free doubling formula.
        // There is 30% faster Jacobian formula, but it is not complete.
        // https://eprint.iacr.org/2015/1060, algorithm 3
        // Cost: 8M + 3S + 3*a + 2*b3 + 15add.
        double() {
          const { a, b } = CURVE;
          const b3 = Fp.mul(b, _3n);
          const { X: X1, Y: Y1, Z: Z1 } = this;
          let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO;
          let t0 = Fp.mul(X1, X1);
          let t1 = Fp.mul(Y1, Y1);
          let t2 = Fp.mul(Z1, Z1);
          let t3 = Fp.mul(X1, Y1);
          t3 = Fp.add(t3, t3);
          Z3 = Fp.mul(X1, Z1);
          Z3 = Fp.add(Z3, Z3);
          X3 = Fp.mul(a, Z3);
          Y3 = Fp.mul(b3, t2);
          Y3 = Fp.add(X3, Y3);
          X3 = Fp.sub(t1, Y3);
          Y3 = Fp.add(t1, Y3);
          Y3 = Fp.mul(X3, Y3);
          X3 = Fp.mul(t3, X3);
          Z3 = Fp.mul(b3, Z3);
          t2 = Fp.mul(a, t2);
          t3 = Fp.sub(t0, t2);
          t3 = Fp.mul(a, t3);
          t3 = Fp.add(t3, Z3);
          Z3 = Fp.add(t0, t0);
          t0 = Fp.add(Z3, t0);
          t0 = Fp.add(t0, t2);
          t0 = Fp.mul(t0, t3);
          Y3 = Fp.add(Y3, t0);
          t2 = Fp.mul(Y1, Z1);
          t2 = Fp.add(t2, t2);
          t0 = Fp.mul(t2, t3);
          X3 = Fp.sub(X3, t0);
          Z3 = Fp.mul(t2, t1);
          Z3 = Fp.add(Z3, Z3);
          Z3 = Fp.add(Z3, Z3);
          return new Point(X3, Y3, Z3);
        }
        // Renes-Costello-Batina exception-free addition formula.
        // There is 30% faster Jacobian formula, but it is not complete.
        // https://eprint.iacr.org/2015/1060, algorithm 1
        // Cost: 12M + 0S + 3*a + 3*b3 + 23add.
        add(other) {
          aprjpoint(other);
          const { X: X1, Y: Y1, Z: Z1 } = this;
          const { X: X2, Y: Y2, Z: Z2 } = other;
          let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO;
          const a = CURVE.a;
          const b3 = Fp.mul(CURVE.b, _3n);
          let t0 = Fp.mul(X1, X2);
          let t1 = Fp.mul(Y1, Y2);
          let t2 = Fp.mul(Z1, Z2);
          let t3 = Fp.add(X1, Y1);
          let t4 = Fp.add(X2, Y2);
          t3 = Fp.mul(t3, t4);
          t4 = Fp.add(t0, t1);
          t3 = Fp.sub(t3, t4);
          t4 = Fp.add(X1, Z1);
          let t5 = Fp.add(X2, Z2);
          t4 = Fp.mul(t4, t5);
          t5 = Fp.add(t0, t2);
          t4 = Fp.sub(t4, t5);
          t5 = Fp.add(Y1, Z1);
          X3 = Fp.add(Y2, Z2);
          t5 = Fp.mul(t5, X3);
          X3 = Fp.add(t1, t2);
          t5 = Fp.sub(t5, X3);
          Z3 = Fp.mul(a, t4);
          X3 = Fp.mul(b3, t2);
          Z3 = Fp.add(X3, Z3);
          X3 = Fp.sub(t1, Z3);
          Z3 = Fp.add(t1, Z3);
          Y3 = Fp.mul(X3, Z3);
          t1 = Fp.add(t0, t0);
          t1 = Fp.add(t1, t0);
          t2 = Fp.mul(a, t2);
          t4 = Fp.mul(b3, t4);
          t1 = Fp.add(t1, t2);
          t2 = Fp.sub(t0, t2);
          t2 = Fp.mul(a, t2);
          t4 = Fp.add(t4, t2);
          t0 = Fp.mul(t1, t4);
          Y3 = Fp.add(Y3, t0);
          t0 = Fp.mul(t5, t4);
          X3 = Fp.mul(t3, X3);
          X3 = Fp.sub(X3, t0);
          t0 = Fp.mul(t3, t1);
          Z3 = Fp.mul(t5, Z3);
          Z3 = Fp.add(Z3, t0);
          return new Point(X3, Y3, Z3);
        }
        subtract(other) {
          return this.add(other.negate());
        }
        is0() {
          return this.equals(Point.ZERO);
        }
        /**
         * Constant time multiplication.
         * Uses wNAF method. Windowed method may be 10% faster,
         * but takes 2x longer to generate and consumes 2x memory.
         * Uses precomputes when available.
         * Uses endomorphism for Koblitz curves.
         * @param scalar by which the point would be multiplied
         * @returns New point
         */
        multiply(scalar) {
          const { endo: endo2 } = curveOpts;
          if (!Fn.isValidNot0(scalar))
            throw new Error("invalid scalar: out of range");
          let point, fake;
          const mul = (n) => wnaf.cached(this, n, (p) => (0, curve_ts_1.normalizeZ)(Point, p));
          if (endo2) {
            const { k1neg, k1, k2neg, k2 } = splitEndoScalarN(scalar);
            const { p: k1p, f: k1f } = mul(k1);
            const { p: k2p, f: k2f } = mul(k2);
            fake = k1f.add(k2f);
            point = finishEndo(endo2.beta, k1p, k2p, k1neg, k2neg);
          } else {
            const { p, f } = mul(scalar);
            point = p;
            fake = f;
          }
          return (0, curve_ts_1.normalizeZ)(Point, [point, fake])[0];
        }
        /**
         * Non-constant-time multiplication. Uses double-and-add algorithm.
         * It's faster, but should only be used when you don't care about
         * an exposed secret key e.g. sig verification, which works over *public* keys.
         */
        multiplyUnsafe(sc) {
          const { endo: endo2 } = curveOpts;
          const p = this;
          if (!Fn.isValid(sc))
            throw new Error("invalid scalar: out of range");
          if (sc === _0n || p.is0())
            return Point.ZERO;
          if (sc === _1n)
            return p;
          if (wnaf.hasCache(this))
            return this.multiply(sc);
          if (endo2) {
            const { k1neg, k1, k2neg, k2 } = splitEndoScalarN(sc);
            const { p1, p2 } = (0, curve_ts_1.mulEndoUnsafe)(Point, p, k1, k2);
            return finishEndo(endo2.beta, p1, p2, k1neg, k2neg);
          } else {
            return wnaf.unsafe(p, sc);
          }
        }
        multiplyAndAddUnsafe(Q, a, b) {
          const sum = this.multiplyUnsafe(a).add(Q.multiplyUnsafe(b));
          return sum.is0() ? void 0 : sum;
        }
        /**
         * Converts Projective point to affine (x, y) coordinates.
         * @param invertedZ Z^-1 (inverted zero) - optional, precomputation is useful for invertBatch
         */
        toAffine(invertedZ) {
          return toAffineMemo(this, invertedZ);
        }
        /**
         * Checks whether Point is free of torsion elements (is in prime subgroup).
         * Always torsion-free for cofactor=1 curves.
         */
        isTorsionFree() {
          const { isTorsionFree } = curveOpts;
          if (cofactor === _1n)
            return true;
          if (isTorsionFree)
            return isTorsionFree(Point, this);
          return wnaf.unsafe(this, CURVE_ORDER).is0();
        }
        clearCofactor() {
          const { clearCofactor } = curveOpts;
          if (cofactor === _1n)
            return this;
          if (clearCofactor)
            return clearCofactor(Point, this);
          return this.multiplyUnsafe(cofactor);
        }
        isSmallOrder() {
          return this.multiplyUnsafe(cofactor).is0();
        }
        toBytes(isCompressed = true) {
          (0, utils_ts_1.abool)("isCompressed", isCompressed);
          this.assertValidity();
          return toBytes(Point, this, isCompressed);
        }
        /** @deprecated use `toBytes` */
        toRawBytes(isCompressed = true) {
          return this.toBytes(isCompressed);
        }
        toHex(isCompressed = true) {
          return (0, utils_ts_1.bytesToHex)(this.toBytes(isCompressed));
        }
        toString() {
          return `<Point ${this.is0() ? "ZERO" : this.toHex()}>`;
        }
      }
      Point.BASE = new Point(CURVE.Gx, CURVE.Gy, Fp.ONE);
      Point.ZERO = new Point(Fp.ZERO, Fp.ONE, Fp.ZERO);
      Point.Fp = Fp;
      Point.Fn = Fn;
      const bits = Fn.BITS;
      const wnaf = new curve_ts_1.wNAF(Point, curveOpts.endo ? Math.ceil(bits / 2) : bits);
      return Point;
    }
    function weierstrassPoints(c) {
      const { CURVE, curveOpts } = _weierstrass_legacy_opts_to_new(c);
      const Point = weierstrassN(CURVE, curveOpts);
      return _weierstrass_new_output_to_legacy(c, Point);
    }
    function pprefix(hasEvenY) {
      return Uint8Array.of(hasEvenY ? 2 : 3);
    }
    function SWUFpSqrtRatio(Fp, Z) {
      const q = Fp.ORDER;
      let l = _0n;
      for (let o = q - _1n; o % _2n === _0n; o /= _2n)
        l += _1n;
      const c1 = l;
      const _2n_pow_c1_1 = _2n << c1 - _1n - _1n;
      const _2n_pow_c1 = _2n_pow_c1_1 * _2n;
      const c2 = (q - _1n) / _2n_pow_c1;
      const c3 = (c2 - _1n) / _2n;
      const c4 = _2n_pow_c1 - _1n;
      const c5 = _2n_pow_c1_1;
      const c6 = Fp.pow(Z, c2);
      const c7 = Fp.pow(Z, (c2 + _1n) / _2n);
      let sqrtRatio = (u, v) => {
        let tv1 = c6;
        let tv2 = Fp.pow(v, c4);
        let tv3 = Fp.sqr(tv2);
        tv3 = Fp.mul(tv3, v);
        let tv5 = Fp.mul(u, tv3);
        tv5 = Fp.pow(tv5, c3);
        tv5 = Fp.mul(tv5, tv2);
        tv2 = Fp.mul(tv5, v);
        tv3 = Fp.mul(tv5, u);
        let tv4 = Fp.mul(tv3, tv2);
        tv5 = Fp.pow(tv4, c5);
        let isQR = Fp.eql(tv5, Fp.ONE);
        tv2 = Fp.mul(tv3, c7);
        tv5 = Fp.mul(tv4, tv1);
        tv3 = Fp.cmov(tv2, tv3, isQR);
        tv4 = Fp.cmov(tv5, tv4, isQR);
        for (let i = c1; i > _1n; i--) {
          let tv52 = i - _2n;
          tv52 = _2n << tv52 - _1n;
          let tvv5 = Fp.pow(tv4, tv52);
          const e1 = Fp.eql(tvv5, Fp.ONE);
          tv2 = Fp.mul(tv3, tv1);
          tv1 = Fp.mul(tv1, tv1);
          tvv5 = Fp.mul(tv4, tv1);
          tv3 = Fp.cmov(tv2, tv3, e1);
          tv4 = Fp.cmov(tvv5, tv4, e1);
        }
        return { isValid: isQR, value: tv3 };
      };
      if (Fp.ORDER % _4n === _3n) {
        const c12 = (Fp.ORDER - _3n) / _4n;
        const c22 = Fp.sqrt(Fp.neg(Z));
        sqrtRatio = (u, v) => {
          let tv1 = Fp.sqr(v);
          const tv2 = Fp.mul(u, v);
          tv1 = Fp.mul(tv1, tv2);
          let y1 = Fp.pow(tv1, c12);
          y1 = Fp.mul(y1, tv2);
          const y2 = Fp.mul(y1, c22);
          const tv3 = Fp.mul(Fp.sqr(y1), v);
          const isQR = Fp.eql(tv3, u);
          let y = Fp.cmov(y2, y1, isQR);
          return { isValid: isQR, value: y };
        };
      }
      return sqrtRatio;
    }
    function mapToCurveSimpleSWU(Fp, opts) {
      (0, modular_ts_1.validateField)(Fp);
      const { A, B, Z } = opts;
      if (!Fp.isValid(A) || !Fp.isValid(B) || !Fp.isValid(Z))
        throw new Error("mapToCurveSimpleSWU: invalid opts");
      const sqrtRatio = SWUFpSqrtRatio(Fp, Z);
      if (!Fp.isOdd)
        throw new Error("Field does not have .isOdd()");
      return (u) => {
        let tv1, tv2, tv3, tv4, tv5, tv6, x, y;
        tv1 = Fp.sqr(u);
        tv1 = Fp.mul(tv1, Z);
        tv2 = Fp.sqr(tv1);
        tv2 = Fp.add(tv2, tv1);
        tv3 = Fp.add(tv2, Fp.ONE);
        tv3 = Fp.mul(tv3, B);
        tv4 = Fp.cmov(Z, Fp.neg(tv2), !Fp.eql(tv2, Fp.ZERO));
        tv4 = Fp.mul(tv4, A);
        tv2 = Fp.sqr(tv3);
        tv6 = Fp.sqr(tv4);
        tv5 = Fp.mul(tv6, A);
        tv2 = Fp.add(tv2, tv5);
        tv2 = Fp.mul(tv2, tv3);
        tv6 = Fp.mul(tv6, tv4);
        tv5 = Fp.mul(tv6, B);
        tv2 = Fp.add(tv2, tv5);
        x = Fp.mul(tv1, tv3);
        const { isValid, value } = sqrtRatio(tv2, tv6);
        y = Fp.mul(tv1, u);
        y = Fp.mul(y, value);
        x = Fp.cmov(x, tv3, isValid);
        y = Fp.cmov(y, value, isValid);
        const e1 = Fp.isOdd(u) === Fp.isOdd(y);
        y = Fp.cmov(Fp.neg(y), y, e1);
        const tv4_inv = (0, modular_ts_1.FpInvertBatch)(Fp, [tv4], true)[0];
        x = Fp.mul(x, tv4_inv);
        return { x, y };
      };
    }
    function ecdsa(Point, hash, ecdsaOpts = {}) {
      (0, utils_1.ahash)(hash);
      (0, utils_ts_1._validateObject)(ecdsaOpts, {}, {
        hmac: "function",
        lowS: "boolean",
        randomBytes: "function",
        bits2int: "function",
        bits2int_modN: "function"
      });
      const randomBytes_ = ecdsaOpts.randomBytes || utils_ts_1.randomBytes;
      const hmac_ = ecdsaOpts.hmac || ((key, ...msgs) => (0, hmac_js_1.hmac)(hash, key, (0, utils_ts_1.concatBytes)(...msgs)));
      const { Fp, Fn } = Point;
      const { ORDER: CURVE_ORDER, BITS: fnBits } = Fn;
      const seedLen = (0, modular_ts_1.getMinHashLength)(CURVE_ORDER);
      const lengths = {
        secret: Fn.BYTES,
        public: 1 + Fp.BYTES,
        publicUncompressed: 1 + 2 * Fp.BYTES,
        signature: 2 * Fn.BYTES,
        seed: seedLen
      };
      function isBiggerThanHalfOrder(number) {
        const HALF = CURVE_ORDER >> _1n;
        return number > HALF;
      }
      function normalizeS(s) {
        return isBiggerThanHalfOrder(s) ? Fn.neg(s) : s;
      }
      function aValidRS(title, num) {
        if (!Fn.isValidNot0(num))
          throw new Error(`invalid signature ${title}: out of range 1..CURVE.n`);
      }
      class Signature {
        constructor(r, s, recovery) {
          aValidRS("r", r);
          aValidRS("s", s);
          this.r = r;
          this.s = s;
          if (recovery != null)
            this.recovery = recovery;
          Object.freeze(this);
        }
        static fromBytes(bytes, format = "compact") {
          if (format === "compact") {
            const L = Fn.BYTES;
            (0, utils_ts_1.abytes)(bytes, L * 2);
            const r = bytes.subarray(0, L);
            const s = bytes.subarray(L, L * 2);
            return new Signature(Fn.fromBytes(r), Fn.fromBytes(s));
          }
          if (format === "der") {
            (0, utils_ts_1.abytes)(bytes);
            const { r, s } = exports.DER.toSig(bytes);
            return new Signature(r, s);
          }
          throw new Error("invalid format");
        }
        static fromHex(hex, format) {
          return this.fromBytes((0, utils_ts_1.hexToBytes)(hex), format);
        }
        addRecoveryBit(recovery) {
          return new Signature(this.r, this.s, recovery);
        }
        // ProjPointType<bigint>
        recoverPublicKey(msgHash) {
          const FIELD_ORDER = Fp.ORDER;
          const { r, s, recovery: rec } = this;
          if (rec == null || ![0, 1, 2, 3].includes(rec))
            throw new Error("recovery id invalid");
          const hasCofactor = CURVE_ORDER * _2n < FIELD_ORDER;
          if (hasCofactor && rec > 1)
            throw new Error("recovery id is ambiguous for h>1 curve");
          const radj = rec === 2 || rec === 3 ? r + CURVE_ORDER : r;
          if (!Fp.isValid(radj))
            throw new Error("recovery id 2 or 3 invalid");
          const x = Fp.toBytes(radj);
          const R = Point.fromHex((0, utils_ts_1.concatBytes)(pprefix((rec & 1) === 0), x));
          const ir = Fn.inv(radj);
          const h = bits2int_modN((0, utils_ts_1.ensureBytes)("msgHash", msgHash));
          const u1 = Fn.create(-h * ir);
          const u2 = Fn.create(s * ir);
          const Q = Point.BASE.multiplyUnsafe(u1).add(R.multiplyUnsafe(u2));
          if (Q.is0())
            throw new Error("point at infinify");
          Q.assertValidity();
          return Q;
        }
        // Signatures should be low-s, to prevent malleability.
        hasHighS() {
          return isBiggerThanHalfOrder(this.s);
        }
        normalizeS() {
          return this.hasHighS() ? new Signature(this.r, Fn.neg(this.s), this.recovery) : this;
        }
        toBytes(format = "compact") {
          if (format === "compact")
            return (0, utils_ts_1.concatBytes)(Fn.toBytes(this.r), Fn.toBytes(this.s));
          if (format === "der")
            return (0, utils_ts_1.hexToBytes)(exports.DER.hexFromSig(this));
          throw new Error("invalid format");
        }
        toHex(format) {
          return (0, utils_ts_1.bytesToHex)(this.toBytes(format));
        }
        // TODO: remove
        assertValidity() {
        }
        static fromCompact(hex) {
          return Signature.fromBytes((0, utils_ts_1.ensureBytes)("sig", hex), "compact");
        }
        static fromDER(hex) {
          return Signature.fromBytes((0, utils_ts_1.ensureBytes)("sig", hex), "der");
        }
        toDERRawBytes() {
          return this.toBytes("der");
        }
        toDERHex() {
          return (0, utils_ts_1.bytesToHex)(this.toBytes("der"));
        }
        toCompactRawBytes() {
          return this.toBytes("compact");
        }
        toCompactHex() {
          return (0, utils_ts_1.bytesToHex)(this.toBytes("compact"));
        }
      }
      function isValidSecretKey(privateKey) {
        try {
          return !!_normFnElement(Fn, privateKey);
        } catch (error) {
          return false;
        }
      }
      function isValidPublicKey(publicKey, isCompressed) {
        try {
          const l = publicKey.length;
          if (isCompressed === true && l !== lengths.public)
            return false;
          if (isCompressed === false && l !== lengths.publicUncompressed)
            return false;
          return !!Point.fromBytes(publicKey);
        } catch (error) {
          return false;
        }
      }
      function randomSecretKey(seed = randomBytes_(seedLen)) {
        return (0, modular_ts_1.mapHashToField)(seed, CURVE_ORDER);
      }
      const utils = {
        isValidSecretKey,
        isValidPublicKey,
        randomSecretKey,
        // TODO: remove
        isValidPrivateKey: isValidSecretKey,
        randomPrivateKey: randomSecretKey,
        normPrivateKeyToScalar: (key) => _normFnElement(Fn, key),
        precompute(windowSize = 8, point = Point.BASE) {
          return point.precompute(windowSize, false);
        }
      };
      function getPublicKey(secretKey, isCompressed = true) {
        return Point.BASE.multiply(_normFnElement(Fn, secretKey)).toBytes(isCompressed);
      }
      function isProbPub(item) {
        if (typeof item === "bigint")
          return false;
        if (item instanceof Point)
          return true;
        if (Fn.allowedLengths || lengths.secret === lengths.public)
          return void 0;
        const l = (0, utils_ts_1.ensureBytes)("key", item).length;
        return l === lengths.public || l === lengths.publicUncompressed;
      }
      function getSharedSecret(secretKeyA, publicKeyB, isCompressed = true) {
        if (isProbPub(secretKeyA) === true)
          throw new Error("first arg must be private key");
        if (isProbPub(publicKeyB) === false)
          throw new Error("second arg must be public key");
        const s = _normFnElement(Fn, secretKeyA);
        const b = Point.fromHex(publicKeyB);
        return b.multiply(s).toBytes(isCompressed);
      }
      const bits2int = ecdsaOpts.bits2int || function(bytes) {
        if (bytes.length > 8192)
          throw new Error("input is too large");
        const num = (0, utils_ts_1.bytesToNumberBE)(bytes);
        const delta = bytes.length * 8 - fnBits;
        return delta > 0 ? num >> BigInt(delta) : num;
      };
      const bits2int_modN = ecdsaOpts.bits2int_modN || function(bytes) {
        return Fn.create(bits2int(bytes));
      };
      const ORDER_MASK = (0, utils_ts_1.bitMask)(fnBits);
      function int2octets(num) {
        (0, utils_ts_1.aInRange)("num < 2^" + fnBits, num, _0n, ORDER_MASK);
        return Fn.toBytes(num);
      }
      function prepSig(msgHash, privateKey, opts = defaultSigOpts) {
        if (["recovered", "canonical"].some((k) => k in opts))
          throw new Error("sign() legacy options not supported");
        let { lowS, prehash, extraEntropy: ent } = opts;
        if (lowS == null)
          lowS = true;
        msgHash = (0, utils_ts_1.ensureBytes)("msgHash", msgHash);
        validateSigVerOpts(opts);
        if (prehash)
          msgHash = (0, utils_ts_1.ensureBytes)("prehashed msgHash", hash(msgHash));
        const h1int = bits2int_modN(msgHash);
        const d = _normFnElement(Fn, privateKey);
        const seedArgs = [int2octets(d), int2octets(h1int)];
        if (ent != null && ent !== false) {
          const e = ent === true ? randomBytes_(lengths.secret) : ent;
          seedArgs.push((0, utils_ts_1.ensureBytes)("extraEntropy", e));
        }
        const seed = (0, utils_ts_1.concatBytes)(...seedArgs);
        const m = h1int;
        function k2sig(kBytes) {
          const k = bits2int(kBytes);
          if (!Fn.isValidNot0(k))
            return;
          const ik = Fn.inv(k);
          const q = Point.BASE.multiply(k).toAffine();
          const r = Fn.create(q.x);
          if (r === _0n)
            return;
          const s = Fn.create(ik * Fn.create(m + r * d));
          if (s === _0n)
            return;
          let recovery = (q.x === r ? 0 : 2) | Number(q.y & _1n);
          let normS = s;
          if (lowS && isBiggerThanHalfOrder(s)) {
            normS = normalizeS(s);
            recovery ^= 1;
          }
          return new Signature(r, normS, recovery);
        }
        return { seed, k2sig };
      }
      const defaultSigOpts = { lowS: ecdsaOpts.lowS, prehash: false };
      const defaultVerOpts = { lowS: ecdsaOpts.lowS, prehash: false };
      function sign(msgHash, secretKey, opts = defaultSigOpts) {
        const { seed, k2sig } = prepSig(msgHash, secretKey, opts);
        const drbg = (0, utils_ts_1.createHmacDrbg)(hash.outputLen, Fn.BYTES, hmac_);
        return drbg(seed, k2sig);
      }
      Point.BASE.precompute(8);
      function verify(signature, msgHash, publicKey, opts = defaultVerOpts) {
        const sg = signature;
        msgHash = (0, utils_ts_1.ensureBytes)("msgHash", msgHash);
        publicKey = (0, utils_ts_1.ensureBytes)("publicKey", publicKey);
        validateSigVerOpts(opts);
        const { lowS, prehash, format } = opts;
        if ("strict" in opts)
          throw new Error("options.strict was renamed to lowS");
        let _sig = void 0;
        let P;
        if (format === void 0) {
          const isHex = typeof sg === "string" || (0, utils_ts_1.isBytes)(sg);
          const isObj = !isHex && sg !== null && typeof sg === "object" && typeof sg.r === "bigint" && typeof sg.s === "bigint";
          if (!isHex && !isObj)
            throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");
          if (isObj) {
            _sig = new Signature(sg.r, sg.s);
          } else if (isHex) {
            try {
              _sig = Signature.fromDER(sg);
            } catch (derError) {
              if (!(derError instanceof exports.DER.Err))
                throw derError;
            }
            if (!_sig) {
              try {
                _sig = Signature.fromCompact(sg);
              } catch (error) {
                return false;
              }
            }
          }
        } else {
          if (format === "compact" || format === "der") {
            if (typeof sg !== "string" && !(0, utils_ts_1.isBytes)(sg))
              throw new Error('"der" / "compact" format expects Uint8Array signature');
            _sig = Signature.fromBytes((0, utils_ts_1.ensureBytes)("sig", sg), format);
          } else if (format === "js") {
            if (!(sg instanceof Signature))
              throw new Error('"js" format expects Signature instance');
            _sig = sg;
          } else {
            throw new Error('format must be "compact", "der" or "js"');
          }
        }
        if (!_sig)
          return false;
        try {
          P = Point.fromHex(publicKey);
          if (lowS && _sig.hasHighS())
            return false;
          if (prehash)
            msgHash = hash(msgHash);
          const { r, s } = _sig;
          const h = bits2int_modN(msgHash);
          const is = Fn.inv(s);
          const u1 = Fn.create(h * is);
          const u2 = Fn.create(r * is);
          const R = Point.BASE.multiplyUnsafe(u1).add(P.multiplyUnsafe(u2));
          if (R.is0())
            return false;
          const v = Fn.create(R.x);
          return v === r;
        } catch (e) {
          return false;
        }
      }
      function keygen(seed) {
        const secretKey = utils.randomSecretKey(seed);
        return { secretKey, publicKey: getPublicKey(secretKey) };
      }
      return Object.freeze({
        keygen,
        getPublicKey,
        sign,
        verify,
        getSharedSecret,
        utils,
        Point,
        Signature,
        info: { type: "weierstrass", lengths, publicKeyHasPrefix: true }
      });
    }
    function _weierstrass_legacy_opts_to_new(c) {
      const CURVE = {
        a: c.a,
        b: c.b,
        p: c.Fp.ORDER,
        n: c.n,
        h: c.h,
        Gx: c.Gx,
        Gy: c.Gy
      };
      const Fp = c.Fp;
      let allowedLengths = c.allowedPrivateKeyLengths ? Array.from(new Set(c.allowedPrivateKeyLengths.map((l) => Math.ceil(l / 2)))) : void 0;
      const Fn = (0, modular_ts_1.Field)(CURVE.n, {
        BITS: c.nBitLength,
        allowedLengths,
        modOnDecode: c.wrapPrivateKey
      });
      const curveOpts = {
        Fp,
        Fn,
        allowInfinityPoint: c.allowInfinityPoint,
        endo: c.endo,
        isTorsionFree: c.isTorsionFree,
        clearCofactor: c.clearCofactor,
        fromBytes: c.fromBytes,
        toBytes: c.toBytes
      };
      return { CURVE, curveOpts };
    }
    function _ecdsa_legacy_opts_to_new(c) {
      const { CURVE, curveOpts } = _weierstrass_legacy_opts_to_new(c);
      const ecdsaOpts = {
        hmac: c.hmac,
        randomBytes: c.randomBytes,
        lowS: c.lowS,
        bits2int: c.bits2int,
        bits2int_modN: c.bits2int_modN
      };
      return { CURVE, curveOpts, hash: c.hash, ecdsaOpts };
    }
    function _weierstrass_new_output_to_legacy(c, Point) {
      const { Fp, Fn } = Point;
      function isWithinCurveOrder(num) {
        return (0, utils_ts_1.inRange)(num, _1n, Fn.ORDER);
      }
      const weierstrassEquation = _legacyHelperEquat(Fp, c.a, c.b);
      return Object.assign({}, {
        CURVE: c,
        Point,
        ProjectivePoint: Point,
        normPrivateKeyToScalar: (key) => _normFnElement(Fn, key),
        weierstrassEquation,
        isWithinCurveOrder
      });
    }
    function _ecdsa_new_output_to_legacy(c, ecdsa2) {
      return Object.assign({}, ecdsa2, {
        ProjectivePoint: ecdsa2.Point,
        CURVE: c
      });
    }
    function weierstrass(c) {
      const { CURVE, curveOpts, hash, ecdsaOpts } = _ecdsa_legacy_opts_to_new(c);
      const Point = weierstrassN(CURVE, curveOpts);
      const signs = ecdsa(Point, hash, ecdsaOpts);
      return _ecdsa_new_output_to_legacy(c, signs);
    }
  }
});

// ../../node_modules/.pnpm/@noble+curves@1.9.4/node_modules/@noble/curves/_shortw_utils.js
var require_shortw_utils = __commonJS({
  "../../node_modules/.pnpm/@noble+curves@1.9.4/node_modules/@noble/curves/_shortw_utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getHash = getHash;
    exports.createCurve = createCurve;
    var weierstrass_ts_1 = require_weierstrass();
    function getHash(hash) {
      return { hash };
    }
    function createCurve(curveDef, defHash) {
      const create = (hash) => (0, weierstrass_ts_1.weierstrass)({ ...curveDef, hash });
      return { ...create(defHash), create };
    }
  }
});

// ../../node_modules/.pnpm/@noble+curves@1.9.4/node_modules/@noble/curves/abstract/hash-to-curve.js
var require_hash_to_curve = __commonJS({
  "../../node_modules/.pnpm/@noble+curves@1.9.4/node_modules/@noble/curves/abstract/hash-to-curve.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports._DST_scalar = void 0;
    exports.expand_message_xmd = expand_message_xmd;
    exports.expand_message_xof = expand_message_xof;
    exports.hash_to_field = hash_to_field;
    exports.isogenyMap = isogenyMap;
    exports.createHasher = createHasher;
    var utils_ts_1 = require_utils3();
    var modular_ts_1 = require_modular();
    var os2ip = utils_ts_1.bytesToNumberBE;
    function i2osp(value, length) {
      anum(value);
      anum(length);
      if (value < 0 || value >= 1 << 8 * length)
        throw new Error("invalid I2OSP input: " + value);
      const res = Array.from({ length }).fill(0);
      for (let i = length - 1; i >= 0; i--) {
        res[i] = value & 255;
        value >>>= 8;
      }
      return new Uint8Array(res);
    }
    function strxor(a, b) {
      const arr = new Uint8Array(a.length);
      for (let i = 0; i < a.length; i++) {
        arr[i] = a[i] ^ b[i];
      }
      return arr;
    }
    function anum(item) {
      if (!Number.isSafeInteger(item))
        throw new Error("number expected");
    }
    function normDST(DST) {
      if (!(0, utils_ts_1.isBytes)(DST) && typeof DST !== "string")
        throw new Error("DST must be Uint8Array or string");
      return typeof DST === "string" ? (0, utils_ts_1.utf8ToBytes)(DST) : DST;
    }
    function expand_message_xmd(msg, DST, lenInBytes, H) {
      (0, utils_ts_1.abytes)(msg);
      anum(lenInBytes);
      DST = normDST(DST);
      if (DST.length > 255)
        DST = H((0, utils_ts_1.concatBytes)((0, utils_ts_1.utf8ToBytes)("H2C-OVERSIZE-DST-"), DST));
      const { outputLen: b_in_bytes, blockLen: r_in_bytes } = H;
      const ell = Math.ceil(lenInBytes / b_in_bytes);
      if (lenInBytes > 65535 || ell > 255)
        throw new Error("expand_message_xmd: invalid lenInBytes");
      const DST_prime = (0, utils_ts_1.concatBytes)(DST, i2osp(DST.length, 1));
      const Z_pad = i2osp(0, r_in_bytes);
      const l_i_b_str = i2osp(lenInBytes, 2);
      const b = new Array(ell);
      const b_0 = H((0, utils_ts_1.concatBytes)(Z_pad, msg, l_i_b_str, i2osp(0, 1), DST_prime));
      b[0] = H((0, utils_ts_1.concatBytes)(b_0, i2osp(1, 1), DST_prime));
      for (let i = 1; i <= ell; i++) {
        const args = [strxor(b_0, b[i - 1]), i2osp(i + 1, 1), DST_prime];
        b[i] = H((0, utils_ts_1.concatBytes)(...args));
      }
      const pseudo_random_bytes = (0, utils_ts_1.concatBytes)(...b);
      return pseudo_random_bytes.slice(0, lenInBytes);
    }
    function expand_message_xof(msg, DST, lenInBytes, k, H) {
      (0, utils_ts_1.abytes)(msg);
      anum(lenInBytes);
      DST = normDST(DST);
      if (DST.length > 255) {
        const dkLen = Math.ceil(2 * k / 8);
        DST = H.create({ dkLen }).update((0, utils_ts_1.utf8ToBytes)("H2C-OVERSIZE-DST-")).update(DST).digest();
      }
      if (lenInBytes > 65535 || DST.length > 255)
        throw new Error("expand_message_xof: invalid lenInBytes");
      return H.create({ dkLen: lenInBytes }).update(msg).update(i2osp(lenInBytes, 2)).update(DST).update(i2osp(DST.length, 1)).digest();
    }
    function hash_to_field(msg, count, options) {
      (0, utils_ts_1._validateObject)(options, {
        p: "bigint",
        m: "number",
        k: "number",
        hash: "function"
      });
      const { p, k, m, hash, expand, DST } = options;
      if (!(0, utils_ts_1.isHash)(options.hash))
        throw new Error("expected valid hash");
      (0, utils_ts_1.abytes)(msg);
      anum(count);
      const log2p = p.toString(2).length;
      const L = Math.ceil((log2p + k) / 8);
      const len_in_bytes = count * m * L;
      let prb;
      if (expand === "xmd") {
        prb = expand_message_xmd(msg, DST, len_in_bytes, hash);
      } else if (expand === "xof") {
        prb = expand_message_xof(msg, DST, len_in_bytes, k, hash);
      } else if (expand === "_internal_pass") {
        prb = msg;
      } else {
        throw new Error('expand must be "xmd" or "xof"');
      }
      const u = new Array(count);
      for (let i = 0; i < count; i++) {
        const e = new Array(m);
        for (let j = 0; j < m; j++) {
          const elm_offset = L * (j + i * m);
          const tv = prb.subarray(elm_offset, elm_offset + L);
          e[j] = (0, modular_ts_1.mod)(os2ip(tv), p);
        }
        u[i] = e;
      }
      return u;
    }
    function isogenyMap(field, map) {
      const coeff = map.map((i) => Array.from(i).reverse());
      return (x, y) => {
        const [xn, xd, yn, yd] = coeff.map((val) => val.reduce((acc, i) => field.add(field.mul(acc, x), i)));
        const [xd_inv, yd_inv] = (0, modular_ts_1.FpInvertBatch)(field, [xd, yd], true);
        x = field.mul(xn, xd_inv);
        y = field.mul(y, field.mul(yn, yd_inv));
        return { x, y };
      };
    }
    exports._DST_scalar = (0, utils_ts_1.utf8ToBytes)("HashToScalar-");
    function createHasher(Point, mapToCurve, defaults) {
      if (typeof mapToCurve !== "function")
        throw new Error("mapToCurve() must be defined");
      function map(num) {
        return Point.fromAffine(mapToCurve(num));
      }
      function clear(initial) {
        const P = initial.clearCofactor();
        if (P.equals(Point.ZERO))
          return Point.ZERO;
        P.assertValidity();
        return P;
      }
      return {
        defaults,
        hashToCurve(msg, options) {
          const opts = Object.assign({}, defaults, options);
          const u = hash_to_field(msg, 2, opts);
          const u0 = map(u[0]);
          const u1 = map(u[1]);
          return clear(u0.add(u1));
        },
        encodeToCurve(msg, options) {
          const optsDst = defaults.encodeDST ? { DST: defaults.encodeDST } : {};
          const opts = Object.assign({}, defaults, optsDst, options);
          const u = hash_to_field(msg, 1, opts);
          const u0 = map(u[0]);
          return clear(u0);
        },
        /** See {@link H2CHasher} */
        mapToCurve(scalars) {
          if (!Array.isArray(scalars))
            throw new Error("expected array of bigints");
          for (const i of scalars)
            if (typeof i !== "bigint")
              throw new Error("expected array of bigints");
          return clear(map(scalars));
        },
        // hash_to_scalar can produce 0: https://www.rfc-editor.org/errata/eid8393
        // RFC 9380, draft-irtf-cfrg-bbs-signatures-08
        hashToScalar(msg, options) {
          const N = Point.Fn.ORDER;
          const opts = Object.assign({}, defaults, { p: N, m: 1, DST: exports._DST_scalar }, options);
          return hash_to_field(msg, 1, opts)[0][0];
        }
      };
    }
  }
});

// ../../node_modules/.pnpm/@noble+curves@1.9.4/node_modules/@noble/curves/secp256k1.js
var require_secp256k1 = __commonJS({
  "../../node_modules/.pnpm/@noble+curves@1.9.4/node_modules/@noble/curves/secp256k1.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.encodeToCurve = exports.hashToCurve = exports.secp256k1_hasher = exports.schnorr = exports.secp256k1 = void 0;
    var sha2_js_1 = require_sha2();
    var utils_js_1 = require_utils();
    var _shortw_utils_ts_1 = require_shortw_utils();
    var hash_to_curve_ts_1 = require_hash_to_curve();
    var modular_ts_1 = require_modular();
    var weierstrass_ts_1 = require_weierstrass();
    var utils_ts_1 = require_utils3();
    var secp256k1_CURVE = {
      p: BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),
      n: BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),
      h: BigInt(1),
      a: BigInt(0),
      b: BigInt(7),
      Gx: BigInt("0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"),
      Gy: BigInt("0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8")
    };
    var secp256k1_ENDO = {
      beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
      basises: [
        [BigInt("0x3086d221a7d46bcde86c90e49284eb15"), -BigInt("0xe4437ed6010e88286f547fa90abfe4c3")],
        [BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"), BigInt("0x3086d221a7d46bcde86c90e49284eb15")]
      ]
    };
    var _0n = BigInt(0);
    var _1n = BigInt(1);
    var _2n = BigInt(2);
    function sqrtMod(y) {
      const P = secp256k1_CURVE.p;
      const _3n = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);
      const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);
      const b2 = y * y * y % P;
      const b3 = b2 * b2 * y % P;
      const b6 = (0, modular_ts_1.pow2)(b3, _3n, P) * b3 % P;
      const b9 = (0, modular_ts_1.pow2)(b6, _3n, P) * b3 % P;
      const b11 = (0, modular_ts_1.pow2)(b9, _2n, P) * b2 % P;
      const b22 = (0, modular_ts_1.pow2)(b11, _11n, P) * b11 % P;
      const b44 = (0, modular_ts_1.pow2)(b22, _22n, P) * b22 % P;
      const b88 = (0, modular_ts_1.pow2)(b44, _44n, P) * b44 % P;
      const b176 = (0, modular_ts_1.pow2)(b88, _88n, P) * b88 % P;
      const b220 = (0, modular_ts_1.pow2)(b176, _44n, P) * b44 % P;
      const b223 = (0, modular_ts_1.pow2)(b220, _3n, P) * b3 % P;
      const t1 = (0, modular_ts_1.pow2)(b223, _23n, P) * b22 % P;
      const t2 = (0, modular_ts_1.pow2)(t1, _6n, P) * b2 % P;
      const root = (0, modular_ts_1.pow2)(t2, _2n, P);
      if (!Fpk1.eql(Fpk1.sqr(root), y))
        throw new Error("Cannot find square root");
      return root;
    }
    var Fpk1 = (0, modular_ts_1.Field)(secp256k1_CURVE.p, void 0, void 0, { sqrt: sqrtMod });
    exports.secp256k1 = (0, _shortw_utils_ts_1.createCurve)({ ...secp256k1_CURVE, Fp: Fpk1, lowS: true, endo: secp256k1_ENDO }, sha2_js_1.sha256);
    var TAGGED_HASH_PREFIXES = {};
    function taggedHash(tag, ...messages) {
      let tagP = TAGGED_HASH_PREFIXES[tag];
      if (tagP === void 0) {
        const tagH = (0, sha2_js_1.sha256)(Uint8Array.from(tag, (c) => c.charCodeAt(0)));
        tagP = (0, utils_ts_1.concatBytes)(tagH, tagH);
        TAGGED_HASH_PREFIXES[tag] = tagP;
      }
      return (0, sha2_js_1.sha256)((0, utils_ts_1.concatBytes)(tagP, ...messages));
    }
    var pointToBytes = (point) => point.toBytes(true).slice(1);
    var numTo32b = (n) => (0, utils_ts_1.numberToBytesBE)(n, 32);
    var modP = (x) => (0, modular_ts_1.mod)(x, secp256k1_CURVE.p);
    var modN = (x) => (0, modular_ts_1.mod)(x, secp256k1_CURVE.n);
    var Point = (() => exports.secp256k1.Point)();
    var hasEven = (y) => y % _2n === _0n;
    function schnorrGetExtPubKey(priv) {
      let d_ = (0, weierstrass_ts_1._normFnElement)(Point.Fn, priv);
      let p = Point.BASE.multiply(d_);
      const scalar = hasEven(p.y) ? d_ : modN(-d_);
      return { scalar, bytes: pointToBytes(p) };
    }
    function lift_x(x) {
      (0, utils_ts_1.aInRange)("x", x, _1n, secp256k1_CURVE.p);
      const xx = modP(x * x);
      const c = modP(xx * x + BigInt(7));
      let y = sqrtMod(c);
      if (!hasEven(y))
        y = modP(-y);
      const p = Point.fromAffine({ x, y });
      p.assertValidity();
      return p;
    }
    var num = utils_ts_1.bytesToNumberBE;
    function challenge(...args) {
      return modN(num(taggedHash("BIP0340/challenge", ...args)));
    }
    function schnorrGetPublicKey(secretKey) {
      return schnorrGetExtPubKey(secretKey).bytes;
    }
    function schnorrSign(message, secretKey, auxRand = (0, utils_js_1.randomBytes)(32)) {
      const m = (0, utils_ts_1.ensureBytes)("message", message);
      const { bytes: px, scalar: d } = schnorrGetExtPubKey(secretKey);
      const a = (0, utils_ts_1.ensureBytes)("auxRand", auxRand, 32);
      const t = numTo32b(d ^ num(taggedHash("BIP0340/aux", a)));
      const rand = taggedHash("BIP0340/nonce", t, px, m);
      const k_ = modN(num(rand));
      if (k_ === _0n)
        throw new Error("sign failed: k is zero");
      const { bytes: rx, scalar: k } = schnorrGetExtPubKey(k_);
      const e = challenge(rx, px, m);
      const sig = new Uint8Array(64);
      sig.set(rx, 0);
      sig.set(numTo32b(modN(k + e * d)), 32);
      if (!schnorrVerify(sig, m, px))
        throw new Error("sign: Invalid signature produced");
      return sig;
    }
    function schnorrVerify(signature, message, publicKey) {
      const sig = (0, utils_ts_1.ensureBytes)("signature", signature, 64);
      const m = (0, utils_ts_1.ensureBytes)("message", message);
      const pub = (0, utils_ts_1.ensureBytes)("publicKey", publicKey, 32);
      try {
        const P = lift_x(num(pub));
        const r = num(sig.subarray(0, 32));
        if (!(0, utils_ts_1.inRange)(r, _1n, secp256k1_CURVE.p))
          return false;
        const s = num(sig.subarray(32, 64));
        if (!(0, utils_ts_1.inRange)(s, _1n, secp256k1_CURVE.n))
          return false;
        const e = challenge(numTo32b(r), pointToBytes(P), m);
        const R = Point.BASE.multiplyUnsafe(s).add(P.multiplyUnsafe(modN(-e)));
        const { x, y } = R.toAffine();
        if (R.is0() || !hasEven(y) || x !== r)
          return false;
        return true;
      } catch (error) {
        return false;
      }
    }
    exports.schnorr = (() => {
      const size = 32;
      const seedLength = 48;
      const randomSecretKey = (seed = (0, utils_js_1.randomBytes)(seedLength)) => {
        return (0, modular_ts_1.mapHashToField)(seed, secp256k1_CURVE.n);
      };
      exports.secp256k1.utils.randomSecretKey;
      function keygen(seed) {
        const secretKey = randomSecretKey(seed);
        return { secretKey, publicKey: schnorrGetPublicKey(secretKey) };
      }
      return {
        keygen,
        getPublicKey: schnorrGetPublicKey,
        sign: schnorrSign,
        verify: schnorrVerify,
        Point,
        utils: {
          randomSecretKey,
          randomPrivateKey: randomSecretKey,
          taggedHash,
          // TODO: remove
          lift_x,
          pointToBytes,
          numberToBytesBE: utils_ts_1.numberToBytesBE,
          bytesToNumberBE: utils_ts_1.bytesToNumberBE,
          mod: modular_ts_1.mod
        },
        info: {
          type: "weierstrass",
          publicKeyHasPrefix: false,
          lengths: {
            secret: size,
            public: size,
            signature: size * 2,
            seed: seedLength
          }
        }
      };
    })();
    var isoMap = (() => (0, hash_to_curve_ts_1.isogenyMap)(Fpk1, [
      // xNum
      [
        "0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7",
        "0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581",
        "0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262",
        "0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c"
      ],
      // xDen
      [
        "0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b",
        "0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14",
        "0x0000000000000000000000000000000000000000000000000000000000000001"
        // LAST 1
      ],
      // yNum
      [
        "0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c",
        "0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3",
        "0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931",
        "0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84"
      ],
      // yDen
      [
        "0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b",
        "0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573",
        "0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f",
        "0x0000000000000000000000000000000000000000000000000000000000000001"
        // LAST 1
      ]
    ].map((i) => i.map((j) => BigInt(j)))))();
    var mapSWU = (() => (0, weierstrass_ts_1.mapToCurveSimpleSWU)(Fpk1, {
      A: BigInt("0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533"),
      B: BigInt("1771"),
      Z: Fpk1.create(BigInt("-11"))
    }))();
    exports.secp256k1_hasher = (() => (0, hash_to_curve_ts_1.createHasher)(exports.secp256k1.Point, (scalars) => {
      const { x, y } = mapSWU(Fpk1.create(scalars[0]));
      return isoMap(x, y);
    }, {
      DST: "secp256k1_XMD:SHA-256_SSWU_RO_",
      encodeDST: "secp256k1_XMD:SHA-256_SSWU_NU_",
      p: Fpk1.ORDER,
      m: 1,
      k: 128,
      expand: "xmd",
      hash: sha2_js_1.sha256
    }))();
    exports.hashToCurve = (() => exports.secp256k1_hasher.hashToCurve)();
    exports.encodeToCurve = (() => exports.secp256k1_hasher.encodeToCurve)();
  }
});

// ../../node_modules/.pnpm/@cosmjs+crypto@0.34.0/node_modules/@cosmjs/crypto/build/secp256k1signature.js
var require_secp256k1signature = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+crypto@0.34.0/node_modules/@cosmjs/crypto/build/secp256k1signature.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ExtendedSecp256k1Signature = exports.Secp256k1Signature = void 0;
    function trimLeadingNullBytes(inData) {
      let numberOfLeadingNullBytes = 0;
      for (const byte of inData) {
        if (byte === 0) {
          numberOfLeadingNullBytes++;
        } else {
          break;
        }
      }
      return inData.slice(numberOfLeadingNullBytes);
    }
    var derTagInteger = 2;
    var Secp256k1Signature = class _Secp256k1Signature {
      /**
       * Takes the pair of integers (r, s) as 2x32 byte of binary data.
       *
       * Note: This is the format Cosmos SDK uses natively.
       *
       * @param data a 64 byte value containing integers r and s.
       */
      static fromFixedLength(data) {
        if (data.length !== 64) {
          throw new Error(`Got invalid data length: ${data.length}. Expected 2x 32 bytes for the pair (r, s)`);
        }
        return new _Secp256k1Signature(trimLeadingNullBytes(data.slice(0, 32)), trimLeadingNullBytes(data.slice(32, 64)));
      }
      static fromDer(data) {
        let pos = 0;
        if (data[pos++] !== 48) {
          throw new Error("Prefix 0x30 expected");
        }
        const bodyLength = data[pos++];
        if (data.length - pos !== bodyLength) {
          throw new Error("Data length mismatch detected");
        }
        const rTag = data[pos++];
        if (rTag !== derTagInteger) {
          throw new Error("INTEGER tag expected");
        }
        const rLength = data[pos++];
        if (rLength >= 128) {
          throw new Error("Decoding length values above 127 not supported");
        }
        const rData = data.slice(pos, pos + rLength);
        pos += rLength;
        const sTag = data[pos++];
        if (sTag !== derTagInteger) {
          throw new Error("INTEGER tag expected");
        }
        const sLength = data[pos++];
        if (sLength >= 128) {
          throw new Error("Decoding length values above 127 not supported");
        }
        const sData = data.slice(pos, pos + sLength);
        pos += sLength;
        return new _Secp256k1Signature(
          // r/s data can contain leading 0 bytes to express integers being non-negative in DER
          trimLeadingNullBytes(rData),
          trimLeadingNullBytes(sData)
        );
      }
      constructor(r, s) {
        if (r.length > 32 || r.length === 0 || r[0] === 0) {
          throw new Error("Unsigned integer r must be encoded as unpadded big endian.");
        }
        if (s.length > 32 || s.length === 0 || s[0] === 0) {
          throw new Error("Unsigned integer s must be encoded as unpadded big endian.");
        }
        this.data = {
          r,
          s
        };
      }
      r(length) {
        if (length === void 0) {
          return this.data.r;
        } else {
          const paddingLength = length - this.data.r.length;
          if (paddingLength < 0) {
            throw new Error("Length too small to hold parameter r");
          }
          const padding = new Uint8Array(paddingLength);
          return new Uint8Array([...padding, ...this.data.r]);
        }
      }
      s(length) {
        if (length === void 0) {
          return this.data.s;
        } else {
          const paddingLength = length - this.data.s.length;
          if (paddingLength < 0) {
            throw new Error("Length too small to hold parameter s");
          }
          const padding = new Uint8Array(paddingLength);
          return new Uint8Array([...padding, ...this.data.s]);
        }
      }
      toFixedLength() {
        return new Uint8Array([...this.r(32), ...this.s(32)]);
      }
      toDer() {
        const rEncoded = this.data.r[0] >= 128 ? new Uint8Array([0, ...this.data.r]) : this.data.r;
        const sEncoded = this.data.s[0] >= 128 ? new Uint8Array([0, ...this.data.s]) : this.data.s;
        const rLength = rEncoded.length;
        const sLength = sEncoded.length;
        const data = new Uint8Array([derTagInteger, rLength, ...rEncoded, derTagInteger, sLength, ...sEncoded]);
        return new Uint8Array([48, data.length, ...data]);
      }
    };
    exports.Secp256k1Signature = Secp256k1Signature;
    var ExtendedSecp256k1Signature = class _ExtendedSecp256k1Signature extends Secp256k1Signature {
      /**
       * Decode extended signature from the simple fixed length encoding
       * described in toFixedLength().
       */
      static fromFixedLength(data) {
        if (data.length !== 65) {
          throw new Error(`Got invalid data length ${data.length}. Expected 32 + 32 + 1`);
        }
        return new _ExtendedSecp256k1Signature(trimLeadingNullBytes(data.slice(0, 32)), trimLeadingNullBytes(data.slice(32, 64)), data[64]);
      }
      constructor(r, s, recovery) {
        super(r, s);
        if (!Number.isInteger(recovery)) {
          throw new Error("The recovery parameter must be an integer.");
        }
        if (recovery < 0 || recovery > 4) {
          throw new Error("The recovery parameter must be one of 0, 1, 2, 3.");
        }
        this.recovery = recovery;
      }
      /**
       * A simple custom encoding that encodes the extended signature as
       * r (32 bytes) | s (32 bytes) | recovery param (1 byte)
       * where | denotes concatenation of bonary data.
       */
      toFixedLength() {
        return new Uint8Array([...this.r(32), ...this.s(32), this.recovery]);
      }
    };
    exports.ExtendedSecp256k1Signature = ExtendedSecp256k1Signature;
  }
});

// ../../node_modules/.pnpm/@cosmjs+crypto@0.34.0/node_modules/@cosmjs/crypto/build/secp256k1.js
var require_secp256k12 = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+crypto@0.34.0/node_modules/@cosmjs/crypto/build/secp256k1.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Secp256k1 = void 0;
    var encoding_1 = require_build();
    var utils_1 = require_build3();
    var secp256k1_1 = require_secp256k1();
    var secp256k1signature_1 = require_secp256k1signature();
    function unsignedBigIntToBytes(a) {
      (0, utils_1.assert)(a >= 0n);
      let hex = a.toString(16);
      if (hex.length % 2)
        hex = "0" + hex;
      return (0, encoding_1.fromHex)(hex);
    }
    function bytesToUnsignedBigInt(a) {
      return BigInt("0x" + (0, encoding_1.toHex)(a));
    }
    var Secp256k1 = class {
      /**
       * Takes a 32 byte private key and returns a privkey/pubkey pair.
       *
       * The resulting pubkey is uncompressed. For the use in Cosmos it should
       * be compressed first using `Secp256k1.compressPubkey`.
       */
      static async makeKeypair(privkey) {
        if (privkey.length !== 32) {
          throw new Error("input data is not a valid secp256k1 private key");
        }
        if (!secp256k1_1.secp256k1.utils.isValidPrivateKey(privkey)) {
          throw new Error("input data is not a valid secp256k1 private key");
        }
        const out = {
          privkey,
          // encodes uncompressed as
          // - 1-byte prefix "04"
          // - 32-byte x coordinate
          // - 32-byte y coordinate
          pubkey: secp256k1_1.secp256k1.getPublicKey(privkey, false)
        };
        return out;
      }
      /**
       * Creates a signature that is
       * - deterministic (RFC 6979)
       * - lowS signature
       * - DER encoded
       */
      static async createSignature(messageHash, privkey) {
        if (messageHash.length === 0) {
          throw new Error("Message hash must not be empty");
        }
        if (messageHash.length > 32) {
          throw new Error("Message hash length must not exceed 32 bytes");
        }
        const { recovery, r, s } = secp256k1_1.secp256k1.sign(messageHash, privkey, {
          lowS: true
        });
        if (typeof recovery !== "number")
          throw new Error("Recovery param missing");
        return new secp256k1signature_1.ExtendedSecp256k1Signature(unsignedBigIntToBytes(r), unsignedBigIntToBytes(s), recovery);
      }
      static async verifySignature(signature, messageHash, pubkey) {
        if (messageHash.length === 0) {
          throw new Error("Message hash must not be empty");
        }
        if (messageHash.length > 32) {
          throw new Error("Message hash length must not exceed 32 bytes");
        }
        const encodedSig = secp256k1_1.secp256k1.Signature.fromDER(signature.toDer());
        return secp256k1_1.secp256k1.verify(encodedSig, messageHash, pubkey, { lowS: false });
      }
      static recoverPubkey(signature, messageHash) {
        const pk = new secp256k1_1.secp256k1.Signature(bytesToUnsignedBigInt(signature.r()), bytesToUnsignedBigInt(signature.s()), signature.recovery).recoverPublicKey(messageHash);
        return pk.toBytes(false);
      }
      /**
       * Takes a compressed or uncompressed pubkey and return a compressed one.
       *
       * This function is idempotent.
       */
      static compressPubkey(pubkey) {
        switch (pubkey.length) {
          case 33:
            return pubkey;
          case 65:
            return secp256k1_1.secp256k1.Point.fromHex(pubkey).toRawBytes(true);
          default:
            throw new Error("Invalid pubkey length");
        }
      }
      /**
       * Takes a compressed or uncompressed pubkey and returns an uncompressed one.
       *
       * This function is idempotent.
       */
      static uncompressPubkey(pubkey) {
        switch (pubkey.length) {
          case 33:
            return secp256k1_1.secp256k1.Point.fromHex(pubkey).toRawBytes(false);
          case 65:
            return pubkey;
          default:
            throw new Error("Invalid pubkey length");
        }
      }
      static trimRecoveryByte(signature) {
        switch (signature.length) {
          case 64:
            return signature;
          case 65:
            return signature.slice(0, 64);
          default:
            throw new Error("Invalid signature length");
        }
      }
    };
    exports.Secp256k1 = Secp256k1;
  }
});

// ../../node_modules/.pnpm/@cosmjs+crypto@0.34.0/node_modules/@cosmjs/crypto/build/slip10.js
var require_slip10 = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+crypto@0.34.0/node_modules/@cosmjs/crypto/build/slip10.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Slip10 = exports.Slip10RawIndex = exports.Slip10Curve = void 0;
    exports.slip10CurveFromString = slip10CurveFromString;
    exports.pathToString = pathToString;
    exports.stringToPath = stringToPath;
    var encoding_1 = require_build();
    var math_1 = require_build2();
    var secp256k1_1 = require_secp256k1();
    var bn_js_1 = __importDefault(require_bn());
    var hmac_1 = require_hmac2();
    var sha_1 = require_sha();
    var Slip10Curve;
    (function(Slip10Curve2) {
      Slip10Curve2["Secp256k1"] = "Bitcoin seed";
      Slip10Curve2["Ed25519"] = "ed25519 seed";
    })(Slip10Curve || (exports.Slip10Curve = Slip10Curve = {}));
    function bytesToUnsignedBigInt(a) {
      return BigInt("0x" + (0, encoding_1.toHex)(a));
    }
    function slip10CurveFromString(curveString) {
      switch (curveString) {
        case Slip10Curve.Ed25519:
          return Slip10Curve.Ed25519;
        case Slip10Curve.Secp256k1:
          return Slip10Curve.Secp256k1;
        default:
          throw new Error(`Unknown curve string: '${curveString}'`);
      }
    }
    var Slip10RawIndex = class _Slip10RawIndex extends math_1.Uint32 {
      static hardened(hardenedIndex) {
        return new _Slip10RawIndex(hardenedIndex + 2 ** 31);
      }
      static normal(normalIndex) {
        return new _Slip10RawIndex(normalIndex);
      }
      isHardened() {
        return this.data >= 2 ** 31;
      }
    };
    exports.Slip10RawIndex = Slip10RawIndex;
    var Slip10 = class _Slip10 {
      static derivePath(curve, seed, path) {
        let result = this.master(curve, seed);
        for (const rawIndex of path) {
          result = this.child(curve, result.privkey, result.chainCode, rawIndex);
        }
        return result;
      }
      static master(curve, seed) {
        const i = new hmac_1.Hmac(sha_1.Sha512, (0, encoding_1.toAscii)(curve)).update(seed).digest();
        const il = i.slice(0, 32);
        const ir = i.slice(32, 64);
        if (curve !== Slip10Curve.Ed25519 && (this.isZero(il) || this.isGteN(curve, il))) {
          return this.master(curve, i);
        }
        return {
          chainCode: ir,
          privkey: il
        };
      }
      static child(curve, parentPrivkey, parentChainCode, rawIndex) {
        let i;
        if (rawIndex.isHardened()) {
          const payload = new Uint8Array([0, ...parentPrivkey, ...rawIndex.toBytesBigEndian()]);
          i = new hmac_1.Hmac(sha_1.Sha512, parentChainCode).update(payload).digest();
        } else {
          if (curve === Slip10Curve.Ed25519) {
            throw new Error("Normal keys are not allowed with ed25519");
          } else {
            const data = new Uint8Array([
              ..._Slip10.serializedPoint(curve, bytesToUnsignedBigInt(parentPrivkey)),
              ...rawIndex.toBytesBigEndian()
            ]);
            i = new hmac_1.Hmac(sha_1.Sha512, parentChainCode).update(data).digest();
          }
        }
        return this.childImpl(curve, parentPrivkey, parentChainCode, rawIndex, i);
      }
      /**
       * Implementation of ser_P(point(k_par)) from BIP-0032
       *
       * @see https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki
       */
      static serializedPoint(curve, p) {
        switch (curve) {
          case Slip10Curve.Secp256k1:
            return secp256k1_1.secp256k1.Point.BASE.multiply(p).toRawBytes(true);
          default:
            throw new Error("curve not supported");
        }
      }
      static childImpl(curve, parentPrivkey, parentChainCode, rawIndex, i) {
        const il = i.slice(0, 32);
        const ir = i.slice(32, 64);
        const returnChainCode = ir;
        if (curve === Slip10Curve.Ed25519) {
          return {
            chainCode: returnChainCode,
            privkey: il
          };
        }
        const n = this.n(curve);
        const returnChildKeyAsNumber = new bn_js_1.default(il).add(new bn_js_1.default(parentPrivkey)).mod(n);
        const returnChildKey = Uint8Array.from(returnChildKeyAsNumber.toArray("be", 32));
        if (this.isGteN(curve, il) || this.isZero(returnChildKey)) {
          const newI = new hmac_1.Hmac(sha_1.Sha512, parentChainCode).update(new Uint8Array([1, ...ir, ...rawIndex.toBytesBigEndian()])).digest();
          return this.childImpl(curve, parentPrivkey, parentChainCode, rawIndex, newI);
        }
        return {
          chainCode: returnChainCode,
          privkey: returnChildKey
        };
      }
      static isZero(privkey) {
        return privkey.every((byte) => byte === 0);
      }
      static isGteN(curve, privkey) {
        const keyAsNumber = new bn_js_1.default(privkey);
        return keyAsNumber.gte(this.n(curve));
      }
      static n(curve) {
        switch (curve) {
          case Slip10Curve.Secp256k1:
            return new bn_js_1.default("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141", 16);
          default:
            throw new Error("curve not supported");
        }
      }
    };
    exports.Slip10 = Slip10;
    function pathToString(path) {
      return path.reduce((current, component) => {
        const componentString = component.isHardened() ? `${component.toNumber() - 2 ** 31}'` : component.toString();
        return current + "/" + componentString;
      }, "m");
    }
    function stringToPath(input) {
      if (!input.startsWith("m"))
        throw new Error("Path string must start with 'm'");
      let rest = input.slice(1);
      const out = new Array();
      while (rest) {
        const match = rest.match(/^\/([0-9]+)('?)/);
        if (!match)
          throw new Error("Syntax error while reading path component");
        const [fullMatch, numberString, apostrophe] = match;
        const value = math_1.Uint53.fromString(numberString).toNumber();
        if (value >= 2 ** 31)
          throw new Error("Component value too high. Must not exceed 2**31-1.");
        if (apostrophe)
          out.push(Slip10RawIndex.hardened(value));
        else
          out.push(Slip10RawIndex.normal(value));
        rest = rest.slice(fullMatch.length);
      }
      return out;
    }
  }
});

// ../../node_modules/.pnpm/@cosmjs+crypto@0.34.0/node_modules/@cosmjs/crypto/build/index.js
var require_build4 = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+crypto@0.34.0/node_modules/@cosmjs/crypto/build/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.stringToPath = exports.Slip10RawIndex = exports.slip10CurveFromString = exports.Slip10Curve = exports.Slip10 = exports.pathToString = exports.sha512 = exports.Sha512 = exports.sha256 = exports.Sha256 = exports.Secp256k1Signature = exports.ExtendedSecp256k1Signature = exports.Secp256k1 = exports.ripemd160 = exports.Ripemd160 = exports.Random = exports.Xchacha20poly1305Ietf = exports.xchacha20NonceLength = exports.isArgon2idOptions = exports.Ed25519Keypair = exports.Ed25519 = exports.Argon2id = exports.keccak256 = exports.Keccak256 = exports.Hmac = exports.EnglishMnemonic = exports.Bip39 = void 0;
    var bip39_1 = require_bip39();
    Object.defineProperty(exports, "Bip39", { enumerable: true, get: function() {
      return bip39_1.Bip39;
    } });
    Object.defineProperty(exports, "EnglishMnemonic", { enumerable: true, get: function() {
      return bip39_1.EnglishMnemonic;
    } });
    var hmac_1 = require_hmac2();
    Object.defineProperty(exports, "Hmac", { enumerable: true, get: function() {
      return hmac_1.Hmac;
    } });
    var keccak_1 = require_keccak();
    Object.defineProperty(exports, "Keccak256", { enumerable: true, get: function() {
      return keccak_1.Keccak256;
    } });
    Object.defineProperty(exports, "keccak256", { enumerable: true, get: function() {
      return keccak_1.keccak256;
    } });
    var libsodium_1 = require_libsodium();
    Object.defineProperty(exports, "Argon2id", { enumerable: true, get: function() {
      return libsodium_1.Argon2id;
    } });
    Object.defineProperty(exports, "Ed25519", { enumerable: true, get: function() {
      return libsodium_1.Ed25519;
    } });
    Object.defineProperty(exports, "Ed25519Keypair", { enumerable: true, get: function() {
      return libsodium_1.Ed25519Keypair;
    } });
    Object.defineProperty(exports, "isArgon2idOptions", { enumerable: true, get: function() {
      return libsodium_1.isArgon2idOptions;
    } });
    Object.defineProperty(exports, "xchacha20NonceLength", { enumerable: true, get: function() {
      return libsodium_1.xchacha20NonceLength;
    } });
    Object.defineProperty(exports, "Xchacha20poly1305Ietf", { enumerable: true, get: function() {
      return libsodium_1.Xchacha20poly1305Ietf;
    } });
    var random_1 = require_random();
    Object.defineProperty(exports, "Random", { enumerable: true, get: function() {
      return random_1.Random;
    } });
    var ripemd_1 = require_ripemd();
    Object.defineProperty(exports, "Ripemd160", { enumerable: true, get: function() {
      return ripemd_1.Ripemd160;
    } });
    Object.defineProperty(exports, "ripemd160", { enumerable: true, get: function() {
      return ripemd_1.ripemd160;
    } });
    var secp256k1_1 = require_secp256k12();
    Object.defineProperty(exports, "Secp256k1", { enumerable: true, get: function() {
      return secp256k1_1.Secp256k1;
    } });
    var secp256k1signature_1 = require_secp256k1signature();
    Object.defineProperty(exports, "ExtendedSecp256k1Signature", { enumerable: true, get: function() {
      return secp256k1signature_1.ExtendedSecp256k1Signature;
    } });
    Object.defineProperty(exports, "Secp256k1Signature", { enumerable: true, get: function() {
      return secp256k1signature_1.Secp256k1Signature;
    } });
    var sha_1 = require_sha();
    Object.defineProperty(exports, "Sha256", { enumerable: true, get: function() {
      return sha_1.Sha256;
    } });
    Object.defineProperty(exports, "sha256", { enumerable: true, get: function() {
      return sha_1.sha256;
    } });
    Object.defineProperty(exports, "Sha512", { enumerable: true, get: function() {
      return sha_1.Sha512;
    } });
    Object.defineProperty(exports, "sha512", { enumerable: true, get: function() {
      return sha_1.sha512;
    } });
    var slip10_1 = require_slip10();
    Object.defineProperty(exports, "pathToString", { enumerable: true, get: function() {
      return slip10_1.pathToString;
    } });
    Object.defineProperty(exports, "Slip10", { enumerable: true, get: function() {
      return slip10_1.Slip10;
    } });
    Object.defineProperty(exports, "Slip10Curve", { enumerable: true, get: function() {
      return slip10_1.Slip10Curve;
    } });
    Object.defineProperty(exports, "slip10CurveFromString", { enumerable: true, get: function() {
      return slip10_1.slip10CurveFromString;
    } });
    Object.defineProperty(exports, "Slip10RawIndex", { enumerable: true, get: function() {
      return slip10_1.Slip10RawIndex;
    } });
    Object.defineProperty(exports, "stringToPath", { enumerable: true, get: function() {
      return slip10_1.stringToPath;
    } });
  }
});

// ../../node_modules/.pnpm/@cosmjs+amino@0.34.0/node_modules/@cosmjs/amino/build/pubkeys.js
var require_pubkeys = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+amino@0.34.0/node_modules/@cosmjs/amino/build/pubkeys.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.pubkeyType = void 0;
    exports.isEd25519Pubkey = isEd25519Pubkey;
    exports.isSecp256k1Pubkey = isSecp256k1Pubkey;
    exports.isSinglePubkey = isSinglePubkey;
    exports.isMultisigThresholdPubkey = isMultisigThresholdPubkey;
    function isEd25519Pubkey(pubkey) {
      return pubkey.type === "tendermint/PubKeyEd25519";
    }
    function isSecp256k1Pubkey(pubkey) {
      return pubkey.type === "tendermint/PubKeySecp256k1";
    }
    exports.pubkeyType = {
      /** @see https://github.com/tendermint/tendermint/blob/v0.33.0/crypto/ed25519/ed25519.go#L22 */
      secp256k1: "tendermint/PubKeySecp256k1",
      /** @see https://github.com/tendermint/tendermint/blob/v0.33.0/crypto/secp256k1/secp256k1.go#L23 */
      ed25519: "tendermint/PubKeyEd25519",
      /** @see https://github.com/tendermint/tendermint/blob/v0.33.0/crypto/sr25519/codec.go#L12 */
      sr25519: "tendermint/PubKeySr25519",
      multisigThreshold: "tendermint/PubKeyMultisigThreshold"
    };
    function isSinglePubkey(pubkey) {
      const singPubkeyTypes = [exports.pubkeyType.ed25519, exports.pubkeyType.secp256k1, exports.pubkeyType.sr25519];
      return singPubkeyTypes.includes(pubkey.type);
    }
    function isMultisigThresholdPubkey(pubkey) {
      return pubkey.type === "tendermint/PubKeyMultisigThreshold";
    }
  }
});

// ../../node_modules/.pnpm/@cosmjs+amino@0.34.0/node_modules/@cosmjs/amino/build/encoding.js
var require_encoding = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+amino@0.34.0/node_modules/@cosmjs/amino/build/encoding.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.encodeSecp256k1Pubkey = encodeSecp256k1Pubkey;
    exports.encodeEd25519Pubkey = encodeEd25519Pubkey;
    exports.decodeAminoPubkey = decodeAminoPubkey;
    exports.decodeBech32Pubkey = decodeBech32Pubkey;
    exports.encodeAminoPubkey = encodeAminoPubkey;
    exports.encodeBech32Pubkey = encodeBech32Pubkey;
    var encoding_1 = require_build();
    var math_1 = require_build2();
    var utils_1 = require_build3();
    var pubkeys_1 = require_pubkeys();
    function encodeSecp256k1Pubkey(pubkey) {
      if (pubkey.length !== 33 || pubkey[0] !== 2 && pubkey[0] !== 3) {
        throw new Error("Public key must be compressed secp256k1, i.e. 33 bytes starting with 0x02 or 0x03");
      }
      return {
        type: pubkeys_1.pubkeyType.secp256k1,
        value: (0, encoding_1.toBase64)(pubkey)
      };
    }
    function encodeEd25519Pubkey(pubkey) {
      if (pubkey.length !== 32) {
        throw new Error("Ed25519 public key must be 32 bytes long");
      }
      return {
        type: pubkeys_1.pubkeyType.ed25519,
        value: (0, encoding_1.toBase64)(pubkey)
      };
    }
    var pubkeyAminoPrefixSecp256k1 = (0, encoding_1.fromHex)(
      "eb5ae98721"
      /* fixed length */
    );
    var pubkeyAminoPrefixEd25519 = (0, encoding_1.fromHex)(
      "1624de6420"
      /* fixed length */
    );
    var pubkeyAminoPrefixSr25519 = (0, encoding_1.fromHex)(
      "0dfb100520"
      /* fixed length */
    );
    var pubkeyAminoPrefixMultisigThreshold = (0, encoding_1.fromHex)(
      "22c1f7e2"
      /* variable length not included */
    );
    function decodeAminoPubkey(data) {
      if ((0, utils_1.arrayContentStartsWith)(data, pubkeyAminoPrefixSecp256k1)) {
        const rest = data.slice(pubkeyAminoPrefixSecp256k1.length);
        if (rest.length !== 33) {
          throw new Error("Invalid rest data length. Expected 33 bytes (compressed secp256k1 pubkey).");
        }
        return {
          type: pubkeys_1.pubkeyType.secp256k1,
          value: (0, encoding_1.toBase64)(rest)
        };
      } else if ((0, utils_1.arrayContentStartsWith)(data, pubkeyAminoPrefixEd25519)) {
        const rest = data.slice(pubkeyAminoPrefixEd25519.length);
        if (rest.length !== 32) {
          throw new Error("Invalid rest data length. Expected 32 bytes (Ed25519 pubkey).");
        }
        return {
          type: pubkeys_1.pubkeyType.ed25519,
          value: (0, encoding_1.toBase64)(rest)
        };
      } else if ((0, utils_1.arrayContentStartsWith)(data, pubkeyAminoPrefixSr25519)) {
        const rest = data.slice(pubkeyAminoPrefixSr25519.length);
        if (rest.length !== 32) {
          throw new Error("Invalid rest data length. Expected 32 bytes (Sr25519 pubkey).");
        }
        return {
          type: pubkeys_1.pubkeyType.sr25519,
          value: (0, encoding_1.toBase64)(rest)
        };
      } else if ((0, utils_1.arrayContentStartsWith)(data, pubkeyAminoPrefixMultisigThreshold)) {
        return decodeMultisigPubkey(data);
      } else {
        throw new Error("Unsupported public key type. Amino data starts with: " + (0, encoding_1.toHex)(data.slice(0, 5)));
      }
    }
    function decodeBech32Pubkey(bechEncoded) {
      const { data } = (0, encoding_1.fromBech32)(bechEncoded);
      return decodeAminoPubkey(data);
    }
    function decodeUvarint(reader) {
      if (reader.length < 1) {
        throw new Error("Can't decode varint. EOF");
      }
      if (reader[0] > 127) {
        throw new Error("Decoding numbers > 127 is not supported here. Please tell those lazy CosmJS maintainers to port the binary.Varint implementation from the Go standard library and write some tests.");
      }
      return [reader[0], 1];
    }
    function decodeMultisigPubkey(data) {
      const reader = Array.from(data);
      const prefixFromReader = reader.splice(0, pubkeyAminoPrefixMultisigThreshold.length);
      if (!(0, utils_1.arrayContentStartsWith)(prefixFromReader, pubkeyAminoPrefixMultisigThreshold)) {
        throw new Error("Invalid multisig prefix.");
      }
      if (reader.shift() != 8) {
        throw new Error("Invalid multisig data. Expecting 0x08 prefix before threshold.");
      }
      const [threshold, thresholdBytesLength] = decodeUvarint(reader);
      reader.splice(0, thresholdBytesLength);
      const pubkeys = [];
      while (reader.length > 0) {
        if (reader.shift() != 18) {
          throw new Error("Invalid multisig data. Expecting 0x12 prefix before participant pubkey length.");
        }
        const [pubkeyLength, pubkeyLengthBytesSize] = decodeUvarint(reader);
        reader.splice(0, pubkeyLengthBytesSize);
        if (reader.length < pubkeyLength) {
          throw new Error("Invalid multisig data length.");
        }
        const encodedPubkey = reader.splice(0, pubkeyLength);
        const pubkey = decodeAminoPubkey(Uint8Array.from(encodedPubkey));
        pubkeys.push(pubkey);
      }
      return {
        type: pubkeys_1.pubkeyType.multisigThreshold,
        value: {
          threshold: threshold.toString(),
          pubkeys
        }
      };
    }
    function encodeUvarint(value) {
      const checked = math_1.Uint53.fromString(value.toString()).toNumber();
      if (checked > 127) {
        throw new Error("Encoding numbers > 127 is not supported here. Please tell those lazy CosmJS maintainers to port the binary.PutUvarint implementation from the Go standard library and write some tests.");
      }
      return [checked];
    }
    function encodeAminoPubkey(pubkey) {
      if ((0, pubkeys_1.isMultisigThresholdPubkey)(pubkey)) {
        const out = Array.from(pubkeyAminoPrefixMultisigThreshold);
        out.push(8);
        out.push(...encodeUvarint(pubkey.value.threshold));
        for (const pubkeyData of pubkey.value.pubkeys.map((p) => encodeAminoPubkey(p))) {
          out.push(18);
          out.push(...encodeUvarint(pubkeyData.length));
          out.push(...pubkeyData);
        }
        return new Uint8Array(out);
      } else if ((0, pubkeys_1.isEd25519Pubkey)(pubkey)) {
        return new Uint8Array([...pubkeyAminoPrefixEd25519, ...(0, encoding_1.fromBase64)(pubkey.value)]);
      } else if ((0, pubkeys_1.isSecp256k1Pubkey)(pubkey)) {
        return new Uint8Array([...pubkeyAminoPrefixSecp256k1, ...(0, encoding_1.fromBase64)(pubkey.value)]);
      } else {
        throw new Error("Unsupported pubkey type");
      }
    }
    function encodeBech32Pubkey(pubkey, prefix) {
      return (0, encoding_1.toBech32)(prefix, encodeAminoPubkey(pubkey));
    }
  }
});

// ../../node_modules/.pnpm/@cosmjs+amino@0.34.0/node_modules/@cosmjs/amino/build/addresses.js
var require_addresses = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+amino@0.34.0/node_modules/@cosmjs/amino/build/addresses.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.rawEd25519PubkeyToRawAddress = rawEd25519PubkeyToRawAddress;
    exports.rawSecp256k1PubkeyToRawAddress = rawSecp256k1PubkeyToRawAddress;
    exports.pubkeyToRawAddress = pubkeyToRawAddress;
    exports.pubkeyToAddress = pubkeyToAddress;
    var crypto_1 = require_build4();
    var encoding_1 = require_build();
    var encoding_2 = require_encoding();
    var pubkeys_1 = require_pubkeys();
    function rawEd25519PubkeyToRawAddress(pubkeyData) {
      if (pubkeyData.length !== 32) {
        throw new Error(`Invalid Ed25519 pubkey length: ${pubkeyData.length}`);
      }
      return (0, crypto_1.sha256)(pubkeyData).slice(0, 20);
    }
    function rawSecp256k1PubkeyToRawAddress(pubkeyData) {
      if (pubkeyData.length !== 33) {
        throw new Error(`Invalid Secp256k1 pubkey length (compressed): ${pubkeyData.length}`);
      }
      return (0, crypto_1.ripemd160)((0, crypto_1.sha256)(pubkeyData));
    }
    function pubkeyToRawAddress(pubkey) {
      if ((0, pubkeys_1.isSecp256k1Pubkey)(pubkey)) {
        const pubkeyData = (0, encoding_1.fromBase64)(pubkey.value);
        return rawSecp256k1PubkeyToRawAddress(pubkeyData);
      } else if ((0, pubkeys_1.isEd25519Pubkey)(pubkey)) {
        const pubkeyData = (0, encoding_1.fromBase64)(pubkey.value);
        return rawEd25519PubkeyToRawAddress(pubkeyData);
      } else if ((0, pubkeys_1.isMultisigThresholdPubkey)(pubkey)) {
        const pubkeyData = (0, encoding_2.encodeAminoPubkey)(pubkey);
        return (0, crypto_1.sha256)(pubkeyData).slice(0, 20);
      } else {
        throw new Error("Unsupported public key type");
      }
    }
    function pubkeyToAddress(pubkey, prefix) {
      return (0, encoding_1.toBech32)(prefix, pubkeyToRawAddress(pubkey));
    }
  }
});

// ../../node_modules/.pnpm/@cosmjs+amino@0.34.0/node_modules/@cosmjs/amino/build/coins.js
var require_coins = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+amino@0.34.0/node_modules/@cosmjs/amino/build/coins.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.coin = coin;
    exports.coins = coins;
    exports.parseCoins = parseCoins;
    exports.addCoins = addCoins;
    var math_1 = require_build2();
    function coin(amount, denom) {
      let outAmount;
      if (typeof amount === "number") {
        try {
          outAmount = new math_1.Uint53(amount).toString();
        } catch (_err) {
          throw new Error("Given amount is not a safe integer. Consider using a string instead to overcome the limitations of JS numbers.");
        }
      } else {
        if (!amount.match(/^[0-9]+$/)) {
          throw new Error("Invalid unsigned integer string format");
        }
        outAmount = amount.replace(/^0*/, "") || "0";
      }
      return {
        amount: outAmount,
        denom
      };
    }
    function coins(amount, denom) {
      return [coin(amount, denom)];
    }
    function parseCoins(input) {
      return input.replace(/\s/g, "").split(",").filter(Boolean).map((part) => {
        const match = part.match(/^([0-9]+)([a-zA-Z][a-zA-Z0-9/]{2,127})$/);
        if (!match)
          throw new Error("Got an invalid coin string");
        return {
          amount: match[1].replace(/^0+/, "") || "0",
          denom: match[2]
        };
      });
    }
    function addCoins(lhs, rhs) {
      if (lhs.denom !== rhs.denom)
        throw new Error("Trying to add two coins with different denoms");
      return {
        amount: math_1.Decimal.fromAtomics(lhs.amount, 0).plus(math_1.Decimal.fromAtomics(rhs.amount, 0)).atomics,
        denom: lhs.denom
      };
    }
  }
});

// ../../node_modules/.pnpm/@cosmjs+amino@0.34.0/node_modules/@cosmjs/amino/build/multisig.js
var require_multisig2 = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+amino@0.34.0/node_modules/@cosmjs/amino/build/multisig.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.compareArrays = compareArrays;
    exports.createMultisigThresholdPubkey = createMultisigThresholdPubkey;
    var encoding_1 = require_build();
    var math_1 = require_build2();
    var addresses_1 = require_addresses();
    function compareArrays(a, b) {
      const aHex = (0, encoding_1.toHex)(a);
      const bHex = (0, encoding_1.toHex)(b);
      return aHex === bHex ? 0 : aHex < bHex ? -1 : 1;
    }
    function createMultisigThresholdPubkey(pubkeys, threshold, nosort = false) {
      const uintThreshold = new math_1.Uint53(threshold);
      if (uintThreshold.toNumber() > pubkeys.length) {
        throw new Error(`Threshold k = ${uintThreshold.toNumber()} exceeds number of keys n = ${pubkeys.length}`);
      }
      const outPubkeys = nosort ? pubkeys : Array.from(pubkeys).sort((lhs, rhs) => {
        const addressLhs = (0, addresses_1.pubkeyToRawAddress)(lhs);
        const addressRhs = (0, addresses_1.pubkeyToRawAddress)(rhs);
        return compareArrays(addressLhs, addressRhs);
      });
      return {
        type: "tendermint/PubKeyMultisigThreshold",
        value: {
          threshold: uintThreshold.toString(),
          pubkeys: outPubkeys
        }
      };
    }
  }
});

// ../../node_modules/.pnpm/@cosmjs+amino@0.34.0/node_modules/@cosmjs/amino/build/omitdefault.js
var require_omitdefault = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+amino@0.34.0/node_modules/@cosmjs/amino/build/omitdefault.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.omitDefault = omitDefault;
    function omitDefault(input) {
      switch (typeof input) {
        case "string":
          return input === "" ? void 0 : input;
        case "number":
          return input === 0 ? void 0 : input;
        case "bigint":
          return input === BigInt(0) ? void 0 : input;
        case "boolean":
          return !input ? void 0 : input;
        default:
          throw new Error(`Got unsupported type '${typeof input}'`);
      }
    }
  }
});

// ../../node_modules/.pnpm/@cosmjs+amino@0.34.0/node_modules/@cosmjs/amino/build/paths.js
var require_paths = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+amino@0.34.0/node_modules/@cosmjs/amino/build/paths.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.makeCosmoshubPath = makeCosmoshubPath;
    var crypto_1 = require_build4();
    function makeCosmoshubPath(a) {
      return [
        crypto_1.Slip10RawIndex.hardened(44),
        crypto_1.Slip10RawIndex.hardened(118),
        crypto_1.Slip10RawIndex.hardened(0),
        crypto_1.Slip10RawIndex.normal(0),
        crypto_1.Slip10RawIndex.normal(a)
      ];
    }
  }
});

// ../../node_modules/.pnpm/@cosmjs+amino@0.34.0/node_modules/@cosmjs/amino/build/signature.js
var require_signature = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+amino@0.34.0/node_modules/@cosmjs/amino/build/signature.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.encodeSecp256k1Signature = encodeSecp256k1Signature;
    exports.decodeSignature = decodeSignature;
    var encoding_1 = require_build();
    var encoding_2 = require_encoding();
    var pubkeys_1 = require_pubkeys();
    function encodeSecp256k1Signature(pubkey, signature) {
      if (signature.length !== 64) {
        throw new Error("Signature must be 64 bytes long. Cosmos SDK uses a 2x32 byte fixed length encoding for the secp256k1 signature integers r and s.");
      }
      return {
        pub_key: (0, encoding_2.encodeSecp256k1Pubkey)(pubkey),
        signature: (0, encoding_1.toBase64)(signature)
      };
    }
    function decodeSignature(signature) {
      switch (signature.pub_key.type) {
        case pubkeys_1.pubkeyType.secp256k1:
          return {
            pubkey: (0, encoding_1.fromBase64)(signature.pub_key.value),
            signature: (0, encoding_1.fromBase64)(signature.signature)
          };
        default:
          throw new Error("Unsupported pubkey type");
      }
    }
  }
});

// ../../node_modules/.pnpm/@cosmjs+amino@0.34.0/node_modules/@cosmjs/amino/build/signdoc.js
var require_signdoc = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+amino@0.34.0/node_modules/@cosmjs/amino/build/signdoc.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.sortedJsonStringify = sortedJsonStringify;
    exports.makeSignDoc = makeSignDoc;
    exports.escapeCharacters = escapeCharacters;
    exports.serializeSignDoc = serializeSignDoc;
    var encoding_1 = require_build();
    var math_1 = require_build2();
    function sortedObject(obj) {
      if (typeof obj !== "object" || obj === null) {
        return obj;
      }
      if (Array.isArray(obj)) {
        return obj.map(sortedObject);
      }
      const sortedKeys = Object.keys(obj).sort();
      const result = {};
      sortedKeys.forEach((key) => {
        result[key] = sortedObject(obj[key]);
      });
      return result;
    }
    function sortedJsonStringify(obj) {
      return JSON.stringify(sortedObject(obj));
    }
    function makeSignDoc(msgs, fee, chainId, memo, accountNumber, sequence, timeout_height) {
      return {
        chain_id: chainId,
        account_number: math_1.Uint53.fromString(accountNumber.toString()).toString(),
        sequence: math_1.Uint53.fromString(sequence.toString()).toString(),
        fee,
        msgs,
        memo: memo || "",
        ...timeout_height && { timeout_height: timeout_height.toString() }
      };
    }
    function escapeCharacters(input) {
      const amp = /&/g;
      const lt = /</g;
      const gt = />/g;
      return input.replace(amp, "\\u0026").replace(lt, "\\u003c").replace(gt, "\\u003e");
    }
    function serializeSignDoc(signDoc) {
      const serialized = escapeCharacters(sortedJsonStringify(signDoc));
      return (0, encoding_1.toUtf8)(serialized);
    }
  }
});

// ../../node_modules/.pnpm/@cosmjs+amino@0.34.0/node_modules/@cosmjs/amino/build/wallet.js
var require_wallet = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+amino@0.34.0/node_modules/@cosmjs/amino/build/wallet.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.supportedAlgorithms = exports.cosmjsSalt = void 0;
    exports.executeKdf = executeKdf;
    exports.encrypt = encrypt;
    exports.decrypt = decrypt;
    var crypto_1 = require_build4();
    var encoding_1 = require_build();
    exports.cosmjsSalt = (0, encoding_1.toAscii)("The CosmJS salt.");
    async function executeKdf(password, configuration) {
      switch (configuration.algorithm) {
        case "argon2id": {
          const options = configuration.params;
          if (!(0, crypto_1.isArgon2idOptions)(options))
            throw new Error("Invalid format of argon2id params");
          return crypto_1.Argon2id.execute(password, exports.cosmjsSalt, options);
        }
        default:
          throw new Error("Unsupported KDF algorithm");
      }
    }
    exports.supportedAlgorithms = {
      xchacha20poly1305Ietf: "xchacha20poly1305-ietf"
    };
    async function encrypt(plaintext, encryptionKey, config) {
      switch (config.algorithm) {
        case exports.supportedAlgorithms.xchacha20poly1305Ietf: {
          const nonce = crypto_1.Random.getBytes(crypto_1.xchacha20NonceLength);
          return new Uint8Array([
            ...nonce,
            ...await crypto_1.Xchacha20poly1305Ietf.encrypt(plaintext, encryptionKey, nonce)
          ]);
        }
        default:
          throw new Error(`Unsupported encryption algorithm: '${config.algorithm}'`);
      }
    }
    async function decrypt(ciphertext, encryptionKey, config) {
      switch (config.algorithm) {
        case exports.supportedAlgorithms.xchacha20poly1305Ietf: {
          const nonce = ciphertext.slice(0, crypto_1.xchacha20NonceLength);
          return crypto_1.Xchacha20poly1305Ietf.decrypt(ciphertext.slice(crypto_1.xchacha20NonceLength), encryptionKey, nonce);
        }
        default:
          throw new Error(`Unsupported encryption algorithm: '${config.algorithm}'`);
      }
    }
  }
});

// ../../node_modules/.pnpm/@cosmjs+amino@0.34.0/node_modules/@cosmjs/amino/build/secp256k1hdwallet.js
var require_secp256k1hdwallet = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+amino@0.34.0/node_modules/@cosmjs/amino/build/secp256k1hdwallet.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Secp256k1HdWallet = void 0;
    exports.extractKdfConfiguration = extractKdfConfiguration;
    var crypto_1 = require_build4();
    var encoding_1 = require_build();
    var utils_1 = require_build3();
    var addresses_1 = require_addresses();
    var paths_1 = require_paths();
    var signature_1 = require_signature();
    var signdoc_1 = require_signdoc();
    var wallet_1 = require_wallet();
    var serializationTypeV1 = "secp256k1wallet-v1";
    var basicPasswordHashingOptions = {
      algorithm: "argon2id",
      params: {
        outputLength: 32,
        opsLimit: 24,
        memLimitKib: 12 * 1024
      }
    };
    function isDerivationJson(thing) {
      if (!(0, utils_1.isNonNullObject)(thing))
        return false;
      if (typeof thing.hdPath !== "string")
        return false;
      if (typeof thing.prefix !== "string")
        return false;
      return true;
    }
    function extractKdfConfigurationV1(doc) {
      return doc.kdf;
    }
    function extractKdfConfiguration(serialization) {
      const root = JSON.parse(serialization);
      if (!(0, utils_1.isNonNullObject)(root))
        throw new Error("Root document is not an object.");
      switch (root.type) {
        case serializationTypeV1:
          return extractKdfConfigurationV1(root);
        default:
          throw new Error("Unsupported serialization type");
      }
    }
    var defaultOptions = {
      bip39Password: "",
      hdPaths: [(0, paths_1.makeCosmoshubPath)(0)],
      prefix: "cosmos"
    };
    var Secp256k1HdWallet = class _Secp256k1HdWallet {
      /**
       * Restores a wallet from the given BIP39 mnemonic.
       *
       * @param mnemonic Any valid English mnemonic.
       * @param options An optional `Secp256k1HdWalletOptions` object optionally containing a bip39Password, hdPaths, and prefix.
       */
      static async fromMnemonic(mnemonic, options = {}) {
        const mnemonicChecked = new crypto_1.EnglishMnemonic(mnemonic);
        const seed = await crypto_1.Bip39.mnemonicToSeed(mnemonicChecked, options.bip39Password);
        return new _Secp256k1HdWallet(mnemonicChecked, {
          ...options,
          seed
        });
      }
      /**
       * Generates a new wallet with a BIP39 mnemonic of the given length.
       *
       * @param length The number of words in the mnemonic (12, 15, 18, 21 or 24).
       * @param options An optional `Secp256k1HdWalletOptions` object optionally containing a bip39Password, hdPaths, and prefix.
       */
      static async generate(length = 12, options = {}) {
        const entropyLength = 4 * Math.floor(11 * length / 33);
        const entropy = crypto_1.Random.getBytes(entropyLength);
        const mnemonic = crypto_1.Bip39.encode(entropy);
        return _Secp256k1HdWallet.fromMnemonic(mnemonic.toString(), options);
      }
      /**
       * Restores a wallet from an encrypted serialization.
       *
       * @param password The user provided password used to generate an encryption key via a KDF.
       *                 This is not normalized internally (see "Unicode normalization" to learn more).
       */
      static async deserialize(serialization, password) {
        const root = JSON.parse(serialization);
        if (!(0, utils_1.isNonNullObject)(root))
          throw new Error("Root document is not an object.");
        switch (root.type) {
          case serializationTypeV1:
            return _Secp256k1HdWallet.deserializeTypeV1(serialization, password);
          default:
            throw new Error("Unsupported serialization type");
        }
      }
      /**
       * Restores a wallet from an encrypted serialization.
       *
       * This is an advanced alternative to calling `deserialize(serialization, password)` directly, which allows
       * you to offload the KDF execution to a non-UI thread (e.g. in a WebWorker).
       *
       * The caller is responsible for ensuring the key was derived with the given KDF configuration. This can be
       * done using `extractKdfConfiguration(serialization)` and `executeKdf(password, kdfConfiguration)` from this package.
       */
      static async deserializeWithEncryptionKey(serialization, encryptionKey) {
        const root = JSON.parse(serialization);
        if (!(0, utils_1.isNonNullObject)(root))
          throw new Error("Root document is not an object.");
        const untypedRoot = root;
        switch (untypedRoot.type) {
          case serializationTypeV1: {
            const decryptedBytes = await (0, wallet_1.decrypt)((0, encoding_1.fromBase64)(untypedRoot.data), encryptionKey, untypedRoot.encryption);
            const decryptedDocument = JSON.parse((0, encoding_1.fromUtf8)(decryptedBytes));
            const { mnemonic, accounts } = decryptedDocument;
            (0, utils_1.assert)(typeof mnemonic === "string");
            if (!Array.isArray(accounts))
              throw new Error("Property 'accounts' is not an array");
            if (!accounts.every((account) => isDerivationJson(account))) {
              throw new Error("Account is not in the correct format.");
            }
            const firstPrefix = accounts[0].prefix;
            if (!accounts.every(({ prefix }) => prefix === firstPrefix)) {
              throw new Error("Accounts do not all have the same prefix");
            }
            const hdPaths = accounts.map(({ hdPath }) => (0, crypto_1.stringToPath)(hdPath));
            return _Secp256k1HdWallet.fromMnemonic(mnemonic, {
              hdPaths,
              prefix: firstPrefix
            });
          }
          default:
            throw new Error("Unsupported serialization type");
        }
      }
      static async deserializeTypeV1(serialization, password) {
        const root = JSON.parse(serialization);
        if (!(0, utils_1.isNonNullObject)(root))
          throw new Error("Root document is not an object.");
        const encryptionKey = await (0, wallet_1.executeKdf)(password, root.kdf);
        return _Secp256k1HdWallet.deserializeWithEncryptionKey(serialization, encryptionKey);
      }
      constructor(mnemonic, options) {
        const hdPaths = options.hdPaths ?? defaultOptions.hdPaths;
        const prefix = options.prefix ?? defaultOptions.prefix;
        this.secret = mnemonic;
        this.seed = options.seed;
        this.accounts = hdPaths.map((hdPath) => ({
          hdPath,
          prefix
        }));
      }
      get mnemonic() {
        return this.secret.toString();
      }
      async getAccounts() {
        const accountsWithPrivkeys = await this.getAccountsWithPrivkeys();
        return accountsWithPrivkeys.map(({ algo, pubkey, address }) => ({
          algo,
          pubkey,
          address
        }));
      }
      async signAmino(signerAddress, signDoc) {
        const accounts = await this.getAccountsWithPrivkeys();
        const account = accounts.find(({ address }) => address === signerAddress);
        if (account === void 0) {
          throw new Error(`Address ${signerAddress} not found in wallet`);
        }
        const { privkey, pubkey } = account;
        const message = (0, crypto_1.sha256)((0, signdoc_1.serializeSignDoc)(signDoc));
        const signature = await crypto_1.Secp256k1.createSignature(message, privkey);
        const signatureBytes = new Uint8Array([...signature.r(32), ...signature.s(32)]);
        return {
          signed: signDoc,
          signature: (0, signature_1.encodeSecp256k1Signature)(pubkey, signatureBytes)
        };
      }
      /**
       * Generates an encrypted serialization of this wallet.
       *
       * @param password The user provided password used to generate an encryption key via a KDF.
       *                 This is not normalized internally (see "Unicode normalization" to learn more).
       */
      async serialize(password) {
        const kdfConfiguration = basicPasswordHashingOptions;
        const encryptionKey = await (0, wallet_1.executeKdf)(password, kdfConfiguration);
        return this.serializeWithEncryptionKey(encryptionKey, kdfConfiguration);
      }
      /**
       * Generates an encrypted serialization of this wallet.
       *
       * This is an advanced alternative to calling `serialize(password)` directly, which allows you to
       * offload the KDF execution to a non-UI thread (e.g. in a WebWorker).
       *
       * The caller is responsible for ensuring the key was derived with the given KDF options. If this
       * is not the case, the wallet cannot be restored with the original password.
       */
      async serializeWithEncryptionKey(encryptionKey, kdfConfiguration) {
        const dataToEncrypt = {
          mnemonic: this.mnemonic,
          accounts: this.accounts.map(({ hdPath, prefix }) => ({
            hdPath: (0, crypto_1.pathToString)(hdPath),
            prefix
          }))
        };
        const dataToEncryptRaw = (0, encoding_1.toUtf8)(JSON.stringify(dataToEncrypt));
        const encryptionConfiguration = {
          algorithm: wallet_1.supportedAlgorithms.xchacha20poly1305Ietf
        };
        const encryptedData = await (0, wallet_1.encrypt)(dataToEncryptRaw, encryptionKey, encryptionConfiguration);
        const out = {
          type: serializationTypeV1,
          kdf: kdfConfiguration,
          encryption: encryptionConfiguration,
          data: (0, encoding_1.toBase64)(encryptedData)
        };
        return JSON.stringify(out);
      }
      async getKeyPair(hdPath) {
        const { privkey } = crypto_1.Slip10.derivePath(crypto_1.Slip10Curve.Secp256k1, this.seed, hdPath);
        const { pubkey } = await crypto_1.Secp256k1.makeKeypair(privkey);
        return {
          privkey,
          pubkey: crypto_1.Secp256k1.compressPubkey(pubkey)
        };
      }
      async getAccountsWithPrivkeys() {
        return Promise.all(this.accounts.map(async ({ hdPath, prefix }) => {
          const { privkey, pubkey } = await this.getKeyPair(hdPath);
          const address = (0, encoding_1.toBech32)(prefix, (0, addresses_1.rawSecp256k1PubkeyToRawAddress)(pubkey));
          return {
            algo: "secp256k1",
            privkey,
            pubkey,
            address
          };
        }));
      }
    };
    exports.Secp256k1HdWallet = Secp256k1HdWallet;
  }
});

// ../../node_modules/.pnpm/@cosmjs+amino@0.34.0/node_modules/@cosmjs/amino/build/secp256k1wallet.js
var require_secp256k1wallet = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+amino@0.34.0/node_modules/@cosmjs/amino/build/secp256k1wallet.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Secp256k1Wallet = void 0;
    var crypto_1 = require_build4();
    var encoding_1 = require_build();
    var addresses_1 = require_addresses();
    var signature_1 = require_signature();
    var signdoc_1 = require_signdoc();
    var Secp256k1Wallet = class _Secp256k1Wallet {
      /**
       * Creates a Secp256k1Wallet from the given private key
       *
       * @param privkey The private key.
       * @param prefix The bech32 address prefix (human readable part). Defaults to "cosmos".
       */
      static async fromKey(privkey, prefix = "cosmos") {
        const uncompressed = (await crypto_1.Secp256k1.makeKeypair(privkey)).pubkey;
        return new _Secp256k1Wallet(privkey, crypto_1.Secp256k1.compressPubkey(uncompressed), prefix);
      }
      constructor(privkey, pubkey, prefix) {
        this.privkey = privkey;
        this.pubkey = pubkey;
        this.prefix = prefix;
      }
      get address() {
        return (0, encoding_1.toBech32)(this.prefix, (0, addresses_1.rawSecp256k1PubkeyToRawAddress)(this.pubkey));
      }
      async getAccounts() {
        return [
          {
            algo: "secp256k1",
            address: this.address,
            pubkey: this.pubkey
          }
        ];
      }
      async signAmino(signerAddress, signDoc) {
        if (signerAddress !== this.address) {
          throw new Error(`Address ${signerAddress} not found in wallet`);
        }
        const message = new crypto_1.Sha256((0, signdoc_1.serializeSignDoc)(signDoc)).digest();
        const signature = await crypto_1.Secp256k1.createSignature(message, this.privkey);
        const signatureBytes = new Uint8Array([...signature.r(32), ...signature.s(32)]);
        return {
          signed: signDoc,
          signature: (0, signature_1.encodeSecp256k1Signature)(this.pubkey, signatureBytes)
        };
      }
    };
    exports.Secp256k1Wallet = Secp256k1Wallet;
  }
});

// ../../node_modules/.pnpm/@cosmjs+amino@0.34.0/node_modules/@cosmjs/amino/build/stdtx.js
var require_stdtx = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+amino@0.34.0/node_modules/@cosmjs/amino/build/stdtx.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isStdTx = isStdTx;
    exports.makeStdTx = makeStdTx;
    function isStdTx(txValue) {
      const { memo, msg, fee, signatures } = txValue;
      return typeof memo === "string" && Array.isArray(msg) && typeof fee === "object" && Array.isArray(signatures);
    }
    function makeStdTx(content, signatures) {
      return {
        msg: content.msgs,
        fee: content.fee,
        memo: content.memo,
        signatures: Array.isArray(signatures) ? signatures : [signatures]
      };
    }
  }
});

// ../../node_modules/.pnpm/@cosmjs+amino@0.34.0/node_modules/@cosmjs/amino/build/index.js
var require_build5 = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+amino@0.34.0/node_modules/@cosmjs/amino/build/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.executeKdf = exports.makeStdTx = exports.isStdTx = exports.serializeSignDoc = exports.makeSignDoc = exports.encodeSecp256k1Signature = exports.decodeSignature = exports.Secp256k1Wallet = exports.Secp256k1HdWallet = exports.extractKdfConfiguration = exports.pubkeyType = exports.isSinglePubkey = exports.isSecp256k1Pubkey = exports.isMultisigThresholdPubkey = exports.isEd25519Pubkey = exports.makeCosmoshubPath = exports.omitDefault = exports.createMultisigThresholdPubkey = exports.encodeSecp256k1Pubkey = exports.encodeEd25519Pubkey = exports.encodeBech32Pubkey = exports.encodeAminoPubkey = exports.decodeBech32Pubkey = exports.decodeAminoPubkey = exports.parseCoins = exports.coins = exports.coin = exports.addCoins = exports.rawSecp256k1PubkeyToRawAddress = exports.rawEd25519PubkeyToRawAddress = exports.pubkeyToRawAddress = exports.pubkeyToAddress = void 0;
    var addresses_1 = require_addresses();
    Object.defineProperty(exports, "pubkeyToAddress", { enumerable: true, get: function() {
      return addresses_1.pubkeyToAddress;
    } });
    Object.defineProperty(exports, "pubkeyToRawAddress", { enumerable: true, get: function() {
      return addresses_1.pubkeyToRawAddress;
    } });
    Object.defineProperty(exports, "rawEd25519PubkeyToRawAddress", { enumerable: true, get: function() {
      return addresses_1.rawEd25519PubkeyToRawAddress;
    } });
    Object.defineProperty(exports, "rawSecp256k1PubkeyToRawAddress", { enumerable: true, get: function() {
      return addresses_1.rawSecp256k1PubkeyToRawAddress;
    } });
    var coins_1 = require_coins();
    Object.defineProperty(exports, "addCoins", { enumerable: true, get: function() {
      return coins_1.addCoins;
    } });
    Object.defineProperty(exports, "coin", { enumerable: true, get: function() {
      return coins_1.coin;
    } });
    Object.defineProperty(exports, "coins", { enumerable: true, get: function() {
      return coins_1.coins;
    } });
    Object.defineProperty(exports, "parseCoins", { enumerable: true, get: function() {
      return coins_1.parseCoins;
    } });
    var encoding_1 = require_encoding();
    Object.defineProperty(exports, "decodeAminoPubkey", { enumerable: true, get: function() {
      return encoding_1.decodeAminoPubkey;
    } });
    Object.defineProperty(exports, "decodeBech32Pubkey", { enumerable: true, get: function() {
      return encoding_1.decodeBech32Pubkey;
    } });
    Object.defineProperty(exports, "encodeAminoPubkey", { enumerable: true, get: function() {
      return encoding_1.encodeAminoPubkey;
    } });
    Object.defineProperty(exports, "encodeBech32Pubkey", { enumerable: true, get: function() {
      return encoding_1.encodeBech32Pubkey;
    } });
    Object.defineProperty(exports, "encodeEd25519Pubkey", { enumerable: true, get: function() {
      return encoding_1.encodeEd25519Pubkey;
    } });
    Object.defineProperty(exports, "encodeSecp256k1Pubkey", { enumerable: true, get: function() {
      return encoding_1.encodeSecp256k1Pubkey;
    } });
    var multisig_1 = require_multisig2();
    Object.defineProperty(exports, "createMultisigThresholdPubkey", { enumerable: true, get: function() {
      return multisig_1.createMultisigThresholdPubkey;
    } });
    var omitdefault_1 = require_omitdefault();
    Object.defineProperty(exports, "omitDefault", { enumerable: true, get: function() {
      return omitdefault_1.omitDefault;
    } });
    var paths_1 = require_paths();
    Object.defineProperty(exports, "makeCosmoshubPath", { enumerable: true, get: function() {
      return paths_1.makeCosmoshubPath;
    } });
    var pubkeys_1 = require_pubkeys();
    Object.defineProperty(exports, "isEd25519Pubkey", { enumerable: true, get: function() {
      return pubkeys_1.isEd25519Pubkey;
    } });
    Object.defineProperty(exports, "isMultisigThresholdPubkey", { enumerable: true, get: function() {
      return pubkeys_1.isMultisigThresholdPubkey;
    } });
    Object.defineProperty(exports, "isSecp256k1Pubkey", { enumerable: true, get: function() {
      return pubkeys_1.isSecp256k1Pubkey;
    } });
    Object.defineProperty(exports, "isSinglePubkey", { enumerable: true, get: function() {
      return pubkeys_1.isSinglePubkey;
    } });
    Object.defineProperty(exports, "pubkeyType", { enumerable: true, get: function() {
      return pubkeys_1.pubkeyType;
    } });
    var secp256k1hdwallet_1 = require_secp256k1hdwallet();
    Object.defineProperty(exports, "extractKdfConfiguration", { enumerable: true, get: function() {
      return secp256k1hdwallet_1.extractKdfConfiguration;
    } });
    Object.defineProperty(exports, "Secp256k1HdWallet", { enumerable: true, get: function() {
      return secp256k1hdwallet_1.Secp256k1HdWallet;
    } });
    var secp256k1wallet_1 = require_secp256k1wallet();
    Object.defineProperty(exports, "Secp256k1Wallet", { enumerable: true, get: function() {
      return secp256k1wallet_1.Secp256k1Wallet;
    } });
    var signature_1 = require_signature();
    Object.defineProperty(exports, "decodeSignature", { enumerable: true, get: function() {
      return signature_1.decodeSignature;
    } });
    Object.defineProperty(exports, "encodeSecp256k1Signature", { enumerable: true, get: function() {
      return signature_1.encodeSecp256k1Signature;
    } });
    var signdoc_1 = require_signdoc();
    Object.defineProperty(exports, "makeSignDoc", { enumerable: true, get: function() {
      return signdoc_1.makeSignDoc;
    } });
    Object.defineProperty(exports, "serializeSignDoc", { enumerable: true, get: function() {
      return signdoc_1.serializeSignDoc;
    } });
    var stdtx_1 = require_stdtx();
    Object.defineProperty(exports, "isStdTx", { enumerable: true, get: function() {
      return stdtx_1.isStdTx;
    } });
    Object.defineProperty(exports, "makeStdTx", { enumerable: true, get: function() {
      return stdtx_1.makeStdTx;
    } });
    var wallet_1 = require_wallet();
    Object.defineProperty(exports, "executeKdf", { enumerable: true, get: function() {
      return wallet_1.executeKdf;
    } });
  }
});

// ../../node_modules/.pnpm/@cosmjs+proto-signing@0.34.0/node_modules/@cosmjs/proto-signing/build/signing.js
var require_signing2 = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+proto-signing@0.34.0/node_modules/@cosmjs/proto-signing/build/signing.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.makeAuthInfoBytes = makeAuthInfoBytes;
    exports.makeSignDoc = makeSignDoc;
    exports.makeSignBytes = makeSignBytes;
    var utils_1 = require_build3();
    var signing_1 = require_signing();
    var tx_1 = require_tx();
    function makeSignerInfos(signers, signMode) {
      return signers.map(({ pubkey, sequence }) => ({
        publicKey: pubkey,
        modeInfo: {
          single: { mode: signMode }
        },
        sequence: BigInt(sequence)
      }));
    }
    function makeAuthInfoBytes(signers, feeAmount, gasLimit, feeGranter, feePayer, signMode = signing_1.SignMode.SIGN_MODE_DIRECT) {
      (0, utils_1.assert)(feeGranter === void 0 || typeof feeGranter === "string", "feeGranter must be undefined or string");
      (0, utils_1.assert)(feePayer === void 0 || typeof feePayer === "string", "feePayer must be undefined or string");
      const authInfo = tx_1.AuthInfo.fromPartial({
        signerInfos: makeSignerInfos(signers, signMode),
        fee: {
          amount: [...feeAmount],
          gasLimit: BigInt(gasLimit),
          granter: feeGranter,
          payer: feePayer
        }
      });
      return tx_1.AuthInfo.encode(authInfo).finish();
    }
    function makeSignDoc(bodyBytes, authInfoBytes, chainId, accountNumber) {
      return {
        bodyBytes,
        authInfoBytes,
        chainId,
        accountNumber: BigInt(accountNumber)
      };
    }
    function makeSignBytes({ accountNumber, authInfoBytes, bodyBytes, chainId }) {
      const signDoc = tx_1.SignDoc.fromPartial({
        accountNumber,
        authInfoBytes,
        bodyBytes,
        chainId
      });
      return tx_1.SignDoc.encode(signDoc).finish();
    }
  }
});

// ../../node_modules/.pnpm/@cosmjs+proto-signing@0.34.0/node_modules/@cosmjs/proto-signing/build/wallet.js
var require_wallet2 = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+proto-signing@0.34.0/node_modules/@cosmjs/proto-signing/build/wallet.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.supportedAlgorithms = exports.cosmjsSalt = void 0;
    exports.executeKdf = executeKdf;
    exports.encrypt = encrypt;
    exports.decrypt = decrypt;
    var crypto_1 = require_build4();
    var encoding_1 = require_build();
    exports.cosmjsSalt = (0, encoding_1.toAscii)("The CosmJS salt.");
    async function executeKdf(password, configuration) {
      switch (configuration.algorithm) {
        case "argon2id": {
          const options = configuration.params;
          if (!(0, crypto_1.isArgon2idOptions)(options))
            throw new Error("Invalid format of argon2id params");
          return crypto_1.Argon2id.execute(password, exports.cosmjsSalt, options);
        }
        default:
          throw new Error("Unsupported KDF algorithm");
      }
    }
    exports.supportedAlgorithms = {
      xchacha20poly1305Ietf: "xchacha20poly1305-ietf"
    };
    async function encrypt(plaintext, encryptionKey, config) {
      switch (config.algorithm) {
        case exports.supportedAlgorithms.xchacha20poly1305Ietf: {
          const nonce = crypto_1.Random.getBytes(crypto_1.xchacha20NonceLength);
          return new Uint8Array([
            ...nonce,
            ...await crypto_1.Xchacha20poly1305Ietf.encrypt(plaintext, encryptionKey, nonce)
          ]);
        }
        default:
          throw new Error(`Unsupported encryption algorithm: '${config.algorithm}'`);
      }
    }
    async function decrypt(ciphertext, encryptionKey, config) {
      switch (config.algorithm) {
        case exports.supportedAlgorithms.xchacha20poly1305Ietf: {
          const nonce = ciphertext.slice(0, crypto_1.xchacha20NonceLength);
          return crypto_1.Xchacha20poly1305Ietf.decrypt(ciphertext.slice(crypto_1.xchacha20NonceLength), encryptionKey, nonce);
        }
        default:
          throw new Error(`Unsupported encryption algorithm: '${config.algorithm}'`);
      }
    }
  }
});

// ../../node_modules/.pnpm/@cosmjs+proto-signing@0.34.0/node_modules/@cosmjs/proto-signing/build/directsecp256k1hdwallet.js
var require_directsecp256k1hdwallet = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+proto-signing@0.34.0/node_modules/@cosmjs/proto-signing/build/directsecp256k1hdwallet.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DirectSecp256k1HdWallet = void 0;
    exports.extractKdfConfiguration = extractKdfConfiguration;
    var amino_1 = require_build5();
    var crypto_1 = require_build4();
    var encoding_1 = require_build();
    var utils_1 = require_build3();
    var signing_1 = require_signing2();
    var wallet_1 = require_wallet2();
    var serializationTypeV1 = "directsecp256k1hdwallet-v1";
    var basicPasswordHashingOptions = {
      algorithm: "argon2id",
      params: {
        outputLength: 32,
        opsLimit: 24,
        memLimitKib: 12 * 1024
      }
    };
    function isDerivationJson(thing) {
      if (!(0, utils_1.isNonNullObject)(thing))
        return false;
      if (typeof thing.hdPath !== "string")
        return false;
      if (typeof thing.prefix !== "string")
        return false;
      return true;
    }
    function extractKdfConfigurationV1(doc) {
      return doc.kdf;
    }
    function extractKdfConfiguration(serialization) {
      const root = JSON.parse(serialization);
      if (!(0, utils_1.isNonNullObject)(root))
        throw new Error("Root document is not an object.");
      switch (root.type) {
        case serializationTypeV1:
          return extractKdfConfigurationV1(root);
        default:
          throw new Error("Unsupported serialization type");
      }
    }
    var defaultOptions = {
      bip39Password: "",
      hdPaths: [(0, amino_1.makeCosmoshubPath)(0)],
      prefix: "cosmos"
    };
    var DirectSecp256k1HdWallet = class _DirectSecp256k1HdWallet {
      /**
       * Restores a wallet from the given BIP39 mnemonic.
       *
       * @param mnemonic Any valid English mnemonic.
       * @param options An optional `DirectSecp256k1HdWalletOptions` object optionally containing a bip39Password, hdPaths, and prefix.
       */
      static async fromMnemonic(mnemonic, options = {}) {
        const mnemonicChecked = new crypto_1.EnglishMnemonic(mnemonic);
        const seed = await crypto_1.Bip39.mnemonicToSeed(mnemonicChecked, options.bip39Password);
        return new _DirectSecp256k1HdWallet(mnemonicChecked, {
          ...options,
          seed
        });
      }
      /**
       * Generates a new wallet with a BIP39 mnemonic of the given length.
       *
       * @param length The number of words in the mnemonic (12, 15, 18, 21 or 24).
       * @param options An optional `DirectSecp256k1HdWalletOptions` object optionally containing a bip39Password, hdPaths, and prefix.
       */
      static async generate(length = 12, options = {}) {
        const entropyLength = 4 * Math.floor(11 * length / 33);
        const entropy = crypto_1.Random.getBytes(entropyLength);
        const mnemonic = crypto_1.Bip39.encode(entropy);
        return _DirectSecp256k1HdWallet.fromMnemonic(mnemonic.toString(), options);
      }
      /**
       * Restores a wallet from an encrypted serialization.
       *
       * @param password The user provided password used to generate an encryption key via a KDF.
       *                 This is not normalized internally (see "Unicode normalization" to learn more).
       */
      static async deserialize(serialization, password) {
        const root = JSON.parse(serialization);
        if (!(0, utils_1.isNonNullObject)(root))
          throw new Error("Root document is not an object.");
        switch (root.type) {
          case serializationTypeV1:
            return _DirectSecp256k1HdWallet.deserializeTypeV1(serialization, password);
          default:
            throw new Error("Unsupported serialization type");
        }
      }
      /**
       * Restores a wallet from an encrypted serialization.
       *
       * This is an advanced alternative to calling `deserialize(serialization, password)` directly, which allows
       * you to offload the KDF execution to a non-UI thread (e.g. in a WebWorker).
       *
       * The caller is responsible for ensuring the key was derived with the given KDF configuration. This can be
       * done using `extractKdfConfiguration(serialization)` and `executeKdf(password, kdfConfiguration)` from this package.
       */
      static async deserializeWithEncryptionKey(serialization, encryptionKey) {
        const root = JSON.parse(serialization);
        if (!(0, utils_1.isNonNullObject)(root))
          throw new Error("Root document is not an object.");
        const untypedRoot = root;
        switch (untypedRoot.type) {
          case serializationTypeV1: {
            const decryptedBytes = await (0, wallet_1.decrypt)((0, encoding_1.fromBase64)(untypedRoot.data), encryptionKey, untypedRoot.encryption);
            const decryptedDocument = JSON.parse((0, encoding_1.fromUtf8)(decryptedBytes));
            const { mnemonic, accounts } = decryptedDocument;
            (0, utils_1.assert)(typeof mnemonic === "string");
            if (!Array.isArray(accounts))
              throw new Error("Property 'accounts' is not an array");
            if (!accounts.every((account) => isDerivationJson(account))) {
              throw new Error("Account is not in the correct format.");
            }
            const firstPrefix = accounts[0].prefix;
            if (!accounts.every(({ prefix }) => prefix === firstPrefix)) {
              throw new Error("Accounts do not all have the same prefix");
            }
            const hdPaths = accounts.map(({ hdPath }) => (0, crypto_1.stringToPath)(hdPath));
            return _DirectSecp256k1HdWallet.fromMnemonic(mnemonic, {
              hdPaths,
              prefix: firstPrefix
            });
          }
          default:
            throw new Error("Unsupported serialization type");
        }
      }
      static async deserializeTypeV1(serialization, password) {
        const root = JSON.parse(serialization);
        if (!(0, utils_1.isNonNullObject)(root))
          throw new Error("Root document is not an object.");
        const encryptionKey = await (0, wallet_1.executeKdf)(password, root.kdf);
        return _DirectSecp256k1HdWallet.deserializeWithEncryptionKey(serialization, encryptionKey);
      }
      constructor(mnemonic, options) {
        const prefix = options.prefix ?? defaultOptions.prefix;
        const hdPaths = options.hdPaths ?? defaultOptions.hdPaths;
        this.secret = mnemonic;
        this.seed = options.seed;
        this.accounts = hdPaths.map((hdPath) => ({
          hdPath,
          prefix
        }));
      }
      get mnemonic() {
        return this.secret.toString();
      }
      async getAccounts() {
        const accountsWithPrivkeys = await this.getAccountsWithPrivkeys();
        return accountsWithPrivkeys.map(({ algo, pubkey, address }) => ({
          algo,
          pubkey,
          address
        }));
      }
      async signDirect(signerAddress, signDoc) {
        const accounts = await this.getAccountsWithPrivkeys();
        const account = accounts.find(({ address }) => address === signerAddress);
        if (account === void 0) {
          throw new Error(`Address ${signerAddress} not found in wallet`);
        }
        const { privkey, pubkey } = account;
        const signBytes = (0, signing_1.makeSignBytes)(signDoc);
        const hashedMessage = (0, crypto_1.sha256)(signBytes);
        const signature = await crypto_1.Secp256k1.createSignature(hashedMessage, privkey);
        const signatureBytes = new Uint8Array([...signature.r(32), ...signature.s(32)]);
        const stdSignature = (0, amino_1.encodeSecp256k1Signature)(pubkey, signatureBytes);
        return {
          signed: signDoc,
          signature: stdSignature
        };
      }
      /**
       * Generates an encrypted serialization of this wallet.
       *
       * @param password The user provided password used to generate an encryption key via a KDF.
       *                 This is not normalized internally (see "Unicode normalization" to learn more).
       */
      async serialize(password) {
        const kdfConfiguration = basicPasswordHashingOptions;
        const encryptionKey = await (0, wallet_1.executeKdf)(password, kdfConfiguration);
        return this.serializeWithEncryptionKey(encryptionKey, kdfConfiguration);
      }
      /**
       * Generates an encrypted serialization of this wallet.
       *
       * This is an advanced alternative to calling `serialize(password)` directly, which allows you to
       * offload the KDF execution to a non-UI thread (e.g. in a WebWorker).
       *
       * The caller is responsible for ensuring the key was derived with the given KDF options. If this
       * is not the case, the wallet cannot be restored with the original password.
       */
      async serializeWithEncryptionKey(encryptionKey, kdfConfiguration) {
        const dataToEncrypt = {
          mnemonic: this.mnemonic,
          accounts: this.accounts.map(({ hdPath, prefix }) => ({
            hdPath: (0, crypto_1.pathToString)(hdPath),
            prefix
          }))
        };
        const dataToEncryptRaw = (0, encoding_1.toUtf8)(JSON.stringify(dataToEncrypt));
        const encryptionConfiguration = {
          algorithm: wallet_1.supportedAlgorithms.xchacha20poly1305Ietf
        };
        const encryptedData = await (0, wallet_1.encrypt)(dataToEncryptRaw, encryptionKey, encryptionConfiguration);
        const out = {
          type: serializationTypeV1,
          kdf: kdfConfiguration,
          encryption: encryptionConfiguration,
          data: (0, encoding_1.toBase64)(encryptedData)
        };
        return JSON.stringify(out);
      }
      async getKeyPair(hdPath) {
        const { privkey } = crypto_1.Slip10.derivePath(crypto_1.Slip10Curve.Secp256k1, this.seed, hdPath);
        const { pubkey } = await crypto_1.Secp256k1.makeKeypair(privkey);
        return {
          privkey,
          pubkey: crypto_1.Secp256k1.compressPubkey(pubkey)
        };
      }
      async getAccountsWithPrivkeys() {
        return Promise.all(this.accounts.map(async ({ hdPath, prefix }) => {
          const { privkey, pubkey } = await this.getKeyPair(hdPath);
          const address = (0, encoding_1.toBech32)(prefix, (0, amino_1.rawSecp256k1PubkeyToRawAddress)(pubkey));
          return {
            algo: "secp256k1",
            privkey,
            pubkey,
            address
          };
        }));
      }
    };
    exports.DirectSecp256k1HdWallet = DirectSecp256k1HdWallet;
  }
});

// ../../node_modules/.pnpm/@cosmjs+proto-signing@0.34.0/node_modules/@cosmjs/proto-signing/build/directsecp256k1wallet.js
var require_directsecp256k1wallet = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+proto-signing@0.34.0/node_modules/@cosmjs/proto-signing/build/directsecp256k1wallet.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DirectSecp256k1Wallet = void 0;
    var amino_1 = require_build5();
    var crypto_1 = require_build4();
    var encoding_1 = require_build();
    var signing_1 = require_signing2();
    var DirectSecp256k1Wallet = class _DirectSecp256k1Wallet {
      /**
       * Creates a DirectSecp256k1Wallet from the given private key
       *
       * @param privkey The private key.
       * @param prefix The bech32 address prefix (human readable part). Defaults to "cosmos".
       */
      static async fromKey(privkey, prefix = "cosmos") {
        const uncompressed = (await crypto_1.Secp256k1.makeKeypair(privkey)).pubkey;
        return new _DirectSecp256k1Wallet(privkey, crypto_1.Secp256k1.compressPubkey(uncompressed), prefix);
      }
      constructor(privkey, pubkey, prefix) {
        this.privkey = privkey;
        this.pubkey = pubkey;
        this.prefix = prefix;
      }
      get address() {
        return (0, encoding_1.toBech32)(this.prefix, (0, amino_1.rawSecp256k1PubkeyToRawAddress)(this.pubkey));
      }
      async getAccounts() {
        return [
          {
            algo: "secp256k1",
            address: this.address,
            pubkey: this.pubkey
          }
        ];
      }
      async signDirect(address, signDoc) {
        const signBytes = (0, signing_1.makeSignBytes)(signDoc);
        if (address !== this.address) {
          throw new Error(`Address ${address} not found in wallet`);
        }
        const hashedMessage = (0, crypto_1.sha256)(signBytes);
        const signature = await crypto_1.Secp256k1.createSignature(hashedMessage, this.privkey);
        const signatureBytes = new Uint8Array([...signature.r(32), ...signature.s(32)]);
        const stdSignature = (0, amino_1.encodeSecp256k1Signature)(this.pubkey, signatureBytes);
        return {
          signed: signDoc,
          signature: stdSignature
        };
      }
    };
    exports.DirectSecp256k1Wallet = DirectSecp256k1Wallet;
  }
});

// ../../node_modules/.pnpm/@cosmjs+proto-signing@0.34.0/node_modules/@cosmjs/proto-signing/build/paths.js
var require_paths2 = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+proto-signing@0.34.0/node_modules/@cosmjs/proto-signing/build/paths.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.makeCosmoshubPath = makeCosmoshubPath;
    var crypto_1 = require_build4();
    function makeCosmoshubPath(a) {
      return [
        crypto_1.Slip10RawIndex.hardened(44),
        crypto_1.Slip10RawIndex.hardened(118),
        crypto_1.Slip10RawIndex.hardened(0),
        crypto_1.Slip10RawIndex.normal(0),
        crypto_1.Slip10RawIndex.normal(a)
      ];
    }
  }
});

// ../../node_modules/.pnpm/@cosmjs+proto-signing@0.34.0/node_modules/@cosmjs/proto-signing/build/pubkey.js
var require_pubkey = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+proto-signing@0.34.0/node_modules/@cosmjs/proto-signing/build/pubkey.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.encodePubkey = encodePubkey;
    exports.anyToSinglePubkey = anyToSinglePubkey;
    exports.decodePubkey = decodePubkey;
    exports.decodeOptionalPubkey = decodeOptionalPubkey;
    var amino_1 = require_build5();
    var encoding_1 = require_build();
    var math_1 = require_build2();
    var keys_1 = require_keys();
    var keys_2 = require_keys2();
    var keys_3 = require_keys3();
    var any_1 = require_any();
    function encodePubkey(pubkey) {
      if ((0, amino_1.isSecp256k1Pubkey)(pubkey)) {
        const pubkeyProto = keys_3.PubKey.fromPartial({
          key: (0, encoding_1.fromBase64)(pubkey.value)
        });
        return any_1.Any.fromPartial({
          typeUrl: "/cosmos.crypto.secp256k1.PubKey",
          value: Uint8Array.from(keys_3.PubKey.encode(pubkeyProto).finish())
        });
      } else if ((0, amino_1.isEd25519Pubkey)(pubkey)) {
        const pubkeyProto = keys_1.PubKey.fromPartial({
          key: (0, encoding_1.fromBase64)(pubkey.value)
        });
        return any_1.Any.fromPartial({
          typeUrl: "/cosmos.crypto.ed25519.PubKey",
          value: Uint8Array.from(keys_1.PubKey.encode(pubkeyProto).finish())
        });
      } else if ((0, amino_1.isMultisigThresholdPubkey)(pubkey)) {
        const pubkeyProto = keys_2.LegacyAminoPubKey.fromPartial({
          threshold: math_1.Uint53.fromString(pubkey.value.threshold).toNumber(),
          publicKeys: pubkey.value.pubkeys.map(encodePubkey)
        });
        return any_1.Any.fromPartial({
          typeUrl: "/cosmos.crypto.multisig.LegacyAminoPubKey",
          value: Uint8Array.from(keys_2.LegacyAminoPubKey.encode(pubkeyProto).finish())
        });
      } else {
        throw new Error(`Pubkey type ${pubkey.type} not recognized`);
      }
    }
    function anyToSinglePubkey(pubkey) {
      switch (pubkey.typeUrl) {
        case "/cosmos.crypto.secp256k1.PubKey": {
          const { key } = keys_3.PubKey.decode(pubkey.value);
          return (0, amino_1.encodeSecp256k1Pubkey)(key);
        }
        case "/cosmos.crypto.ed25519.PubKey": {
          const { key } = keys_1.PubKey.decode(pubkey.value);
          return (0, amino_1.encodeEd25519Pubkey)(key);
        }
        default:
          throw new Error(`Pubkey type_url ${pubkey.typeUrl} not recognized as single public key type`);
      }
    }
    function decodePubkey(pubkey) {
      switch (pubkey.typeUrl) {
        case "/cosmos.crypto.secp256k1.PubKey":
        case "/cosmos.crypto.ed25519.PubKey": {
          return anyToSinglePubkey(pubkey);
        }
        case "/cosmos.crypto.multisig.LegacyAminoPubKey": {
          const { threshold, publicKeys } = keys_2.LegacyAminoPubKey.decode(pubkey.value);
          const out = {
            type: "tendermint/PubKeyMultisigThreshold",
            value: {
              threshold: threshold.toString(),
              pubkeys: publicKeys.map(anyToSinglePubkey)
            }
          };
          return out;
        }
        default:
          throw new Error(`Pubkey type URL '${pubkey.typeUrl}' not recognized`);
      }
    }
    function decodeOptionalPubkey(pubkey) {
      if (!pubkey)
        return null;
      if (pubkey.typeUrl) {
        if (pubkey.value.length) {
          return decodePubkey(pubkey);
        } else {
          throw new Error(`Pubkey is an Any with type URL '${pubkey.typeUrl}' but an empty value`);
        }
      } else {
        if (pubkey.value.length) {
          throw new Error(`Pubkey is an Any with an empty type URL but a value set`);
        } else {
          return null;
        }
      }
    }
  }
});

// ../../node_modules/.pnpm/@cosmjs+proto-signing@0.34.0/node_modules/@cosmjs/proto-signing/build/registry.js
var require_registry = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+proto-signing@0.34.0/node_modules/@cosmjs/proto-signing/build/registry.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Registry = void 0;
    exports.isTelescopeGeneratedType = isTelescopeGeneratedType;
    exports.isTsProtoGeneratedType = isTsProtoGeneratedType;
    exports.isPbjsGeneratedType = isPbjsGeneratedType;
    exports.isTxBodyEncodeObject = isTxBodyEncodeObject;
    var tx_1 = require_tx2();
    var coin_1 = require_coin();
    var tx_2 = require_tx();
    var any_1 = require_any();
    function isTelescopeGeneratedType(type) {
      const casted = type;
      return typeof casted.fromPartial === "function" && typeof casted.typeUrl == "string";
    }
    function isTsProtoGeneratedType(type) {
      return typeof type.fromPartial === "function";
    }
    function isPbjsGeneratedType(type) {
      return !isTsProtoGeneratedType(type);
    }
    var defaultTypeUrls = {
      cosmosCoin: "/cosmos.base.v1beta1.Coin",
      cosmosMsgSend: "/cosmos.bank.v1beta1.MsgSend",
      cosmosTxBody: "/cosmos.tx.v1beta1.TxBody",
      googleAny: "/google.protobuf.Any"
    };
    function isTxBodyEncodeObject(encodeObject) {
      return encodeObject.typeUrl === "/cosmos.tx.v1beta1.TxBody";
    }
    var Registry = class {
      /**
       * Creates a new Registry for mapping protobuf type identifiers/type URLs to
       * actual implementations. Those implementations are typically generated with ts-proto
       * but we also support protobuf.js as a type generator.
       *
       * If there is no parameter given, a `new Registry()` adds the types `Coin` and `MsgSend`
       * for historic reasons. Those can be overriden by customTypes.
       *
       * There are currently two methods for adding new types:
       * 1. Passing types to the constructor.
       * 2. Using the `register()` method
       */
      constructor(customTypes) {
        const { cosmosCoin, cosmosMsgSend } = defaultTypeUrls;
        this.types = customTypes ? new Map([...customTypes]) : /* @__PURE__ */ new Map([
          [cosmosCoin, coin_1.Coin],
          [cosmosMsgSend, tx_1.MsgSend]
        ]);
      }
      register(typeUrl, type) {
        this.types.set(typeUrl, type);
      }
      /**
       * Looks up a type that was previously added to the registry.
       *
       * The generator information (ts-proto or pbjs) gets lost along the way.
       * If you need to work with the result type in TypeScript, you can use:
       *
       * ```
       * import { assert } from "@cosmjs/utils";
       *
       * const Coin = registry.lookupType("/cosmos.base.v1beta1.Coin");
       * assert(Coin); // Ensures not unset
       * assert(isTsProtoGeneratedType(Coin)); // Ensures this is the type we expect
       *
       * // Coin is typed TsProtoGeneratedType now.
       * ```
       */
      lookupType(typeUrl) {
        return this.types.get(typeUrl);
      }
      lookupTypeWithError(typeUrl) {
        const type = this.lookupType(typeUrl);
        if (!type) {
          throw new Error(`Unregistered type url: ${typeUrl}`);
        }
        return type;
      }
      /**
       * Takes a typeUrl/value pair and encodes the value to protobuf if
       * the given type was previously registered.
       *
       * If the value has to be wrapped in an Any, this needs to be done
       * manually after this call. Or use `encodeAsAny` instead.
       */
      encode(encodeObject) {
        const { value, typeUrl } = encodeObject;
        if (isTxBodyEncodeObject(encodeObject)) {
          return this.encodeTxBody(value);
        }
        const type = this.lookupTypeWithError(typeUrl);
        const instance = isTelescopeGeneratedType(type) || isTsProtoGeneratedType(type) ? type.fromPartial(value) : type.create(value);
        return type.encode(instance).finish();
      }
      /**
       * Takes a typeUrl/value pair and encodes the value to an Any if
       * the given type was previously registered.
       */
      encodeAsAny(encodeObject) {
        const binaryValue = this.encode(encodeObject);
        return any_1.Any.fromPartial({
          typeUrl: encodeObject.typeUrl,
          value: binaryValue
        });
      }
      encodeTxBody(txBodyFields) {
        var _a;
        const wrappedMessages = txBodyFields.messages.map((message) => this.encodeAsAny(message));
        const txBody = tx_2.TxBody.fromPartial({
          ...txBodyFields,
          timeoutHeight: BigInt(((_a = txBodyFields.timeoutHeight) == null ? void 0 : _a.toString()) ?? "0"),
          messages: wrappedMessages
        });
        return tx_2.TxBody.encode(txBody).finish();
      }
      decode({ typeUrl, value }) {
        if (typeUrl === defaultTypeUrls.cosmosTxBody) {
          return this.decodeTxBody(value);
        }
        const type = this.lookupTypeWithError(typeUrl);
        const decoded = type.decode(value);
        Object.entries(decoded).forEach(([key, val]) => {
          if (typeof Buffer !== "undefined" && typeof Buffer.isBuffer !== "undefined" && Buffer.isBuffer(val)) {
            decoded[key] = Uint8Array.from(val);
          }
        });
        return decoded;
      }
      decodeTxBody(txBody) {
        const decodedTxBody = tx_2.TxBody.decode(txBody);
        return {
          ...decodedTxBody,
          messages: decodedTxBody.messages.map(({ typeUrl, value }) => {
            if (!typeUrl) {
              throw new Error("Missing type_url in Any");
            }
            if (!value) {
              throw new Error("Missing value in Any");
            }
            return this.decode({ typeUrl, value });
          })
        };
      }
    };
    exports.Registry = Registry;
  }
});

// ../../node_modules/.pnpm/@cosmjs+proto-signing@0.34.0/node_modules/@cosmjs/proto-signing/build/signer.js
var require_signer = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+proto-signing@0.34.0/node_modules/@cosmjs/proto-signing/build/signer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isOfflineDirectSigner = isOfflineDirectSigner;
    function isOfflineDirectSigner(signer) {
      return signer.signDirect !== void 0;
    }
  }
});

// ../../node_modules/.pnpm/@cosmjs+proto-signing@0.34.0/node_modules/@cosmjs/proto-signing/build/index.js
var require_build6 = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+proto-signing@0.34.0/node_modules/@cosmjs/proto-signing/build/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseCoins = exports.coins = exports.coin = exports.executeKdf = exports.makeSignDoc = exports.makeSignBytes = exports.makeAuthInfoBytes = exports.isOfflineDirectSigner = exports.Registry = exports.isTxBodyEncodeObject = exports.isTsProtoGeneratedType = exports.isPbjsGeneratedType = exports.encodePubkey = exports.decodePubkey = exports.decodeOptionalPubkey = exports.anyToSinglePubkey = exports.makeCosmoshubPath = exports.DirectSecp256k1Wallet = exports.extractKdfConfiguration = exports.DirectSecp256k1HdWallet = exports.decodeTxRaw = void 0;
    var decode_1 = require_decode();
    Object.defineProperty(exports, "decodeTxRaw", { enumerable: true, get: function() {
      return decode_1.decodeTxRaw;
    } });
    var directsecp256k1hdwallet_1 = require_directsecp256k1hdwallet();
    Object.defineProperty(exports, "DirectSecp256k1HdWallet", { enumerable: true, get: function() {
      return directsecp256k1hdwallet_1.DirectSecp256k1HdWallet;
    } });
    Object.defineProperty(exports, "extractKdfConfiguration", { enumerable: true, get: function() {
      return directsecp256k1hdwallet_1.extractKdfConfiguration;
    } });
    var directsecp256k1wallet_1 = require_directsecp256k1wallet();
    Object.defineProperty(exports, "DirectSecp256k1Wallet", { enumerable: true, get: function() {
      return directsecp256k1wallet_1.DirectSecp256k1Wallet;
    } });
    var paths_1 = require_paths2();
    Object.defineProperty(exports, "makeCosmoshubPath", { enumerable: true, get: function() {
      return paths_1.makeCosmoshubPath;
    } });
    var pubkey_1 = require_pubkey();
    Object.defineProperty(exports, "anyToSinglePubkey", { enumerable: true, get: function() {
      return pubkey_1.anyToSinglePubkey;
    } });
    Object.defineProperty(exports, "decodeOptionalPubkey", { enumerable: true, get: function() {
      return pubkey_1.decodeOptionalPubkey;
    } });
    Object.defineProperty(exports, "decodePubkey", { enumerable: true, get: function() {
      return pubkey_1.decodePubkey;
    } });
    Object.defineProperty(exports, "encodePubkey", { enumerable: true, get: function() {
      return pubkey_1.encodePubkey;
    } });
    var registry_1 = require_registry();
    Object.defineProperty(exports, "isPbjsGeneratedType", { enumerable: true, get: function() {
      return registry_1.isPbjsGeneratedType;
    } });
    Object.defineProperty(exports, "isTsProtoGeneratedType", { enumerable: true, get: function() {
      return registry_1.isTsProtoGeneratedType;
    } });
    Object.defineProperty(exports, "isTxBodyEncodeObject", { enumerable: true, get: function() {
      return registry_1.isTxBodyEncodeObject;
    } });
    Object.defineProperty(exports, "Registry", { enumerable: true, get: function() {
      return registry_1.Registry;
    } });
    var signer_1 = require_signer();
    Object.defineProperty(exports, "isOfflineDirectSigner", { enumerable: true, get: function() {
      return signer_1.isOfflineDirectSigner;
    } });
    var signing_1 = require_signing2();
    Object.defineProperty(exports, "makeAuthInfoBytes", { enumerable: true, get: function() {
      return signing_1.makeAuthInfoBytes;
    } });
    Object.defineProperty(exports, "makeSignBytes", { enumerable: true, get: function() {
      return signing_1.makeSignBytes;
    } });
    Object.defineProperty(exports, "makeSignDoc", { enumerable: true, get: function() {
      return signing_1.makeSignDoc;
    } });
    var wallet_1 = require_wallet2();
    Object.defineProperty(exports, "executeKdf", { enumerable: true, get: function() {
      return wallet_1.executeKdf;
    } });
    var amino_1 = require_build5();
    Object.defineProperty(exports, "coin", { enumerable: true, get: function() {
      return amino_1.coin;
    } });
    Object.defineProperty(exports, "coins", { enumerable: true, get: function() {
      return amino_1.coins;
    } });
    Object.defineProperty(exports, "parseCoins", { enumerable: true, get: function() {
      return amino_1.parseCoins;
    } });
  }
});

// ../../node_modules/.pnpm/@cosmjs+stargate@0.34.0/node_modules/@cosmjs/stargate/build/accounts.js
var require_accounts = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+stargate@0.34.0/node_modules/@cosmjs/stargate/build/accounts.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.accountFromAny = accountFromAny;
    var math_1 = require_build2();
    var proto_signing_1 = require_build6();
    var utils_1 = require_build3();
    var auth_1 = require_auth();
    var vesting_1 = require_vesting();
    function uint64FromProto(input) {
      return math_1.Uint64.fromString(input.toString());
    }
    function accountFromBaseAccount(input) {
      const { address, pubKey, accountNumber, sequence } = input;
      const pubkey = (0, proto_signing_1.decodeOptionalPubkey)(pubKey);
      return {
        address,
        pubkey,
        accountNumber: uint64FromProto(accountNumber).toNumber(),
        sequence: uint64FromProto(sequence).toNumber()
      };
    }
    function accountFromAny(input) {
      var _a, _b, _c, _d, _e, _f, _g;
      const { typeUrl, value } = input;
      switch (typeUrl) {
        case "/cosmos.auth.v1beta1.BaseAccount":
          return accountFromBaseAccount(auth_1.BaseAccount.decode(value));
        case "/cosmos.auth.v1beta1.ModuleAccount": {
          const baseAccount = auth_1.ModuleAccount.decode(value).baseAccount;
          (0, utils_1.assert)(baseAccount);
          return accountFromBaseAccount(baseAccount);
        }
        case "/cosmos.vesting.v1beta1.BaseVestingAccount": {
          const baseAccount = (_a = vesting_1.BaseVestingAccount.decode(value)) == null ? void 0 : _a.baseAccount;
          (0, utils_1.assert)(baseAccount);
          return accountFromBaseAccount(baseAccount);
        }
        case "/cosmos.vesting.v1beta1.ContinuousVestingAccount": {
          const baseAccount = (_c = (_b = vesting_1.ContinuousVestingAccount.decode(value)) == null ? void 0 : _b.baseVestingAccount) == null ? void 0 : _c.baseAccount;
          (0, utils_1.assert)(baseAccount);
          return accountFromBaseAccount(baseAccount);
        }
        case "/cosmos.vesting.v1beta1.DelayedVestingAccount": {
          const baseAccount = (_e = (_d = vesting_1.DelayedVestingAccount.decode(value)) == null ? void 0 : _d.baseVestingAccount) == null ? void 0 : _e.baseAccount;
          (0, utils_1.assert)(baseAccount);
          return accountFromBaseAccount(baseAccount);
        }
        case "/cosmos.vesting.v1beta1.PeriodicVestingAccount": {
          const baseAccount = (_g = (_f = vesting_1.PeriodicVestingAccount.decode(value)) == null ? void 0 : _f.baseVestingAccount) == null ? void 0 : _g.baseAccount;
          (0, utils_1.assert)(baseAccount);
          return accountFromBaseAccount(baseAccount);
        }
        default:
          throw new Error(`Unsupported type: '${typeUrl}'`);
      }
    }
  }
});

// ../../node_modules/.pnpm/@cosmjs+stargate@0.34.0/node_modules/@cosmjs/stargate/build/aminotypes.js
var require_aminotypes = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+stargate@0.34.0/node_modules/@cosmjs/stargate/build/aminotypes.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AminoTypes = void 0;
    var AminoTypes = class {
      constructor(types) {
        this.register = types;
      }
      toAmino({ typeUrl, value }) {
        const converter = this.register[typeUrl];
        if (!converter) {
          throw new Error(`Type URL '${typeUrl}' does not exist in the Amino message type register. If you need support for this message type, you can pass in additional entries to the AminoTypes constructor. If you think this message type should be included by default, please open an issue at https://github.com/cosmos/cosmjs/issues.`);
        }
        return {
          type: converter.aminoType,
          value: converter.toAmino(value)
        };
      }
      fromAmino({ type, value }) {
        const matches = Object.entries(this.register).filter(([_typeUrl, { aminoType }]) => aminoType === type);
        switch (matches.length) {
          case 0: {
            throw new Error(`Amino type identifier '${type}' does not exist in the Amino message type register. If you need support for this message type, you can pass in additional entries to the AminoTypes constructor. If you think this message type should be included by default, please open an issue at https://github.com/cosmos/cosmjs/issues.`);
          }
          case 1: {
            const [typeUrl, converter] = matches[0];
            return {
              typeUrl,
              value: converter.fromAmino(value)
            };
          }
          default:
            throw new Error(`Multiple types are registered with Amino type identifier '${type}': '` + matches.map(([key, _value]) => key).sort().join("', '") + "'. Thus fromAmino cannot be performed.");
        }
      }
    };
    exports.AminoTypes = AminoTypes;
  }
});

// ../../node_modules/.pnpm/@cosmjs+stargate@0.34.0/node_modules/@cosmjs/stargate/build/events.js
var require_events = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+stargate@0.34.0/node_modules/@cosmjs/stargate/build/events.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.fromTendermintEvent = fromTendermintEvent;
    var encoding_1 = require_build();
    function fromTendermintEvent(event) {
      return {
        type: event.type,
        attributes: event.attributes.map((attr) => ({
          key: typeof attr.key == "string" ? attr.key : (0, encoding_1.fromUtf8)(attr.key, true),
          value: typeof attr.value == "string" ? attr.value : (0, encoding_1.fromUtf8)(attr.value, true)
        }))
      };
    }
  }
});

// ../../node_modules/.pnpm/@cosmjs+stargate@0.34.0/node_modules/@cosmjs/stargate/build/fee.js
var require_fee = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+stargate@0.34.0/node_modules/@cosmjs/stargate/build/fee.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.GasPrice = void 0;
    exports.calculateFee = calculateFee;
    var math_1 = require_build2();
    var proto_signing_1 = require_build6();
    function checkDenom(denom) {
      if (denom.length < 3 || denom.length > 128) {
        throw new Error("Denom must be between 3 and 128 characters");
      }
    }
    var GasPrice = class _GasPrice {
      constructor(amount, denom) {
        this.amount = amount;
        this.denom = denom;
      }
      /**
       * Parses a gas price formatted as `<amount><denom>`, e.g. `GasPrice.fromString("0.012utoken")`.
       *
       * The denom must match the Cosmos SDK 0.42 pattern (https://github.com/cosmos/cosmos-sdk/blob/v0.42.4/types/coin.go#L599-L601).
       * See `GasPrice` in @cosmjs/stargate for a more generic matcher.
       *
       * Separators are not yet supported.
       */
      static fromString(gasPrice) {
        const matchResult = gasPrice.match(/^([0-9.]+)([a-zA-Z][a-zA-Z0-9/:._-]*)$/);
        if (!matchResult) {
          throw new Error("Invalid gas price string");
        }
        const [_, amount, denom] = matchResult;
        checkDenom(denom);
        const fractionalDigits = 18;
        const decimalAmount = math_1.Decimal.fromUserInput(amount, fractionalDigits);
        return new _GasPrice(decimalAmount, denom);
      }
      /**
       * Returns a string representation of this gas price, e.g. "0.025uatom".
       * This can be used as an input to `GasPrice.fromString`.
       */
      toString() {
        return this.amount.toString() + this.denom;
      }
    };
    exports.GasPrice = GasPrice;
    function calculateFee(gasLimit, gasPrice) {
      const processedGasPrice = typeof gasPrice === "string" ? GasPrice.fromString(gasPrice) : gasPrice;
      const { denom, amount: gasPriceAmount } = processedGasPrice;
      const amount = gasPriceAmount.multiply(new math_1.Uint53(gasLimit)).ceil().toString();
      return {
        amount: (0, proto_signing_1.coins)(amount, denom),
        gas: gasLimit.toString()
      };
    }
  }
});

// ../../node_modules/.pnpm/@cosmjs+stargate@0.34.0/node_modules/@cosmjs/stargate/build/logs.js
var require_logs = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+stargate@0.34.0/node_modules/@cosmjs/stargate/build/logs.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseAttribute = parseAttribute;
    exports.parseEvent = parseEvent;
    exports.parseLog = parseLog;
    exports.parseLogs = parseLogs;
    exports.parseRawLog = parseRawLog;
    exports.findAttribute = findAttribute;
    var utils_1 = require_build3();
    function parseAttribute(input) {
      if (!(0, utils_1.isNonNullObject)(input))
        throw new Error("Attribute must be a non-null object");
      const { key, value } = input;
      if (typeof key !== "string" || !key)
        throw new Error("Attribute's key must be a non-empty string");
      if (typeof value !== "string" && typeof value !== "undefined") {
        throw new Error("Attribute's value must be a string or unset");
      }
      return {
        key,
        value: value || ""
      };
    }
    function parseEvent(input) {
      if (!(0, utils_1.isNonNullObject)(input))
        throw new Error("Event must be a non-null object");
      const { type, attributes } = input;
      if (typeof type !== "string" || type === "") {
        throw new Error(`Event type must be a non-empty string`);
      }
      if (!Array.isArray(attributes))
        throw new Error("Event's attributes must be an array");
      return {
        type,
        attributes: attributes.map(parseAttribute)
      };
    }
    function parseLog(input) {
      if (!(0, utils_1.isNonNullObject)(input))
        throw new Error("Log must be a non-null object");
      const { msg_index, log, events } = input;
      if (typeof msg_index !== "number")
        throw new Error("Log's msg_index must be a number");
      if (typeof log !== "string")
        throw new Error("Log's log must be a string");
      if (!Array.isArray(events))
        throw new Error("Log's events must be an array");
      return {
        msg_index,
        log,
        events: events.map(parseEvent)
      };
    }
    function parseLogs(input) {
      if (!Array.isArray(input))
        throw new Error("Logs must be an array");
      return input.map(parseLog);
    }
    function parseRawLog(input) {
      if (!input)
        return [];
      const logsToParse = JSON.parse(input).map(({ events }, i) => ({
        msg_index: i,
        events,
        log: ""
      }));
      return parseLogs(logsToParse);
    }
    function findAttribute(logs, eventType, attrKey) {
      var _a;
      const firstLogs = logs.find(() => true);
      const out = (_a = firstLogs == null ? void 0 : firstLogs.events.find((event) => event.type === eventType)) == null ? void 0 : _a.attributes.find((attr) => attr.key === attrKey);
      if (!out) {
        throw new Error(`Could not find attribute '${attrKey}' in first event of type '${eventType}' in first log.`);
      }
      return out;
    }
  }
});

// ../../node_modules/.pnpm/@cosmjs+stargate@0.34.0/node_modules/@cosmjs/stargate/build/queryclient/queryclient.js
var require_queryclient = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+stargate@0.34.0/node_modules/@cosmjs/stargate/build/queryclient/queryclient.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.QueryClient = void 0;
    var utils_1 = require_build3();
    var QueryClient = class _QueryClient {
      static withExtensions(cometClient, ...extensionSetups) {
        const client = new _QueryClient(cometClient);
        const extensions = extensionSetups.map((setupExtension) => setupExtension(client));
        for (const extension of extensions) {
          (0, utils_1.assert)((0, utils_1.isNonNullObject)(extension), `Extension must be a non-null object`);
          for (const [moduleKey, moduleValue] of Object.entries(extension)) {
            (0, utils_1.assert)((0, utils_1.isNonNullObject)(moduleValue), `Module must be a non-null object. Found type ${typeof moduleValue} for module "${moduleKey}".`);
            const current = client[moduleKey] || {};
            client[moduleKey] = {
              ...current,
              ...moduleValue
            };
          }
        }
        return client;
      }
      constructor(cometClient) {
        this.cometClient = cometClient;
      }
      /**
       * Performs an ABCI query to Tendermint without requesting a proof.
       *
       * If the `desiredHeight` is set, a particular height is requested. Otherwise
       * the latest height is requested. The response contains the actual height of
       * the query.
       */
      async queryAbci(path, request, desiredHeight) {
        const response = await this.cometClient.abciQuery({
          path,
          data: request,
          prove: false,
          height: desiredHeight
        });
        if (response.code) {
          throw new Error(`Query failed with (${response.code}): ${response.log}`);
        }
        if (!response.height) {
          throw new Error("No query height returned");
        }
        return {
          value: response.value,
          height: response.height
        };
      }
    };
    exports.QueryClient = QueryClient;
  }
});

// ../../node_modules/.pnpm/@cosmjs+stargate@0.34.0/node_modules/@cosmjs/stargate/build/queryclient/utils.js
var require_utils4 = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+stargate@0.34.0/node_modules/@cosmjs/stargate/build/queryclient/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.toAccAddress = toAccAddress;
    exports.createPagination = createPagination;
    exports.createProtobufRpcClient = createProtobufRpcClient;
    exports.longify = longify;
    exports.decodeCosmosSdkDecFromProto = decodeCosmosSdkDecFromProto;
    var encoding_1 = require_build();
    var math_1 = require_build2();
    var pagination_1 = require_pagination();
    function toAccAddress(address) {
      return (0, encoding_1.fromBech32)(address).data;
    }
    function createPagination(paginationKey) {
      return paginationKey ? pagination_1.PageRequest.fromPartial({ key: paginationKey }) : pagination_1.PageRequest.fromPartial({});
    }
    function createProtobufRpcClient(base) {
      return {
        request: async (service, method, data) => {
          const path = `/${service}/${method}`;
          const response = await base.queryAbci(path, data, void 0);
          return response.value;
        }
      };
    }
    function longify(value) {
      const checkedValue = math_1.Uint64.fromString(value.toString());
      return BigInt(checkedValue.toString());
    }
    function decodeCosmosSdkDecFromProto(input) {
      const asString = typeof input === "string" ? input : (0, encoding_1.fromAscii)(input);
      return math_1.Decimal.fromAtomics(asString, 18);
    }
  }
});

// ../../node_modules/.pnpm/@cosmjs+stargate@0.34.0/node_modules/@cosmjs/stargate/build/queryclient/index.js
var require_queryclient2 = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+stargate@0.34.0/node_modules/@cosmjs/stargate/build/queryclient/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.longify = exports.decodeCosmosSdkDecFromProto = exports.createProtobufRpcClient = exports.createPagination = exports.QueryClient = void 0;
    var queryclient_1 = require_queryclient();
    Object.defineProperty(exports, "QueryClient", { enumerable: true, get: function() {
      return queryclient_1.QueryClient;
    } });
    var utils_1 = require_utils4();
    Object.defineProperty(exports, "createPagination", { enumerable: true, get: function() {
      return utils_1.createPagination;
    } });
    Object.defineProperty(exports, "createProtobufRpcClient", { enumerable: true, get: function() {
      return utils_1.createProtobufRpcClient;
    } });
    Object.defineProperty(exports, "decodeCosmosSdkDecFromProto", { enumerable: true, get: function() {
      return utils_1.decodeCosmosSdkDecFromProto;
    } });
    Object.defineProperty(exports, "longify", { enumerable: true, get: function() {
      return utils_1.longify;
    } });
  }
});

// ../../node_modules/.pnpm/@cosmjs+stargate@0.34.0/node_modules/@cosmjs/stargate/build/modules/auth/queries.js
var require_queries = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+stargate@0.34.0/node_modules/@cosmjs/stargate/build/modules/auth/queries.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.setupAuthExtension = setupAuthExtension;
    var query_1 = require_query();
    var queryclient_1 = require_queryclient2();
    function setupAuthExtension(base) {
      const rpc = (0, queryclient_1.createProtobufRpcClient)(base);
      const queryService = new query_1.QueryClientImpl(rpc);
      return {
        auth: {
          account: async (address) => {
            const { account } = await queryService.Account({ address });
            return account ?? null;
          }
        }
      };
    }
  }
});

// ../../node_modules/.pnpm/@cosmjs+stargate@0.34.0/node_modules/@cosmjs/stargate/build/modules/authz/aminomessages.js
var require_aminomessages = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+stargate@0.34.0/node_modules/@cosmjs/stargate/build/modules/authz/aminomessages.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createAuthzAminoConverters = createAuthzAminoConverters;
    function createAuthzAminoConverters() {
      return {
        // For Cosmos SDK < 0.46 the Amino JSON codec was broken on chain and thus inaccessible.
        // Now this can be implemented for 0.46+ chains, see
        // https://github.com/cosmos/cosmjs/issues/1092
        //
        // "/cosmos.authz.v1beta1.MsgGrant": IMPLEMENT ME,
        // "/cosmos.authz.v1beta1.MsgExec": IMPLEMENT ME,
        // "/cosmos.authz.v1beta1.MsgRevoke": IMPLEMENT ME,
      };
    }
  }
});

// ../../node_modules/.pnpm/@cosmjs+stargate@0.34.0/node_modules/@cosmjs/stargate/build/modules/authz/messages.js
var require_messages = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+stargate@0.34.0/node_modules/@cosmjs/stargate/build/modules/authz/messages.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.authzTypes = void 0;
    var tx_1 = require_tx3();
    exports.authzTypes = [
      ["/cosmos.authz.v1beta1.MsgExec", tx_1.MsgExec],
      ["/cosmos.authz.v1beta1.MsgGrant", tx_1.MsgGrant],
      ["/cosmos.authz.v1beta1.MsgRevoke", tx_1.MsgRevoke]
    ];
  }
});

// ../../node_modules/.pnpm/@cosmjs+stargate@0.34.0/node_modules/@cosmjs/stargate/build/modules/authz/queries.js
var require_queries2 = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+stargate@0.34.0/node_modules/@cosmjs/stargate/build/modules/authz/queries.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.setupAuthzExtension = setupAuthzExtension;
    var query_1 = require_query2();
    var queryclient_1 = require_queryclient2();
    function setupAuthzExtension(base) {
      const rpc = (0, queryclient_1.createProtobufRpcClient)(base);
      const queryService = new query_1.QueryClientImpl(rpc);
      return {
        authz: {
          grants: async (granter, grantee, msgTypeUrl, paginationKey) => {
            return await queryService.Grants({
              granter,
              grantee,
              msgTypeUrl,
              pagination: (0, queryclient_1.createPagination)(paginationKey)
            });
          },
          granteeGrants: async (grantee, paginationKey) => {
            return await queryService.GranteeGrants({
              grantee,
              pagination: (0, queryclient_1.createPagination)(paginationKey)
            });
          },
          granterGrants: async (granter, paginationKey) => {
            return await queryService.GranterGrants({
              granter,
              pagination: (0, queryclient_1.createPagination)(paginationKey)
            });
          }
        }
      };
    }
  }
});

// ../../node_modules/.pnpm/@cosmjs+stargate@0.34.0/node_modules/@cosmjs/stargate/build/modules/bank/aminomessages.js
var require_aminomessages2 = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+stargate@0.34.0/node_modules/@cosmjs/stargate/build/modules/bank/aminomessages.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isAminoMsgSend = isAminoMsgSend;
    exports.isAminoMsgMultiSend = isAminoMsgMultiSend;
    exports.createBankAminoConverters = createBankAminoConverters;
    function isAminoMsgSend(msg) {
      return msg.type === "cosmos-sdk/MsgSend";
    }
    function isAminoMsgMultiSend(msg) {
      return msg.type === "cosmos-sdk/MsgMultiSend";
    }
    function createBankAminoConverters() {
      return {
        "/cosmos.bank.v1beta1.MsgSend": {
          aminoType: "cosmos-sdk/MsgSend",
          toAmino: ({ fromAddress, toAddress, amount }) => ({
            from_address: fromAddress,
            to_address: toAddress,
            amount: [...amount]
          }),
          fromAmino: ({ from_address, to_address, amount }) => ({
            fromAddress: from_address,
            toAddress: to_address,
            amount: [...amount]
          })
        },
        "/cosmos.bank.v1beta1.MsgMultiSend": {
          aminoType: "cosmos-sdk/MsgMultiSend",
          toAmino: ({ inputs, outputs }) => ({
            inputs: inputs.map((input) => ({
              address: input.address,
              coins: [...input.coins]
            })),
            outputs: outputs.map((output) => ({
              address: output.address,
              coins: [...output.coins]
            }))
          }),
          fromAmino: ({ inputs, outputs }) => ({
            inputs: inputs.map((input) => ({
              address: input.address,
              coins: [...input.coins]
            })),
            outputs: outputs.map((output) => ({
              address: output.address,
              coins: [...output.coins]
            }))
          })
        }
      };
    }
  }
});

// ../../node_modules/.pnpm/@cosmjs+stargate@0.34.0/node_modules/@cosmjs/stargate/build/modules/bank/messages.js
var require_messages2 = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+stargate@0.34.0/node_modules/@cosmjs/stargate/build/modules/bank/messages.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.bankTypes = void 0;
    exports.isMsgSendEncodeObject = isMsgSendEncodeObject;
    var tx_1 = require_tx2();
    exports.bankTypes = [
      ["/cosmos.bank.v1beta1.MsgMultiSend", tx_1.MsgMultiSend],
      ["/cosmos.bank.v1beta1.MsgSend", tx_1.MsgSend]
    ];
    function isMsgSendEncodeObject(encodeObject) {
      return encodeObject.typeUrl === "/cosmos.bank.v1beta1.MsgSend";
    }
  }
});

// ../../node_modules/.pnpm/@cosmjs+stargate@0.34.0/node_modules/@cosmjs/stargate/build/modules/bank/queries.js
var require_queries3 = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+stargate@0.34.0/node_modules/@cosmjs/stargate/build/modules/bank/queries.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.setupBankExtension = setupBankExtension;
    var utils_1 = require_build3();
    var query_1 = require_query3();
    var queryclient_1 = require_queryclient2();
    function setupBankExtension(base) {
      const rpc = (0, queryclient_1.createProtobufRpcClient)(base);
      const queryService = new query_1.QueryClientImpl(rpc);
      return {
        bank: {
          balance: async (address, denom) => {
            const { balance } = await queryService.Balance({ address, denom });
            (0, utils_1.assert)(balance);
            return balance;
          },
          allBalances: async (address) => {
            const { balances } = await queryService.AllBalances(query_1.QueryAllBalancesRequest.fromPartial({ address }));
            return balances;
          },
          totalSupply: async (paginationKey) => {
            const response = await queryService.TotalSupply({
              pagination: (0, queryclient_1.createPagination)(paginationKey)
            });
            return response;
          },
          supplyOf: async (denom) => {
            const { amount } = await queryService.SupplyOf({ denom });
            (0, utils_1.assert)(amount);
            return amount;
          },
          denomMetadata: async (denom) => {
            const { metadata } = await queryService.DenomMetadata({ denom });
            (0, utils_1.assert)(metadata);
            return metadata;
          },
          denomsMetadata: async () => {
            const { metadatas } = await queryService.DenomsMetadata(query_1.QueryDenomsMetadataRequest.fromPartial({
              pagination: void 0
              // Not implemented
            }));
            return metadatas;
          }
        }
      };
    }
  }
});

// ../../node_modules/.pnpm/@cosmjs+stargate@0.34.0/node_modules/@cosmjs/stargate/build/modules/crisis/aminomessages.js
var require_aminomessages3 = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+stargate@0.34.0/node_modules/@cosmjs/stargate/build/modules/crisis/aminomessages.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isAminoMsgVerifyInvariant = isAminoMsgVerifyInvariant;
    exports.createCrysisAminoConverters = createCrysisAminoConverters;
    function isAminoMsgVerifyInvariant(msg) {
      return msg.type === "cosmos-sdk/MsgVerifyInvariant";
    }
    function createCrysisAminoConverters() {
      throw new Error("Not implemented");
    }
  }
});

// ../../node_modules/.pnpm/@cosmjs+stargate@0.34.0/node_modules/@cosmjs/stargate/build/modules/distribution/aminomessages.js
var require_aminomessages4 = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+stargate@0.34.0/node_modules/@cosmjs/stargate/build/modules/distribution/aminomessages.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isAminoMsgSetWithdrawAddress = isAminoMsgSetWithdrawAddress;
    exports.isAminoMsgWithdrawDelegatorReward = isAminoMsgWithdrawDelegatorReward;
    exports.isAminoMsgWithdrawValidatorCommission = isAminoMsgWithdrawValidatorCommission;
    exports.isAminoMsgFundCommunityPool = isAminoMsgFundCommunityPool;
    exports.createDistributionAminoConverters = createDistributionAminoConverters;
    function isAminoMsgSetWithdrawAddress(msg) {
      return msg.type === "cosmos-sdk/MsgModifyWithdrawAddress";
    }
    function isAminoMsgWithdrawDelegatorReward(msg) {
      return msg.type === "cosmos-sdk/MsgWithdrawDelegationReward";
    }
    function isAminoMsgWithdrawValidatorCommission(msg) {
      return msg.type === "cosmos-sdk/MsgWithdrawValidatorCommission";
    }
    function isAminoMsgFundCommunityPool(msg) {
      return msg.type === "cosmos-sdk/MsgFundCommunityPool";
    }
    function createDistributionAminoConverters() {
      return {
        "/cosmos.distribution.v1beta1.MsgFundCommunityPool": {
          aminoType: "cosmos-sdk/MsgFundCommunityPool",
          toAmino: ({ amount, depositor }) => ({
            amount: [...amount],
            depositor
          }),
          fromAmino: ({ amount, depositor }) => ({
            amount: [...amount],
            depositor
          })
        },
        "/cosmos.distribution.v1beta1.MsgSetWithdrawAddress": {
          aminoType: "cosmos-sdk/MsgModifyWithdrawAddress",
          toAmino: ({ delegatorAddress, withdrawAddress }) => ({
            delegator_address: delegatorAddress,
            withdraw_address: withdrawAddress
          }),
          fromAmino: ({ delegator_address, withdraw_address }) => ({
            delegatorAddress: delegator_address,
            withdrawAddress: withdraw_address
          })
        },
        "/cosmos.distribution.v1beta1.MsgWithdrawDelegatorReward": {
          aminoType: "cosmos-sdk/MsgWithdrawDelegationReward",
          toAmino: ({ delegatorAddress, validatorAddress }) => ({
            delegator_address: delegatorAddress,
            validator_address: validatorAddress
          }),
          fromAmino: ({ delegator_address, validator_address }) => ({
            delegatorAddress: delegator_address,
            validatorAddress: validator_address
          })
        },
        "/cosmos.distribution.v1beta1.MsgWithdrawValidatorCommission": {
          aminoType: "cosmos-sdk/MsgWithdrawValidatorCommission",
          toAmino: ({ validatorAddress }) => ({
            validator_address: validatorAddress
          }),
          fromAmino: ({ validator_address }) => ({
            validatorAddress: validator_address
          })
        }
      };
    }
  }
});

// ../../node_modules/.pnpm/@cosmjs+stargate@0.34.0/node_modules/@cosmjs/stargate/build/modules/distribution/messages.js
var require_messages3 = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+stargate@0.34.0/node_modules/@cosmjs/stargate/build/modules/distribution/messages.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.distributionTypes = void 0;
    exports.isMsgWithdrawDelegatorRewardEncodeObject = isMsgWithdrawDelegatorRewardEncodeObject;
    var tx_1 = require_tx4();
    exports.distributionTypes = [
      ["/cosmos.distribution.v1beta1.MsgFundCommunityPool", tx_1.MsgFundCommunityPool],
      ["/cosmos.distribution.v1beta1.MsgSetWithdrawAddress", tx_1.MsgSetWithdrawAddress],
      ["/cosmos.distribution.v1beta1.MsgWithdrawDelegatorReward", tx_1.MsgWithdrawDelegatorReward],
      ["/cosmos.distribution.v1beta1.MsgWithdrawValidatorCommission", tx_1.MsgWithdrawValidatorCommission]
    ];
    function isMsgWithdrawDelegatorRewardEncodeObject(object) {
      return object.typeUrl === "/cosmos.distribution.v1beta1.MsgWithdrawDelegatorReward";
    }
  }
});

// ../../node_modules/.pnpm/@cosmjs+stargate@0.34.0/node_modules/@cosmjs/stargate/build/modules/distribution/queries.js
var require_queries4 = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+stargate@0.34.0/node_modules/@cosmjs/stargate/build/modules/distribution/queries.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.setupDistributionExtension = setupDistributionExtension;
    var query_1 = require_query4();
    var queryclient_1 = require_queryclient2();
    function setupDistributionExtension(base) {
      const rpc = (0, queryclient_1.createProtobufRpcClient)(base);
      const queryService = new query_1.QueryClientImpl(rpc);
      return {
        distribution: {
          communityPool: async () => {
            const response = await queryService.CommunityPool({});
            return response;
          },
          delegationRewards: async (delegatorAddress, validatorAddress) => {
            const response = await queryService.DelegationRewards({
              delegatorAddress,
              validatorAddress
            });
            return response;
          },
          delegationTotalRewards: async (delegatorAddress) => {
            const response = await queryService.DelegationTotalRewards({
              delegatorAddress
            });
            return response;
          },
          delegatorValidators: async (delegatorAddress) => {
            const response = await queryService.DelegatorValidators({
              delegatorAddress
            });
            return response;
          },
          delegatorWithdrawAddress: async (delegatorAddress) => {
            const response = await queryService.DelegatorWithdrawAddress({
              delegatorAddress
            });
            return response;
          },
          params: async () => {
            const response = await queryService.Params({});
            return response;
          },
          validatorCommission: async (validatorAddress) => {
            const response = await queryService.ValidatorCommission({
              validatorAddress
            });
            return response;
          },
          validatorOutstandingRewards: async (validatorAddress) => {
            const response = await queryService.ValidatorOutstandingRewards({
              validatorAddress
            });
            return response;
          },
          validatorSlashes: async (validatorAddress, startingHeight, endingHeight, paginationKey) => {
            const response = await queryService.ValidatorSlashes({
              validatorAddress,
              startingHeight: BigInt(startingHeight),
              endingHeight: BigInt(endingHeight),
              pagination: (0, queryclient_1.createPagination)(paginationKey)
            });
            return response;
          }
        }
      };
    }
  }
});

// ../../node_modules/.pnpm/@cosmjs+stargate@0.34.0/node_modules/@cosmjs/stargate/build/modules/evidence/aminomessages.js
var require_aminomessages5 = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+stargate@0.34.0/node_modules/@cosmjs/stargate/build/modules/evidence/aminomessages.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isAminoMsgSubmitEvidence = isAminoMsgSubmitEvidence;
    exports.createEvidenceAminoConverters = createEvidenceAminoConverters;
    function isAminoMsgSubmitEvidence(msg) {
      return msg.type === "cosmos-sdk/MsgSubmitEvidence";
    }
    function createEvidenceAminoConverters() {
      throw new Error("Not implemented");
    }
  }
});

// ../../node_modules/.pnpm/@cosmjs+stargate@0.34.0/node_modules/@cosmjs/stargate/build/modules/feegrant/aminomessages.js
var require_aminomessages6 = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+stargate@0.34.0/node_modules/@cosmjs/stargate/build/modules/feegrant/aminomessages.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createFeegrantAminoConverters = createFeegrantAminoConverters;
    function createFeegrantAminoConverters() {
      return {
        // For Cosmos SDK < 0.46 the Amino JSON codec was broken on chain and thus inaccessible.
        // Now this can be implemented for 0.46+ chains, see
        // https://github.com/cosmos/cosmjs/issues/1092
        //
        // "/cosmos.feegrant.v1beta1.MsgGrantAllowance": IMPLEMENT_ME,
        // "/cosmos.feegrant.v1beta1.MsgRevokeAllowance": IMPLEMENT_ME,
      };
    }
  }
});

// ../../node_modules/.pnpm/@cosmjs+stargate@0.34.0/node_modules/@cosmjs/stargate/build/modules/feegrant/messages.js
var require_messages4 = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+stargate@0.34.0/node_modules/@cosmjs/stargate/build/modules/feegrant/messages.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.feegrantTypes = void 0;
    var tx_1 = require_tx5();
    exports.feegrantTypes = [
      ["/cosmos.feegrant.v1beta1.MsgGrantAllowance", tx_1.MsgGrantAllowance],
      ["/cosmos.feegrant.v1beta1.MsgRevokeAllowance", tx_1.MsgRevokeAllowance]
    ];
  }
});

// ../../node_modules/.pnpm/@cosmjs+stargate@0.34.0/node_modules/@cosmjs/stargate/build/modules/feegrant/queries.js
var require_queries5 = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+stargate@0.34.0/node_modules/@cosmjs/stargate/build/modules/feegrant/queries.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.setupFeegrantExtension = setupFeegrantExtension;
    var query_1 = require_query5();
    var queryclient_1 = require_queryclient2();
    function setupFeegrantExtension(base) {
      const rpc = (0, queryclient_1.createProtobufRpcClient)(base);
      const queryService = new query_1.QueryClientImpl(rpc);
      return {
        feegrant: {
          allowance: async (granter, grantee) => {
            const response = await queryService.Allowance({
              granter,
              grantee
            });
            return response;
          },
          allowances: async (grantee, paginationKey) => {
            const response = await queryService.Allowances({
              grantee,
              pagination: (0, queryclient_1.createPagination)(paginationKey)
            });
            return response;
          }
        }
      };
    }
  }
});

// ../../node_modules/.pnpm/@cosmjs+stargate@0.34.0/node_modules/@cosmjs/stargate/build/modules/gov/aminomessages.js
var require_aminomessages7 = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+stargate@0.34.0/node_modules/@cosmjs/stargate/build/modules/gov/aminomessages.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isAminoMsgSubmitProposal = isAminoMsgSubmitProposal;
    exports.isAminoMsgVote = isAminoMsgVote;
    exports.isAminoMsgVoteWeighted = isAminoMsgVoteWeighted;
    exports.isAminoMsgDeposit = isAminoMsgDeposit;
    exports.createGovAminoConverters = createGovAminoConverters;
    var math_1 = require_build2();
    var utils_1 = require_build3();
    var gov_1 = require_gov();
    var any_1 = require_any();
    var queryclient_1 = require_queryclient2();
    function isAminoMsgSubmitProposal(msg) {
      return msg.type === "cosmos-sdk/MsgSubmitProposal";
    }
    function isAminoMsgVote(msg) {
      return msg.type === "cosmos-sdk/MsgVote";
    }
    function isAminoMsgVoteWeighted(msg) {
      return msg.type === "cosmos-sdk/MsgVoteWeighted";
    }
    function isAminoMsgDeposit(msg) {
      return msg.type === "cosmos-sdk/MsgDeposit";
    }
    function createGovAminoConverters() {
      return {
        "/cosmos.gov.v1beta1.MsgDeposit": {
          aminoType: "cosmos-sdk/MsgDeposit",
          toAmino: ({ amount, depositor, proposalId }) => {
            return {
              amount,
              depositor,
              proposal_id: proposalId.toString()
            };
          },
          fromAmino: ({ amount, depositor, proposal_id }) => {
            return {
              amount: Array.from(amount),
              depositor,
              proposalId: BigInt(proposal_id)
            };
          }
        },
        "/cosmos.gov.v1beta1.MsgVote": {
          aminoType: "cosmos-sdk/MsgVote",
          toAmino: ({ option, proposalId, voter }) => {
            return {
              option,
              proposal_id: proposalId.toString(),
              voter
            };
          },
          fromAmino: ({ option, proposal_id, voter }) => {
            return {
              option: (0, gov_1.voteOptionFromJSON)(option),
              proposalId: BigInt(proposal_id),
              voter
            };
          }
        },
        "/cosmos.gov.v1beta1.MsgVoteWeighted": {
          aminoType: "cosmos-sdk/MsgVoteWeighted",
          toAmino: ({ options, proposalId, voter }) => {
            return {
              options: options.map((o) => ({
                option: o.option,
                // Weight is between 0 and 1, so we always have 20 characters when printing all trailing
                // zeros (e.g. "0.700000000000000000" or "1.000000000000000000")
                weight: (0, queryclient_1.decodeCosmosSdkDecFromProto)(o.weight).toString().padEnd(20, "0")
              })),
              proposal_id: proposalId.toString(),
              voter
            };
          },
          fromAmino: ({ options, proposal_id, voter }) => {
            return {
              proposalId: BigInt(proposal_id),
              voter,
              options: options.map((o) => ({
                option: (0, gov_1.voteOptionFromJSON)(o.option),
                weight: math_1.Decimal.fromUserInput(o.weight, 18).atomics
              }))
            };
          }
        },
        "/cosmos.gov.v1beta1.MsgSubmitProposal": {
          aminoType: "cosmos-sdk/MsgSubmitProposal",
          toAmino: ({ initialDeposit, proposer, content }) => {
            (0, utils_1.assertDefinedAndNotNull)(content);
            let proposal;
            switch (content.typeUrl) {
              case "/cosmos.gov.v1beta1.TextProposal": {
                const textProposal = gov_1.TextProposal.decode(content.value);
                proposal = {
                  type: "cosmos-sdk/TextProposal",
                  value: {
                    description: textProposal.description,
                    title: textProposal.title
                  }
                };
                break;
              }
              default:
                throw new Error(`Unsupported proposal type: '${content.typeUrl}'`);
            }
            return {
              initial_deposit: initialDeposit,
              proposer,
              content: proposal
            };
          },
          fromAmino: ({ initial_deposit, proposer, content }) => {
            let any_content;
            switch (content.type) {
              case "cosmos-sdk/TextProposal": {
                const { value } = content;
                (0, utils_1.assert)((0, utils_1.isNonNullObject)(value));
                const { title, description } = value;
                (0, utils_1.assert)(typeof title === "string");
                (0, utils_1.assert)(typeof description === "string");
                any_content = any_1.Any.fromPartial({
                  typeUrl: "/cosmos.gov.v1beta1.TextProposal",
                  value: gov_1.TextProposal.encode(gov_1.TextProposal.fromPartial({
                    title,
                    description
                  })).finish()
                });
                break;
              }
              default:
                throw new Error(`Unsupported proposal type: '${content.type}'`);
            }
            return {
              initialDeposit: Array.from(initial_deposit),
              proposer,
              content: any_content
            };
          }
        }
      };
    }
  }
});

// ../../node_modules/.pnpm/@cosmjs+stargate@0.34.0/node_modules/@cosmjs/stargate/build/modules/gov/messages.js
var require_messages5 = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+stargate@0.34.0/node_modules/@cosmjs/stargate/build/modules/gov/messages.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.govTypes = void 0;
    exports.isMsgDepositEncodeObject = isMsgDepositEncodeObject;
    exports.isMsgSubmitProposalEncodeObject = isMsgSubmitProposalEncodeObject;
    exports.isMsgVoteEncodeObject = isMsgVoteEncodeObject;
    exports.isMsgVoteWeightedEncodeObject = isMsgVoteWeightedEncodeObject;
    var tx_1 = require_tx6();
    var tx_2 = require_tx7();
    exports.govTypes = [
      ["/cosmos.gov.v1.MsgDeposit", tx_1.MsgDeposit],
      ["/cosmos.gov.v1.MsgSubmitProposal", tx_1.MsgSubmitProposal],
      ["/cosmos.gov.v1.MsgUpdateParams", tx_1.MsgUpdateParams],
      ["/cosmos.gov.v1.MsgVote", tx_1.MsgVote],
      ["/cosmos.gov.v1.MsgVoteWeighted", tx_1.MsgVoteWeighted],
      ["/cosmos.gov.v1beta1.MsgDeposit", tx_2.MsgDeposit],
      ["/cosmos.gov.v1beta1.MsgSubmitProposal", tx_2.MsgSubmitProposal],
      ["/cosmos.gov.v1beta1.MsgVote", tx_2.MsgVote],
      ["/cosmos.gov.v1beta1.MsgVoteWeighted", tx_2.MsgVoteWeighted]
    ];
    function isMsgDepositEncodeObject(object) {
      return object.typeUrl === "/cosmos.gov.v1beta1.MsgDeposit";
    }
    function isMsgSubmitProposalEncodeObject(object) {
      return object.typeUrl === "/cosmos.gov.v1beta1.MsgSubmitProposal";
    }
    function isMsgVoteEncodeObject(object) {
      return object.typeUrl === "/cosmos.gov.v1beta1.MsgVote";
    }
    function isMsgVoteWeightedEncodeObject(object) {
      return object.typeUrl === "/cosmos.gov.v1beta1.MsgVoteWeighted";
    }
  }
});

// ../../node_modules/.pnpm/@cosmjs+stargate@0.34.0/node_modules/@cosmjs/stargate/build/modules/gov/queries.js
var require_queries6 = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+stargate@0.34.0/node_modules/@cosmjs/stargate/build/modules/gov/queries.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.setupGovExtension = setupGovExtension;
    var query_1 = require_query6();
    var queryclient_1 = require_queryclient2();
    function setupGovExtension(base) {
      const rpc = (0, queryclient_1.createProtobufRpcClient)(base);
      const queryService = new query_1.QueryClientImpl(rpc);
      return {
        gov: {
          params: async (parametersType) => {
            const response = await queryService.Params({ paramsType: parametersType });
            return response;
          },
          proposals: async (proposalStatus, depositorAddress, voterAddress, paginationKey) => {
            const response = await queryService.Proposals({
              proposalStatus,
              depositor: depositorAddress,
              voter: voterAddress,
              pagination: (0, queryclient_1.createPagination)(paginationKey)
            });
            return response;
          },
          proposal: async (proposalId) => {
            const response = await queryService.Proposal({ proposalId: (0, queryclient_1.longify)(proposalId) });
            return response;
          },
          deposits: async (proposalId, paginationKey) => {
            const response = await queryService.Deposits({
              proposalId: (0, queryclient_1.longify)(proposalId),
              pagination: (0, queryclient_1.createPagination)(paginationKey)
            });
            return response;
          },
          deposit: async (proposalId, depositorAddress) => {
            const response = await queryService.Deposit({
              proposalId: (0, queryclient_1.longify)(proposalId),
              depositor: depositorAddress
            });
            return response;
          },
          tally: async (proposalId) => {
            const response = await queryService.TallyResult({
              proposalId: (0, queryclient_1.longify)(proposalId)
            });
            return response;
          },
          votes: async (proposalId, paginationKey) => {
            const response = await queryService.Votes({
              proposalId: (0, queryclient_1.longify)(proposalId),
              pagination: (0, queryclient_1.createPagination)(paginationKey)
            });
            return response;
          },
          vote: async (proposalId, voterAddress) => {
            const response = await queryService.Vote({
              proposalId: (0, queryclient_1.longify)(proposalId),
              voter: voterAddress
            });
            return response;
          }
        }
      };
    }
  }
});

// ../../node_modules/.pnpm/@cosmjs+stargate@0.34.0/node_modules/@cosmjs/stargate/build/modules/group/aminomessages.js
var require_aminomessages8 = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+stargate@0.34.0/node_modules/@cosmjs/stargate/build/modules/group/aminomessages.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createGroupAminoConverters = createGroupAminoConverters;
    function createGroupAminoConverters() {
      return {};
    }
  }
});

// ../../node_modules/.pnpm/@cosmjs+stargate@0.34.0/node_modules/@cosmjs/stargate/build/modules/group/messages.js
var require_messages6 = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+stargate@0.34.0/node_modules/@cosmjs/stargate/build/modules/group/messages.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.groupTypes = void 0;
    var tx_1 = require_tx8();
    exports.groupTypes = [
      ["/cosmos.group.v1.MsgCreateGroup", tx_1.MsgCreateGroup],
      ["/cosmos.group.v1.MsgCreateGroupPolicy", tx_1.MsgCreateGroupPolicy],
      ["/cosmos.group.v1.MsgCreateGroupWithPolicy", tx_1.MsgCreateGroupWithPolicy],
      ["/cosmos.group.v1.MsgExec", tx_1.MsgExec],
      ["/cosmos.group.v1.MsgLeaveGroup", tx_1.MsgLeaveGroup],
      ["/cosmos.group.v1.MsgSubmitProposal", tx_1.MsgSubmitProposal],
      ["/cosmos.group.v1.MsgUpdateGroupAdmin", tx_1.MsgUpdateGroupAdmin],
      ["/cosmos.group.v1.MsgUpdateGroupMembers", tx_1.MsgUpdateGroupMembers],
      ["/cosmos.group.v1.MsgUpdateGroupMetadata", tx_1.MsgUpdateGroupMetadata],
      ["/cosmos.group.v1.MsgUpdateGroupPolicyAdmin", tx_1.MsgUpdateGroupPolicyAdmin],
      ["/cosmos.group.v1.MsgUpdateGroupPolicyDecisionPolicy", tx_1.MsgUpdateGroupPolicyDecisionPolicy],
      ["/cosmos.group.v1.MsgUpdateGroupPolicyMetadata", tx_1.MsgUpdateGroupPolicyMetadata],
      ["/cosmos.group.v1.MsgVote", tx_1.MsgVote],
      ["/cosmos.group.v1.MsgWithdrawProposal", tx_1.MsgWithdrawProposal]
    ];
  }
});

// ../../node_modules/.pnpm/@cosmjs+stargate@0.34.0/node_modules/@cosmjs/stargate/build/modules/ibc/aminomessages.js
var require_aminomessages9 = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+stargate@0.34.0/node_modules/@cosmjs/stargate/build/modules/ibc/aminomessages.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isAminoMsgTransfer = isAminoMsgTransfer;
    exports.createIbcAminoConverters = createIbcAminoConverters;
    var amino_1 = require_build5();
    var tx_1 = require_tx9();
    function isAminoMsgTransfer(msg) {
      return msg.type === "cosmos-sdk/MsgTransfer";
    }
    function createIbcAminoConverters() {
      return {
        "/ibc.applications.transfer.v1.MsgTransfer": {
          aminoType: "cosmos-sdk/MsgTransfer",
          toAmino: ({ sourcePort, sourceChannel, token, sender, receiver, timeoutHeight, timeoutTimestamp, memo }) => {
            var _a, _b, _c;
            return {
              source_port: sourcePort,
              source_channel: sourceChannel,
              token,
              sender,
              receiver,
              timeout_height: timeoutHeight ? {
                revision_height: (_a = (0, amino_1.omitDefault)(timeoutHeight.revisionHeight)) == null ? void 0 : _a.toString(),
                revision_number: (_b = (0, amino_1.omitDefault)(timeoutHeight.revisionNumber)) == null ? void 0 : _b.toString()
              } : {},
              timeout_timestamp: (_c = (0, amino_1.omitDefault)(timeoutTimestamp)) == null ? void 0 : _c.toString(),
              memo: (0, amino_1.omitDefault)(memo)
            };
          },
          fromAmino: ({ source_port, source_channel, token, sender, receiver, timeout_height, timeout_timestamp, memo }) => tx_1.MsgTransfer.fromPartial({
            sourcePort: source_port,
            sourceChannel: source_channel,
            token,
            sender,
            receiver,
            timeoutHeight: timeout_height ? {
              revisionHeight: BigInt(timeout_height.revision_height || "0"),
              revisionNumber: BigInt(timeout_height.revision_number || "0")
            } : void 0,
            timeoutTimestamp: BigInt(timeout_timestamp || "0"),
            memo: memo ?? ""
          })
        }
      };
    }
  }
});

// ../../node_modules/.pnpm/@cosmjs+stargate@0.34.0/node_modules/@cosmjs/stargate/build/modules/ibc/messages.js
var require_messages7 = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+stargate@0.34.0/node_modules/@cosmjs/stargate/build/modules/ibc/messages.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ibcTypes = void 0;
    exports.isMsgTransferEncodeObject = isMsgTransferEncodeObject;
    var tx_1 = require_tx9();
    var tx_2 = require_tx10();
    var tx_3 = require_tx11();
    var tx_4 = require_tx12();
    exports.ibcTypes = [
      ["/ibc.applications.transfer.v1.MsgTransfer", tx_1.MsgTransfer],
      ["/ibc.core.channel.v1.MsgAcknowledgement", tx_2.MsgAcknowledgement],
      ["/ibc.core.channel.v1.MsgChannelCloseConfirm", tx_2.MsgChannelCloseConfirm],
      ["/ibc.core.channel.v1.MsgChannelCloseInit", tx_2.MsgChannelCloseInit],
      ["/ibc.core.channel.v1.MsgChannelOpenAck", tx_2.MsgChannelOpenAck],
      ["/ibc.core.channel.v1.MsgChannelOpenConfirm", tx_2.MsgChannelOpenConfirm],
      ["/ibc.core.channel.v1.MsgChannelOpenInit", tx_2.MsgChannelOpenInit],
      ["/ibc.core.channel.v1.MsgChannelOpenTry", tx_2.MsgChannelOpenTry],
      ["/ibc.core.channel.v1.MsgRecvPacket", tx_2.MsgRecvPacket],
      ["/ibc.core.channel.v1.MsgTimeout", tx_2.MsgTimeout],
      ["/ibc.core.channel.v1.MsgTimeoutOnClose", tx_2.MsgTimeoutOnClose],
      ["/ibc.core.client.v1.MsgCreateClient", tx_3.MsgCreateClient],
      ["/ibc.core.client.v1.MsgSubmitMisbehaviour", tx_3.MsgSubmitMisbehaviour],
      ["/ibc.core.client.v1.MsgUpdateClient", tx_3.MsgUpdateClient],
      ["/ibc.core.client.v1.MsgUpgradeClient", tx_3.MsgUpgradeClient],
      ["/ibc.core.connection.v1.MsgConnectionOpenAck", tx_4.MsgConnectionOpenAck],
      ["/ibc.core.connection.v1.MsgConnectionOpenConfirm", tx_4.MsgConnectionOpenConfirm],
      ["/ibc.core.connection.v1.MsgConnectionOpenInit", tx_4.MsgConnectionOpenInit],
      ["/ibc.core.connection.v1.MsgConnectionOpenTry", tx_4.MsgConnectionOpenTry]
    ];
    function isMsgTransferEncodeObject(object) {
      return object.typeUrl === "/ibc.applications.transfer.v1.MsgTransfer";
    }
  }
});

// ../../node_modules/.pnpm/@cosmjs+stargate@0.34.0/node_modules/@cosmjs/stargate/build/modules/ibc/queries.js
var require_queries7 = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+stargate@0.34.0/node_modules/@cosmjs/stargate/build/modules/ibc/queries.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.setupIbcExtension = setupIbcExtension;
    var query_1 = require_query7();
    var query_2 = require_query8();
    var query_3 = require_query9();
    var query_4 = require_query10();
    var tendermint_1 = require_tendermint();
    var queryclient_1 = require_queryclient2();
    function decodeTendermintClientStateAny(clientState) {
      if ((clientState == null ? void 0 : clientState.typeUrl) !== "/ibc.lightclients.tendermint.v1.ClientState") {
        throw new Error(`Unexpected client state type: ${clientState == null ? void 0 : clientState.typeUrl}`);
      }
      return tendermint_1.ClientState.decode(clientState.value);
    }
    function decodeTendermintConsensusStateAny(clientState) {
      if ((clientState == null ? void 0 : clientState.typeUrl) !== "/ibc.lightclients.tendermint.v1.ConsensusState") {
        throw new Error(`Unexpected client state type: ${clientState == null ? void 0 : clientState.typeUrl}`);
      }
      return tendermint_1.ConsensusState.decode(clientState.value);
    }
    function setupIbcExtension(base) {
      const rpc = (0, queryclient_1.createProtobufRpcClient)(base);
      const channelQueryService = new query_2.QueryClientImpl(rpc);
      const clientQueryService = new query_3.QueryClientImpl(rpc);
      const connectionQueryService = new query_4.QueryClientImpl(rpc);
      const transferQueryService = new query_1.QueryClientImpl(rpc);
      return {
        ibc: {
          channel: {
            channel: async (portId, channelId) => channelQueryService.Channel({
              portId,
              channelId
            }),
            channels: async (paginationKey) => channelQueryService.Channels({
              pagination: (0, queryclient_1.createPagination)(paginationKey)
            }),
            allChannels: async () => {
              var _a;
              const channels = [];
              let response;
              let key;
              do {
                response = await channelQueryService.Channels({
                  pagination: (0, queryclient_1.createPagination)(key)
                });
                channels.push(...response.channels);
                key = (_a = response.pagination) == null ? void 0 : _a.nextKey;
              } while (key && key.length);
              return query_2.QueryChannelsResponse.fromPartial({
                channels,
                height: response.height
              });
            },
            connectionChannels: async (connection, paginationKey) => channelQueryService.ConnectionChannels({
              connection,
              pagination: (0, queryclient_1.createPagination)(paginationKey)
            }),
            allConnectionChannels: async (connection) => {
              var _a;
              const channels = [];
              let response;
              let key;
              do {
                response = await channelQueryService.ConnectionChannels({
                  connection,
                  pagination: (0, queryclient_1.createPagination)(key)
                });
                channels.push(...response.channels);
                key = (_a = response.pagination) == null ? void 0 : _a.nextKey;
              } while (key && key.length);
              return query_2.QueryConnectionChannelsResponse.fromPartial({
                channels,
                height: response.height
              });
            },
            clientState: async (portId, channelId) => channelQueryService.ChannelClientState({
              portId,
              channelId
            }),
            consensusState: async (portId, channelId, revisionNumber, revisionHeight) => channelQueryService.ChannelConsensusState({
              portId,
              channelId,
              revisionNumber: BigInt(revisionNumber),
              revisionHeight: BigInt(revisionHeight)
            }),
            packetCommitment: async (portId, channelId, sequence) => channelQueryService.PacketCommitment({
              portId,
              channelId,
              sequence: (0, queryclient_1.longify)(sequence)
            }),
            packetCommitments: async (portId, channelId, paginationKey) => channelQueryService.PacketCommitments({
              channelId,
              portId,
              pagination: (0, queryclient_1.createPagination)(paginationKey)
            }),
            allPacketCommitments: async (portId, channelId) => {
              var _a;
              const commitments = [];
              let response;
              let key;
              do {
                response = await channelQueryService.PacketCommitments({
                  channelId,
                  portId,
                  pagination: (0, queryclient_1.createPagination)(key)
                });
                commitments.push(...response.commitments);
                key = (_a = response.pagination) == null ? void 0 : _a.nextKey;
              } while (key && key.length);
              return query_2.QueryPacketCommitmentsResponse.fromPartial({
                commitments,
                height: response.height
              });
            },
            packetReceipt: async (portId, channelId, sequence) => channelQueryService.PacketReceipt({
              portId,
              channelId,
              sequence: (0, queryclient_1.longify)(sequence)
            }),
            packetAcknowledgement: async (portId, channelId, sequence) => channelQueryService.PacketAcknowledgement({
              portId,
              channelId,
              sequence: (0, queryclient_1.longify)(sequence)
            }),
            packetAcknowledgements: async (portId, channelId, paginationKey) => {
              const request = query_2.QueryPacketAcknowledgementsRequest.fromPartial({
                portId,
                channelId,
                pagination: (0, queryclient_1.createPagination)(paginationKey)
              });
              return channelQueryService.PacketAcknowledgements(request);
            },
            allPacketAcknowledgements: async (portId, channelId) => {
              var _a;
              const acknowledgements = [];
              let response;
              let key;
              do {
                const request = query_2.QueryPacketAcknowledgementsRequest.fromPartial({
                  channelId,
                  portId,
                  pagination: (0, queryclient_1.createPagination)(key)
                });
                response = await channelQueryService.PacketAcknowledgements(request);
                acknowledgements.push(...response.acknowledgements);
                key = (_a = response.pagination) == null ? void 0 : _a.nextKey;
              } while (key && key.length);
              return query_2.QueryPacketAcknowledgementsResponse.fromPartial({
                acknowledgements,
                height: response.height
              });
            },
            unreceivedPackets: async (portId, channelId, packetCommitmentSequences) => channelQueryService.UnreceivedPackets({
              portId,
              channelId,
              packetCommitmentSequences: packetCommitmentSequences.map((s) => BigInt(s))
            }),
            unreceivedAcks: async (portId, channelId, packetAckSequences) => channelQueryService.UnreceivedAcks({
              portId,
              channelId,
              packetAckSequences: packetAckSequences.map((s) => BigInt(s))
            }),
            nextSequenceReceive: async (portId, channelId) => channelQueryService.NextSequenceReceive({
              portId,
              channelId
            })
          },
          client: {
            state: async (clientId) => clientQueryService.ClientState({ clientId }),
            states: async (paginationKey) => clientQueryService.ClientStates({
              pagination: (0, queryclient_1.createPagination)(paginationKey)
            }),
            allStates: async () => {
              var _a;
              const clientStates = [];
              let response;
              let key;
              do {
                response = await clientQueryService.ClientStates({
                  pagination: (0, queryclient_1.createPagination)(key)
                });
                clientStates.push(...response.clientStates);
                key = (_a = response.pagination) == null ? void 0 : _a.nextKey;
              } while (key && key.length);
              return query_3.QueryClientStatesResponse.fromPartial({
                clientStates
              });
            },
            consensusState: async (clientId, consensusHeight) => clientQueryService.ConsensusState(query_3.QueryConsensusStateRequest.fromPartial({
              clientId,
              revisionHeight: consensusHeight !== void 0 ? BigInt(consensusHeight) : void 0,
              latestHeight: consensusHeight === void 0
            })),
            consensusStates: async (clientId, paginationKey) => clientQueryService.ConsensusStates({
              clientId,
              pagination: (0, queryclient_1.createPagination)(paginationKey)
            }),
            allConsensusStates: async (clientId) => {
              var _a;
              const consensusStates = [];
              let response;
              let key;
              do {
                response = await clientQueryService.ConsensusStates({
                  clientId,
                  pagination: (0, queryclient_1.createPagination)(key)
                });
                consensusStates.push(...response.consensusStates);
                key = (_a = response.pagination) == null ? void 0 : _a.nextKey;
              } while (key && key.length);
              return query_3.QueryConsensusStatesResponse.fromPartial({
                consensusStates
              });
            },
            params: async () => clientQueryService.ClientParams({}),
            stateTm: async (clientId) => {
              const response = await clientQueryService.ClientState({ clientId });
              return decodeTendermintClientStateAny(response.clientState);
            },
            statesTm: async (paginationKey) => {
              const { clientStates } = await clientQueryService.ClientStates({
                pagination: (0, queryclient_1.createPagination)(paginationKey)
              });
              return clientStates.map(({ clientState }) => decodeTendermintClientStateAny(clientState));
            },
            allStatesTm: async () => {
              var _a;
              const clientStates = [];
              let response;
              let key;
              do {
                response = await clientQueryService.ClientStates({
                  pagination: (0, queryclient_1.createPagination)(key)
                });
                clientStates.push(...response.clientStates);
                key = (_a = response.pagination) == null ? void 0 : _a.nextKey;
              } while (key && key.length);
              return clientStates.map(({ clientState }) => decodeTendermintClientStateAny(clientState));
            },
            consensusStateTm: async (clientId, consensusHeight) => {
              const response = await clientQueryService.ConsensusState(query_3.QueryConsensusStateRequest.fromPartial({
                clientId,
                revisionHeight: consensusHeight == null ? void 0 : consensusHeight.revisionHeight,
                revisionNumber: consensusHeight == null ? void 0 : consensusHeight.revisionNumber,
                latestHeight: consensusHeight === void 0
              }));
              return decodeTendermintConsensusStateAny(response.consensusState);
            }
          },
          connection: {
            connection: async (connectionId) => connectionQueryService.Connection({
              connectionId
            }),
            connections: async (paginationKey) => connectionQueryService.Connections({
              pagination: (0, queryclient_1.createPagination)(paginationKey)
            }),
            allConnections: async () => {
              var _a;
              const connections = [];
              let response;
              let key;
              do {
                response = await connectionQueryService.Connections({
                  pagination: (0, queryclient_1.createPagination)(key)
                });
                connections.push(...response.connections);
                key = (_a = response.pagination) == null ? void 0 : _a.nextKey;
              } while (key && key.length);
              return query_4.QueryConnectionsResponse.fromPartial({
                connections,
                height: response.height
              });
            },
            clientConnections: async (clientId) => connectionQueryService.ClientConnections({
              clientId
            }),
            clientState: async (connectionId) => connectionQueryService.ConnectionClientState({
              connectionId
            }),
            consensusState: async (connectionId, revisionHeight) => connectionQueryService.ConnectionConsensusState(query_4.QueryConnectionConsensusStateRequest.fromPartial({
              connectionId,
              revisionHeight: BigInt(revisionHeight)
            }))
          },
          transfer: {
            denomTrace: async (hash) => transferQueryService.DenomTrace({ hash }),
            denomTraces: async (paginationKey) => transferQueryService.DenomTraces({
              pagination: (0, queryclient_1.createPagination)(paginationKey)
            }),
            allDenomTraces: async () => {
              var _a;
              const denomTraces = [];
              let response;
              let key;
              do {
                response = await transferQueryService.DenomTraces({
                  pagination: (0, queryclient_1.createPagination)(key)
                });
                denomTraces.push(...response.denomTraces);
                key = (_a = response.pagination) == null ? void 0 : _a.nextKey;
              } while (key && key.length);
              return query_1.QueryDenomTracesResponse.fromPartial({
                denomTraces
              });
            },
            params: async () => transferQueryService.Params({})
          }
        }
      };
    }
  }
});

// ../../node_modules/.pnpm/@cosmjs+stargate@0.34.0/node_modules/@cosmjs/stargate/build/modules/mint/queries.js
var require_queries8 = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+stargate@0.34.0/node_modules/@cosmjs/stargate/build/modules/mint/queries.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.setupMintExtension = setupMintExtension;
    var utils_1 = require_build3();
    var query_1 = require_query11();
    var queryclient_1 = require_queryclient2();
    function setupMintExtension(base) {
      const rpc = (0, queryclient_1.createProtobufRpcClient)(base);
      const queryService = new query_1.QueryClientImpl(rpc);
      return {
        mint: {
          params: async () => {
            const { params } = await queryService.Params({});
            (0, utils_1.assert)(params);
            return {
              blocksPerYear: params.blocksPerYear,
              goalBonded: (0, queryclient_1.decodeCosmosSdkDecFromProto)(params.goalBonded),
              inflationMin: (0, queryclient_1.decodeCosmosSdkDecFromProto)(params.inflationMin),
              inflationMax: (0, queryclient_1.decodeCosmosSdkDecFromProto)(params.inflationMax),
              inflationRateChange: (0, queryclient_1.decodeCosmosSdkDecFromProto)(params.inflationRateChange),
              mintDenom: params.mintDenom
            };
          },
          inflation: async () => {
            const { inflation } = await queryService.Inflation({});
            return (0, queryclient_1.decodeCosmosSdkDecFromProto)(inflation);
          },
          annualProvisions: async () => {
            const { annualProvisions } = await queryService.AnnualProvisions({});
            return (0, queryclient_1.decodeCosmosSdkDecFromProto)(annualProvisions);
          }
        }
      };
    }
  }
});

// ../../node_modules/.pnpm/@cosmjs+stargate@0.34.0/node_modules/@cosmjs/stargate/build/modules/slashing/aminomessages.js
var require_aminomessages10 = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+stargate@0.34.0/node_modules/@cosmjs/stargate/build/modules/slashing/aminomessages.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isAminoMsgUnjail = isAminoMsgUnjail;
    exports.createSlashingAminoConverters = createSlashingAminoConverters;
    function isAminoMsgUnjail(msg) {
      return msg.type === "cosmos-sdk/MsgUnjail";
    }
    function createSlashingAminoConverters() {
      throw new Error("Not implemented");
    }
  }
});

// ../../node_modules/.pnpm/@cosmjs+stargate@0.34.0/node_modules/@cosmjs/stargate/build/modules/slashing/queries.js
var require_queries9 = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+stargate@0.34.0/node_modules/@cosmjs/stargate/build/modules/slashing/queries.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.setupSlashingExtension = setupSlashingExtension;
    var query_1 = require_query12();
    var queryclient_1 = require_queryclient2();
    function setupSlashingExtension(base) {
      const rpc = (0, queryclient_1.createProtobufRpcClient)(base);
      const queryService = new query_1.QueryClientImpl(rpc);
      return {
        slashing: {
          signingInfo: async (consAddress) => {
            const response = await queryService.SigningInfo({
              consAddress
            });
            return response;
          },
          signingInfos: async (paginationKey) => {
            const response = await queryService.SigningInfos({
              pagination: (0, queryclient_1.createPagination)(paginationKey)
            });
            return response;
          },
          params: async () => {
            const response = await queryService.Params({});
            return response;
          }
        }
      };
    }
  }
});

// ../../node_modules/.pnpm/@cosmjs+stargate@0.34.0/node_modules/@cosmjs/stargate/build/modules/staking/aminomessages.js
var require_aminomessages11 = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+stargate@0.34.0/node_modules/@cosmjs/stargate/build/modules/staking/aminomessages.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.protoDecimalToJson = protoDecimalToJson;
    exports.isAminoMsgCreateValidator = isAminoMsgCreateValidator;
    exports.isAminoMsgEditValidator = isAminoMsgEditValidator;
    exports.isAminoMsgDelegate = isAminoMsgDelegate;
    exports.isAminoMsgBeginRedelegate = isAminoMsgBeginRedelegate;
    exports.isAminoMsgUndelegate = isAminoMsgUndelegate;
    exports.isAminoMsgCancelUnbondingDelegation = isAminoMsgCancelUnbondingDelegation;
    exports.createStakingAminoConverters = createStakingAminoConverters;
    var math_1 = require_build2();
    var proto_signing_1 = require_build6();
    var utils_1 = require_build3();
    function protoDecimalToJson(decimal) {
      const parsed = math_1.Decimal.fromAtomics(decimal, 18);
      const [whole, fractional] = parsed.toString().split(".");
      return `${whole}.${(fractional ?? "").padEnd(18, "0")}`;
    }
    function jsonDecimalToProto(decimal) {
      const parsed = math_1.Decimal.fromUserInput(decimal, 18);
      return parsed.atomics;
    }
    function isAminoMsgCreateValidator(msg) {
      return msg.type === "cosmos-sdk/MsgCreateValidator";
    }
    function isAminoMsgEditValidator(msg) {
      return msg.type === "cosmos-sdk/MsgEditValidator";
    }
    function isAminoMsgDelegate(msg) {
      return msg.type === "cosmos-sdk/MsgDelegate";
    }
    function isAminoMsgBeginRedelegate(msg) {
      return msg.type === "cosmos-sdk/MsgBeginRedelegate";
    }
    function isAminoMsgUndelegate(msg) {
      return msg.type === "cosmos-sdk/MsgUndelegate";
    }
    function isAminoMsgCancelUnbondingDelegation(msg) {
      return msg.type === "cosmos-sdk/MsgCancelUnbondingDelegation";
    }
    function createStakingAminoConverters() {
      return {
        "/cosmos.staking.v1beta1.MsgBeginRedelegate": {
          aminoType: "cosmos-sdk/MsgBeginRedelegate",
          toAmino: ({ delegatorAddress, validatorSrcAddress, validatorDstAddress, amount }) => {
            (0, utils_1.assertDefinedAndNotNull)(amount, "missing amount");
            return {
              delegator_address: delegatorAddress,
              validator_src_address: validatorSrcAddress,
              validator_dst_address: validatorDstAddress,
              amount
            };
          },
          fromAmino: ({ delegator_address, validator_src_address, validator_dst_address, amount }) => ({
            delegatorAddress: delegator_address,
            validatorSrcAddress: validator_src_address,
            validatorDstAddress: validator_dst_address,
            amount
          })
        },
        "/cosmos.staking.v1beta1.MsgCreateValidator": {
          aminoType: "cosmos-sdk/MsgCreateValidator",
          toAmino: ({ description, commission, minSelfDelegation, delegatorAddress, validatorAddress, pubkey, value }) => {
            (0, utils_1.assertDefinedAndNotNull)(description, "missing description");
            (0, utils_1.assertDefinedAndNotNull)(commission, "missing commission");
            (0, utils_1.assertDefinedAndNotNull)(pubkey, "missing pubkey");
            (0, utils_1.assertDefinedAndNotNull)(value, "missing value");
            return {
              description: {
                moniker: description.moniker,
                identity: description.identity,
                website: description.website,
                security_contact: description.securityContact,
                details: description.details
              },
              commission: {
                rate: protoDecimalToJson(commission.rate),
                max_rate: protoDecimalToJson(commission.maxRate),
                max_change_rate: protoDecimalToJson(commission.maxChangeRate)
              },
              min_self_delegation: minSelfDelegation,
              delegator_address: delegatorAddress,
              validator_address: validatorAddress,
              pubkey: (0, proto_signing_1.decodePubkey)(pubkey),
              value
            };
          },
          fromAmino: ({ description, commission, min_self_delegation, delegator_address, validator_address, pubkey, value }) => {
            return {
              description: {
                moniker: description.moniker,
                identity: description.identity,
                website: description.website,
                securityContact: description.security_contact,
                details: description.details
              },
              commission: {
                rate: jsonDecimalToProto(commission.rate),
                maxRate: jsonDecimalToProto(commission.max_rate),
                maxChangeRate: jsonDecimalToProto(commission.max_change_rate)
              },
              minSelfDelegation: min_self_delegation,
              delegatorAddress: delegator_address,
              validatorAddress: validator_address,
              pubkey: (0, proto_signing_1.encodePubkey)(pubkey),
              value
            };
          }
        },
        "/cosmos.staking.v1beta1.MsgDelegate": {
          aminoType: "cosmos-sdk/MsgDelegate",
          toAmino: ({ delegatorAddress, validatorAddress, amount }) => {
            (0, utils_1.assertDefinedAndNotNull)(amount, "missing amount");
            return {
              delegator_address: delegatorAddress,
              validator_address: validatorAddress,
              amount
            };
          },
          fromAmino: ({ delegator_address, validator_address, amount }) => ({
            delegatorAddress: delegator_address,
            validatorAddress: validator_address,
            amount
          })
        },
        "/cosmos.staking.v1beta1.MsgEditValidator": {
          aminoType: "cosmos-sdk/MsgEditValidator",
          toAmino: ({ description, commissionRate, minSelfDelegation, validatorAddress }) => {
            (0, utils_1.assertDefinedAndNotNull)(description, "missing description");
            return {
              description: {
                moniker: description.moniker,
                identity: description.identity,
                website: description.website,
                security_contact: description.securityContact,
                details: description.details
              },
              // empty string in the protobuf document means "do not change"
              commission_rate: commissionRate ? protoDecimalToJson(commissionRate) : void 0,
              // empty string in the protobuf document means "do not change"
              min_self_delegation: minSelfDelegation ? minSelfDelegation : void 0,
              validator_address: validatorAddress
            };
          },
          fromAmino: ({ description, commission_rate, min_self_delegation, validator_address }) => ({
            description: {
              moniker: description.moniker,
              identity: description.identity,
              website: description.website,
              securityContact: description.security_contact,
              details: description.details
            },
            // empty string in the protobuf document means "do not change"
            commissionRate: commission_rate ? jsonDecimalToProto(commission_rate) : "",
            // empty string in the protobuf document means "do not change"
            minSelfDelegation: min_self_delegation ?? "",
            validatorAddress: validator_address
          })
        },
        "/cosmos.staking.v1beta1.MsgUndelegate": {
          aminoType: "cosmos-sdk/MsgUndelegate",
          toAmino: ({ delegatorAddress, validatorAddress, amount }) => {
            (0, utils_1.assertDefinedAndNotNull)(amount, "missing amount");
            return {
              delegator_address: delegatorAddress,
              validator_address: validatorAddress,
              amount
            };
          },
          fromAmino: ({ delegator_address, validator_address, amount }) => ({
            delegatorAddress: delegator_address,
            validatorAddress: validator_address,
            amount
          })
        },
        "/cosmos.staking.v1beta1.MsgCancelUnbondingDelegation": {
          aminoType: "cosmos-sdk/MsgCancelUnbondingDelegation",
          toAmino: ({ delegatorAddress, validatorAddress, amount, creationHeight }) => {
            (0, utils_1.assertDefinedAndNotNull)(amount, "missing amount");
            return {
              delegator_address: delegatorAddress,
              validator_address: validatorAddress,
              amount,
              creation_height: creationHeight.toString()
            };
          },
          fromAmino: ({ delegator_address, validator_address, amount, creation_height }) => ({
            delegatorAddress: delegator_address,
            validatorAddress: validator_address,
            amount,
            creationHeight: BigInt(creation_height)
          })
        }
      };
    }
  }
});

// ../../node_modules/.pnpm/@cosmjs+stargate@0.34.0/node_modules/@cosmjs/stargate/build/modules/staking/messages.js
var require_messages8 = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+stargate@0.34.0/node_modules/@cosmjs/stargate/build/modules/staking/messages.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.stakingTypes = void 0;
    exports.isMsgBeginRedelegateEncodeObject = isMsgBeginRedelegateEncodeObject;
    exports.isMsgCreateValidatorEncodeObject = isMsgCreateValidatorEncodeObject;
    exports.isMsgDelegateEncodeObject = isMsgDelegateEncodeObject;
    exports.isMsgEditValidatorEncodeObject = isMsgEditValidatorEncodeObject;
    exports.isMsgUndelegateEncodeObject = isMsgUndelegateEncodeObject;
    exports.isMsgCancelUnbondingDelegationEncodeObject = isMsgCancelUnbondingDelegationEncodeObject;
    var tx_1 = require_tx13();
    exports.stakingTypes = [
      ["/cosmos.staking.v1beta1.MsgBeginRedelegate", tx_1.MsgBeginRedelegate],
      ["/cosmos.staking.v1beta1.MsgCreateValidator", tx_1.MsgCreateValidator],
      ["/cosmos.staking.v1beta1.MsgDelegate", tx_1.MsgDelegate],
      ["/cosmos.staking.v1beta1.MsgEditValidator", tx_1.MsgEditValidator],
      ["/cosmos.staking.v1beta1.MsgUndelegate", tx_1.MsgUndelegate],
      ["/cosmos.staking.v1beta1.MsgCancelUnbondingDelegation", tx_1.MsgCancelUnbondingDelegation]
    ];
    function isMsgBeginRedelegateEncodeObject(o) {
      return o.typeUrl === "/cosmos.staking.v1beta1.MsgBeginRedelegate";
    }
    function isMsgCreateValidatorEncodeObject(o) {
      return o.typeUrl === "/cosmos.staking.v1beta1.MsgCreateValidator";
    }
    function isMsgDelegateEncodeObject(object) {
      return object.typeUrl === "/cosmos.staking.v1beta1.MsgDelegate";
    }
    function isMsgEditValidatorEncodeObject(o) {
      return o.typeUrl === "/cosmos.staking.v1beta1.MsgEditValidator";
    }
    function isMsgUndelegateEncodeObject(object) {
      return object.typeUrl === "/cosmos.staking.v1beta1.MsgUndelegate";
    }
    function isMsgCancelUnbondingDelegationEncodeObject(object) {
      return object.typeUrl === "/cosmos.staking.v1beta1.MsgCancelUnbondingDelegation";
    }
  }
});

// ../../node_modules/.pnpm/@cosmjs+stargate@0.34.0/node_modules/@cosmjs/stargate/build/modules/staking/queries.js
var require_queries10 = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+stargate@0.34.0/node_modules/@cosmjs/stargate/build/modules/staking/queries.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.setupStakingExtension = setupStakingExtension;
    var query_1 = require_query13();
    var queryclient_1 = require_queryclient2();
    function setupStakingExtension(base) {
      const rpc = (0, queryclient_1.createProtobufRpcClient)(base);
      const queryService = new query_1.QueryClientImpl(rpc);
      return {
        staking: {
          delegation: async (delegatorAddress, validatorAddress) => {
            const response = await queryService.Delegation({
              delegatorAddr: delegatorAddress,
              validatorAddr: validatorAddress
            });
            return response;
          },
          delegatorDelegations: async (delegatorAddress, paginationKey) => {
            const response = await queryService.DelegatorDelegations({
              delegatorAddr: delegatorAddress,
              pagination: (0, queryclient_1.createPagination)(paginationKey)
            });
            return response;
          },
          delegatorUnbondingDelegations: async (delegatorAddress, paginationKey) => {
            const response = await queryService.DelegatorUnbondingDelegations({
              delegatorAddr: delegatorAddress,
              pagination: (0, queryclient_1.createPagination)(paginationKey)
            });
            return response;
          },
          delegatorValidator: async (delegatorAddress, validatorAddress) => {
            const response = await queryService.DelegatorValidator({
              delegatorAddr: delegatorAddress,
              validatorAddr: validatorAddress
            });
            return response;
          },
          delegatorValidators: async (delegatorAddress, paginationKey) => {
            const response = await queryService.DelegatorValidators({
              delegatorAddr: delegatorAddress,
              pagination: (0, queryclient_1.createPagination)(paginationKey)
            });
            return response;
          },
          historicalInfo: async (height) => {
            const response = await queryService.HistoricalInfo({
              height: BigInt(height)
            });
            return response;
          },
          params: async () => {
            const response = await queryService.Params({});
            return response;
          },
          pool: async () => {
            const response = await queryService.Pool({});
            return response;
          },
          redelegations: async (delegatorAddress, sourceValidatorAddress, destinationValidatorAddress, paginationKey) => {
            const response = await queryService.Redelegations({
              delegatorAddr: delegatorAddress,
              srcValidatorAddr: sourceValidatorAddress,
              dstValidatorAddr: destinationValidatorAddress,
              pagination: (0, queryclient_1.createPagination)(paginationKey)
            });
            return response;
          },
          unbondingDelegation: async (delegatorAddress, validatorAddress) => {
            const response = await queryService.UnbondingDelegation({
              delegatorAddr: delegatorAddress,
              validatorAddr: validatorAddress
            });
            return response;
          },
          validator: async (validatorAddress) => {
            const response = await queryService.Validator({ validatorAddr: validatorAddress });
            return response;
          },
          validatorDelegations: async (validatorAddress, paginationKey) => {
            const response = await queryService.ValidatorDelegations({
              validatorAddr: validatorAddress,
              pagination: (0, queryclient_1.createPagination)(paginationKey)
            });
            return response;
          },
          validators: async (status, paginationKey) => {
            const response = await queryService.Validators({
              status,
              pagination: (0, queryclient_1.createPagination)(paginationKey)
            });
            return response;
          },
          validatorUnbondingDelegations: async (validatorAddress, paginationKey) => {
            const response = await queryService.ValidatorUnbondingDelegations({
              validatorAddr: validatorAddress,
              pagination: (0, queryclient_1.createPagination)(paginationKey)
            });
            return response;
          }
        }
      };
    }
  }
});

// ../../node_modules/.pnpm/@cosmjs+stargate@0.34.0/node_modules/@cosmjs/stargate/build/modules/tx/queries.js
var require_queries11 = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+stargate@0.34.0/node_modules/@cosmjs/stargate/build/modules/tx/queries.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.setupTxExtension = setupTxExtension;
    var proto_signing_1 = require_build6();
    var signing_1 = require_signing();
    var service_1 = require_service();
    var tx_1 = require_tx();
    var queryclient_1 = require_queryclient2();
    function setupTxExtension(base) {
      const rpc = (0, queryclient_1.createProtobufRpcClient)(base);
      const queryService = new service_1.ServiceClientImpl(rpc);
      return {
        tx: {
          getTx: async (txId) => {
            const request = {
              hash: txId
            };
            const response = await queryService.GetTx(request);
            return response;
          },
          simulate: async (messages, memo, signer, sequence) => {
            const tx = tx_1.Tx.fromPartial({
              authInfo: tx_1.AuthInfo.fromPartial({
                fee: tx_1.Fee.fromPartial({}),
                signerInfos: [
                  {
                    publicKey: (0, proto_signing_1.encodePubkey)(signer),
                    sequence: BigInt(sequence),
                    modeInfo: { single: { mode: signing_1.SignMode.SIGN_MODE_UNSPECIFIED } }
                  }
                ]
              }),
              body: tx_1.TxBody.fromPartial({
                messages: Array.from(messages),
                memo
              }),
              signatures: [new Uint8Array()]
            });
            const request = service_1.SimulateRequest.fromPartial({
              txBytes: tx_1.Tx.encode(tx).finish()
            });
            const response = await queryService.Simulate(request);
            return response;
          }
        }
      };
    }
  }
});

// ../../node_modules/.pnpm/@cosmjs+stargate@0.34.0/node_modules/@cosmjs/stargate/build/modules/vesting/aminomessages.js
var require_aminomessages12 = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+stargate@0.34.0/node_modules/@cosmjs/stargate/build/modules/vesting/aminomessages.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isAminoMsgCreateVestingAccount = isAminoMsgCreateVestingAccount;
    exports.createVestingAminoConverters = createVestingAminoConverters;
    function isAminoMsgCreateVestingAccount(msg) {
      return msg.type === "cosmos-sdk/MsgCreateVestingAccount";
    }
    function createVestingAminoConverters() {
      return {
        "/cosmos.vesting.v1beta1.MsgCreateVestingAccount": {
          aminoType: "cosmos-sdk/MsgCreateVestingAccount",
          toAmino: ({ fromAddress, toAddress, amount, endTime, delayed }) => ({
            from_address: fromAddress,
            to_address: toAddress,
            amount: [...amount],
            end_time: endTime.toString(),
            delayed
          }),
          fromAmino: ({ from_address, to_address, amount, end_time, delayed }) => ({
            fromAddress: from_address,
            toAddress: to_address,
            amount: [...amount],
            endTime: BigInt(end_time),
            delayed
          })
        }
      };
    }
  }
});

// ../../node_modules/.pnpm/@cosmjs+stargate@0.34.0/node_modules/@cosmjs/stargate/build/modules/vesting/messages.js
var require_messages9 = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+stargate@0.34.0/node_modules/@cosmjs/stargate/build/modules/vesting/messages.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.vestingTypes = void 0;
    var tx_1 = require_tx14();
    exports.vestingTypes = [
      ["/cosmos.vesting.v1beta1.MsgCreateVestingAccount", tx_1.MsgCreateVestingAccount]
    ];
  }
});

// ../../node_modules/.pnpm/@cosmjs+stargate@0.34.0/node_modules/@cosmjs/stargate/build/modules/index.js
var require_modules = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+stargate@0.34.0/node_modules/@cosmjs/stargate/build/modules/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isAminoMsgCreateValidator = exports.isAminoMsgBeginRedelegate = exports.createStakingAminoConverters = exports.setupSlashingExtension = exports.isAminoMsgUnjail = exports.createSlashingAminoConverters = exports.setupMintExtension = exports.setupIbcExtension = exports.isMsgTransferEncodeObject = exports.ibcTypes = exports.isAminoMsgTransfer = exports.createIbcAminoConverters = exports.groupTypes = exports.createGroupAminoConverters = exports.setupGovExtension = exports.isMsgVoteWeightedEncodeObject = exports.isMsgVoteEncodeObject = exports.isMsgSubmitProposalEncodeObject = exports.isMsgDepositEncodeObject = exports.govTypes = exports.isAminoMsgVoteWeighted = exports.isAminoMsgVote = exports.isAminoMsgSubmitProposal = exports.isAminoMsgDeposit = exports.createGovAminoConverters = exports.setupFeegrantExtension = exports.feegrantTypes = exports.createFeegrantAminoConverters = exports.isAminoMsgSubmitEvidence = exports.createEvidenceAminoConverters = exports.setupDistributionExtension = exports.isMsgWithdrawDelegatorRewardEncodeObject = exports.distributionTypes = exports.isAminoMsgWithdrawValidatorCommission = exports.isAminoMsgWithdrawDelegatorReward = exports.isAminoMsgSetWithdrawAddress = exports.isAminoMsgFundCommunityPool = exports.createDistributionAminoConverters = exports.isAminoMsgVerifyInvariant = exports.createCrysisAminoConverters = exports.setupBankExtension = exports.isMsgSendEncodeObject = exports.bankTypes = exports.isAminoMsgSend = exports.isAminoMsgMultiSend = exports.createBankAminoConverters = exports.setupAuthzExtension = exports.authzTypes = exports.createAuthzAminoConverters = exports.setupAuthExtension = void 0;
    exports.vestingTypes = exports.isAminoMsgCreateVestingAccount = exports.createVestingAminoConverters = exports.setupTxExtension = exports.setupStakingExtension = exports.stakingTypes = exports.isMsgUndelegateEncodeObject = exports.isMsgEditValidatorEncodeObject = exports.isMsgDelegateEncodeObject = exports.isMsgCreateValidatorEncodeObject = exports.isMsgCancelUnbondingDelegationEncodeObject = exports.isMsgBeginRedelegateEncodeObject = exports.isAminoMsgUndelegate = exports.isAminoMsgEditValidator = exports.isAminoMsgDelegate = void 0;
    var queries_1 = require_queries();
    Object.defineProperty(exports, "setupAuthExtension", { enumerable: true, get: function() {
      return queries_1.setupAuthExtension;
    } });
    var aminomessages_1 = require_aminomessages();
    Object.defineProperty(exports, "createAuthzAminoConverters", { enumerable: true, get: function() {
      return aminomessages_1.createAuthzAminoConverters;
    } });
    var messages_1 = require_messages();
    Object.defineProperty(exports, "authzTypes", { enumerable: true, get: function() {
      return messages_1.authzTypes;
    } });
    var queries_2 = require_queries2();
    Object.defineProperty(exports, "setupAuthzExtension", { enumerable: true, get: function() {
      return queries_2.setupAuthzExtension;
    } });
    var aminomessages_2 = require_aminomessages2();
    Object.defineProperty(exports, "createBankAminoConverters", { enumerable: true, get: function() {
      return aminomessages_2.createBankAminoConverters;
    } });
    Object.defineProperty(exports, "isAminoMsgMultiSend", { enumerable: true, get: function() {
      return aminomessages_2.isAminoMsgMultiSend;
    } });
    Object.defineProperty(exports, "isAminoMsgSend", { enumerable: true, get: function() {
      return aminomessages_2.isAminoMsgSend;
    } });
    var messages_2 = require_messages2();
    Object.defineProperty(exports, "bankTypes", { enumerable: true, get: function() {
      return messages_2.bankTypes;
    } });
    Object.defineProperty(exports, "isMsgSendEncodeObject", { enumerable: true, get: function() {
      return messages_2.isMsgSendEncodeObject;
    } });
    var queries_3 = require_queries3();
    Object.defineProperty(exports, "setupBankExtension", { enumerable: true, get: function() {
      return queries_3.setupBankExtension;
    } });
    var aminomessages_3 = require_aminomessages3();
    Object.defineProperty(exports, "createCrysisAminoConverters", { enumerable: true, get: function() {
      return aminomessages_3.createCrysisAminoConverters;
    } });
    Object.defineProperty(exports, "isAminoMsgVerifyInvariant", { enumerable: true, get: function() {
      return aminomessages_3.isAminoMsgVerifyInvariant;
    } });
    var aminomessages_4 = require_aminomessages4();
    Object.defineProperty(exports, "createDistributionAminoConverters", { enumerable: true, get: function() {
      return aminomessages_4.createDistributionAminoConverters;
    } });
    Object.defineProperty(exports, "isAminoMsgFundCommunityPool", { enumerable: true, get: function() {
      return aminomessages_4.isAminoMsgFundCommunityPool;
    } });
    Object.defineProperty(exports, "isAminoMsgSetWithdrawAddress", { enumerable: true, get: function() {
      return aminomessages_4.isAminoMsgSetWithdrawAddress;
    } });
    Object.defineProperty(exports, "isAminoMsgWithdrawDelegatorReward", { enumerable: true, get: function() {
      return aminomessages_4.isAminoMsgWithdrawDelegatorReward;
    } });
    Object.defineProperty(exports, "isAminoMsgWithdrawValidatorCommission", { enumerable: true, get: function() {
      return aminomessages_4.isAminoMsgWithdrawValidatorCommission;
    } });
    var messages_3 = require_messages3();
    Object.defineProperty(exports, "distributionTypes", { enumerable: true, get: function() {
      return messages_3.distributionTypes;
    } });
    Object.defineProperty(exports, "isMsgWithdrawDelegatorRewardEncodeObject", { enumerable: true, get: function() {
      return messages_3.isMsgWithdrawDelegatorRewardEncodeObject;
    } });
    var queries_4 = require_queries4();
    Object.defineProperty(exports, "setupDistributionExtension", { enumerable: true, get: function() {
      return queries_4.setupDistributionExtension;
    } });
    var aminomessages_5 = require_aminomessages5();
    Object.defineProperty(exports, "createEvidenceAminoConverters", { enumerable: true, get: function() {
      return aminomessages_5.createEvidenceAminoConverters;
    } });
    Object.defineProperty(exports, "isAminoMsgSubmitEvidence", { enumerable: true, get: function() {
      return aminomessages_5.isAminoMsgSubmitEvidence;
    } });
    var aminomessages_6 = require_aminomessages6();
    Object.defineProperty(exports, "createFeegrantAminoConverters", { enumerable: true, get: function() {
      return aminomessages_6.createFeegrantAminoConverters;
    } });
    var messages_4 = require_messages4();
    Object.defineProperty(exports, "feegrantTypes", { enumerable: true, get: function() {
      return messages_4.feegrantTypes;
    } });
    var queries_5 = require_queries5();
    Object.defineProperty(exports, "setupFeegrantExtension", { enumerable: true, get: function() {
      return queries_5.setupFeegrantExtension;
    } });
    var aminomessages_7 = require_aminomessages7();
    Object.defineProperty(exports, "createGovAminoConverters", { enumerable: true, get: function() {
      return aminomessages_7.createGovAminoConverters;
    } });
    Object.defineProperty(exports, "isAminoMsgDeposit", { enumerable: true, get: function() {
      return aminomessages_7.isAminoMsgDeposit;
    } });
    Object.defineProperty(exports, "isAminoMsgSubmitProposal", { enumerable: true, get: function() {
      return aminomessages_7.isAminoMsgSubmitProposal;
    } });
    Object.defineProperty(exports, "isAminoMsgVote", { enumerable: true, get: function() {
      return aminomessages_7.isAminoMsgVote;
    } });
    Object.defineProperty(exports, "isAminoMsgVoteWeighted", { enumerable: true, get: function() {
      return aminomessages_7.isAminoMsgVoteWeighted;
    } });
    var messages_5 = require_messages5();
    Object.defineProperty(exports, "govTypes", { enumerable: true, get: function() {
      return messages_5.govTypes;
    } });
    Object.defineProperty(exports, "isMsgDepositEncodeObject", { enumerable: true, get: function() {
      return messages_5.isMsgDepositEncodeObject;
    } });
    Object.defineProperty(exports, "isMsgSubmitProposalEncodeObject", { enumerable: true, get: function() {
      return messages_5.isMsgSubmitProposalEncodeObject;
    } });
    Object.defineProperty(exports, "isMsgVoteEncodeObject", { enumerable: true, get: function() {
      return messages_5.isMsgVoteEncodeObject;
    } });
    Object.defineProperty(exports, "isMsgVoteWeightedEncodeObject", { enumerable: true, get: function() {
      return messages_5.isMsgVoteWeightedEncodeObject;
    } });
    var queries_6 = require_queries6();
    Object.defineProperty(exports, "setupGovExtension", { enumerable: true, get: function() {
      return queries_6.setupGovExtension;
    } });
    var aminomessages_8 = require_aminomessages8();
    Object.defineProperty(exports, "createGroupAminoConverters", { enumerable: true, get: function() {
      return aminomessages_8.createGroupAminoConverters;
    } });
    var messages_6 = require_messages6();
    Object.defineProperty(exports, "groupTypes", { enumerable: true, get: function() {
      return messages_6.groupTypes;
    } });
    var aminomessages_9 = require_aminomessages9();
    Object.defineProperty(exports, "createIbcAminoConverters", { enumerable: true, get: function() {
      return aminomessages_9.createIbcAminoConverters;
    } });
    Object.defineProperty(exports, "isAminoMsgTransfer", { enumerable: true, get: function() {
      return aminomessages_9.isAminoMsgTransfer;
    } });
    var messages_7 = require_messages7();
    Object.defineProperty(exports, "ibcTypes", { enumerable: true, get: function() {
      return messages_7.ibcTypes;
    } });
    Object.defineProperty(exports, "isMsgTransferEncodeObject", { enumerable: true, get: function() {
      return messages_7.isMsgTransferEncodeObject;
    } });
    var queries_7 = require_queries7();
    Object.defineProperty(exports, "setupIbcExtension", { enumerable: true, get: function() {
      return queries_7.setupIbcExtension;
    } });
    var queries_8 = require_queries8();
    Object.defineProperty(exports, "setupMintExtension", { enumerable: true, get: function() {
      return queries_8.setupMintExtension;
    } });
    var aminomessages_10 = require_aminomessages10();
    Object.defineProperty(exports, "createSlashingAminoConverters", { enumerable: true, get: function() {
      return aminomessages_10.createSlashingAminoConverters;
    } });
    Object.defineProperty(exports, "isAminoMsgUnjail", { enumerable: true, get: function() {
      return aminomessages_10.isAminoMsgUnjail;
    } });
    var queries_9 = require_queries9();
    Object.defineProperty(exports, "setupSlashingExtension", { enumerable: true, get: function() {
      return queries_9.setupSlashingExtension;
    } });
    var aminomessages_11 = require_aminomessages11();
    Object.defineProperty(exports, "createStakingAminoConverters", { enumerable: true, get: function() {
      return aminomessages_11.createStakingAminoConverters;
    } });
    Object.defineProperty(exports, "isAminoMsgBeginRedelegate", { enumerable: true, get: function() {
      return aminomessages_11.isAminoMsgBeginRedelegate;
    } });
    Object.defineProperty(exports, "isAminoMsgCreateValidator", { enumerable: true, get: function() {
      return aminomessages_11.isAminoMsgCreateValidator;
    } });
    Object.defineProperty(exports, "isAminoMsgDelegate", { enumerable: true, get: function() {
      return aminomessages_11.isAminoMsgDelegate;
    } });
    Object.defineProperty(exports, "isAminoMsgEditValidator", { enumerable: true, get: function() {
      return aminomessages_11.isAminoMsgEditValidator;
    } });
    Object.defineProperty(exports, "isAminoMsgUndelegate", { enumerable: true, get: function() {
      return aminomessages_11.isAminoMsgUndelegate;
    } });
    var messages_8 = require_messages8();
    Object.defineProperty(exports, "isMsgBeginRedelegateEncodeObject", { enumerable: true, get: function() {
      return messages_8.isMsgBeginRedelegateEncodeObject;
    } });
    Object.defineProperty(exports, "isMsgCancelUnbondingDelegationEncodeObject", { enumerable: true, get: function() {
      return messages_8.isMsgCancelUnbondingDelegationEncodeObject;
    } });
    Object.defineProperty(exports, "isMsgCreateValidatorEncodeObject", { enumerable: true, get: function() {
      return messages_8.isMsgCreateValidatorEncodeObject;
    } });
    Object.defineProperty(exports, "isMsgDelegateEncodeObject", { enumerable: true, get: function() {
      return messages_8.isMsgDelegateEncodeObject;
    } });
    Object.defineProperty(exports, "isMsgEditValidatorEncodeObject", { enumerable: true, get: function() {
      return messages_8.isMsgEditValidatorEncodeObject;
    } });
    Object.defineProperty(exports, "isMsgUndelegateEncodeObject", { enumerable: true, get: function() {
      return messages_8.isMsgUndelegateEncodeObject;
    } });
    Object.defineProperty(exports, "stakingTypes", { enumerable: true, get: function() {
      return messages_8.stakingTypes;
    } });
    var queries_10 = require_queries10();
    Object.defineProperty(exports, "setupStakingExtension", { enumerable: true, get: function() {
      return queries_10.setupStakingExtension;
    } });
    var queries_11 = require_queries11();
    Object.defineProperty(exports, "setupTxExtension", { enumerable: true, get: function() {
      return queries_11.setupTxExtension;
    } });
    var aminomessages_12 = require_aminomessages12();
    Object.defineProperty(exports, "createVestingAminoConverters", { enumerable: true, get: function() {
      return aminomessages_12.createVestingAminoConverters;
    } });
    Object.defineProperty(exports, "isAminoMsgCreateVestingAccount", { enumerable: true, get: function() {
      return aminomessages_12.isAminoMsgCreateVestingAccount;
    } });
    var messages_9 = require_messages9();
    Object.defineProperty(exports, "vestingTypes", { enumerable: true, get: function() {
      return messages_9.vestingTypes;
    } });
  }
});

// ../../node_modules/.pnpm/@cosmjs+stargate@0.34.0/node_modules/@cosmjs/stargate/build/multisignature.js
var require_multisignature = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+stargate@0.34.0/node_modules/@cosmjs/stargate/build/multisignature.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.makeCompactBitArray = makeCompactBitArray;
    exports.makeMultisignedTx = makeMultisignedTx;
    exports.makeMultisignedTxBytes = makeMultisignedTxBytes;
    var amino_1 = require_build5();
    var encoding_1 = require_build();
    var proto_signing_1 = require_build6();
    var multisig_1 = require_multisig();
    var signing_1 = require_signing();
    var tx_1 = require_tx();
    var tx_2 = require_tx();
    function makeCompactBitArray(bits) {
      const byteCount = Math.ceil(bits.length / 8);
      const extraBits = bits.length - Math.floor(bits.length / 8) * 8;
      const bytes = new Uint8Array(byteCount);
      bits.forEach((value, index) => {
        const bytePos = Math.floor(index / 8);
        const bitPos = index % 8;
        if (value)
          bytes[bytePos] |= 1 << 8 - 1 - bitPos;
      });
      return multisig_1.CompactBitArray.fromPartial({ elems: bytes, extraBitsStored: extraBits });
    }
    function makeMultisignedTx(multisigPubkey, sequence, fee, bodyBytes, signatures) {
      const addresses = Array.from(signatures.keys());
      const prefix = (0, encoding_1.fromBech32)(addresses[0]).prefix;
      const signers = Array(multisigPubkey.value.pubkeys.length).fill(false);
      const signaturesList = new Array();
      for (let i = 0; i < multisigPubkey.value.pubkeys.length; i++) {
        const signerAddress = (0, amino_1.pubkeyToAddress)(multisigPubkey.value.pubkeys[i], prefix);
        const signature = signatures.get(signerAddress);
        if (signature) {
          signers[i] = true;
          signaturesList.push(signature);
        }
      }
      const signerInfo = {
        publicKey: (0, proto_signing_1.encodePubkey)(multisigPubkey),
        modeInfo: {
          multi: {
            bitarray: makeCompactBitArray(signers),
            modeInfos: signaturesList.map((_) => ({ single: { mode: signing_1.SignMode.SIGN_MODE_LEGACY_AMINO_JSON } }))
          }
        },
        sequence: BigInt(sequence)
      };
      const authInfo = tx_1.AuthInfo.fromPartial({
        signerInfos: [signerInfo],
        fee: {
          amount: [...fee.amount],
          gasLimit: BigInt(fee.gas)
        }
      });
      const authInfoBytes = tx_1.AuthInfo.encode(authInfo).finish();
      const signedTx = tx_2.TxRaw.fromPartial({
        bodyBytes,
        authInfoBytes,
        signatures: [multisig_1.MultiSignature.encode(multisig_1.MultiSignature.fromPartial({ signatures: signaturesList })).finish()]
      });
      return signedTx;
    }
    function makeMultisignedTxBytes(multisigPubkey, sequence, fee, bodyBytes, signatures) {
      const signedTx = makeMultisignedTx(multisigPubkey, sequence, fee, bodyBytes, signatures);
      return Uint8Array.from(tx_2.TxRaw.encode(signedTx).finish());
    }
  }
});

// ../../node_modules/.pnpm/@cosmjs+stargate@0.34.0/node_modules/@cosmjs/stargate/build/search.js
var require_search = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+stargate@0.34.0/node_modules/@cosmjs/stargate/build/search.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isSearchTxQueryArray = isSearchTxQueryArray;
    function isSearchTxQueryArray(query) {
      return Array.isArray(query);
    }
  }
});

// ../../node_modules/.pnpm/@cosmjs+tendermint-rpc@0.34.0/node_modules/@cosmjs/tendermint-rpc/build/addresses.js
var require_addresses2 = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+tendermint-rpc@0.34.0/node_modules/@cosmjs/tendermint-rpc/build/addresses.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.rawEd25519PubkeyToRawAddress = rawEd25519PubkeyToRawAddress;
    exports.rawSecp256k1PubkeyToRawAddress = rawSecp256k1PubkeyToRawAddress;
    exports.pubkeyToRawAddress = pubkeyToRawAddress;
    exports.pubkeyToAddress = pubkeyToAddress;
    var crypto_1 = require_build4();
    var encoding_1 = require_build();
    function rawEd25519PubkeyToRawAddress(pubkeyData) {
      if (pubkeyData.length !== 32) {
        throw new Error(`Invalid Ed25519 pubkey length: ${pubkeyData.length}`);
      }
      return (0, crypto_1.sha256)(pubkeyData).slice(0, 20);
    }
    function rawSecp256k1PubkeyToRawAddress(pubkeyData) {
      if (pubkeyData.length !== 33) {
        throw new Error(`Invalid Secp256k1 pubkey length (compressed): ${pubkeyData.length}`);
      }
      return (0, crypto_1.ripemd160)((0, crypto_1.sha256)(pubkeyData));
    }
    function pubkeyToRawAddress(type, data) {
      switch (type) {
        case "ed25519":
          return rawEd25519PubkeyToRawAddress(data);
        case "secp256k1":
          return rawSecp256k1PubkeyToRawAddress(data);
        default:
          throw new Error(`Pubkey type ${type} not supported`);
      }
    }
    function pubkeyToAddress(type, data) {
      return (0, encoding_1.toHex)(pubkeyToRawAddress(type, data)).toUpperCase();
    }
  }
});

// ../../node_modules/.pnpm/@cosmjs+tendermint-rpc@0.34.0/node_modules/@cosmjs/tendermint-rpc/build/dates.js
var require_dates = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+tendermint-rpc@0.34.0/node_modules/@cosmjs/tendermint-rpc/build/dates.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DateTime = void 0;
    exports.fromRfc3339WithNanoseconds = fromRfc3339WithNanoseconds;
    exports.toRfc3339WithNanoseconds = toRfc3339WithNanoseconds;
    exports.fromSeconds = fromSeconds;
    exports.toSeconds = toSeconds;
    var encoding_1 = require_build();
    var math_1 = require_build2();
    function fromRfc3339WithNanoseconds(dateTimeString) {
      const out = (0, encoding_1.fromRfc3339)(dateTimeString);
      const nanosecondsMatch = dateTimeString.match(/\.(\d+)Z$/);
      const nanoseconds = nanosecondsMatch ? nanosecondsMatch[1].slice(3) : "";
      out.nanoseconds = parseInt(nanoseconds.padEnd(6, "0"), 10);
      return out;
    }
    function toRfc3339WithNanoseconds(dateTime) {
      var _a;
      const millisecondIso = dateTime.toISOString();
      const nanoseconds = ((_a = dateTime.nanoseconds) == null ? void 0 : _a.toString()) ?? "";
      return `${millisecondIso.slice(0, -1)}${nanoseconds.padStart(6, "0")}Z`;
    }
    function fromSeconds(seconds, nanos = 0) {
      const checkedNanos = new math_1.Uint32(nanos).toNumber();
      if (checkedNanos > 999999999) {
        throw new Error("Nano seconds must not exceed 999999999");
      }
      const out = new Date(seconds * 1e3 + Math.floor(checkedNanos / 1e6));
      out.nanoseconds = checkedNanos % 1e6;
      return out;
    }
    function toSeconds(date) {
      return {
        seconds: Math.floor(date.getTime() / 1e3),
        nanos: date.getTime() % 1e3 * 1e6 + (date.nanoseconds ?? 0)
      };
    }
    var DateTime = class {
      /** @deprecated Use fromRfc3339WithNanoseconds instead */
      static decode(dateTimeString) {
        return fromRfc3339WithNanoseconds(dateTimeString);
      }
      /** @deprecated Use toRfc3339WithNanoseconds instead */
      static encode(dateTime) {
        return toRfc3339WithNanoseconds(dateTime);
      }
    };
    exports.DateTime = DateTime;
  }
});

// ../../node_modules/.pnpm/@cosmjs+tendermint-rpc@0.34.0/node_modules/@cosmjs/tendermint-rpc/build/jsonrpc.js
var require_jsonrpc = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+tendermint-rpc@0.34.0/node_modules/@cosmjs/tendermint-rpc/build/jsonrpc.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createJsonRpcRequest = createJsonRpcRequest;
    var numbersWithoutZero = "123456789";
    function randomNumericChar() {
      return numbersWithoutZero[Math.floor(Math.random() * numbersWithoutZero.length)];
    }
    function randomId() {
      return parseInt(Array.from({ length: 12 }).map(() => randomNumericChar()).join(""), 10);
    }
    function createJsonRpcRequest(method, params) {
      const paramsCopy = params ? { ...params } : {};
      return {
        jsonrpc: "2.0",
        id: randomId(),
        method,
        params: paramsCopy
      };
    }
  }
});

// ../../node_modules/.pnpm/@cosmjs+json-rpc@0.34.0/node_modules/@cosmjs/json-rpc/build/id.js
var require_id = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+json-rpc@0.34.0/node_modules/@cosmjs/json-rpc/build/id.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.makeJsonRpcId = makeJsonRpcId;
    var counter = 1e4;
    function makeJsonRpcId() {
      return counter += 1;
    }
  }
});

// ../../node_modules/.pnpm/@cosmjs+stream@0.34.0/node_modules/@cosmjs/stream/build/concat.js
var require_concat = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+stream@0.34.0/node_modules/@cosmjs/stream/build/concat.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.concat = concat;
    var xstream_1 = require_xstream();
    function concat(...streams) {
      const subscriptions = new Array();
      const queues = new Array();
      const completedStreams = /* @__PURE__ */ new Set();
      let activeStreamIndex = 0;
      function reset() {
        while (subscriptions.length > 0) {
          const subscription = subscriptions.shift();
          subscription.unsubscribe();
        }
        queues.length = 0;
        completedStreams.clear();
        activeStreamIndex = 0;
      }
      const producer = {
        start: (listener) => {
          streams.forEach((_) => queues.push([]));
          function emitAllQueuesEvents(streamIndex) {
            while (true) {
              const element = queues[streamIndex].shift();
              if (element === void 0) {
                return;
              }
              listener.next(element);
            }
          }
          function isDone() {
            return activeStreamIndex >= streams.length;
          }
          if (isDone()) {
            listener.complete();
            return;
          }
          streams.forEach((stream, index) => {
            subscriptions.push(stream.subscribe({
              next: (value) => {
                if (index === activeStreamIndex) {
                  listener.next(value);
                } else {
                  queues[index].push(value);
                }
              },
              complete: () => {
                completedStreams.add(index);
                while (completedStreams.has(activeStreamIndex)) {
                  emitAllQueuesEvents(activeStreamIndex);
                  activeStreamIndex++;
                }
                if (isDone()) {
                  listener.complete();
                } else {
                  emitAllQueuesEvents(activeStreamIndex);
                }
              },
              error: (error) => {
                listener.error(error);
                reset();
              }
            }));
          });
        },
        stop: () => {
          reset();
        }
      };
      return xstream_1.Stream.create(producer);
    }
  }
});

// ../../node_modules/.pnpm/@cosmjs+stream@0.34.0/node_modules/@cosmjs/stream/build/defaultvalueproducer.js
var require_defaultvalueproducer = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+stream@0.34.0/node_modules/@cosmjs/stream/build/defaultvalueproducer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DefaultValueProducer = void 0;
    var DefaultValueProducer = class {
      get value() {
        return this.internalValue;
      }
      constructor(value, callbacks) {
        this.callbacks = callbacks;
        this.internalValue = value;
      }
      /**
       * Update the current value.
       *
       * If producer is active (i.e. someone is listening), this emits an event.
       * If not, just the current value is updated.
       */
      update(value) {
        this.internalValue = value;
        if (this.listener) {
          this.listener.next(value);
        }
      }
      /**
       * Produce an error
       */
      // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
      error(error) {
        if (this.listener) {
          this.listener.error(error);
        }
      }
      /**
       * Called by the stream. Do not call this directly.
       */
      start(listener) {
        this.listener = listener;
        listener.next(this.internalValue);
        if (this.callbacks) {
          this.callbacks.onStarted();
        }
      }
      /**
       * Called by the stream. Do not call this directly.
       */
      stop() {
        if (this.callbacks) {
          this.callbacks.onStop();
        }
        this.listener = void 0;
      }
    };
    exports.DefaultValueProducer = DefaultValueProducer;
  }
});

// ../../node_modules/.pnpm/@cosmjs+stream@0.34.0/node_modules/@cosmjs/stream/build/dropduplicates.js
var require_dropduplicates = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+stream@0.34.0/node_modules/@cosmjs/stream/build/dropduplicates.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.dropDuplicates = dropDuplicates;
    function dropDuplicates(valueToKey) {
      const operand = (instream) => {
        const emittedKeys = /* @__PURE__ */ new Set();
        const deduplicatedStream = instream.filter((value) => !emittedKeys.has(valueToKey(value))).debug((value) => emittedKeys.add(valueToKey(value)));
        return deduplicatedStream;
      };
      return operand;
    }
  }
});

// ../../node_modules/.pnpm/@cosmjs+stream@0.34.0/node_modules/@cosmjs/stream/build/promise.js
var require_promise = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+stream@0.34.0/node_modules/@cosmjs/stream/build/promise.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.fromListPromise = fromListPromise;
    exports.toListPromise = toListPromise;
    exports.firstEvent = firstEvent;
    var xstream_1 = require_xstream();
    function fromListPromise(promise) {
      const producer = {
        start: (listener) => {
          promise.then((iterable) => {
            for (const element of iterable) {
              listener.next(element);
            }
            listener.complete();
          }).catch((error) => listener.error(error));
        },
        // eslint-disable-next-line @typescript-eslint/no-empty-function
        stop: () => {
        }
      };
      return xstream_1.Stream.create(producer);
    }
    async function toListPromise(stream, count) {
      return new Promise((resolve, reject) => {
        if (count === 0) {
          resolve([]);
          return;
        }
        const events = new Array();
        stream.take(count).subscribe({
          next: (event) => {
            events.push(event);
            if (events.length === count) {
              resolve(events);
            }
          },
          complete: () => {
            reject(`Stream completed before all events could be collected. Collected ${events.length}, expected ${count}`);
          },
          error: (error) => reject(error)
        });
      });
    }
    async function firstEvent(stream) {
      return (await toListPromise(stream, 1))[0];
    }
  }
});

// ../../node_modules/.pnpm/@cosmjs+stream@0.34.0/node_modules/@cosmjs/stream/build/reducer.js
var require_reducer = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+stream@0.34.0/node_modules/@cosmjs/stream/build/reducer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Reducer = void 0;
    exports.countStream = countStream;
    exports.asArray = asArray;
    exports.lastValue = lastValue;
    var Reducer = class {
      constructor(stream, reducer, initState) {
        this.stream = stream;
        this.reducer = reducer;
        this.state = initState;
        this.completed = new Promise((resolve, reject) => {
          const subscription = this.stream.subscribe({
            next: (evt) => {
              this.state = this.reducer(this.state, evt);
            },
            complete: () => {
              resolve();
              subscription.unsubscribe();
            },
            error: (err) => {
              reject(err);
              subscription.unsubscribe();
            }
          });
        });
      }
      // value returns current materialized state
      value() {
        return this.state;
      }
      // finished resolves on completed stream, rejects on stream error
      async finished() {
        return this.completed;
      }
    };
    exports.Reducer = Reducer;
    function increment(sum, _) {
      return sum + 1;
    }
    function countStream(stream) {
      return new Reducer(stream, increment, 0);
    }
    function append(list, evt) {
      return [...list, evt];
    }
    function asArray(stream) {
      return new Reducer(stream, append, []);
    }
    function last(_, event) {
      return event;
    }
    function lastValue(stream) {
      return new Reducer(stream, last, void 0);
    }
  }
});

// ../../node_modules/.pnpm/@cosmjs+stream@0.34.0/node_modules/@cosmjs/stream/build/valueandupdates.js
var require_valueandupdates = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+stream@0.34.0/node_modules/@cosmjs/stream/build/valueandupdates.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ValueAndUpdates = void 0;
    var xstream_1 = require_xstream();
    var ValueAndUpdates = class {
      get value() {
        return this.producer.value;
      }
      constructor(producer) {
        this.producer = producer;
        this.updates = xstream_1.MemoryStream.createWithMemory(this.producer);
      }
      /**
       * Resolves as soon as search value is found.
       *
       * @param search either a value or a function that must return true when found
       * @returns the value of the update that caused the search match
       */
      async waitFor(search) {
        const searchImplementation = typeof search === "function" ? search : (value) => value === search;
        return new Promise((resolve, reject) => {
          const subscription = this.updates.subscribe({
            next: (newValue) => {
              if (searchImplementation(newValue)) {
                resolve(newValue);
                setTimeout(() => subscription.unsubscribe(), 0);
              }
            },
            complete: () => {
              subscription.unsubscribe();
              reject("Update stream completed without expected value");
            },
            error: (error) => {
              reject(error);
            }
          });
        });
      }
    };
    exports.ValueAndUpdates = ValueAndUpdates;
  }
});

// ../../node_modules/.pnpm/@cosmjs+stream@0.34.0/node_modules/@cosmjs/stream/build/index.js
var require_build7 = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+stream@0.34.0/node_modules/@cosmjs/stream/build/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ValueAndUpdates = exports.toListPromise = exports.fromListPromise = exports.firstEvent = exports.dropDuplicates = exports.DefaultValueProducer = exports.concat = void 0;
    var concat_1 = require_concat();
    Object.defineProperty(exports, "concat", { enumerable: true, get: function() {
      return concat_1.concat;
    } });
    var defaultvalueproducer_1 = require_defaultvalueproducer();
    Object.defineProperty(exports, "DefaultValueProducer", { enumerable: true, get: function() {
      return defaultvalueproducer_1.DefaultValueProducer;
    } });
    var dropduplicates_1 = require_dropduplicates();
    Object.defineProperty(exports, "dropDuplicates", { enumerable: true, get: function() {
      return dropduplicates_1.dropDuplicates;
    } });
    var promise_1 = require_promise();
    Object.defineProperty(exports, "firstEvent", { enumerable: true, get: function() {
      return promise_1.firstEvent;
    } });
    Object.defineProperty(exports, "fromListPromise", { enumerable: true, get: function() {
      return promise_1.fromListPromise;
    } });
    Object.defineProperty(exports, "toListPromise", { enumerable: true, get: function() {
      return promise_1.toListPromise;
    } });
    __exportStar(require_reducer(), exports);
    var valueandupdates_1 = require_valueandupdates();
    Object.defineProperty(exports, "ValueAndUpdates", { enumerable: true, get: function() {
      return valueandupdates_1.ValueAndUpdates;
    } });
  }
});

// ../../node_modules/.pnpm/@cosmjs+json-rpc@0.34.0/node_modules/@cosmjs/json-rpc/build/types.js
var require_types2 = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+json-rpc@0.34.0/node_modules/@cosmjs/json-rpc/build/types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.jsonRpcCode = void 0;
    exports.isJsonRpcErrorResponse = isJsonRpcErrorResponse;
    exports.isJsonRpcSuccessResponse = isJsonRpcSuccessResponse;
    function isJsonRpcErrorResponse(response) {
      return typeof response.error === "object";
    }
    function isJsonRpcSuccessResponse(response) {
      return !isJsonRpcErrorResponse(response);
    }
    exports.jsonRpcCode = {
      parseError: -32700,
      invalidRequest: -32600,
      methodNotFound: -32601,
      invalidParams: -32602,
      internalError: -32603,
      // server error (Reserved for implementation-defined server-errors.):
      // -32000 to -32099
      serverError: {
        default: -32e3
      }
    };
  }
});

// ../../node_modules/.pnpm/@cosmjs+json-rpc@0.34.0/node_modules/@cosmjs/json-rpc/build/jsonrpcclient.js
var require_jsonrpcclient = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+json-rpc@0.34.0/node_modules/@cosmjs/json-rpc/build/jsonrpcclient.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.JsonRpcClient = void 0;
    var stream_1 = require_build7();
    var types_1 = require_types2();
    var JsonRpcClient = class {
      constructor(connection) {
        this.connection = connection;
      }
      async run(request) {
        const filteredStream = this.connection.responseStream.filter((r) => r.id === request.id);
        const pendingResponses = (0, stream_1.firstEvent)(filteredStream);
        this.connection.sendRequest(request);
        const response = await pendingResponses;
        if ((0, types_1.isJsonRpcErrorResponse)(response)) {
          const error = response.error;
          throw new Error(`JSON RPC error: code=${error.code}; message='${error.message}'`);
        }
        return response;
      }
    };
    exports.JsonRpcClient = JsonRpcClient;
  }
});

// ../../node_modules/.pnpm/@cosmjs+json-rpc@0.34.0/node_modules/@cosmjs/json-rpc/build/compatibility.js
var require_compatibility = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+json-rpc@0.34.0/node_modules/@cosmjs/json-rpc/build/compatibility.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isJsonCompatibleValue = isJsonCompatibleValue;
    exports.isJsonCompatibleArray = isJsonCompatibleArray;
    exports.isJsonCompatibleDictionary = isJsonCompatibleDictionary;
    function isJsonCompatibleValue(value) {
      if (typeof value === "string" || typeof value === "number" || typeof value === "boolean" || value === null || // eslint-disable-next-line @typescript-eslint/no-use-before-define
      isJsonCompatibleArray(value) || // eslint-disable-next-line @typescript-eslint/no-use-before-define
      isJsonCompatibleDictionary(value)) {
        return true;
      } else {
        return false;
      }
    }
    function isJsonCompatibleArray(value) {
      if (!Array.isArray(value)) {
        return false;
      }
      for (const item of value) {
        if (!isJsonCompatibleValue(item)) {
          return false;
        }
      }
      return true;
    }
    function isJsonCompatibleDictionary(value) {
      if (typeof value !== "object" || value === null) {
        return false;
      }
      if (Object.prototype.toString.call(value) !== "[object Object]") {
        return false;
      }
      return Object.values(value).every(isJsonCompatibleValue);
    }
  }
});

// ../../node_modules/.pnpm/@cosmjs+json-rpc@0.34.0/node_modules/@cosmjs/json-rpc/build/parse.js
var require_parse = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+json-rpc@0.34.0/node_modules/@cosmjs/json-rpc/build/parse.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseJsonRpcId = parseJsonRpcId;
    exports.parseJsonRpcRequest = parseJsonRpcRequest;
    exports.parseJsonRpcErrorResponse = parseJsonRpcErrorResponse;
    exports.parseJsonRpcSuccessResponse = parseJsonRpcSuccessResponse;
    exports.parseJsonRpcResponse = parseJsonRpcResponse;
    var compatibility_1 = require_compatibility();
    function parseJsonRpcId(data) {
      if (!(0, compatibility_1.isJsonCompatibleDictionary)(data)) {
        throw new Error("Data must be JSON compatible dictionary");
      }
      const id = data.id;
      if (typeof id !== "number" && typeof id !== "string") {
        return null;
      }
      return id;
    }
    function parseJsonRpcRequest(data) {
      if (!(0, compatibility_1.isJsonCompatibleDictionary)(data)) {
        throw new Error("Data must be JSON compatible dictionary");
      }
      if (data.jsonrpc !== "2.0") {
        throw new Error(`Got unexpected jsonrpc version: ${data.jsonrpc}`);
      }
      const id = parseJsonRpcId(data);
      if (id === null) {
        throw new Error("Invalid id field");
      }
      const method = data.method;
      if (typeof method !== "string") {
        throw new Error("Invalid method field");
      }
      if (!(0, compatibility_1.isJsonCompatibleArray)(data.params) && !(0, compatibility_1.isJsonCompatibleDictionary)(data.params)) {
        throw new Error("Invalid params field");
      }
      return {
        jsonrpc: "2.0",
        id,
        method,
        params: data.params
      };
    }
    function parseError(error) {
      if (typeof error.code !== "number") {
        throw new Error("Error property 'code' is not a number");
      }
      if (typeof error.message !== "string") {
        throw new Error("Error property 'message' is not a string");
      }
      let maybeUndefinedData;
      if (error.data === void 0) {
        maybeUndefinedData = void 0;
      } else if ((0, compatibility_1.isJsonCompatibleValue)(error.data)) {
        maybeUndefinedData = error.data;
      } else {
        throw new Error("Error property 'data' is defined but not a JSON compatible value.");
      }
      return {
        code: error.code,
        message: error.message,
        ...maybeUndefinedData !== void 0 ? { data: maybeUndefinedData } : {}
      };
    }
    function parseJsonRpcErrorResponse(data) {
      if (!(0, compatibility_1.isJsonCompatibleDictionary)(data)) {
        throw new Error("Data must be JSON compatible dictionary");
      }
      if (data.jsonrpc !== "2.0") {
        throw new Error(`Got unexpected jsonrpc version: ${JSON.stringify(data)}`);
      }
      const id = data.id;
      if (typeof id !== "number" && typeof id !== "string" && id !== null) {
        throw new Error("Invalid id field");
      }
      if (typeof data.error === "undefined" || !(0, compatibility_1.isJsonCompatibleDictionary)(data.error)) {
        throw new Error("Invalid error field");
      }
      return {
        jsonrpc: "2.0",
        id,
        error: parseError(data.error)
      };
    }
    function parseJsonRpcSuccessResponse(data) {
      if (!(0, compatibility_1.isJsonCompatibleDictionary)(data)) {
        throw new Error("Data must be JSON compatible dictionary");
      }
      if (data.jsonrpc !== "2.0") {
        throw new Error(`Got unexpected jsonrpc version: ${JSON.stringify(data)}`);
      }
      const id = data.id;
      if (typeof id !== "number" && typeof id !== "string") {
        throw new Error("Invalid id field");
      }
      if (typeof data.result === "undefined") {
        throw new Error("Invalid result field");
      }
      const result = data.result;
      return {
        jsonrpc: "2.0",
        id,
        result
      };
    }
    function parseJsonRpcResponse(data) {
      let response;
      try {
        response = parseJsonRpcErrorResponse(data);
      } catch (_) {
        response = parseJsonRpcSuccessResponse(data);
      }
      return response;
    }
  }
});

// ../../node_modules/.pnpm/@cosmjs+json-rpc@0.34.0/node_modules/@cosmjs/json-rpc/build/index.js
var require_build8 = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+json-rpc@0.34.0/node_modules/@cosmjs/json-rpc/build/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.jsonRpcCode = exports.isJsonRpcSuccessResponse = exports.isJsonRpcErrorResponse = exports.parseJsonRpcSuccessResponse = exports.parseJsonRpcResponse = exports.parseJsonRpcRequest = exports.parseJsonRpcId = exports.parseJsonRpcErrorResponse = exports.JsonRpcClient = exports.makeJsonRpcId = void 0;
    var id_1 = require_id();
    Object.defineProperty(exports, "makeJsonRpcId", { enumerable: true, get: function() {
      return id_1.makeJsonRpcId;
    } });
    var jsonrpcclient_1 = require_jsonrpcclient();
    Object.defineProperty(exports, "JsonRpcClient", { enumerable: true, get: function() {
      return jsonrpcclient_1.JsonRpcClient;
    } });
    var parse_1 = require_parse();
    Object.defineProperty(exports, "parseJsonRpcErrorResponse", { enumerable: true, get: function() {
      return parse_1.parseJsonRpcErrorResponse;
    } });
    Object.defineProperty(exports, "parseJsonRpcId", { enumerable: true, get: function() {
      return parse_1.parseJsonRpcId;
    } });
    Object.defineProperty(exports, "parseJsonRpcRequest", { enumerable: true, get: function() {
      return parse_1.parseJsonRpcRequest;
    } });
    Object.defineProperty(exports, "parseJsonRpcResponse", { enumerable: true, get: function() {
      return parse_1.parseJsonRpcResponse;
    } });
    Object.defineProperty(exports, "parseJsonRpcSuccessResponse", { enumerable: true, get: function() {
      return parse_1.parseJsonRpcSuccessResponse;
    } });
    var types_1 = require_types2();
    Object.defineProperty(exports, "isJsonRpcErrorResponse", { enumerable: true, get: function() {
      return types_1.isJsonRpcErrorResponse;
    } });
    Object.defineProperty(exports, "isJsonRpcSuccessResponse", { enumerable: true, get: function() {
      return types_1.isJsonRpcSuccessResponse;
    } });
    Object.defineProperty(exports, "jsonRpcCode", { enumerable: true, get: function() {
      return types_1.jsonRpcCode;
    } });
  }
});

// ../../node_modules/.pnpm/cross-fetch@4.1.0/node_modules/cross-fetch/dist/browser-ponyfill.js
var require_browser_ponyfill = __commonJS({
  "../../node_modules/.pnpm/cross-fetch@4.1.0/node_modules/cross-fetch/dist/browser-ponyfill.js"(exports, module) {
    var __global__ = typeof globalThis !== "undefined" && globalThis || typeof self !== "undefined" && self || typeof global !== "undefined" && global;
    var __globalThis__ = function() {
      function F() {
        this.fetch = false;
        this.DOMException = __global__.DOMException;
      }
      F.prototype = __global__;
      return new F();
    }();
    (function(globalThis2) {
      var irrelevant = function(exports2) {
        var g = typeof globalThis2 !== "undefined" && globalThis2 || typeof self !== "undefined" && self || // eslint-disable-next-line no-undef
        typeof global !== "undefined" && global || {};
        var support = {
          searchParams: "URLSearchParams" in g,
          iterable: "Symbol" in g && "iterator" in Symbol,
          blob: "FileReader" in g && "Blob" in g && function() {
            try {
              new Blob();
              return true;
            } catch (e) {
              return false;
            }
          }(),
          formData: "FormData" in g,
          arrayBuffer: "ArrayBuffer" in g
        };
        function isDataView(obj) {
          return obj && DataView.prototype.isPrototypeOf(obj);
        }
        if (support.arrayBuffer) {
          var viewClasses = [
            "[object Int8Array]",
            "[object Uint8Array]",
            "[object Uint8ClampedArray]",
            "[object Int16Array]",
            "[object Uint16Array]",
            "[object Int32Array]",
            "[object Uint32Array]",
            "[object Float32Array]",
            "[object Float64Array]"
          ];
          var isArrayBufferView = ArrayBuffer.isView || function(obj) {
            return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1;
          };
        }
        function normalizeName(name) {
          if (typeof name !== "string") {
            name = String(name);
          }
          if (/[^a-z0-9\-#$%&'*+.^_`|~!]/i.test(name) || name === "") {
            throw new TypeError('Invalid character in header field name: "' + name + '"');
          }
          return name.toLowerCase();
        }
        function normalizeValue(value) {
          if (typeof value !== "string") {
            value = String(value);
          }
          return value;
        }
        function iteratorFor(items) {
          var iterator = {
            next: function() {
              var value = items.shift();
              return { done: value === void 0, value };
            }
          };
          if (support.iterable) {
            iterator[Symbol.iterator] = function() {
              return iterator;
            };
          }
          return iterator;
        }
        function Headers(headers) {
          this.map = {};
          if (headers instanceof Headers) {
            headers.forEach(function(value, name) {
              this.append(name, value);
            }, this);
          } else if (Array.isArray(headers)) {
            headers.forEach(function(header) {
              if (header.length != 2) {
                throw new TypeError("Headers constructor: expected name/value pair to be length 2, found" + header.length);
              }
              this.append(header[0], header[1]);
            }, this);
          } else if (headers) {
            Object.getOwnPropertyNames(headers).forEach(function(name) {
              this.append(name, headers[name]);
            }, this);
          }
        }
        Headers.prototype.append = function(name, value) {
          name = normalizeName(name);
          value = normalizeValue(value);
          var oldValue = this.map[name];
          this.map[name] = oldValue ? oldValue + ", " + value : value;
        };
        Headers.prototype["delete"] = function(name) {
          delete this.map[normalizeName(name)];
        };
        Headers.prototype.get = function(name) {
          name = normalizeName(name);
          return this.has(name) ? this.map[name] : null;
        };
        Headers.prototype.has = function(name) {
          return this.map.hasOwnProperty(normalizeName(name));
        };
        Headers.prototype.set = function(name, value) {
          this.map[normalizeName(name)] = normalizeValue(value);
        };
        Headers.prototype.forEach = function(callback, thisArg) {
          for (var name in this.map) {
            if (this.map.hasOwnProperty(name)) {
              callback.call(thisArg, this.map[name], name, this);
            }
          }
        };
        Headers.prototype.keys = function() {
          var items = [];
          this.forEach(function(value, name) {
            items.push(name);
          });
          return iteratorFor(items);
        };
        Headers.prototype.values = function() {
          var items = [];
          this.forEach(function(value) {
            items.push(value);
          });
          return iteratorFor(items);
        };
        Headers.prototype.entries = function() {
          var items = [];
          this.forEach(function(value, name) {
            items.push([name, value]);
          });
          return iteratorFor(items);
        };
        if (support.iterable) {
          Headers.prototype[Symbol.iterator] = Headers.prototype.entries;
        }
        function consumed(body) {
          if (body._noBody)
            return;
          if (body.bodyUsed) {
            return Promise.reject(new TypeError("Already read"));
          }
          body.bodyUsed = true;
        }
        function fileReaderReady(reader) {
          return new Promise(function(resolve, reject) {
            reader.onload = function() {
              resolve(reader.result);
            };
            reader.onerror = function() {
              reject(reader.error);
            };
          });
        }
        function readBlobAsArrayBuffer(blob) {
          var reader = new FileReader();
          var promise = fileReaderReady(reader);
          reader.readAsArrayBuffer(blob);
          return promise;
        }
        function readBlobAsText(blob) {
          var reader = new FileReader();
          var promise = fileReaderReady(reader);
          var match = /charset=([A-Za-z0-9_-]+)/.exec(blob.type);
          var encoding = match ? match[1] : "utf-8";
          reader.readAsText(blob, encoding);
          return promise;
        }
        function readArrayBufferAsText(buf) {
          var view = new Uint8Array(buf);
          var chars = new Array(view.length);
          for (var i = 0; i < view.length; i++) {
            chars[i] = String.fromCharCode(view[i]);
          }
          return chars.join("");
        }
        function bufferClone(buf) {
          if (buf.slice) {
            return buf.slice(0);
          } else {
            var view = new Uint8Array(buf.byteLength);
            view.set(new Uint8Array(buf));
            return view.buffer;
          }
        }
        function Body() {
          this.bodyUsed = false;
          this._initBody = function(body) {
            this.bodyUsed = this.bodyUsed;
            this._bodyInit = body;
            if (!body) {
              this._noBody = true;
              this._bodyText = "";
            } else if (typeof body === "string") {
              this._bodyText = body;
            } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
              this._bodyBlob = body;
            } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
              this._bodyFormData = body;
            } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
              this._bodyText = body.toString();
            } else if (support.arrayBuffer && support.blob && isDataView(body)) {
              this._bodyArrayBuffer = bufferClone(body.buffer);
              this._bodyInit = new Blob([this._bodyArrayBuffer]);
            } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
              this._bodyArrayBuffer = bufferClone(body);
            } else {
              this._bodyText = body = Object.prototype.toString.call(body);
            }
            if (!this.headers.get("content-type")) {
              if (typeof body === "string") {
                this.headers.set("content-type", "text/plain;charset=UTF-8");
              } else if (this._bodyBlob && this._bodyBlob.type) {
                this.headers.set("content-type", this._bodyBlob.type);
              } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
                this.headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8");
              }
            }
          };
          if (support.blob) {
            this.blob = function() {
              var rejected = consumed(this);
              if (rejected) {
                return rejected;
              }
              if (this._bodyBlob) {
                return Promise.resolve(this._bodyBlob);
              } else if (this._bodyArrayBuffer) {
                return Promise.resolve(new Blob([this._bodyArrayBuffer]));
              } else if (this._bodyFormData) {
                throw new Error("could not read FormData body as blob");
              } else {
                return Promise.resolve(new Blob([this._bodyText]));
              }
            };
          }
          this.arrayBuffer = function() {
            if (this._bodyArrayBuffer) {
              var isConsumed = consumed(this);
              if (isConsumed) {
                return isConsumed;
              } else if (ArrayBuffer.isView(this._bodyArrayBuffer)) {
                return Promise.resolve(
                  this._bodyArrayBuffer.buffer.slice(
                    this._bodyArrayBuffer.byteOffset,
                    this._bodyArrayBuffer.byteOffset + this._bodyArrayBuffer.byteLength
                  )
                );
              } else {
                return Promise.resolve(this._bodyArrayBuffer);
              }
            } else if (support.blob) {
              return this.blob().then(readBlobAsArrayBuffer);
            } else {
              throw new Error("could not read as ArrayBuffer");
            }
          };
          this.text = function() {
            var rejected = consumed(this);
            if (rejected) {
              return rejected;
            }
            if (this._bodyBlob) {
              return readBlobAsText(this._bodyBlob);
            } else if (this._bodyArrayBuffer) {
              return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer));
            } else if (this._bodyFormData) {
              throw new Error("could not read FormData body as text");
            } else {
              return Promise.resolve(this._bodyText);
            }
          };
          if (support.formData) {
            this.formData = function() {
              return this.text().then(decode);
            };
          }
          this.json = function() {
            return this.text().then(JSON.parse);
          };
          return this;
        }
        var methods = ["CONNECT", "DELETE", "GET", "HEAD", "OPTIONS", "PATCH", "POST", "PUT", "TRACE"];
        function normalizeMethod(method) {
          var upcased = method.toUpperCase();
          return methods.indexOf(upcased) > -1 ? upcased : method;
        }
        function Request(input, options) {
          if (!(this instanceof Request)) {
            throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
          }
          options = options || {};
          var body = options.body;
          if (input instanceof Request) {
            if (input.bodyUsed) {
              throw new TypeError("Already read");
            }
            this.url = input.url;
            this.credentials = input.credentials;
            if (!options.headers) {
              this.headers = new Headers(input.headers);
            }
            this.method = input.method;
            this.mode = input.mode;
            this.signal = input.signal;
            if (!body && input._bodyInit != null) {
              body = input._bodyInit;
              input.bodyUsed = true;
            }
          } else {
            this.url = String(input);
          }
          this.credentials = options.credentials || this.credentials || "same-origin";
          if (options.headers || !this.headers) {
            this.headers = new Headers(options.headers);
          }
          this.method = normalizeMethod(options.method || this.method || "GET");
          this.mode = options.mode || this.mode || null;
          this.signal = options.signal || this.signal || function() {
            if ("AbortController" in g) {
              var ctrl = new AbortController();
              return ctrl.signal;
            }
          }();
          this.referrer = null;
          if ((this.method === "GET" || this.method === "HEAD") && body) {
            throw new TypeError("Body not allowed for GET or HEAD requests");
          }
          this._initBody(body);
          if (this.method === "GET" || this.method === "HEAD") {
            if (options.cache === "no-store" || options.cache === "no-cache") {
              var reParamSearch = /([?&])_=[^&]*/;
              if (reParamSearch.test(this.url)) {
                this.url = this.url.replace(reParamSearch, "$1_=" + (/* @__PURE__ */ new Date()).getTime());
              } else {
                var reQueryString = /\?/;
                this.url += (reQueryString.test(this.url) ? "&" : "?") + "_=" + (/* @__PURE__ */ new Date()).getTime();
              }
            }
          }
        }
        Request.prototype.clone = function() {
          return new Request(this, { body: this._bodyInit });
        };
        function decode(body) {
          var form = new FormData();
          body.trim().split("&").forEach(function(bytes) {
            if (bytes) {
              var split = bytes.split("=");
              var name = split.shift().replace(/\+/g, " ");
              var value = split.join("=").replace(/\+/g, " ");
              form.append(decodeURIComponent(name), decodeURIComponent(value));
            }
          });
          return form;
        }
        function parseHeaders(rawHeaders) {
          var headers = new Headers();
          var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, " ");
          preProcessedHeaders.split("\r").map(function(header) {
            return header.indexOf("\n") === 0 ? header.substr(1, header.length) : header;
          }).forEach(function(line) {
            var parts = line.split(":");
            var key = parts.shift().trim();
            if (key) {
              var value = parts.join(":").trim();
              try {
                headers.append(key, value);
              } catch (error) {
                console.warn("Response " + error.message);
              }
            }
          });
          return headers;
        }
        Body.call(Request.prototype);
        function Response(bodyInit, options) {
          if (!(this instanceof Response)) {
            throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
          }
          if (!options) {
            options = {};
          }
          this.type = "default";
          this.status = options.status === void 0 ? 200 : options.status;
          if (this.status < 200 || this.status > 599) {
            throw new RangeError("Failed to construct 'Response': The status provided (0) is outside the range [200, 599].");
          }
          this.ok = this.status >= 200 && this.status < 300;
          this.statusText = options.statusText === void 0 ? "" : "" + options.statusText;
          this.headers = new Headers(options.headers);
          this.url = options.url || "";
          this._initBody(bodyInit);
        }
        Body.call(Response.prototype);
        Response.prototype.clone = function() {
          return new Response(this._bodyInit, {
            status: this.status,
            statusText: this.statusText,
            headers: new Headers(this.headers),
            url: this.url
          });
        };
        Response.error = function() {
          var response = new Response(null, { status: 200, statusText: "" });
          response.ok = false;
          response.status = 0;
          response.type = "error";
          return response;
        };
        var redirectStatuses = [301, 302, 303, 307, 308];
        Response.redirect = function(url, status) {
          if (redirectStatuses.indexOf(status) === -1) {
            throw new RangeError("Invalid status code");
          }
          return new Response(null, { status, headers: { location: url } });
        };
        exports2.DOMException = g.DOMException;
        try {
          new exports2.DOMException();
        } catch (err) {
          exports2.DOMException = function(message, name) {
            this.message = message;
            this.name = name;
            var error = Error(message);
            this.stack = error.stack;
          };
          exports2.DOMException.prototype = Object.create(Error.prototype);
          exports2.DOMException.prototype.constructor = exports2.DOMException;
        }
        function fetch(input, init) {
          return new Promise(function(resolve, reject) {
            var request = new Request(input, init);
            if (request.signal && request.signal.aborted) {
              return reject(new exports2.DOMException("Aborted", "AbortError"));
            }
            var xhr = new XMLHttpRequest();
            function abortXhr() {
              xhr.abort();
            }
            xhr.onload = function() {
              var options = {
                statusText: xhr.statusText,
                headers: parseHeaders(xhr.getAllResponseHeaders() || "")
              };
              if (request.url.indexOf("file://") === 0 && (xhr.status < 200 || xhr.status > 599)) {
                options.status = 200;
              } else {
                options.status = xhr.status;
              }
              options.url = "responseURL" in xhr ? xhr.responseURL : options.headers.get("X-Request-URL");
              var body = "response" in xhr ? xhr.response : xhr.responseText;
              setTimeout(function() {
                resolve(new Response(body, options));
              }, 0);
            };
            xhr.onerror = function() {
              setTimeout(function() {
                reject(new TypeError("Network request failed"));
              }, 0);
            };
            xhr.ontimeout = function() {
              setTimeout(function() {
                reject(new TypeError("Network request timed out"));
              }, 0);
            };
            xhr.onabort = function() {
              setTimeout(function() {
                reject(new exports2.DOMException("Aborted", "AbortError"));
              }, 0);
            };
            function fixUrl(url) {
              try {
                return url === "" && g.location.href ? g.location.href : url;
              } catch (e) {
                return url;
              }
            }
            xhr.open(request.method, fixUrl(request.url), true);
            if (request.credentials === "include") {
              xhr.withCredentials = true;
            } else if (request.credentials === "omit") {
              xhr.withCredentials = false;
            }
            if ("responseType" in xhr) {
              if (support.blob) {
                xhr.responseType = "blob";
              } else if (support.arrayBuffer) {
                xhr.responseType = "arraybuffer";
              }
            }
            if (init && typeof init.headers === "object" && !(init.headers instanceof Headers || g.Headers && init.headers instanceof g.Headers)) {
              var names = [];
              Object.getOwnPropertyNames(init.headers).forEach(function(name) {
                names.push(normalizeName(name));
                xhr.setRequestHeader(name, normalizeValue(init.headers[name]));
              });
              request.headers.forEach(function(value, name) {
                if (names.indexOf(name) === -1) {
                  xhr.setRequestHeader(name, value);
                }
              });
            } else {
              request.headers.forEach(function(value, name) {
                xhr.setRequestHeader(name, value);
              });
            }
            if (request.signal) {
              request.signal.addEventListener("abort", abortXhr);
              xhr.onreadystatechange = function() {
                if (xhr.readyState === 4) {
                  request.signal.removeEventListener("abort", abortXhr);
                }
              };
            }
            xhr.send(typeof request._bodyInit === "undefined" ? null : request._bodyInit);
          });
        }
        fetch.polyfill = true;
        if (!g.fetch) {
          g.fetch = fetch;
          g.Headers = Headers;
          g.Request = Request;
          g.Response = Response;
        }
        exports2.Headers = Headers;
        exports2.Request = Request;
        exports2.Response = Response;
        exports2.fetch = fetch;
        return exports2;
      }({});
    })(__globalThis__);
    __globalThis__.fetch.ponyfill = true;
    delete __globalThis__.fetch.polyfill;
    var ctx = __global__.fetch ? __global__ : __globalThis__;
    exports = ctx.fetch;
    exports.default = ctx.fetch;
    exports.fetch = ctx.fetch;
    exports.Headers = ctx.Headers;
    exports.Request = ctx.Request;
    exports.Response = ctx.Response;
    module.exports = exports;
  }
});

// ../../node_modules/.pnpm/@cosmjs+tendermint-rpc@0.34.0/node_modules/@cosmjs/tendermint-rpc/build/rpcclients/http.js
var require_http = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+tendermint-rpc@0.34.0/node_modules/@cosmjs/tendermint-rpc/build/rpcclients/http.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.http = http;
    var cross_fetch_1 = __importDefault(require_browser_ponyfill());
    function filterBadStatus(res) {
      if (res.status >= 400) {
        throw new Error(`Bad status on response: ${res.status}`);
      }
      return res;
    }
    async function http(method, url, headers, request) {
      const settings = {
        method,
        body: request ? JSON.stringify(request) : void 0,
        headers: {
          // eslint-disable-next-line @typescript-eslint/naming-convention
          "Content-Type": "application/json",
          ...headers
        }
      };
      return (0, cross_fetch_1.default)(url, settings).then(filterBadStatus).then((res) => res.json());
    }
  }
});

// ../../node_modules/.pnpm/@cosmjs+tendermint-rpc@0.34.0/node_modules/@cosmjs/tendermint-rpc/build/rpcclients/rpcclient.js
var require_rpcclient = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+tendermint-rpc@0.34.0/node_modules/@cosmjs/tendermint-rpc/build/rpcclients/rpcclient.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.instanceOfRpcStreamingClient = instanceOfRpcStreamingClient;
    exports.hasProtocol = hasProtocol;
    function instanceOfRpcStreamingClient(client) {
      return typeof client.listen === "function";
    }
    function hasProtocol(url) {
      return url.search("://") !== -1;
    }
  }
});

// ../../node_modules/.pnpm/@cosmjs+tendermint-rpc@0.34.0/node_modules/@cosmjs/tendermint-rpc/build/rpcclients/httpbatchclient.js
var require_httpbatchclient = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+tendermint-rpc@0.34.0/node_modules/@cosmjs/tendermint-rpc/build/rpcclients/httpbatchclient.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.HttpBatchClient = void 0;
    var json_rpc_1 = require_build8();
    var http_1 = require_http();
    var rpcclient_1 = require_rpcclient();
    var defaultHttpBatchClientOptions = {
      dispatchInterval: 20,
      batchSizeLimit: 20
    };
    var HttpBatchClient = class {
      constructor(endpoint, options = {}) {
        this.queue = [];
        this.options = {
          batchSizeLimit: options.batchSizeLimit ?? defaultHttpBatchClientOptions.batchSizeLimit,
          dispatchInterval: options.dispatchInterval ?? defaultHttpBatchClientOptions.dispatchInterval
        };
        if (typeof endpoint === "string") {
          if (!(0, rpcclient_1.hasProtocol)(endpoint)) {
            throw new Error("Endpoint URL is missing a protocol. Expected 'https://' or 'http://'.");
          }
          this.url = endpoint;
        } else {
          this.url = endpoint.url;
          this.headers = endpoint.headers;
        }
        this.timer = setInterval(() => this.tick(), options.dispatchInterval);
        this.validate();
      }
      disconnect() {
        this.timer && clearInterval(this.timer);
        this.timer = void 0;
      }
      async execute(request) {
        return new Promise((resolve, reject) => {
          this.queue.push({ request, resolve, reject });
          if (this.queue.length >= this.options.batchSizeLimit) {
            this.tick();
          }
        });
      }
      validate() {
        if (!this.options.batchSizeLimit || !Number.isSafeInteger(this.options.batchSizeLimit) || this.options.batchSizeLimit < 1) {
          throw new Error("batchSizeLimit must be a safe integer >= 1");
        }
      }
      /**
       * This is called in an interval where promise rejections cannot be handled.
       * So this is not async and HTTP errors need to be handled by the queued promises.
       */
      tick() {
        const batch = this.queue.splice(0, this.options.batchSizeLimit);
        if (!batch.length)
          return;
        const requests = batch.map((s) => s.request);
        const requestIds = requests.map((request) => request.id);
        (0, http_1.http)("POST", this.url, this.headers, requests).then((raw) => {
          const arr = Array.isArray(raw) ? raw : [raw];
          arr.forEach((el) => {
            const req = batch.find((s) => s.request.id === el.id);
            if (!req)
              return;
            const { reject, resolve } = req;
            const response = (0, json_rpc_1.parseJsonRpcResponse)(el);
            if ((0, json_rpc_1.isJsonRpcErrorResponse)(response)) {
              reject(new Error(JSON.stringify(response.error)));
            } else {
              resolve(response);
            }
          });
        }, (error) => {
          for (const requestId of requestIds) {
            const req = batch.find((s) => s.request.id === requestId);
            if (!req)
              return;
            req.reject(error);
          }
        });
      }
    };
    exports.HttpBatchClient = HttpBatchClient;
  }
});

// ../../node_modules/.pnpm/@cosmjs+tendermint-rpc@0.34.0/node_modules/@cosmjs/tendermint-rpc/build/rpcclients/httpclient.js
var require_httpclient = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+tendermint-rpc@0.34.0/node_modules/@cosmjs/tendermint-rpc/build/rpcclients/httpclient.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.HttpClient = void 0;
    var json_rpc_1 = require_build8();
    var http_1 = require_http();
    var rpcclient_1 = require_rpcclient();
    var HttpClient = class {
      constructor(endpoint) {
        if (typeof endpoint === "string") {
          if (!(0, rpcclient_1.hasProtocol)(endpoint)) {
            throw new Error("Endpoint URL is missing a protocol. Expected 'https://' or 'http://'.");
          }
          this.url = endpoint;
        } else {
          this.url = endpoint.url;
          this.headers = endpoint.headers;
        }
      }
      disconnect() {
      }
      async execute(request) {
        const response = (0, json_rpc_1.parseJsonRpcResponse)(await (0, http_1.http)("POST", this.url, this.headers, request));
        if ((0, json_rpc_1.isJsonRpcErrorResponse)(response)) {
          throw new Error(JSON.stringify(response.error));
        }
        return response;
      }
    };
    exports.HttpClient = HttpClient;
  }
});

// ../../node_modules/.pnpm/@cosmjs+socket@0.34.0/node_modules/@cosmjs/socket/build/socketwrapper.js
var require_socketwrapper = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+socket@0.34.0/node_modules/@cosmjs/socket/build/socketwrapper.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SocketWrapper = void 0;
    var isomorphic_ws_1 = __importDefault(require_browser());
    function environmentIsNodeJs() {
      return typeof process !== "undefined" && typeof process.versions !== "undefined" && typeof process.versions.node !== "undefined";
    }
    var SocketWrapper = class {
      constructor(url, messageHandler, errorHandler, openHandler, closeHandler, timeout = 1e4) {
        this.closed = false;
        this.connected = new Promise((resolve, reject) => {
          this.connectedResolver = resolve;
          this.connectedRejecter = reject;
        });
        this.url = url;
        this.messageHandler = messageHandler;
        this.errorHandler = errorHandler;
        this.openHandler = openHandler;
        this.closeHandler = closeHandler;
        this.timeout = timeout;
      }
      /**
       * returns a promise that resolves when connection is open
       */
      connect() {
        const socket = new isomorphic_ws_1.default(this.url);
        socket.onerror = (error) => {
          this.clearTimeout();
          if (this.errorHandler) {
            this.errorHandler(error);
          }
        };
        socket.onmessage = (messageEvent) => {
          this.messageHandler({
            type: messageEvent.type,
            data: messageEvent.data
          });
        };
        socket.onopen = (_) => {
          this.clearTimeout();
          this.connectedResolver();
          if (this.openHandler) {
            this.openHandler();
          }
        };
        socket.onclose = (closeEvent) => {
          this.closed = true;
          if (this.closeHandler) {
            this.closeHandler(closeEvent);
          }
        };
        const started = Date.now();
        this.timeoutId = setTimeout(() => {
          socket.onmessage = () => 0;
          socket.onerror = () => 0;
          socket.onopen = () => 0;
          socket.onclose = () => 0;
          socket.close();
          this.socket = void 0;
          const elapsed = Math.floor(Date.now() - started);
          this.connectedRejecter(`Connection attempt timed out after ${elapsed} ms`);
        }, this.timeout);
        this.socket = socket;
      }
      /**
       * Closes an established connection and aborts other connection states
       */
      disconnect() {
        if (!this.socket) {
          throw new Error("Socket undefined. This must be called after connecting.");
        }
        this.clearTimeout();
        switch (this.socket.readyState) {
          case isomorphic_ws_1.default.OPEN:
            this.socket.close(
              1e3
              /* Normal Closure */
            );
            break;
          case isomorphic_ws_1.default.CLOSED:
            break;
          case isomorphic_ws_1.default.CONNECTING:
            this.socket.onopen = () => 0;
            this.socket.onclose = () => 0;
            this.socket.onerror = () => 0;
            this.socket.onmessage = () => 0;
            this.socket = void 0;
            if (this.closeHandler) {
              this.closeHandler({ wasClean: false, code: 4001 });
            }
            break;
          case isomorphic_ws_1.default.CLOSING:
            break;
          default:
            throw new Error(`Unknown readyState: ${this.socket.readyState}`);
        }
      }
      async send(data) {
        return new Promise((resolve, reject) => {
          if (!this.socket) {
            throw new Error("Socket undefined. This must be called after connecting.");
          }
          if (this.closed) {
            throw new Error("Socket was closed, so no data can be sent anymore.");
          }
          if (this.socket.readyState !== isomorphic_ws_1.default.OPEN) {
            throw new Error("Websocket is not open");
          }
          if (environmentIsNodeJs()) {
            this.socket.send(data, (err) => err ? reject(err) : resolve());
          } else {
            this.socket.send(data);
            resolve();
          }
        });
      }
      /**
       * Clears the timeout function, such that no timeout error will be raised anymore. This should be
       * called when the connection is established, a connection error occurred or the socket is disconnected.
       *
       * This method must not be called before `connect()`.
       * This method is idempotent.
       */
      clearTimeout() {
        if (!this.timeoutId) {
          throw new Error("Timeout ID not set. This should not happen and usually means connect() was not called.");
        }
        clearTimeout(this.timeoutId);
      }
    };
    exports.SocketWrapper = SocketWrapper;
  }
});

// ../../node_modules/.pnpm/@cosmjs+socket@0.34.0/node_modules/@cosmjs/socket/build/streamingsocket.js
var require_streamingsocket = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+socket@0.34.0/node_modules/@cosmjs/socket/build/streamingsocket.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.StreamingSocket = void 0;
    var xstream_1 = require_xstream();
    var socketwrapper_1 = require_socketwrapper();
    var StreamingSocket = class {
      constructor(url, timeout = 1e4) {
        this.socket = new socketwrapper_1.SocketWrapper(url, (event) => {
          if (this.eventProducerListener) {
            this.eventProducerListener.next(event);
          }
        }, (errorEvent) => {
          if (this.eventProducerListener) {
            this.eventProducerListener.error(errorEvent);
          }
        }, () => {
        }, (closeEvent) => {
          if (this.eventProducerListener) {
            if (closeEvent.wasClean) {
              this.eventProducerListener.complete();
            } else {
              this.eventProducerListener.error("Socket was closed unclean");
            }
          }
        }, timeout);
        this.connected = this.socket.connected;
        const eventProducer = {
          start: (listener) => this.eventProducerListener = listener,
          stop: () => this.eventProducerListener = void 0
        };
        this.events = xstream_1.Stream.create(eventProducer);
      }
      connect() {
        this.socket.connect();
      }
      disconnect() {
        this.socket.disconnect();
      }
      async send(data) {
        return this.socket.send(data);
      }
    };
    exports.StreamingSocket = StreamingSocket;
  }
});

// ../../node_modules/.pnpm/@cosmjs+socket@0.34.0/node_modules/@cosmjs/socket/build/queueingstreamingsocket.js
var require_queueingstreamingsocket = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+socket@0.34.0/node_modules/@cosmjs/socket/build/queueingstreamingsocket.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.QueueingStreamingSocket = exports.ConnectionStatus = void 0;
    var stream_1 = require_build7();
    var xstream_1 = require_xstream();
    var streamingsocket_1 = require_streamingsocket();
    var ConnectionStatus;
    (function(ConnectionStatus2) {
      ConnectionStatus2[ConnectionStatus2["Unconnected"] = 0] = "Unconnected";
      ConnectionStatus2[ConnectionStatus2["Connecting"] = 1] = "Connecting";
      ConnectionStatus2[ConnectionStatus2["Connected"] = 2] = "Connected";
      ConnectionStatus2[ConnectionStatus2["Disconnected"] = 3] = "Disconnected";
    })(ConnectionStatus || (exports.ConnectionStatus = ConnectionStatus = {}));
    var QueueingStreamingSocket = class {
      constructor(url, timeout = 1e4, reconnectedHandler) {
        this.queue = [];
        this.isProcessingQueue = false;
        this.url = url;
        this.timeout = timeout;
        this.reconnectedHandler = reconnectedHandler;
        const eventProducer = {
          start: (listener) => this.eventProducerListener = listener,
          stop: () => this.eventProducerListener = void 0
        };
        this.events = xstream_1.Stream.create(eventProducer);
        this.connectionStatusProducer = new stream_1.DefaultValueProducer(ConnectionStatus.Unconnected);
        this.connectionStatus = new stream_1.ValueAndUpdates(this.connectionStatusProducer);
        this.socket = new streamingsocket_1.StreamingSocket(this.url, this.timeout);
        this.socket.events.subscribe({
          next: (event) => {
            if (!this.eventProducerListener)
              throw new Error("No event producer listener set");
            this.eventProducerListener.next(event);
          },
          error: () => this.connectionStatusProducer.update(ConnectionStatus.Disconnected)
        });
      }
      connect() {
        this.connectionStatusProducer.update(ConnectionStatus.Connecting);
        this.socket.connected.then(async () => {
          this.connectionStatusProducer.update(ConnectionStatus.Connected);
          return this.processQueue();
        }, () => this.connectionStatusProducer.update(ConnectionStatus.Disconnected));
        this.socket.connect();
      }
      disconnect() {
        this.connectionStatusProducer.update(ConnectionStatus.Disconnected);
        this.socket.disconnect();
      }
      reconnect() {
        this.socket = new streamingsocket_1.StreamingSocket(this.url, this.timeout);
        this.socket.events.subscribe({
          next: (event) => {
            if (!this.eventProducerListener)
              throw new Error("No event producer listener set");
            this.eventProducerListener.next(event);
          },
          error: () => this.connectionStatusProducer.update(ConnectionStatus.Disconnected)
        });
        this.socket.connected.then(() => {
          if (this.reconnectedHandler) {
            this.reconnectedHandler();
          }
        });
        this.connect();
      }
      getQueueLength() {
        return this.queue.length;
      }
      queueRequest(request) {
        this.queue.push(request);
        this.processQueue();
      }
      async processQueue() {
        if (this.isProcessingQueue || this.connectionStatus.value !== ConnectionStatus.Connected) {
          return;
        }
        this.isProcessingQueue = true;
        let request;
        while (request = this.queue.shift()) {
          try {
            await this.socket.send(request);
            this.isProcessingQueue = false;
          } catch (error) {
            this.queue.unshift(request);
            this.isProcessingQueue = false;
            return;
          }
        }
      }
    };
    exports.QueueingStreamingSocket = QueueingStreamingSocket;
  }
});

// ../../node_modules/.pnpm/@cosmjs+socket@0.34.0/node_modules/@cosmjs/socket/build/reconnectingsocket.js
var require_reconnectingsocket = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+socket@0.34.0/node_modules/@cosmjs/socket/build/reconnectingsocket.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ReconnectingSocket = void 0;
    var xstream_1 = require_xstream();
    var queueingstreamingsocket_1 = require_queueingstreamingsocket();
    var ReconnectingSocket = class _ReconnectingSocket {
      /** Starts with a 0.1 second timeout, then doubles every attempt with a maximum timeout of 5 seconds. */
      static calculateTimeout(index) {
        return Math.min(2 ** index * 100, 5e3);
      }
      constructor(url, timeout = 1e4, reconnectedHandler) {
        this.unconnected = true;
        this.disconnected = false;
        this.timeoutIndex = 0;
        this.reconnectTimeout = null;
        const eventProducer = {
          start: (listener) => this.eventProducerListener = listener,
          stop: () => this.eventProducerListener = void 0
        };
        this.events = xstream_1.Stream.create(eventProducer);
        this.socket = new queueingstreamingsocket_1.QueueingStreamingSocket(url, timeout, reconnectedHandler);
        this.socket.events.subscribe({
          next: (event) => {
            if (this.eventProducerListener) {
              this.eventProducerListener.next(event);
            }
          },
          error: (error) => {
            if (this.eventProducerListener) {
              this.eventProducerListener.error(error);
            }
          }
        });
        this.connectionStatus = this.socket.connectionStatus;
        this.connectionStatus.updates.subscribe({
          next: (status) => {
            if (status === queueingstreamingsocket_1.ConnectionStatus.Connected) {
              this.timeoutIndex = 0;
            }
            if (status === queueingstreamingsocket_1.ConnectionStatus.Disconnected) {
              if (this.reconnectTimeout) {
                clearTimeout(this.reconnectTimeout);
                this.reconnectTimeout = null;
              }
              this.reconnectTimeout = setTimeout(() => this.socket.reconnect(), _ReconnectingSocket.calculateTimeout(this.timeoutIndex++));
            }
          }
        });
      }
      connect() {
        if (!this.unconnected) {
          throw new Error("Cannot connect: socket has already connected");
        }
        this.socket.connect();
        this.unconnected = false;
      }
      disconnect() {
        if (this.unconnected) {
          throw new Error("Cannot disconnect: socket has not yet connected");
        }
        this.socket.disconnect();
        if (this.eventProducerListener) {
          this.eventProducerListener.complete();
        }
        this.disconnected = true;
      }
      queueRequest(request) {
        if (this.disconnected) {
          throw new Error("Cannot queue request: socket has disconnected");
        }
        this.socket.queueRequest(request);
      }
    };
    exports.ReconnectingSocket = ReconnectingSocket;
  }
});

// ../../node_modules/.pnpm/@cosmjs+socket@0.34.0/node_modules/@cosmjs/socket/build/index.js
var require_build9 = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+socket@0.34.0/node_modules/@cosmjs/socket/build/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.StreamingSocket = exports.SocketWrapper = exports.ReconnectingSocket = exports.QueueingStreamingSocket = exports.ConnectionStatus = void 0;
    var queueingstreamingsocket_1 = require_queueingstreamingsocket();
    Object.defineProperty(exports, "ConnectionStatus", { enumerable: true, get: function() {
      return queueingstreamingsocket_1.ConnectionStatus;
    } });
    Object.defineProperty(exports, "QueueingStreamingSocket", { enumerable: true, get: function() {
      return queueingstreamingsocket_1.QueueingStreamingSocket;
    } });
    var reconnectingsocket_1 = require_reconnectingsocket();
    Object.defineProperty(exports, "ReconnectingSocket", { enumerable: true, get: function() {
      return reconnectingsocket_1.ReconnectingSocket;
    } });
    var socketwrapper_1 = require_socketwrapper();
    Object.defineProperty(exports, "SocketWrapper", { enumerable: true, get: function() {
      return socketwrapper_1.SocketWrapper;
    } });
    var streamingsocket_1 = require_streamingsocket();
    Object.defineProperty(exports, "StreamingSocket", { enumerable: true, get: function() {
      return streamingsocket_1.StreamingSocket;
    } });
  }
});

// ../../node_modules/.pnpm/@cosmjs+tendermint-rpc@0.34.0/node_modules/@cosmjs/tendermint-rpc/build/rpcclients/websocketclient.js
var require_websocketclient = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+tendermint-rpc@0.34.0/node_modules/@cosmjs/tendermint-rpc/build/rpcclients/websocketclient.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WebsocketClient = void 0;
    var json_rpc_1 = require_build8();
    var socket_1 = require_build9();
    var stream_1 = require_build7();
    var xstream_1 = require_xstream();
    var rpcclient_1 = require_rpcclient();
    function defaultErrorHandler(error) {
      throw error;
    }
    function toJsonRpcResponse(message) {
      if (message.type !== "message") {
        throw new Error(`Unexcepted message type on websocket: ${message.type}`);
      }
      const jsonRpcEvent = (0, json_rpc_1.parseJsonRpcResponse)(JSON.parse(message.data));
      return jsonRpcEvent;
    }
    var RpcEventProducer = class {
      constructor(request, socket) {
        this.running = false;
        this.subscriptions = [];
        this.request = request;
        this.socket = socket;
      }
      /**
       * Implementation of Producer.start
       */
      start(listener) {
        if (this.running) {
          throw Error("Already started. Please stop first before restarting.");
        }
        this.running = true;
        this.connectToClient(listener);
        this.socket.queueRequest(JSON.stringify(this.request));
      }
      /**
       * Implementation of Producer.stop
       *
       * Called by the stream when the stream's last listener stopped listening
       * or when the producer completed.
       */
      stop() {
        this.running = false;
        const endRequest = { ...this.request, method: "unsubscribe" };
        try {
          this.socket.queueRequest(JSON.stringify(endRequest));
        } catch (error) {
          if (error instanceof Error && error.message.match(/socket has disconnected/i)) {
          } else {
            throw error;
          }
        }
      }
      connectToClient(listener) {
        const responseStream = this.socket.events.map(toJsonRpcResponse);
        const idSubscription = responseStream.filter((response) => response.id === this.request.id).subscribe({
          next: (response) => {
            if ((0, json_rpc_1.isJsonRpcErrorResponse)(response)) {
              this.closeSubscriptions();
              listener.error(JSON.stringify(response.error));
            }
            idSubscription.unsubscribe();
          }
        });
        const idEventSubscription = responseStream.filter((response) => response.id === this.request.id).subscribe({
          next: (response) => {
            if ((0, json_rpc_1.isJsonRpcErrorResponse)(response)) {
              this.closeSubscriptions();
              listener.error(JSON.stringify(response.error));
            } else {
              listener.next(response.result);
            }
          }
        });
        const nonResponseSubscription = responseStream.subscribe({
          error: (error) => {
            this.closeSubscriptions();
            listener.error(error);
          },
          complete: () => {
            this.closeSubscriptions();
            listener.complete();
          }
        });
        this.subscriptions.push(idSubscription, idEventSubscription, nonResponseSubscription);
      }
      closeSubscriptions() {
        for (const subscription of this.subscriptions) {
          subscription.unsubscribe();
        }
        this.subscriptions = [];
      }
    };
    var WebsocketClient = class {
      constructor(baseUrl, onError = defaultErrorHandler) {
        this.subscriptionStreams = /* @__PURE__ */ new Map();
        if (!(0, rpcclient_1.hasProtocol)(baseUrl)) {
          throw new Error("Base URL is missing a protocol. Expected 'ws://' or 'wss://'.");
        }
        const path = baseUrl.endsWith("/") ? "websocket" : "/websocket";
        this.url = baseUrl + path;
        this.socket = new socket_1.ReconnectingSocket(this.url);
        const errorSubscription = this.socket.events.subscribe({
          error: (error) => {
            onError(error);
            errorSubscription.unsubscribe();
          }
        });
        this.jsonRpcResponseStream = this.socket.events.map(toJsonRpcResponse);
        this.socket.connect();
      }
      async execute(request) {
        const pendingResponse = this.responseForRequestId(request.id);
        this.socket.queueRequest(JSON.stringify(request));
        const response = await pendingResponse;
        if ((0, json_rpc_1.isJsonRpcErrorResponse)(response)) {
          throw new Error(JSON.stringify(response.error));
        }
        return response;
      }
      listen(request) {
        if (request.method !== "subscribe") {
          throw new Error(`Request method must be "subscribe" to start event listening`);
        }
        const query = request.params.query;
        if (typeof query !== "string") {
          throw new Error("request.params.query must be a string");
        }
        if (!this.subscriptionStreams.has(query)) {
          const producer = new RpcEventProducer(request, this.socket);
          const stream = xstream_1.Stream.create(producer);
          this.subscriptionStreams.set(query, stream);
        }
        return this.subscriptionStreams.get(query).filter((response) => response.query !== void 0);
      }
      /**
       * Resolves as soon as websocket is connected. execute() queues requests automatically,
       * so this should be required for testing purposes only.
       */
      async connected() {
        await this.socket.connectionStatus.waitFor(socket_1.ConnectionStatus.Connected);
      }
      disconnect() {
        this.socket.disconnect();
      }
      async responseForRequestId(id) {
        return (0, stream_1.firstEvent)(this.jsonRpcResponseStream.filter((r) => r.id === id));
      }
    };
    exports.WebsocketClient = WebsocketClient;
  }
});

// ../../node_modules/.pnpm/@cosmjs+tendermint-rpc@0.34.0/node_modules/@cosmjs/tendermint-rpc/build/rpcclients/index.js
var require_rpcclients = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+tendermint-rpc@0.34.0/node_modules/@cosmjs/tendermint-rpc/build/rpcclients/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WebsocketClient = exports.instanceOfRpcStreamingClient = exports.HttpClient = exports.HttpBatchClient = void 0;
    var httpbatchclient_1 = require_httpbatchclient();
    Object.defineProperty(exports, "HttpBatchClient", { enumerable: true, get: function() {
      return httpbatchclient_1.HttpBatchClient;
    } });
    var httpclient_1 = require_httpclient();
    Object.defineProperty(exports, "HttpClient", { enumerable: true, get: function() {
      return httpclient_1.HttpClient;
    } });
    var rpcclient_1 = require_rpcclient();
    Object.defineProperty(exports, "instanceOfRpcStreamingClient", { enumerable: true, get: function() {
      return rpcclient_1.instanceOfRpcStreamingClient;
    } });
    var websocketclient_1 = require_websocketclient();
    Object.defineProperty(exports, "WebsocketClient", { enumerable: true, get: function() {
      return websocketclient_1.WebsocketClient;
    } });
  }
});

// ../../node_modules/.pnpm/@cosmjs+tendermint-rpc@0.34.0/node_modules/@cosmjs/tendermint-rpc/build/tendermint34/encodings.js
var require_encodings = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+tendermint-rpc@0.34.0/node_modules/@cosmjs/tendermint-rpc/build/tendermint34/encodings.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.assertSet = assertSet;
    exports.assertBoolean = assertBoolean;
    exports.assertString = assertString;
    exports.assertNumber = assertNumber;
    exports.assertArray = assertArray;
    exports.assertObject = assertObject;
    exports.assertNotEmpty = assertNotEmpty;
    exports.may = may;
    exports.dictionaryToStringMap = dictionaryToStringMap;
    exports.encodeString = encodeString;
    exports.encodeUvarint = encodeUvarint;
    exports.encodeTime = encodeTime;
    exports.encodeBytes = encodeBytes;
    exports.encodeVersion = encodeVersion;
    exports.encodeBlockId = encodeBlockId;
    var encoding_1 = require_build();
    function assertSet(value) {
      if (value === void 0) {
        throw new Error("Value must not be undefined");
      }
      if (value === null) {
        throw new Error("Value must not be null");
      }
      return value;
    }
    function assertBoolean(value) {
      assertSet(value);
      if (typeof value !== "boolean") {
        throw new Error("Value must be a boolean");
      }
      return value;
    }
    function assertString(value) {
      assertSet(value);
      if (typeof value !== "string") {
        throw new Error("Value must be a string");
      }
      return value;
    }
    function assertNumber(value) {
      assertSet(value);
      if (typeof value !== "number") {
        throw new Error("Value must be a number");
      }
      return value;
    }
    function assertArray(value) {
      assertSet(value);
      if (!Array.isArray(value)) {
        throw new Error("Value must be a an array");
      }
      return value;
    }
    function assertObject(value) {
      assertSet(value);
      if (typeof value !== "object") {
        throw new Error("Value must be an object");
      }
      if (Object.prototype.toString.call(value) !== "[object Object]") {
        throw new Error("Value must be a simple object");
      }
      return value;
    }
    function assertNotEmpty(value) {
      assertSet(value);
      if (typeof value === "number" && value === 0) {
        throw new Error("must provide a non-zero value");
      } else if (value.length === 0) {
        throw new Error("must provide a non-empty value");
      }
      return value;
    }
    function may(transform, value) {
      return value === void 0 || value === null ? void 0 : transform(value);
    }
    function dictionaryToStringMap(obj) {
      const out = /* @__PURE__ */ new Map();
      for (const key of Object.keys(obj)) {
        const value = obj[key];
        if (typeof value !== "string") {
          throw new Error("Found dictionary value of type other than string");
        }
        out.set(key, value);
      }
      return out;
    }
    function encodeString(s) {
      const utf8 = (0, encoding_1.toUtf8)(s);
      return Uint8Array.from([utf8.length, ...utf8]);
    }
    function encodeUvarint(n) {
      return n >= 128 ? (
        // eslint-disable-next-line no-bitwise
        Uint8Array.from([n & 255 | 128, ...encodeUvarint(n >> 7)])
      ) : (
        // eslint-disable-next-line no-bitwise
        Uint8Array.from([n & 255])
      );
    }
    function encodeTime(time) {
      const milliseconds = time.getTime();
      const seconds = Math.floor(milliseconds / 1e3);
      const secondsArray = seconds ? [8, ...encodeUvarint(seconds)] : new Uint8Array();
      const nanoseconds = (time.nanoseconds || 0) + milliseconds % 1e3 * 1e6;
      const nanosecondsArray = nanoseconds ? [16, ...encodeUvarint(nanoseconds)] : new Uint8Array();
      return Uint8Array.from([...secondsArray, ...nanosecondsArray]);
    }
    function encodeBytes(bytes) {
      if (bytes.length >= 128)
        throw new Error("Not implemented for byte arrays of length 128 or more");
      return bytes.length ? Uint8Array.from([bytes.length, ...bytes]) : new Uint8Array();
    }
    function encodeVersion(version) {
      const blockArray = version.block ? Uint8Array.from([8, ...encodeUvarint(version.block)]) : new Uint8Array();
      const appArray = version.app ? Uint8Array.from([16, ...encodeUvarint(version.app)]) : new Uint8Array();
      return Uint8Array.from([...blockArray, ...appArray]);
    }
    function encodeBlockId(blockId) {
      return Uint8Array.from([
        10,
        blockId.hash.length,
        ...blockId.hash,
        18,
        blockId.parts.hash.length + 4,
        8,
        blockId.parts.total,
        18,
        blockId.parts.hash.length,
        ...blockId.parts.hash
      ]);
    }
  }
});

// ../../node_modules/.pnpm/@cosmjs+tendermint-rpc@0.34.0/node_modules/@cosmjs/tendermint-rpc/build/inthelpers.js
var require_inthelpers = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+tendermint-rpc@0.34.0/node_modules/@cosmjs/tendermint-rpc/build/inthelpers.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.apiToSmallInt = apiToSmallInt;
    exports.apiToBigInt = apiToBigInt;
    exports.smallIntToApi = smallIntToApi;
    var math_1 = require_build2();
    var encodings_1 = require_encodings();
    function apiToSmallInt(input) {
      const asInt = typeof input === "number" ? new math_1.Int53(input) : math_1.Int53.fromString(input);
      return asInt.toNumber();
    }
    function apiToBigInt(input) {
      (0, encodings_1.assertString)(input);
      if (!input.match(/^-?[0-9]+$/)) {
        throw new Error("Invalid string format");
      }
      return BigInt(input);
    }
    function smallIntToApi(num) {
      return new math_1.Int53(num).toString();
    }
  }
});

// ../../node_modules/.pnpm/@cosmjs+tendermint-rpc@0.34.0/node_modules/@cosmjs/tendermint-rpc/build/comet38/encodings.js
var require_encodings2 = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+tendermint-rpc@0.34.0/node_modules/@cosmjs/tendermint-rpc/build/comet38/encodings.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.assertSet = assertSet;
    exports.assertBoolean = assertBoolean;
    exports.assertString = assertString;
    exports.assertNumber = assertNumber;
    exports.assertArray = assertArray;
    exports.assertObject = assertObject;
    exports.assertNotEmpty = assertNotEmpty;
    exports.may = may;
    exports.dictionaryToStringMap = dictionaryToStringMap;
    exports.encodeString = encodeString;
    exports.encodeUvarint = encodeUvarint;
    exports.encodeTime = encodeTime;
    exports.encodeBytes = encodeBytes;
    exports.encodeVersion = encodeVersion;
    exports.encodeBlockId = encodeBlockId;
    var encoding_1 = require_build();
    function assertSet(value) {
      if (value === void 0) {
        throw new Error("Value must not be undefined");
      }
      if (value === null) {
        throw new Error("Value must not be null");
      }
      return value;
    }
    function assertBoolean(value) {
      assertSet(value);
      if (typeof value !== "boolean") {
        throw new Error("Value must be a boolean");
      }
      return value;
    }
    function assertString(value) {
      assertSet(value);
      if (typeof value !== "string") {
        throw new Error("Value must be a string");
      }
      return value;
    }
    function assertNumber(value) {
      assertSet(value);
      if (typeof value !== "number") {
        throw new Error("Value must be a number");
      }
      return value;
    }
    function assertArray(value) {
      assertSet(value);
      if (!Array.isArray(value)) {
        throw new Error("Value must be a an array");
      }
      return value;
    }
    function assertObject(value) {
      assertSet(value);
      if (typeof value !== "object") {
        throw new Error("Value must be an object");
      }
      if (Object.prototype.toString.call(value) !== "[object Object]") {
        throw new Error("Value must be a simple object");
      }
      return value;
    }
    function assertNotEmpty(value) {
      assertSet(value);
      if (typeof value === "number" && value === 0) {
        throw new Error("must provide a non-zero value");
      } else if (value.length === 0) {
        throw new Error("must provide a non-empty value");
      }
      return value;
    }
    function may(transform, value) {
      return value === void 0 || value === null ? void 0 : transform(value);
    }
    function dictionaryToStringMap(obj) {
      const out = /* @__PURE__ */ new Map();
      for (const key of Object.keys(obj)) {
        const value = obj[key];
        if (typeof value !== "string") {
          throw new Error("Found dictionary value of type other than string");
        }
        out.set(key, value);
      }
      return out;
    }
    function encodeString(s) {
      const utf8 = (0, encoding_1.toUtf8)(s);
      return Uint8Array.from([utf8.length, ...utf8]);
    }
    function encodeUvarint(n) {
      return n >= 128 ? (
        // eslint-disable-next-line no-bitwise
        Uint8Array.from([n & 255 | 128, ...encodeUvarint(n >> 7)])
      ) : (
        // eslint-disable-next-line no-bitwise
        Uint8Array.from([n & 255])
      );
    }
    function encodeTime(time) {
      const milliseconds = time.getTime();
      const seconds = Math.floor(milliseconds / 1e3);
      const secondsArray = seconds ? [8, ...encodeUvarint(seconds)] : new Uint8Array();
      const nanoseconds = (time.nanoseconds || 0) + milliseconds % 1e3 * 1e6;
      const nanosecondsArray = nanoseconds ? [16, ...encodeUvarint(nanoseconds)] : new Uint8Array();
      return Uint8Array.from([...secondsArray, ...nanosecondsArray]);
    }
    function encodeBytes(bytes) {
      if (bytes.length >= 128)
        throw new Error("Not implemented for byte arrays of length 128 or more");
      return bytes.length ? Uint8Array.from([bytes.length, ...bytes]) : new Uint8Array();
    }
    function encodeVersion(version) {
      const blockArray = version.block ? Uint8Array.from([8, ...encodeUvarint(version.block)]) : new Uint8Array();
      const appArray = version.app ? Uint8Array.from([16, ...encodeUvarint(version.app)]) : new Uint8Array();
      return Uint8Array.from([...blockArray, ...appArray]);
    }
    function encodeBlockId(blockId) {
      return Uint8Array.from([
        10,
        blockId.hash.length,
        ...blockId.hash,
        18,
        blockId.parts.hash.length + 4,
        8,
        blockId.parts.total,
        18,
        blockId.parts.hash.length,
        ...blockId.parts.hash
      ]);
    }
  }
});

// ../../node_modules/.pnpm/@cosmjs+tendermint-rpc@0.34.0/node_modules/@cosmjs/tendermint-rpc/build/comet38/requests.js
var require_requests = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+tendermint-rpc@0.34.0/node_modules/@cosmjs/tendermint-rpc/build/comet38/requests.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SubscriptionEventType = exports.Method = void 0;
    exports.buildQuery = buildQuery;
    var Method;
    (function(Method2) {
      Method2["AbciInfo"] = "abci_info";
      Method2["AbciQuery"] = "abci_query";
      Method2["Block"] = "block";
      Method2["Blockchain"] = "blockchain";
      Method2["BlockResults"] = "block_results";
      Method2["BlockSearch"] = "block_search";
      Method2["BroadcastTxAsync"] = "broadcast_tx_async";
      Method2["BroadcastTxSync"] = "broadcast_tx_sync";
      Method2["BroadcastTxCommit"] = "broadcast_tx_commit";
      Method2["Commit"] = "commit";
      Method2["Genesis"] = "genesis";
      Method2["Health"] = "health";
      Method2["NumUnconfirmedTxs"] = "num_unconfirmed_txs";
      Method2["Status"] = "status";
      Method2["Subscribe"] = "subscribe";
      Method2["Tx"] = "tx";
      Method2["TxSearch"] = "tx_search";
      Method2["Validators"] = "validators";
      Method2["Unsubscribe"] = "unsubscribe";
    })(Method || (exports.Method = Method = {}));
    var SubscriptionEventType;
    (function(SubscriptionEventType2) {
      SubscriptionEventType2["NewBlock"] = "NewBlock";
      SubscriptionEventType2["NewBlockHeader"] = "NewBlockHeader";
      SubscriptionEventType2["Tx"] = "Tx";
    })(SubscriptionEventType || (exports.SubscriptionEventType = SubscriptionEventType = {}));
    function buildQuery(components) {
      const tags = components.tags ? components.tags : [];
      const tagComponents = tags.map((tag) => `${tag.key}='${tag.value}'`);
      const rawComponents = components.raw ? [components.raw] : [];
      return [...tagComponents, ...rawComponents].join(" AND ");
    }
  }
});

// ../../node_modules/.pnpm/@cosmjs+tendermint-rpc@0.34.0/node_modules/@cosmjs/tendermint-rpc/build/comet38/adaptor/requests.js
var require_requests2 = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+tendermint-rpc@0.34.0/node_modules/@cosmjs/tendermint-rpc/build/comet38/adaptor/requests.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function() {
      var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o2) {
          var ar = [];
          for (var k in o2)
            if (Object.prototype.hasOwnProperty.call(o2, k))
              ar[ar.length] = k;
          return ar;
        };
        return ownKeys(o);
      };
      return function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k = ownKeys(mod), i = 0; i < k.length; i++)
            if (k[i] !== "default")
              __createBinding(result, mod, k[i]);
        }
        __setModuleDefault(result, mod);
        return result;
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Params = void 0;
    var encoding_1 = require_build();
    var inthelpers_1 = require_inthelpers();
    var jsonrpc_1 = require_jsonrpc();
    var encodings_1 = require_encodings2();
    var requests = __importStar(require_requests());
    function encodeHeightParam(param) {
      return {
        height: (0, encodings_1.may)(inthelpers_1.smallIntToApi, param.height)
      };
    }
    function encodeBlockchainRequestParams(param) {
      return {
        minHeight: (0, encodings_1.may)(inthelpers_1.smallIntToApi, param.minHeight),
        maxHeight: (0, encodings_1.may)(inthelpers_1.smallIntToApi, param.maxHeight)
      };
    }
    function encodeBlockSearchParams(params) {
      return {
        query: params.query,
        page: (0, encodings_1.may)(inthelpers_1.smallIntToApi, params.page),
        per_page: (0, encodings_1.may)(inthelpers_1.smallIntToApi, params.per_page),
        order_by: params.order_by
      };
    }
    function encodeAbciQueryParams(params) {
      return {
        path: (0, encodings_1.assertNotEmpty)(params.path),
        data: (0, encoding_1.toHex)(params.data),
        height: (0, encodings_1.may)(inthelpers_1.smallIntToApi, params.height),
        prove: params.prove
      };
    }
    function encodeBroadcastTxParams(params) {
      return {
        tx: (0, encoding_1.toBase64)((0, encodings_1.assertNotEmpty)(params.tx))
      };
    }
    function encodeTxParams(params) {
      return {
        hash: (0, encoding_1.toBase64)((0, encodings_1.assertNotEmpty)(params.hash)),
        prove: params.prove
      };
    }
    function encodeTxSearchParams(params) {
      return {
        query: params.query,
        prove: params.prove,
        page: (0, encodings_1.may)(inthelpers_1.smallIntToApi, params.page),
        per_page: (0, encodings_1.may)(inthelpers_1.smallIntToApi, params.per_page),
        order_by: params.order_by
      };
    }
    function encodeValidatorsParams(params) {
      return {
        height: (0, encodings_1.may)(inthelpers_1.smallIntToApi, params.height),
        page: (0, encodings_1.may)(inthelpers_1.smallIntToApi, params.page),
        per_page: (0, encodings_1.may)(inthelpers_1.smallIntToApi, params.per_page)
      };
    }
    var Params = class {
      static encodeAbciInfo(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method);
      }
      static encodeAbciQuery(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeAbciQueryParams(req.params));
      }
      static encodeBlock(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeHeightParam(req.params));
      }
      static encodeBlockchain(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeBlockchainRequestParams(req.params));
      }
      static encodeBlockResults(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeHeightParam(req.params));
      }
      static encodeBlockSearch(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeBlockSearchParams(req.params));
      }
      static encodeBroadcastTx(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeBroadcastTxParams(req.params));
      }
      static encodeCommit(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeHeightParam(req.params));
      }
      static encodeGenesis(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method);
      }
      static encodeHealth(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method);
      }
      static encodeNumUnconfirmedTxs(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method);
      }
      static encodeStatus(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method);
      }
      static encodeSubscribe(req) {
        const eventTag = { key: "tm.event", value: req.query.type };
        const query = requests.buildQuery({ tags: [eventTag], raw: req.query.raw });
        return (0, jsonrpc_1.createJsonRpcRequest)("subscribe", { query });
      }
      static encodeTx(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeTxParams(req.params));
      }
      // TODO: encode params for query string???
      static encodeTxSearch(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeTxSearchParams(req.params));
      }
      static encodeValidators(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeValidatorsParams(req.params));
      }
    };
    exports.Params = Params;
  }
});

// ../../node_modules/.pnpm/@cosmjs+tendermint-rpc@0.34.0/node_modules/@cosmjs/tendermint-rpc/build/types.js
var require_types3 = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+tendermint-rpc@0.34.0/node_modules/@cosmjs/tendermint-rpc/build/types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BlockIdFlag = void 0;
    var BlockIdFlag;
    (function(BlockIdFlag2) {
      BlockIdFlag2[BlockIdFlag2["Unknown"] = 0] = "Unknown";
      BlockIdFlag2[BlockIdFlag2["Absent"] = 1] = "Absent";
      BlockIdFlag2[BlockIdFlag2["Commit"] = 2] = "Commit";
      BlockIdFlag2[BlockIdFlag2["Nil"] = 3] = "Nil";
      BlockIdFlag2[BlockIdFlag2["Unrecognized"] = -1] = "Unrecognized";
    })(BlockIdFlag || (exports.BlockIdFlag = BlockIdFlag = {}));
  }
});

// ../../node_modules/.pnpm/@cosmjs+tendermint-rpc@0.34.0/node_modules/@cosmjs/tendermint-rpc/build/comet38/hasher.js
var require_hasher = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+tendermint-rpc@0.34.0/node_modules/@cosmjs/tendermint-rpc/build/comet38/hasher.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.hashTx = hashTx;
    exports.hashBlock = hashBlock;
    var crypto_1 = require_build4();
    var encodings_1 = require_encodings2();
    function hashTx(tx) {
      return (0, crypto_1.sha256)(tx);
    }
    function getSplitPoint(n) {
      if (n < 1)
        throw new Error("Cannot split an empty tree");
      const largestPowerOf2 = 2 ** Math.floor(Math.log2(n));
      return largestPowerOf2 < n ? largestPowerOf2 : largestPowerOf2 / 2;
    }
    function hashLeaf(leaf) {
      const hash = new crypto_1.Sha256(Uint8Array.from([0]));
      hash.update(leaf);
      return hash.digest();
    }
    function hashInner(left, right) {
      const hash = new crypto_1.Sha256(Uint8Array.from([1]));
      hash.update(left);
      hash.update(right);
      return hash.digest();
    }
    function hashTree(hashes) {
      switch (hashes.length) {
        case 0:
          throw new Error("Cannot hash empty tree");
        case 1:
          return hashLeaf(hashes[0]);
        default: {
          const slicePoint = getSplitPoint(hashes.length);
          const left = hashTree(hashes.slice(0, slicePoint));
          const right = hashTree(hashes.slice(slicePoint));
          return hashInner(left, right);
        }
      }
    }
    function hashBlock(header) {
      if (!header.lastBlockId) {
        throw new Error("Hashing a block header with no last block ID (i.e. header at height 1) is not supported. If you need this, contributions are welcome. Please add documentation and test vectors for this case.");
      }
      const encodedFields = [
        (0, encodings_1.encodeVersion)(header.version),
        (0, encodings_1.encodeString)(header.chainId),
        (0, encodings_1.encodeUvarint)(header.height),
        (0, encodings_1.encodeTime)(header.time),
        (0, encodings_1.encodeBlockId)(header.lastBlockId),
        (0, encodings_1.encodeBytes)(header.lastCommitHash),
        (0, encodings_1.encodeBytes)(header.dataHash),
        (0, encodings_1.encodeBytes)(header.validatorsHash),
        (0, encodings_1.encodeBytes)(header.nextValidatorsHash),
        (0, encodings_1.encodeBytes)(header.consensusHash),
        (0, encodings_1.encodeBytes)(header.appHash),
        (0, encodings_1.encodeBytes)(header.lastResultsHash),
        (0, encodings_1.encodeBytes)(header.evidenceHash),
        (0, encodings_1.encodeBytes)(header.proposerAddress)
      ];
      return hashTree(encodedFields);
    }
  }
});

// ../../node_modules/.pnpm/@cosmjs+tendermint-rpc@0.34.0/node_modules/@cosmjs/tendermint-rpc/build/comet38/adaptor/responses.js
var require_responses = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+tendermint-rpc@0.34.0/node_modules/@cosmjs/tendermint-rpc/build/comet38/adaptor/responses.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Responses = void 0;
    exports.decodeEvent = decodeEvent;
    exports.decodeValidatorUpdate = decodeValidatorUpdate;
    exports.decodeCommit = decodeCommit;
    exports.decodeValidatorGenesis = decodeValidatorGenesis;
    exports.decodeValidatorInfo = decodeValidatorInfo;
    var encoding_1 = require_build();
    var utils_1 = require_build3();
    var dates_1 = require_dates();
    var inthelpers_1 = require_inthelpers();
    var types_1 = require_types3();
    var encodings_1 = require_encodings2();
    var hasher_1 = require_hasher();
    function decodeAbciInfo(data) {
      return {
        data: data.data,
        lastBlockHeight: (0, encodings_1.may)(inthelpers_1.apiToSmallInt, data.last_block_height),
        lastBlockAppHash: (0, encodings_1.may)(encoding_1.fromBase64, data.last_block_app_hash)
      };
    }
    function decodeQueryProof(data) {
      return {
        ops: data.ops.map((op) => ({
          type: op.type,
          key: (0, encoding_1.fromBase64)(op.key),
          data: (0, encoding_1.fromBase64)(op.data)
        }))
      };
    }
    function decodeAbciQuery(data) {
      return {
        key: (0, encoding_1.fromBase64)((0, encodings_1.assertString)(data.key ?? "")),
        value: (0, encoding_1.fromBase64)((0, encodings_1.assertString)(data.value ?? "")),
        proof: (0, encodings_1.may)(decodeQueryProof, data.proofOps),
        height: (0, encodings_1.may)(inthelpers_1.apiToSmallInt, data.height),
        code: (0, encodings_1.may)(inthelpers_1.apiToSmallInt, data.code),
        codespace: (0, encodings_1.assertString)(data.codespace ?? ""),
        index: (0, encodings_1.may)(inthelpers_1.apiToSmallInt, data.index),
        log: data.log,
        info: (0, encodings_1.assertString)(data.info ?? "")
      };
    }
    function decodeEventAttribute(attribute) {
      return {
        key: (0, encodings_1.assertNotEmpty)(attribute.key),
        value: attribute.value ?? ""
      };
    }
    function decodeAttributes(attributes) {
      return (0, encodings_1.assertArray)(attributes).map(decodeEventAttribute);
    }
    function decodeEvent(event) {
      return {
        type: event.type,
        attributes: event.attributes ? decodeAttributes(event.attributes) : []
      };
    }
    function decodeEvents(events) {
      return (0, encodings_1.assertArray)(events).map(decodeEvent);
    }
    function decodeTxData(data) {
      return {
        code: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNumber)(data.code ?? 0)),
        codespace: data.codespace,
        log: data.log,
        data: (0, encodings_1.may)(encoding_1.fromBase64, data.data),
        events: data.events ? decodeEvents(data.events) : [],
        gasWanted: (0, inthelpers_1.apiToBigInt)(data.gas_wanted ?? "0"),
        gasUsed: (0, inthelpers_1.apiToBigInt)(data.gas_used ?? "0")
      };
    }
    function decodePubkey(data) {
      if ("Sum" in data) {
        const [[algorithm, value]] = Object.entries(data.Sum.value);
        (0, utils_1.assert)(algorithm === "ed25519" || algorithm === "secp256k1", `unknown pubkey type: ${algorithm}`);
        return {
          algorithm,
          data: (0, encoding_1.fromBase64)((0, encodings_1.assertNotEmpty)(value))
        };
      } else {
        switch (data.type) {
          case "tendermint/PubKeyEd25519":
            return {
              algorithm: "ed25519",
              data: (0, encoding_1.fromBase64)((0, encodings_1.assertNotEmpty)(data.value))
            };
          case "tendermint/PubKeySecp256k1":
            return {
              algorithm: "secp256k1",
              data: (0, encoding_1.fromBase64)((0, encodings_1.assertNotEmpty)(data.value))
            };
          default:
            throw new Error(`unknown pubkey type: ${data.type}`);
        }
      }
    }
    function decodeBlockParams(data) {
      return {
        maxBytes: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.max_bytes)),
        maxGas: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.max_gas))
      };
    }
    function decodeEvidenceParams(data) {
      return {
        maxAgeNumBlocks: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.max_age_num_blocks)),
        maxAgeDuration: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.max_age_duration))
      };
    }
    function decodeConsensusParams(data) {
      return {
        block: decodeBlockParams((0, encodings_1.assertObject)(data.block)),
        evidence: decodeEvidenceParams((0, encodings_1.assertObject)(data.evidence))
      };
    }
    function decodeValidatorUpdate(data) {
      return {
        pubkey: decodePubkey((0, encodings_1.assertObject)(data.pub_key)),
        votingPower: (0, inthelpers_1.apiToBigInt)(data.power ?? "0")
      };
    }
    function decodeBlockResults(data) {
      return {
        height: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.height)),
        results: (data.txs_results || []).map(decodeTxData),
        validatorUpdates: (data.validator_updates || []).map(decodeValidatorUpdate),
        consensusUpdates: (0, encodings_1.may)(decodeConsensusParams, data.consensus_param_updates),
        finalizeBlockEvents: decodeEvents(data.finalize_block_events || [])
      };
    }
    function decodeBlockId(data) {
      return {
        hash: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data.hash)),
        parts: {
          total: (0, encodings_1.assertNotEmpty)(data.parts.total),
          hash: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data.parts.hash))
        }
      };
    }
    function decodeBlockVersion(data) {
      return {
        block: (0, inthelpers_1.apiToSmallInt)(data.block),
        app: (0, inthelpers_1.apiToSmallInt)(data.app ?? 0)
      };
    }
    function decodeHeader(data) {
      return {
        version: decodeBlockVersion(data.version),
        chainId: (0, encodings_1.assertNotEmpty)(data.chain_id),
        height: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.height)),
        time: (0, dates_1.fromRfc3339WithNanoseconds)((0, encodings_1.assertNotEmpty)(data.time)),
        // When there is no last block ID (i.e. this block's height is 1), we get an empty structure like this:
        // { hash: '', parts: { total: 0, hash: '' } }
        lastBlockId: data.last_block_id.hash ? decodeBlockId(data.last_block_id) : null,
        lastCommitHash: (0, encoding_1.fromHex)((0, encodings_1.assertSet)(data.last_commit_hash)),
        dataHash: (0, encoding_1.fromHex)((0, encodings_1.assertSet)(data.data_hash)),
        validatorsHash: (0, encoding_1.fromHex)((0, encodings_1.assertSet)(data.validators_hash)),
        nextValidatorsHash: (0, encoding_1.fromHex)((0, encodings_1.assertSet)(data.next_validators_hash)),
        consensusHash: (0, encoding_1.fromHex)((0, encodings_1.assertSet)(data.consensus_hash)),
        appHash: (0, encoding_1.fromHex)((0, encodings_1.assertSet)(data.app_hash)),
        lastResultsHash: (0, encoding_1.fromHex)((0, encodings_1.assertSet)(data.last_results_hash)),
        evidenceHash: (0, encoding_1.fromHex)((0, encodings_1.assertSet)(data.evidence_hash)),
        proposerAddress: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data.proposer_address))
      };
    }
    function decodeBlockMeta(data) {
      return {
        blockId: decodeBlockId(data.block_id),
        blockSize: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.block_size)),
        header: decodeHeader(data.header),
        numTxs: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.num_txs))
      };
    }
    function decodeBlockchain(data) {
      return {
        lastHeight: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.last_height)),
        blockMetas: (0, encodings_1.assertArray)(data.block_metas).map(decodeBlockMeta)
      };
    }
    function decodeBroadcastTxSync(data) {
      return {
        ...decodeTxData(data),
        hash: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data.hash))
      };
    }
    function decodeBroadcastTxCommit(data) {
      const txResult = data.tx_result ? decodeTxData(data.tx_result) : void 0;
      return {
        height: (0, inthelpers_1.apiToSmallInt)(data.height),
        hash: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data.hash)),
        checkTx: decodeTxData((0, encodings_1.assertObject)(data.check_tx)),
        deliverTx: txResult,
        txResult
      };
    }
    function decodeBlockIdFlag(blockIdFlag) {
      (0, utils_1.assert)(blockIdFlag in types_1.BlockIdFlag);
      return blockIdFlag;
    }
    function decodeCommitSignature(data) {
      return {
        blockIdFlag: decodeBlockIdFlag(data.block_id_flag),
        validatorAddress: data.validator_address ? (0, encoding_1.fromHex)(data.validator_address) : void 0,
        timestamp: data.timestamp ? (0, dates_1.fromRfc3339WithNanoseconds)(data.timestamp) : void 0,
        signature: data.signature ? (0, encoding_1.fromBase64)(data.signature) : void 0
      };
    }
    function decodeCommit(data) {
      return {
        blockId: decodeBlockId((0, encodings_1.assertObject)(data.block_id)),
        height: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.height)),
        round: (0, inthelpers_1.apiToSmallInt)(data.round),
        signatures: data.signatures ? (0, encodings_1.assertArray)(data.signatures).map(decodeCommitSignature) : []
      };
    }
    function decodeCommitResponse(data) {
      return {
        canonical: (0, encodings_1.assertBoolean)(data.canonical),
        header: decodeHeader(data.signed_header.header),
        commit: decodeCommit(data.signed_header.commit)
      };
    }
    function decodeValidatorGenesis(data) {
      return {
        address: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data.address)),
        pubkey: decodePubkey((0, encodings_1.assertObject)(data.pub_key)),
        votingPower: (0, inthelpers_1.apiToBigInt)((0, encodings_1.assertNotEmpty)(data.power))
      };
    }
    function decodeGenesis(data) {
      return {
        genesisTime: (0, dates_1.fromRfc3339WithNanoseconds)((0, encodings_1.assertNotEmpty)(data.genesis_time)),
        chainId: (0, encodings_1.assertNotEmpty)(data.chain_id),
        consensusParams: decodeConsensusParams(data.consensus_params),
        validators: data.validators ? (0, encodings_1.assertArray)(data.validators).map(decodeValidatorGenesis) : [],
        appHash: (0, encoding_1.fromHex)((0, encodings_1.assertSet)(data.app_hash)),
        // empty string in kvstore app
        appState: data.app_state
      };
    }
    function decodeValidatorInfo(data) {
      return {
        pubkey: decodePubkey((0, encodings_1.assertObject)(data.pub_key)),
        votingPower: (0, inthelpers_1.apiToBigInt)((0, encodings_1.assertNotEmpty)(data.voting_power)),
        address: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data.address)),
        proposerPriority: data.proposer_priority ? (0, inthelpers_1.apiToSmallInt)(data.proposer_priority) : void 0
      };
    }
    function decodeNodeInfo(data) {
      return {
        id: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data.id)),
        listenAddr: (0, encodings_1.assertNotEmpty)(data.listen_addr),
        network: (0, encodings_1.assertNotEmpty)(data.network),
        version: (0, encodings_1.assertString)(data.version),
        // Can be empty (https://github.com/cosmos/cosmos-sdk/issues/7963)
        channels: (0, encodings_1.assertString)(data.channels),
        // can be empty
        moniker: (0, encodings_1.assertNotEmpty)(data.moniker),
        other: (0, encodings_1.dictionaryToStringMap)(data.other),
        protocolVersion: {
          app: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.protocol_version.app)),
          block: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.protocol_version.block)),
          p2p: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.protocol_version.p2p))
        }
      };
    }
    function decodeSyncInfo(data) {
      const earliestBlockHeight = data.earliest_block_height ? (0, inthelpers_1.apiToSmallInt)(data.earliest_block_height) : void 0;
      const earliestBlockTime = data.earliest_block_time ? (0, dates_1.fromRfc3339WithNanoseconds)(data.earliest_block_time) : void 0;
      return {
        earliestAppHash: data.earliest_app_hash ? (0, encoding_1.fromHex)(data.earliest_app_hash) : void 0,
        earliestBlockHash: data.earliest_block_hash ? (0, encoding_1.fromHex)(data.earliest_block_hash) : void 0,
        earliestBlockHeight: earliestBlockHeight || void 0,
        earliestBlockTime: (earliestBlockTime == null ? void 0 : earliestBlockTime.getTime()) ? earliestBlockTime : void 0,
        latestBlockHash: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data.latest_block_hash)),
        latestAppHash: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data.latest_app_hash)),
        latestBlockTime: (0, dates_1.fromRfc3339WithNanoseconds)((0, encodings_1.assertNotEmpty)(data.latest_block_time)),
        latestBlockHeight: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.latest_block_height)),
        catchingUp: (0, encodings_1.assertBoolean)(data.catching_up)
      };
    }
    function decodeStatus(data) {
      return {
        nodeInfo: decodeNodeInfo(data.node_info),
        syncInfo: decodeSyncInfo(data.sync_info),
        validatorInfo: decodeValidatorInfo(data.validator_info)
      };
    }
    function decodeTxProof(data) {
      return {
        data: (0, encoding_1.fromBase64)((0, encodings_1.assertNotEmpty)(data.data)),
        rootHash: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data.root_hash)),
        proof: {
          total: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.proof.total)),
          index: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.proof.index)),
          leafHash: (0, encoding_1.fromBase64)((0, encodings_1.assertNotEmpty)(data.proof.leaf_hash)),
          aunts: (0, encodings_1.assertArray)(data.proof.aunts).map(encoding_1.fromBase64)
        }
      };
    }
    function decodeTxResponse(data) {
      return {
        tx: (0, encoding_1.fromBase64)((0, encodings_1.assertNotEmpty)(data.tx)),
        result: decodeTxData((0, encodings_1.assertObject)(data.tx_result)),
        height: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.height)),
        index: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNumber)(data.index)),
        hash: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data.hash)),
        proof: (0, encodings_1.may)(decodeTxProof, data.proof)
      };
    }
    function decodeTxSearch(data) {
      return {
        totalCount: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.total_count)),
        txs: (0, encodings_1.assertArray)(data.txs).map(decodeTxResponse)
      };
    }
    function decodeTxEvent(data) {
      const tx = (0, encoding_1.fromBase64)((0, encodings_1.assertNotEmpty)(data.tx));
      return {
        tx,
        hash: (0, hasher_1.hashTx)(tx),
        result: decodeTxData(data.result),
        height: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.height))
      };
    }
    function decodeValidators(data) {
      return {
        blockHeight: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.block_height)),
        validators: (0, encodings_1.assertArray)(data.validators).map(decodeValidatorInfo),
        count: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.count)),
        total: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.total))
      };
    }
    function decodeBlock(data) {
      var _a;
      return {
        header: decodeHeader((0, encodings_1.assertObject)(data.header)),
        // For the block at height 1, last commit is not set. This is represented in an empty object like this:
        // { height: '0', round: 0, block_id: { hash: '', parts: [Object] }, signatures: [] }
        lastCommit: data.last_commit.block_id.hash ? decodeCommit((0, encodings_1.assertObject)(data.last_commit)) : null,
        txs: data.data.txs ? (0, encodings_1.assertArray)(data.data.txs).map(encoding_1.fromBase64) : [],
        // Lift up .evidence.evidence to just .evidence
        // See https://github.com/tendermint/tendermint/issues/7697
        evidence: ((_a = data.evidence) == null ? void 0 : _a.evidence) ?? []
      };
    }
    function decodeBlockResponse(data) {
      return {
        blockId: decodeBlockId(data.block_id),
        block: decodeBlock(data.block)
      };
    }
    function decodeBlockSearch(data) {
      return {
        totalCount: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.total_count)),
        blocks: (0, encodings_1.assertArray)(data.blocks).map(decodeBlockResponse)
      };
    }
    function decodeNumUnconfirmedTxs(data) {
      return {
        total: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.total)),
        totalBytes: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.total_bytes))
      };
    }
    var Responses = class _Responses {
      static decodeAbciInfo(response) {
        return decodeAbciInfo((0, encodings_1.assertObject)(response.result.response));
      }
      static decodeAbciQuery(response) {
        return decodeAbciQuery((0, encodings_1.assertObject)(response.result.response));
      }
      static decodeBlock(response) {
        return decodeBlockResponse(response.result);
      }
      static decodeBlockResults(response) {
        return decodeBlockResults(response.result);
      }
      static decodeBlockSearch(response) {
        return decodeBlockSearch(response.result);
      }
      static decodeBlockchain(response) {
        return decodeBlockchain(response.result);
      }
      static decodeBroadcastTxSync(response) {
        return decodeBroadcastTxSync(response.result);
      }
      static decodeBroadcastTxAsync(response) {
        return _Responses.decodeBroadcastTxSync(response);
      }
      static decodeBroadcastTxCommit(response) {
        return decodeBroadcastTxCommit(response.result);
      }
      static decodeCommit(response) {
        return decodeCommitResponse(response.result);
      }
      static decodeGenesis(response) {
        return decodeGenesis((0, encodings_1.assertObject)(response.result.genesis));
      }
      static decodeHealth() {
        return null;
      }
      static decodeNumUnconfirmedTxs(response) {
        return decodeNumUnconfirmedTxs(response.result);
      }
      static decodeStatus(response) {
        return decodeStatus(response.result);
      }
      static decodeNewBlockEvent(event) {
        return decodeBlock(event.data.value.block);
      }
      static decodeNewBlockHeaderEvent(event) {
        return decodeHeader(event.data.value.header);
      }
      static decodeTxEvent(event) {
        return decodeTxEvent(event.data.value.TxResult);
      }
      static decodeTx(response) {
        return decodeTxResponse(response.result);
      }
      static decodeTxSearch(response) {
        return decodeTxSearch(response.result);
      }
      static decodeValidators(response) {
        return decodeValidators(response.result);
      }
    };
    exports.Responses = Responses;
  }
});

// ../../node_modules/.pnpm/@cosmjs+tendermint-rpc@0.34.0/node_modules/@cosmjs/tendermint-rpc/build/comet38/adaptor/index.js
var require_adaptor = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+tendermint-rpc@0.34.0/node_modules/@cosmjs/tendermint-rpc/build/comet38/adaptor/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Responses = exports.Params = void 0;
    var requests_1 = require_requests2();
    Object.defineProperty(exports, "Params", { enumerable: true, get: function() {
      return requests_1.Params;
    } });
    var responses_1 = require_responses();
    Object.defineProperty(exports, "Responses", { enumerable: true, get: function() {
      return responses_1.Responses;
    } });
  }
});

// ../../node_modules/.pnpm/@cosmjs+tendermint-rpc@0.34.0/node_modules/@cosmjs/tendermint-rpc/build/comet38/comet38client.js
var require_comet38client = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+tendermint-rpc@0.34.0/node_modules/@cosmjs/tendermint-rpc/build/comet38/comet38client.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function() {
      var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o2) {
          var ar = [];
          for (var k in o2)
            if (Object.prototype.hasOwnProperty.call(o2, k))
              ar[ar.length] = k;
          return ar;
        };
        return ownKeys(o);
      };
      return function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k = ownKeys(mod), i = 0; i < k.length; i++)
            if (k[i] !== "default")
              __createBinding(result, mod, k[i]);
        }
        __setModuleDefault(result, mod);
        return result;
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Comet38Client = void 0;
    var jsonrpc_1 = require_jsonrpc();
    var rpcclients_1 = require_rpcclients();
    var adaptor_1 = require_adaptor();
    var requests = __importStar(require_requests());
    var Comet38Client = class _Comet38Client {
      /**
       * Creates a new Tendermint client for the given endpoint.
       *
       * Uses HTTP when the URL schema is http or https. Uses WebSockets otherwise.
       */
      static async connect(endpoint) {
        let rpcClient;
        if (typeof endpoint === "object") {
          rpcClient = new rpcclients_1.HttpClient(endpoint);
        } else {
          const useHttp = endpoint.startsWith("http://") || endpoint.startsWith("https://");
          rpcClient = useHttp ? new rpcclients_1.HttpClient(endpoint) : new rpcclients_1.WebsocketClient(endpoint);
        }
        const _version = await this.detectVersion(rpcClient);
        return _Comet38Client.create(rpcClient);
      }
      /**
       * Creates a new Tendermint client given an RPC client.
       */
      static async create(rpcClient) {
        return new _Comet38Client(rpcClient);
      }
      static async detectVersion(client) {
        const req = (0, jsonrpc_1.createJsonRpcRequest)(requests.Method.Status);
        const response = await client.execute(req);
        const result = response.result;
        if (!result || !result.node_info) {
          throw new Error("Unrecognized format for status response");
        }
        const version = result.node_info.version;
        if (typeof version !== "string") {
          throw new Error("Unrecognized version format: must be string");
        }
        return version;
      }
      /**
       * Use `Tendermint37Client.connect` or `Tendermint37Client.create` to create an instance.
       */
      constructor(client) {
        this.client = client;
      }
      disconnect() {
        this.client.disconnect();
      }
      async abciInfo() {
        const query = { method: requests.Method.AbciInfo };
        return this.doCall(query, adaptor_1.Params.encodeAbciInfo, adaptor_1.Responses.decodeAbciInfo);
      }
      async abciQuery(params) {
        const query = { params, method: requests.Method.AbciQuery };
        return this.doCall(query, adaptor_1.Params.encodeAbciQuery, adaptor_1.Responses.decodeAbciQuery);
      }
      async block(height) {
        const query = { method: requests.Method.Block, params: { height } };
        return this.doCall(query, adaptor_1.Params.encodeBlock, adaptor_1.Responses.decodeBlock);
      }
      async blockResults(height) {
        const query = {
          method: requests.Method.BlockResults,
          params: { height }
        };
        return this.doCall(query, adaptor_1.Params.encodeBlockResults, adaptor_1.Responses.decodeBlockResults);
      }
      /**
       * Search for events that are in a block.
       *
       * NOTE
       * This method will error on any node that is running a Tendermint version lower than 0.34.9.
       *
       * @see https://docs.tendermint.com/master/rpc/#/Info/block_search
       */
      async blockSearch(params) {
        const query = { params, method: requests.Method.BlockSearch };
        const resp = await this.doCall(query, adaptor_1.Params.encodeBlockSearch, adaptor_1.Responses.decodeBlockSearch);
        return {
          ...resp,
          // make sure we sort by height, as tendermint may be sorting by string value of the height
          blocks: [...resp.blocks].sort((a, b) => a.block.header.height - b.block.header.height)
        };
      }
      // this should paginate through all blockSearch options to ensure it returns all results.
      // starts with page 1 or whatever was provided (eg. to start on page 7)
      //
      // NOTE
      // This method will error on any node that is running a Tendermint version lower than 0.34.9.
      async blockSearchAll(params) {
        let page = params.page || 1;
        const blocks = [];
        let done = false;
        while (!done) {
          const resp = await this.blockSearch({ ...params, page });
          blocks.push(...resp.blocks);
          if (blocks.length < resp.totalCount) {
            page++;
          } else {
            done = true;
          }
        }
        blocks.sort((a, b) => a.block.header.height - b.block.header.height);
        return {
          totalCount: blocks.length,
          blocks
        };
      }
      /**
       * Queries block headers filtered by minHeight <= height <= maxHeight.
       *
       * @param minHeight The minimum height to be included in the result. Defaults to 0.
       * @param maxHeight The maximum height to be included in the result. Defaults to infinity.
       */
      async blockchain(minHeight, maxHeight) {
        const query = {
          method: requests.Method.Blockchain,
          params: {
            minHeight,
            maxHeight
          }
        };
        return this.doCall(query, adaptor_1.Params.encodeBlockchain, adaptor_1.Responses.decodeBlockchain);
      }
      /**
       * Broadcast transaction to mempool and wait for response
       *
       * @see https://docs.tendermint.com/master/rpc/#/Tx/broadcast_tx_sync
       */
      async broadcastTxSync(params) {
        const query = { params, method: requests.Method.BroadcastTxSync };
        return this.doCall(query, adaptor_1.Params.encodeBroadcastTx, adaptor_1.Responses.decodeBroadcastTxSync);
      }
      /**
       * Broadcast transaction to mempool and do not wait for result
       *
       * @see https://docs.tendermint.com/master/rpc/#/Tx/broadcast_tx_async
       */
      async broadcastTxAsync(params) {
        const query = { params, method: requests.Method.BroadcastTxAsync };
        return this.doCall(query, adaptor_1.Params.encodeBroadcastTx, adaptor_1.Responses.decodeBroadcastTxAsync);
      }
      /**
       * Broadcast transaction to mempool and wait for block
       *
       * @see https://docs.tendermint.com/master/rpc/#/Tx/broadcast_tx_commit
       */
      async broadcastTxCommit(params) {
        const query = { params, method: requests.Method.BroadcastTxCommit };
        return this.doCall(query, adaptor_1.Params.encodeBroadcastTx, adaptor_1.Responses.decodeBroadcastTxCommit);
      }
      async commit(height) {
        const query = { method: requests.Method.Commit, params: { height } };
        return this.doCall(query, adaptor_1.Params.encodeCommit, adaptor_1.Responses.decodeCommit);
      }
      async genesis() {
        const query = { method: requests.Method.Genesis };
        return this.doCall(query, adaptor_1.Params.encodeGenesis, adaptor_1.Responses.decodeGenesis);
      }
      async health() {
        const query = { method: requests.Method.Health };
        return this.doCall(query, adaptor_1.Params.encodeHealth, adaptor_1.Responses.decodeHealth);
      }
      async numUnconfirmedTxs() {
        const query = { method: requests.Method.NumUnconfirmedTxs };
        return this.doCall(query, adaptor_1.Params.encodeNumUnconfirmedTxs, adaptor_1.Responses.decodeNumUnconfirmedTxs);
      }
      async status() {
        const query = { method: requests.Method.Status };
        return this.doCall(query, adaptor_1.Params.encodeStatus, adaptor_1.Responses.decodeStatus);
      }
      subscribeNewBlock() {
        const request = {
          method: requests.Method.Subscribe,
          query: { type: requests.SubscriptionEventType.NewBlock }
        };
        return this.subscribe(request, adaptor_1.Responses.decodeNewBlockEvent);
      }
      subscribeNewBlockHeader() {
        const request = {
          method: requests.Method.Subscribe,
          query: { type: requests.SubscriptionEventType.NewBlockHeader }
        };
        return this.subscribe(request, adaptor_1.Responses.decodeNewBlockHeaderEvent);
      }
      subscribeTx(query) {
        const request = {
          method: requests.Method.Subscribe,
          query: {
            type: requests.SubscriptionEventType.Tx,
            raw: query
          }
        };
        return this.subscribe(request, adaptor_1.Responses.decodeTxEvent);
      }
      /**
       * Get a single transaction by hash
       *
       * @see https://docs.tendermint.com/master/rpc/#/Info/tx
       */
      async tx(params) {
        const query = { params, method: requests.Method.Tx };
        return this.doCall(query, adaptor_1.Params.encodeTx, adaptor_1.Responses.decodeTx);
      }
      /**
       * Search for transactions that are in a block
       *
       * @see https://docs.tendermint.com/master/rpc/#/Info/tx_search
       */
      async txSearch(params) {
        const query = { params, method: requests.Method.TxSearch };
        return this.doCall(query, adaptor_1.Params.encodeTxSearch, adaptor_1.Responses.decodeTxSearch);
      }
      // this should paginate through all txSearch options to ensure it returns all results.
      // starts with page 1 or whatever was provided (eg. to start on page 7)
      async txSearchAll(params) {
        let page = params.page || 1;
        const txs = [];
        let done = false;
        while (!done) {
          const resp = await this.txSearch({ ...params, page });
          txs.push(...resp.txs);
          if (txs.length < resp.totalCount) {
            page++;
          } else {
            done = true;
          }
        }
        return {
          totalCount: txs.length,
          txs
        };
      }
      async validators(params) {
        const query = {
          method: requests.Method.Validators,
          params
        };
        return this.doCall(query, adaptor_1.Params.encodeValidators, adaptor_1.Responses.decodeValidators);
      }
      async validatorsAll(height) {
        const validators = [];
        let page = 1;
        let done = false;
        let blockHeight = height;
        while (!done) {
          const response = await this.validators({
            per_page: 50,
            height: blockHeight,
            page
          });
          validators.push(...response.validators);
          blockHeight = blockHeight || response.blockHeight;
          if (validators.length < response.total) {
            page++;
          } else {
            done = true;
          }
        }
        return {
          // NOTE: Default value is for type safety but this should always be set
          blockHeight: blockHeight ?? 0,
          count: validators.length,
          total: validators.length,
          validators
        };
      }
      // doCall is a helper to handle the encode/call/decode logic
      async doCall(request, encode, decode) {
        const req = encode(request);
        const result = await this.client.execute(req);
        return decode(result);
      }
      subscribe(request, decode) {
        if (!(0, rpcclients_1.instanceOfRpcStreamingClient)(this.client)) {
          throw new Error("This RPC client type cannot subscribe to events");
        }
        const req = adaptor_1.Params.encodeSubscribe(request);
        const eventStream = this.client.listen(req);
        return eventStream.map((event) => {
          return decode(event);
        });
      }
    };
    exports.Comet38Client = Comet38Client;
  }
});

// ../../node_modules/.pnpm/@cosmjs+tendermint-rpc@0.34.0/node_modules/@cosmjs/tendermint-rpc/build/comet38/responses.js
var require_responses2 = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+tendermint-rpc@0.34.0/node_modules/@cosmjs/tendermint-rpc/build/comet38/responses.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.VoteType = void 0;
    exports.broadcastTxSyncSuccess = broadcastTxSyncSuccess;
    exports.broadcastTxCommitSuccess = broadcastTxCommitSuccess;
    function broadcastTxSyncSuccess(res) {
      return res.code === 0;
    }
    function broadcastTxCommitSuccess(response) {
      return response.checkTx.code === 0 && !!response.deliverTx && response.deliverTx.code === 0;
    }
    var VoteType;
    (function(VoteType2) {
      VoteType2[VoteType2["PreVote"] = 1] = "PreVote";
      VoteType2[VoteType2["PreCommit"] = 2] = "PreCommit";
    })(VoteType || (exports.VoteType = VoteType = {}));
  }
});

// ../../node_modules/.pnpm/@cosmjs+tendermint-rpc@0.34.0/node_modules/@cosmjs/tendermint-rpc/build/comet38/index.js
var require_comet38 = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+tendermint-rpc@0.34.0/node_modules/@cosmjs/tendermint-rpc/build/comet38/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.VoteType = exports.broadcastTxSyncSuccess = exports.broadcastTxCommitSuccess = exports.SubscriptionEventType = exports.Method = exports.Comet38Client = void 0;
    var comet38client_1 = require_comet38client();
    Object.defineProperty(exports, "Comet38Client", { enumerable: true, get: function() {
      return comet38client_1.Comet38Client;
    } });
    var requests_1 = require_requests();
    Object.defineProperty(exports, "Method", { enumerable: true, get: function() {
      return requests_1.Method;
    } });
    Object.defineProperty(exports, "SubscriptionEventType", { enumerable: true, get: function() {
      return requests_1.SubscriptionEventType;
    } });
    var responses_1 = require_responses2();
    Object.defineProperty(exports, "broadcastTxCommitSuccess", { enumerable: true, get: function() {
      return responses_1.broadcastTxCommitSuccess;
    } });
    Object.defineProperty(exports, "broadcastTxSyncSuccess", { enumerable: true, get: function() {
      return responses_1.broadcastTxSyncSuccess;
    } });
    Object.defineProperty(exports, "VoteType", { enumerable: true, get: function() {
      return responses_1.VoteType;
    } });
  }
});

// ../../node_modules/.pnpm/@cosmjs+tendermint-rpc@0.34.0/node_modules/@cosmjs/tendermint-rpc/build/tendermint34/requests.js
var require_requests3 = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+tendermint-rpc@0.34.0/node_modules/@cosmjs/tendermint-rpc/build/tendermint34/requests.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SubscriptionEventType = exports.Method = void 0;
    exports.buildQuery = buildQuery;
    var Method;
    (function(Method2) {
      Method2["AbciInfo"] = "abci_info";
      Method2["AbciQuery"] = "abci_query";
      Method2["Block"] = "block";
      Method2["Blockchain"] = "blockchain";
      Method2["BlockResults"] = "block_results";
      Method2["BlockSearch"] = "block_search";
      Method2["BroadcastTxAsync"] = "broadcast_tx_async";
      Method2["BroadcastTxSync"] = "broadcast_tx_sync";
      Method2["BroadcastTxCommit"] = "broadcast_tx_commit";
      Method2["Commit"] = "commit";
      Method2["Genesis"] = "genesis";
      Method2["Health"] = "health";
      Method2["NumUnconfirmedTxs"] = "num_unconfirmed_txs";
      Method2["Status"] = "status";
      Method2["Subscribe"] = "subscribe";
      Method2["Tx"] = "tx";
      Method2["TxSearch"] = "tx_search";
      Method2["Validators"] = "validators";
      Method2["Unsubscribe"] = "unsubscribe";
    })(Method || (exports.Method = Method = {}));
    var SubscriptionEventType;
    (function(SubscriptionEventType2) {
      SubscriptionEventType2["NewBlock"] = "NewBlock";
      SubscriptionEventType2["NewBlockHeader"] = "NewBlockHeader";
      SubscriptionEventType2["Tx"] = "Tx";
    })(SubscriptionEventType || (exports.SubscriptionEventType = SubscriptionEventType = {}));
    function buildQuery(components) {
      const tags = components.tags ? components.tags : [];
      const tagComponents = tags.map((tag) => `${tag.key}='${tag.value}'`);
      const rawComponents = components.raw ? [components.raw] : [];
      return [...tagComponents, ...rawComponents].join(" AND ");
    }
  }
});

// ../../node_modules/.pnpm/@cosmjs+tendermint-rpc@0.34.0/node_modules/@cosmjs/tendermint-rpc/build/tendermint34/responses.js
var require_responses3 = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+tendermint-rpc@0.34.0/node_modules/@cosmjs/tendermint-rpc/build/tendermint34/responses.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.VoteType = void 0;
    exports.broadcastTxSyncSuccess = broadcastTxSyncSuccess;
    exports.broadcastTxCommitSuccess = broadcastTxCommitSuccess;
    function broadcastTxSyncSuccess(res) {
      return res.code === 0;
    }
    function broadcastTxCommitSuccess(response) {
      return response.checkTx.code === 0 && !!response.deliverTx && response.deliverTx.code === 0;
    }
    var VoteType;
    (function(VoteType2) {
      VoteType2[VoteType2["PreVote"] = 1] = "PreVote";
      VoteType2[VoteType2["PreCommit"] = 2] = "PreCommit";
    })(VoteType || (exports.VoteType = VoteType = {}));
  }
});

// ../../node_modules/.pnpm/@cosmjs+tendermint-rpc@0.34.0/node_modules/@cosmjs/tendermint-rpc/build/tendermint34/adaptor/requests.js
var require_requests4 = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+tendermint-rpc@0.34.0/node_modules/@cosmjs/tendermint-rpc/build/tendermint34/adaptor/requests.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function() {
      var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o2) {
          var ar = [];
          for (var k in o2)
            if (Object.prototype.hasOwnProperty.call(o2, k))
              ar[ar.length] = k;
          return ar;
        };
        return ownKeys(o);
      };
      return function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k = ownKeys(mod), i = 0; i < k.length; i++)
            if (k[i] !== "default")
              __createBinding(result, mod, k[i]);
        }
        __setModuleDefault(result, mod);
        return result;
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Params = void 0;
    var encoding_1 = require_build();
    var inthelpers_1 = require_inthelpers();
    var jsonrpc_1 = require_jsonrpc();
    var encodings_1 = require_encodings();
    var requests = __importStar(require_requests3());
    function encodeHeightParam(param) {
      return {
        height: (0, encodings_1.may)(inthelpers_1.smallIntToApi, param.height)
      };
    }
    function encodeBlockchainRequestParams(param) {
      return {
        minHeight: (0, encodings_1.may)(inthelpers_1.smallIntToApi, param.minHeight),
        maxHeight: (0, encodings_1.may)(inthelpers_1.smallIntToApi, param.maxHeight)
      };
    }
    function encodeBlockSearchParams(params) {
      return {
        query: params.query,
        page: (0, encodings_1.may)(inthelpers_1.smallIntToApi, params.page),
        per_page: (0, encodings_1.may)(inthelpers_1.smallIntToApi, params.per_page),
        order_by: params.order_by
      };
    }
    function encodeAbciQueryParams(params) {
      return {
        path: (0, encodings_1.assertNotEmpty)(params.path),
        data: (0, encoding_1.toHex)(params.data),
        height: (0, encodings_1.may)(inthelpers_1.smallIntToApi, params.height),
        prove: params.prove
      };
    }
    function encodeBroadcastTxParams(params) {
      return {
        tx: (0, encoding_1.toBase64)((0, encodings_1.assertNotEmpty)(params.tx))
      };
    }
    function encodeTxParams(params) {
      return {
        hash: (0, encoding_1.toBase64)((0, encodings_1.assertNotEmpty)(params.hash)),
        prove: params.prove
      };
    }
    function encodeTxSearchParams(params) {
      return {
        query: params.query,
        prove: params.prove,
        page: (0, encodings_1.may)(inthelpers_1.smallIntToApi, params.page),
        per_page: (0, encodings_1.may)(inthelpers_1.smallIntToApi, params.per_page),
        order_by: params.order_by
      };
    }
    function encodeValidatorsParams(params) {
      return {
        height: (0, encodings_1.may)(inthelpers_1.smallIntToApi, params.height),
        page: (0, encodings_1.may)(inthelpers_1.smallIntToApi, params.page),
        per_page: (0, encodings_1.may)(inthelpers_1.smallIntToApi, params.per_page)
      };
    }
    var Params = class {
      static encodeAbciInfo(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method);
      }
      static encodeAbciQuery(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeAbciQueryParams(req.params));
      }
      static encodeBlock(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeHeightParam(req.params));
      }
      static encodeBlockchain(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeBlockchainRequestParams(req.params));
      }
      static encodeBlockResults(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeHeightParam(req.params));
      }
      static encodeBlockSearch(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeBlockSearchParams(req.params));
      }
      static encodeBroadcastTx(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeBroadcastTxParams(req.params));
      }
      static encodeCommit(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeHeightParam(req.params));
      }
      static encodeGenesis(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method);
      }
      static encodeHealth(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method);
      }
      static encodeNumUnconfirmedTxs(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method);
      }
      static encodeStatus(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method);
      }
      static encodeSubscribe(req) {
        const eventTag = { key: "tm.event", value: req.query.type };
        const query = requests.buildQuery({ tags: [eventTag], raw: req.query.raw });
        return (0, jsonrpc_1.createJsonRpcRequest)("subscribe", { query });
      }
      static encodeTx(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeTxParams(req.params));
      }
      // TODO: encode params for query string???
      static encodeTxSearch(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeTxSearchParams(req.params));
      }
      static encodeValidators(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeValidatorsParams(req.params));
      }
    };
    exports.Params = Params;
  }
});

// ../../node_modules/.pnpm/@cosmjs+tendermint-rpc@0.34.0/node_modules/@cosmjs/tendermint-rpc/build/tendermint34/hasher.js
var require_hasher2 = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+tendermint-rpc@0.34.0/node_modules/@cosmjs/tendermint-rpc/build/tendermint34/hasher.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.hashTx = hashTx;
    exports.hashBlock = hashBlock;
    var crypto_1 = require_build4();
    var encodings_1 = require_encodings();
    function hashTx(tx) {
      return (0, crypto_1.sha256)(tx);
    }
    function getSplitPoint(n) {
      if (n < 1)
        throw new Error("Cannot split an empty tree");
      const largestPowerOf2 = 2 ** Math.floor(Math.log2(n));
      return largestPowerOf2 < n ? largestPowerOf2 : largestPowerOf2 / 2;
    }
    function hashLeaf(leaf) {
      const hash = new crypto_1.Sha256(Uint8Array.from([0]));
      hash.update(leaf);
      return hash.digest();
    }
    function hashInner(left, right) {
      const hash = new crypto_1.Sha256(Uint8Array.from([1]));
      hash.update(left);
      hash.update(right);
      return hash.digest();
    }
    function hashTree(hashes) {
      switch (hashes.length) {
        case 0:
          throw new Error("Cannot hash empty tree");
        case 1:
          return hashLeaf(hashes[0]);
        default: {
          const slicePoint = getSplitPoint(hashes.length);
          const left = hashTree(hashes.slice(0, slicePoint));
          const right = hashTree(hashes.slice(slicePoint));
          return hashInner(left, right);
        }
      }
    }
    function hashBlock(header) {
      if (!header.lastBlockId) {
        throw new Error("Hashing a block header with no last block ID (i.e. header at height 1) is not supported. If you need this, contributions are welcome. Please add documentation and test vectors for this case.");
      }
      const encodedFields = [
        (0, encodings_1.encodeVersion)(header.version),
        (0, encodings_1.encodeString)(header.chainId),
        (0, encodings_1.encodeUvarint)(header.height),
        (0, encodings_1.encodeTime)(header.time),
        (0, encodings_1.encodeBlockId)(header.lastBlockId),
        (0, encodings_1.encodeBytes)(header.lastCommitHash),
        (0, encodings_1.encodeBytes)(header.dataHash),
        (0, encodings_1.encodeBytes)(header.validatorsHash),
        (0, encodings_1.encodeBytes)(header.nextValidatorsHash),
        (0, encodings_1.encodeBytes)(header.consensusHash),
        (0, encodings_1.encodeBytes)(header.appHash),
        (0, encodings_1.encodeBytes)(header.lastResultsHash),
        (0, encodings_1.encodeBytes)(header.evidenceHash),
        (0, encodings_1.encodeBytes)(header.proposerAddress)
      ];
      return hashTree(encodedFields);
    }
  }
});

// ../../node_modules/.pnpm/@cosmjs+tendermint-rpc@0.34.0/node_modules/@cosmjs/tendermint-rpc/build/tendermint34/adaptor/responses.js
var require_responses4 = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+tendermint-rpc@0.34.0/node_modules/@cosmjs/tendermint-rpc/build/tendermint34/adaptor/responses.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Responses = void 0;
    exports.decodeEvent = decodeEvent;
    exports.decodeValidatorUpdate = decodeValidatorUpdate;
    exports.decodeValidatorGenesis = decodeValidatorGenesis;
    exports.decodeValidatorInfo = decodeValidatorInfo;
    var encoding_1 = require_build();
    var utils_1 = require_build3();
    var dates_1 = require_dates();
    var inthelpers_1 = require_inthelpers();
    var types_1 = require_types3();
    var encodings_1 = require_encodings();
    var hasher_1 = require_hasher2();
    function decodeAbciInfo(data) {
      return {
        data: data.data,
        lastBlockHeight: (0, encodings_1.may)(inthelpers_1.apiToSmallInt, data.last_block_height),
        lastBlockAppHash: (0, encodings_1.may)(encoding_1.fromBase64, data.last_block_app_hash)
      };
    }
    function decodeQueryProof(data) {
      return {
        ops: data.ops.map((op) => ({
          type: op.type,
          key: (0, encoding_1.fromBase64)(op.key),
          data: (0, encoding_1.fromBase64)(op.data)
        }))
      };
    }
    function decodeAbciQuery(data) {
      return {
        key: (0, encoding_1.fromBase64)((0, encodings_1.assertString)(data.key ?? "")),
        value: (0, encoding_1.fromBase64)((0, encodings_1.assertString)(data.value ?? "")),
        proof: (0, encodings_1.may)(decodeQueryProof, data.proofOps),
        height: (0, encodings_1.may)(inthelpers_1.apiToSmallInt, data.height),
        code: (0, encodings_1.may)(inthelpers_1.apiToSmallInt, data.code),
        codespace: (0, encodings_1.assertString)(data.codespace ?? ""),
        index: (0, encodings_1.may)(inthelpers_1.apiToSmallInt, data.index),
        log: data.log,
        info: (0, encodings_1.assertString)(data.info ?? "")
      };
    }
    function decodeAttribute(attribute) {
      return {
        key: (0, encoding_1.fromBase64)((0, encodings_1.assertNotEmpty)(attribute.key)),
        value: (0, encoding_1.fromBase64)((0, encodings_1.assertString)(attribute.value ?? ""))
      };
    }
    function decodeAttributes(attributes) {
      return (0, encodings_1.assertArray)(attributes).map(decodeAttribute);
    }
    function decodeEvent(event) {
      return {
        type: event.type,
        attributes: event.attributes ? decodeAttributes(event.attributes) : []
      };
    }
    function decodeEvents(events) {
      return (0, encodings_1.assertArray)(events).map(decodeEvent);
    }
    function decodeTxData(data) {
      return {
        code: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNumber)(data.code ?? 0)),
        codespace: data.codespace,
        log: data.log,
        data: (0, encodings_1.may)(encoding_1.fromBase64, data.data),
        events: data.events ? decodeEvents(data.events) : [],
        gasWanted: (0, inthelpers_1.apiToBigInt)(data.gas_wanted ?? "0"),
        gasUsed: (0, inthelpers_1.apiToBigInt)(data.gas_used ?? "0")
      };
    }
    function decodePubkey(data) {
      if ("Sum" in data) {
        const [[algorithm, value]] = Object.entries(data.Sum.value);
        (0, utils_1.assert)(algorithm === "ed25519" || algorithm === "secp256k1", `unknown pubkey type: ${algorithm}`);
        return {
          algorithm,
          data: (0, encoding_1.fromBase64)((0, encodings_1.assertNotEmpty)(value))
        };
      } else {
        switch (data.type) {
          case "tendermint/PubKeyEd25519":
            return {
              algorithm: "ed25519",
              data: (0, encoding_1.fromBase64)((0, encodings_1.assertNotEmpty)(data.value))
            };
          case "tendermint/PubKeySecp256k1":
            return {
              algorithm: "secp256k1",
              data: (0, encoding_1.fromBase64)((0, encodings_1.assertNotEmpty)(data.value))
            };
          default:
            throw new Error(`unknown pubkey type: ${data.type}`);
        }
      }
    }
    function decodeBlockParams(data) {
      return {
        maxBytes: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.max_bytes)),
        maxGas: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.max_gas))
      };
    }
    function decodeEvidenceParams(data) {
      return {
        maxAgeNumBlocks: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.max_age_num_blocks)),
        maxAgeDuration: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.max_age_duration))
      };
    }
    function decodeConsensusParams(data) {
      return {
        block: decodeBlockParams((0, encodings_1.assertObject)(data.block)),
        evidence: decodeEvidenceParams((0, encodings_1.assertObject)(data.evidence))
      };
    }
    function decodeValidatorUpdate(data) {
      return {
        pubkey: decodePubkey((0, encodings_1.assertObject)(data.pub_key)),
        votingPower: (0, inthelpers_1.apiToBigInt)(data.power ?? "0")
      };
    }
    function decodeBlockResults(data) {
      return {
        height: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.height)),
        results: (data.txs_results || []).map(decodeTxData),
        validatorUpdates: (data.validator_updates || []).map(decodeValidatorUpdate),
        consensusUpdates: (0, encodings_1.may)(decodeConsensusParams, data.consensus_param_updates),
        beginBlockEvents: decodeEvents(data.begin_block_events || []),
        endBlockEvents: decodeEvents(data.end_block_events || [])
      };
    }
    function decodeBlockId(data) {
      return {
        hash: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data.hash)),
        parts: {
          total: (0, encodings_1.assertNotEmpty)(data.parts.total),
          hash: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data.parts.hash))
        }
      };
    }
    function decodeBlockVersion(data) {
      return {
        block: (0, inthelpers_1.apiToSmallInt)(data.block),
        app: (0, inthelpers_1.apiToSmallInt)(data.app ?? 0)
      };
    }
    function decodeHeader(data) {
      return {
        version: decodeBlockVersion(data.version),
        chainId: (0, encodings_1.assertNotEmpty)(data.chain_id),
        height: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.height)),
        time: (0, dates_1.fromRfc3339WithNanoseconds)((0, encodings_1.assertNotEmpty)(data.time)),
        // When there is no last block ID (i.e. this block's height is 1), we get an empty structure like this:
        // { hash: '', parts: { total: 0, hash: '' } }
        lastBlockId: data.last_block_id.hash ? decodeBlockId(data.last_block_id) : null,
        lastCommitHash: (0, encoding_1.fromHex)((0, encodings_1.assertSet)(data.last_commit_hash)),
        dataHash: (0, encoding_1.fromHex)((0, encodings_1.assertSet)(data.data_hash)),
        validatorsHash: (0, encoding_1.fromHex)((0, encodings_1.assertSet)(data.validators_hash)),
        nextValidatorsHash: (0, encoding_1.fromHex)((0, encodings_1.assertSet)(data.next_validators_hash)),
        consensusHash: (0, encoding_1.fromHex)((0, encodings_1.assertSet)(data.consensus_hash)),
        appHash: (0, encoding_1.fromHex)((0, encodings_1.assertSet)(data.app_hash)),
        lastResultsHash: (0, encoding_1.fromHex)((0, encodings_1.assertSet)(data.last_results_hash)),
        evidenceHash: (0, encoding_1.fromHex)((0, encodings_1.assertSet)(data.evidence_hash)),
        proposerAddress: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data.proposer_address))
      };
    }
    function decodeBlockMeta(data) {
      return {
        blockId: decodeBlockId(data.block_id),
        blockSize: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.block_size)),
        header: decodeHeader(data.header),
        numTxs: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.num_txs))
      };
    }
    function decodeBlockchain(data) {
      return {
        lastHeight: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.last_height)),
        blockMetas: (0, encodings_1.assertArray)(data.block_metas).map(decodeBlockMeta)
      };
    }
    function decodeBroadcastTxSync(data) {
      return {
        ...decodeTxData(data),
        hash: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data.hash))
      };
    }
    function decodeBroadcastTxCommit(data) {
      return {
        height: (0, inthelpers_1.apiToSmallInt)(data.height),
        hash: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data.hash)),
        checkTx: decodeTxData((0, encodings_1.assertObject)(data.check_tx)),
        deliverTx: (0, encodings_1.may)(decodeTxData, data.deliver_tx)
      };
    }
    function decodeBlockIdFlag(blockIdFlag) {
      (0, utils_1.assert)(blockIdFlag in types_1.BlockIdFlag);
      return blockIdFlag;
    }
    function decodeCommitSignature(data) {
      return {
        blockIdFlag: decodeBlockIdFlag(data.block_id_flag),
        validatorAddress: data.validator_address ? (0, encoding_1.fromHex)(data.validator_address) : void 0,
        timestamp: data.timestamp ? (0, dates_1.fromRfc3339WithNanoseconds)(data.timestamp) : void 0,
        signature: data.signature ? (0, encoding_1.fromBase64)(data.signature) : void 0
      };
    }
    function decodeCommit(data) {
      return {
        blockId: decodeBlockId((0, encodings_1.assertObject)(data.block_id)),
        height: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.height)),
        round: (0, inthelpers_1.apiToSmallInt)(data.round),
        signatures: (0, encodings_1.assertArray)(data.signatures).map(decodeCommitSignature)
      };
    }
    function decodeCommitResponse(data) {
      return {
        canonical: (0, encodings_1.assertBoolean)(data.canonical),
        header: decodeHeader(data.signed_header.header),
        commit: decodeCommit(data.signed_header.commit)
      };
    }
    function decodeValidatorGenesis(data) {
      return {
        address: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data.address)),
        pubkey: decodePubkey((0, encodings_1.assertObject)(data.pub_key)),
        votingPower: (0, inthelpers_1.apiToBigInt)((0, encodings_1.assertNotEmpty)(data.power))
      };
    }
    function decodeGenesis(data) {
      return {
        genesisTime: (0, dates_1.fromRfc3339WithNanoseconds)((0, encodings_1.assertNotEmpty)(data.genesis_time)),
        chainId: (0, encodings_1.assertNotEmpty)(data.chain_id),
        consensusParams: decodeConsensusParams(data.consensus_params),
        validators: data.validators ? (0, encodings_1.assertArray)(data.validators).map(decodeValidatorGenesis) : [],
        appHash: (0, encoding_1.fromHex)((0, encodings_1.assertSet)(data.app_hash)),
        // empty string in kvstore app
        appState: data.app_state
      };
    }
    function decodeValidatorInfo(data) {
      return {
        pubkey: decodePubkey((0, encodings_1.assertObject)(data.pub_key)),
        votingPower: (0, inthelpers_1.apiToBigInt)((0, encodings_1.assertNotEmpty)(data.voting_power)),
        address: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data.address)),
        proposerPriority: data.proposer_priority ? (0, inthelpers_1.apiToSmallInt)(data.proposer_priority) : void 0
      };
    }
    function decodeNodeInfo(data) {
      return {
        id: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data.id)),
        listenAddr: (0, encodings_1.assertNotEmpty)(data.listen_addr),
        network: (0, encodings_1.assertNotEmpty)(data.network),
        version: (0, encodings_1.assertString)(data.version),
        // Can be empty (https://github.com/cosmos/cosmos-sdk/issues/7963)
        channels: (0, encodings_1.assertNotEmpty)(data.channels),
        moniker: (0, encodings_1.assertNotEmpty)(data.moniker),
        other: (0, encodings_1.dictionaryToStringMap)(data.other),
        protocolVersion: {
          app: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.protocol_version.app)),
          block: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.protocol_version.block)),
          p2p: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.protocol_version.p2p))
        }
      };
    }
    function decodeSyncInfo(data) {
      const earliestBlockHeight = data.earliest_block_height ? (0, inthelpers_1.apiToSmallInt)(data.earliest_block_height) : void 0;
      const earliestBlockTime = data.earliest_block_time ? (0, dates_1.fromRfc3339WithNanoseconds)(data.earliest_block_time) : void 0;
      return {
        earliestAppHash: data.earliest_app_hash ? (0, encoding_1.fromHex)(data.earliest_app_hash) : void 0,
        earliestBlockHash: data.earliest_block_hash ? (0, encoding_1.fromHex)(data.earliest_block_hash) : void 0,
        earliestBlockHeight: earliestBlockHeight || void 0,
        earliestBlockTime: (earliestBlockTime == null ? void 0 : earliestBlockTime.getTime()) ? earliestBlockTime : void 0,
        latestBlockHash: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data.latest_block_hash)),
        latestAppHash: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data.latest_app_hash)),
        latestBlockTime: (0, dates_1.fromRfc3339WithNanoseconds)((0, encodings_1.assertNotEmpty)(data.latest_block_time)),
        latestBlockHeight: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.latest_block_height)),
        catchingUp: (0, encodings_1.assertBoolean)(data.catching_up)
      };
    }
    function decodeStatus(data) {
      return {
        nodeInfo: decodeNodeInfo(data.node_info),
        syncInfo: decodeSyncInfo(data.sync_info),
        validatorInfo: decodeValidatorInfo(data.validator_info)
      };
    }
    function decodeTxProof(data) {
      return {
        data: (0, encoding_1.fromBase64)((0, encodings_1.assertNotEmpty)(data.data)),
        rootHash: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data.root_hash)),
        proof: {
          total: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.proof.total)),
          index: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.proof.index)),
          leafHash: (0, encoding_1.fromBase64)((0, encodings_1.assertNotEmpty)(data.proof.leaf_hash)),
          aunts: (0, encodings_1.assertArray)(data.proof.aunts).map(encoding_1.fromBase64)
        }
      };
    }
    function decodeTxResponse(data) {
      return {
        tx: (0, encoding_1.fromBase64)((0, encodings_1.assertNotEmpty)(data.tx)),
        result: decodeTxData((0, encodings_1.assertObject)(data.tx_result)),
        height: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.height)),
        index: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNumber)(data.index)),
        hash: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data.hash)),
        proof: (0, encodings_1.may)(decodeTxProof, data.proof)
      };
    }
    function decodeTxSearch(data) {
      return {
        totalCount: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.total_count)),
        txs: (0, encodings_1.assertArray)(data.txs).map(decodeTxResponse)
      };
    }
    function decodeTxEvent(data) {
      const tx = (0, encoding_1.fromBase64)((0, encodings_1.assertNotEmpty)(data.tx));
      return {
        tx,
        hash: (0, hasher_1.hashTx)(tx),
        result: decodeTxData(data.result),
        height: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.height))
      };
    }
    function decodeValidators(data) {
      return {
        blockHeight: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.block_height)),
        validators: (0, encodings_1.assertArray)(data.validators).map(decodeValidatorInfo),
        count: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.count)),
        total: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.total))
      };
    }
    function decodeBlock(data) {
      var _a;
      return {
        header: decodeHeader((0, encodings_1.assertObject)(data.header)),
        // For the block at height 1, last commit is not set. This is represented in an empty object like this:
        // { height: '0', round: 0, block_id: { hash: '', parts: [Object] }, signatures: [] }
        lastCommit: data.last_commit.block_id.hash ? decodeCommit((0, encodings_1.assertObject)(data.last_commit)) : null,
        txs: data.data.txs ? (0, encodings_1.assertArray)(data.data.txs).map(encoding_1.fromBase64) : [],
        // Lift up .evidence.evidence to just .evidence
        // See https://github.com/tendermint/tendermint/issues/7697
        evidence: ((_a = data.evidence) == null ? void 0 : _a.evidence) ?? []
      };
    }
    function decodeBlockResponse(data) {
      return {
        blockId: decodeBlockId(data.block_id),
        block: decodeBlock(data.block)
      };
    }
    function decodeBlockSearch(data) {
      return {
        totalCount: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.total_count)),
        blocks: (0, encodings_1.assertArray)(data.blocks).map(decodeBlockResponse)
      };
    }
    function decodeNumUnconfirmedTxs(data) {
      return {
        total: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.total)),
        totalBytes: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.total_bytes))
      };
    }
    var Responses = class _Responses {
      static decodeAbciInfo(response) {
        return decodeAbciInfo((0, encodings_1.assertObject)(response.result.response));
      }
      static decodeAbciQuery(response) {
        return decodeAbciQuery((0, encodings_1.assertObject)(response.result.response));
      }
      static decodeBlock(response) {
        return decodeBlockResponse(response.result);
      }
      static decodeBlockResults(response) {
        return decodeBlockResults(response.result);
      }
      static decodeBlockSearch(response) {
        return decodeBlockSearch(response.result);
      }
      static decodeBlockchain(response) {
        return decodeBlockchain(response.result);
      }
      static decodeBroadcastTxSync(response) {
        return decodeBroadcastTxSync(response.result);
      }
      static decodeBroadcastTxAsync(response) {
        return _Responses.decodeBroadcastTxSync(response);
      }
      static decodeBroadcastTxCommit(response) {
        return decodeBroadcastTxCommit(response.result);
      }
      static decodeCommit(response) {
        return decodeCommitResponse(response.result);
      }
      static decodeGenesis(response) {
        return decodeGenesis((0, encodings_1.assertObject)(response.result.genesis));
      }
      static decodeHealth() {
        return null;
      }
      static decodeNumUnconfirmedTxs(response) {
        return decodeNumUnconfirmedTxs(response.result);
      }
      static decodeStatus(response) {
        return decodeStatus(response.result);
      }
      static decodeNewBlockEvent(event) {
        return decodeBlock(event.data.value.block);
      }
      static decodeNewBlockHeaderEvent(event) {
        return decodeHeader(event.data.value.header);
      }
      static decodeTxEvent(event) {
        return decodeTxEvent(event.data.value.TxResult);
      }
      static decodeTx(response) {
        return decodeTxResponse(response.result);
      }
      static decodeTxSearch(response) {
        return decodeTxSearch(response.result);
      }
      static decodeValidators(response) {
        return decodeValidators(response.result);
      }
    };
    exports.Responses = Responses;
  }
});

// ../../node_modules/.pnpm/@cosmjs+tendermint-rpc@0.34.0/node_modules/@cosmjs/tendermint-rpc/build/tendermint34/adaptor/index.js
var require_adaptor2 = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+tendermint-rpc@0.34.0/node_modules/@cosmjs/tendermint-rpc/build/tendermint34/adaptor/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Responses = exports.Params = void 0;
    var requests_1 = require_requests4();
    Object.defineProperty(exports, "Params", { enumerable: true, get: function() {
      return requests_1.Params;
    } });
    var responses_1 = require_responses4();
    Object.defineProperty(exports, "Responses", { enumerable: true, get: function() {
      return responses_1.Responses;
    } });
  }
});

// ../../node_modules/.pnpm/@cosmjs+tendermint-rpc@0.34.0/node_modules/@cosmjs/tendermint-rpc/build/tendermint34/tendermint34client.js
var require_tendermint34client = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+tendermint-rpc@0.34.0/node_modules/@cosmjs/tendermint-rpc/build/tendermint34/tendermint34client.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function() {
      var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o2) {
          var ar = [];
          for (var k in o2)
            if (Object.prototype.hasOwnProperty.call(o2, k))
              ar[ar.length] = k;
          return ar;
        };
        return ownKeys(o);
      };
      return function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k = ownKeys(mod), i = 0; i < k.length; i++)
            if (k[i] !== "default")
              __createBinding(result, mod, k[i]);
        }
        __setModuleDefault(result, mod);
        return result;
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Tendermint34Client = void 0;
    var jsonrpc_1 = require_jsonrpc();
    var rpcclients_1 = require_rpcclients();
    var adaptor_1 = require_adaptor2();
    var requests = __importStar(require_requests3());
    var Tendermint34Client = class _Tendermint34Client {
      /**
       * Creates a new Tendermint client for the given endpoint.
       *
       * Uses HTTP when the URL schema is http or https. Uses WebSockets otherwise.
       */
      static async connect(endpoint) {
        let rpcClient;
        if (typeof endpoint === "object") {
          rpcClient = new rpcclients_1.HttpClient(endpoint);
        } else {
          const useHttp = endpoint.startsWith("http://") || endpoint.startsWith("https://");
          rpcClient = useHttp ? new rpcclients_1.HttpClient(endpoint) : new rpcclients_1.WebsocketClient(endpoint);
        }
        const _version = await this.detectVersion(rpcClient);
        return _Tendermint34Client.create(rpcClient);
      }
      /**
       * Creates a new Tendermint client given an RPC client.
       */
      static async create(rpcClient) {
        return new _Tendermint34Client(rpcClient);
      }
      static async detectVersion(client) {
        const req = (0, jsonrpc_1.createJsonRpcRequest)(requests.Method.Status);
        const response = await client.execute(req);
        const result = response.result;
        if (!result || !result.node_info) {
          throw new Error("Unrecognized format for status response");
        }
        const version = result.node_info.version;
        if (typeof version !== "string") {
          throw new Error("Unrecognized version format: must be string");
        }
        return version;
      }
      /**
       * Use `Tendermint34Client.connect` or `Tendermint34Client.create` to create an instance.
       */
      constructor(client) {
        this.client = client;
      }
      disconnect() {
        this.client.disconnect();
      }
      async abciInfo() {
        const query = { method: requests.Method.AbciInfo };
        return this.doCall(query, adaptor_1.Params.encodeAbciInfo, adaptor_1.Responses.decodeAbciInfo);
      }
      async abciQuery(params) {
        const query = { params, method: requests.Method.AbciQuery };
        return this.doCall(query, adaptor_1.Params.encodeAbciQuery, adaptor_1.Responses.decodeAbciQuery);
      }
      async block(height) {
        const query = { method: requests.Method.Block, params: { height } };
        return this.doCall(query, adaptor_1.Params.encodeBlock, adaptor_1.Responses.decodeBlock);
      }
      async blockResults(height) {
        const query = {
          method: requests.Method.BlockResults,
          params: { height }
        };
        return this.doCall(query, adaptor_1.Params.encodeBlockResults, adaptor_1.Responses.decodeBlockResults);
      }
      /**
       * Search for events that are in a block.
       *
       * NOTE
       * This method will error on any node that is running a Tendermint version lower than 0.34.9.
       *
       * @see https://docs.tendermint.com/master/rpc/#/Info/block_search
       */
      async blockSearch(params) {
        const query = { params, method: requests.Method.BlockSearch };
        const resp = await this.doCall(query, adaptor_1.Params.encodeBlockSearch, adaptor_1.Responses.decodeBlockSearch);
        return {
          ...resp,
          // make sure we sort by height, as tendermint may be sorting by string value of the height
          blocks: [...resp.blocks].sort((a, b) => a.block.header.height - b.block.header.height)
        };
      }
      // this should paginate through all blockSearch options to ensure it returns all results.
      // starts with page 1 or whatever was provided (eg. to start on page 7)
      //
      // NOTE
      // This method will error on any node that is running a Tendermint version lower than 0.34.9.
      async blockSearchAll(params) {
        let page = params.page || 1;
        const blocks = [];
        let done = false;
        while (!done) {
          const resp = await this.blockSearch({ ...params, page });
          blocks.push(...resp.blocks);
          if (blocks.length < resp.totalCount) {
            page++;
          } else {
            done = true;
          }
        }
        blocks.sort((a, b) => a.block.header.height - b.block.header.height);
        return {
          totalCount: blocks.length,
          blocks
        };
      }
      /**
       * Queries block headers filtered by minHeight <= height <= maxHeight.
       *
       * @param minHeight The minimum height to be included in the result. Defaults to 0.
       * @param maxHeight The maximum height to be included in the result. Defaults to infinity.
       */
      async blockchain(minHeight, maxHeight) {
        const query = {
          method: requests.Method.Blockchain,
          params: {
            minHeight,
            maxHeight
          }
        };
        return this.doCall(query, adaptor_1.Params.encodeBlockchain, adaptor_1.Responses.decodeBlockchain);
      }
      /**
       * Broadcast transaction to mempool and wait for response
       *
       * @see https://docs.tendermint.com/master/rpc/#/Tx/broadcast_tx_sync
       */
      async broadcastTxSync(params) {
        const query = { params, method: requests.Method.BroadcastTxSync };
        return this.doCall(query, adaptor_1.Params.encodeBroadcastTx, adaptor_1.Responses.decodeBroadcastTxSync);
      }
      /**
       * Broadcast transaction to mempool and do not wait for result
       *
       * @see https://docs.tendermint.com/master/rpc/#/Tx/broadcast_tx_async
       */
      async broadcastTxAsync(params) {
        const query = { params, method: requests.Method.BroadcastTxAsync };
        return this.doCall(query, adaptor_1.Params.encodeBroadcastTx, adaptor_1.Responses.decodeBroadcastTxAsync);
      }
      /**
       * Broadcast transaction to mempool and wait for block
       *
       * @see https://docs.tendermint.com/master/rpc/#/Tx/broadcast_tx_commit
       */
      async broadcastTxCommit(params) {
        const query = { params, method: requests.Method.BroadcastTxCommit };
        return this.doCall(query, adaptor_1.Params.encodeBroadcastTx, adaptor_1.Responses.decodeBroadcastTxCommit);
      }
      async commit(height) {
        const query = { method: requests.Method.Commit, params: { height } };
        return this.doCall(query, adaptor_1.Params.encodeCommit, adaptor_1.Responses.decodeCommit);
      }
      async genesis() {
        const query = { method: requests.Method.Genesis };
        return this.doCall(query, adaptor_1.Params.encodeGenesis, adaptor_1.Responses.decodeGenesis);
      }
      async health() {
        const query = { method: requests.Method.Health };
        return this.doCall(query, adaptor_1.Params.encodeHealth, adaptor_1.Responses.decodeHealth);
      }
      async numUnconfirmedTxs() {
        const query = { method: requests.Method.NumUnconfirmedTxs };
        return this.doCall(query, adaptor_1.Params.encodeNumUnconfirmedTxs, adaptor_1.Responses.decodeNumUnconfirmedTxs);
      }
      async status() {
        const query = { method: requests.Method.Status };
        return this.doCall(query, adaptor_1.Params.encodeStatus, adaptor_1.Responses.decodeStatus);
      }
      subscribeNewBlock() {
        const request = {
          method: requests.Method.Subscribe,
          query: { type: requests.SubscriptionEventType.NewBlock }
        };
        return this.subscribe(request, adaptor_1.Responses.decodeNewBlockEvent);
      }
      subscribeNewBlockHeader() {
        const request = {
          method: requests.Method.Subscribe,
          query: { type: requests.SubscriptionEventType.NewBlockHeader }
        };
        return this.subscribe(request, adaptor_1.Responses.decodeNewBlockHeaderEvent);
      }
      subscribeTx(query) {
        const request = {
          method: requests.Method.Subscribe,
          query: {
            type: requests.SubscriptionEventType.Tx,
            raw: query
          }
        };
        return this.subscribe(request, adaptor_1.Responses.decodeTxEvent);
      }
      /**
       * Get a single transaction by hash
       *
       * @see https://docs.tendermint.com/master/rpc/#/Info/tx
       */
      async tx(params) {
        const query = { params, method: requests.Method.Tx };
        return this.doCall(query, adaptor_1.Params.encodeTx, adaptor_1.Responses.decodeTx);
      }
      /**
       * Search for transactions that are in a block
       *
       * @see https://docs.tendermint.com/master/rpc/#/Info/tx_search
       */
      async txSearch(params) {
        const query = { params, method: requests.Method.TxSearch };
        return this.doCall(query, adaptor_1.Params.encodeTxSearch, adaptor_1.Responses.decodeTxSearch);
      }
      // this should paginate through all txSearch options to ensure it returns all results.
      // starts with page 1 or whatever was provided (eg. to start on page 7)
      async txSearchAll(params) {
        let page = params.page || 1;
        const txs = [];
        let done = false;
        while (!done) {
          const resp = await this.txSearch({ ...params, page });
          txs.push(...resp.txs);
          if (txs.length < resp.totalCount) {
            page++;
          } else {
            done = true;
          }
        }
        return {
          totalCount: txs.length,
          txs
        };
      }
      async validators(params) {
        const query = {
          method: requests.Method.Validators,
          params
        };
        return this.doCall(query, adaptor_1.Params.encodeValidators, adaptor_1.Responses.decodeValidators);
      }
      async validatorsAll(height) {
        const validators = [];
        let page = 1;
        let done = false;
        let blockHeight = height;
        while (!done) {
          const response = await this.validators({
            per_page: 50,
            height: blockHeight,
            page
          });
          validators.push(...response.validators);
          blockHeight = blockHeight || response.blockHeight;
          if (validators.length < response.total) {
            page++;
          } else {
            done = true;
          }
        }
        return {
          // NOTE: Default value is for type safety but this should always be set
          blockHeight: blockHeight ?? 0,
          count: validators.length,
          total: validators.length,
          validators
        };
      }
      // doCall is a helper to handle the encode/call/decode logic
      async doCall(request, encode, decode) {
        const req = encode(request);
        const result = await this.client.execute(req);
        return decode(result);
      }
      subscribe(request, decode) {
        if (!(0, rpcclients_1.instanceOfRpcStreamingClient)(this.client)) {
          throw new Error("This RPC client type cannot subscribe to events");
        }
        const req = adaptor_1.Params.encodeSubscribe(request);
        const eventStream = this.client.listen(req);
        return eventStream.map((event) => {
          return decode(event);
        });
      }
    };
    exports.Tendermint34Client = Tendermint34Client;
  }
});

// ../../node_modules/.pnpm/@cosmjs+tendermint-rpc@0.34.0/node_modules/@cosmjs/tendermint-rpc/build/tendermint34/index.js
var require_tendermint34 = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+tendermint-rpc@0.34.0/node_modules/@cosmjs/tendermint-rpc/build/tendermint34/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Tendermint34Client = exports.VoteType = exports.broadcastTxSyncSuccess = exports.broadcastTxCommitSuccess = exports.SubscriptionEventType = exports.Method = void 0;
    var requests_1 = require_requests3();
    Object.defineProperty(exports, "Method", { enumerable: true, get: function() {
      return requests_1.Method;
    } });
    Object.defineProperty(exports, "SubscriptionEventType", { enumerable: true, get: function() {
      return requests_1.SubscriptionEventType;
    } });
    var responses_1 = require_responses3();
    Object.defineProperty(exports, "broadcastTxCommitSuccess", { enumerable: true, get: function() {
      return responses_1.broadcastTxCommitSuccess;
    } });
    Object.defineProperty(exports, "broadcastTxSyncSuccess", { enumerable: true, get: function() {
      return responses_1.broadcastTxSyncSuccess;
    } });
    Object.defineProperty(exports, "VoteType", { enumerable: true, get: function() {
      return responses_1.VoteType;
    } });
    var tendermint34client_1 = require_tendermint34client();
    Object.defineProperty(exports, "Tendermint34Client", { enumerable: true, get: function() {
      return tendermint34client_1.Tendermint34Client;
    } });
  }
});

// ../../node_modules/.pnpm/@cosmjs+tendermint-rpc@0.34.0/node_modules/@cosmjs/tendermint-rpc/build/tendermint37/requests.js
var require_requests5 = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+tendermint-rpc@0.34.0/node_modules/@cosmjs/tendermint-rpc/build/tendermint37/requests.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SubscriptionEventType = exports.Method = void 0;
    exports.buildQuery = buildQuery;
    var Method;
    (function(Method2) {
      Method2["AbciInfo"] = "abci_info";
      Method2["AbciQuery"] = "abci_query";
      Method2["Block"] = "block";
      Method2["Blockchain"] = "blockchain";
      Method2["BlockResults"] = "block_results";
      Method2["BlockSearch"] = "block_search";
      Method2["BroadcastTxAsync"] = "broadcast_tx_async";
      Method2["BroadcastTxSync"] = "broadcast_tx_sync";
      Method2["BroadcastTxCommit"] = "broadcast_tx_commit";
      Method2["Commit"] = "commit";
      Method2["Genesis"] = "genesis";
      Method2["Health"] = "health";
      Method2["NumUnconfirmedTxs"] = "num_unconfirmed_txs";
      Method2["Status"] = "status";
      Method2["Subscribe"] = "subscribe";
      Method2["Tx"] = "tx";
      Method2["TxSearch"] = "tx_search";
      Method2["Validators"] = "validators";
      Method2["Unsubscribe"] = "unsubscribe";
    })(Method || (exports.Method = Method = {}));
    var SubscriptionEventType;
    (function(SubscriptionEventType2) {
      SubscriptionEventType2["NewBlock"] = "NewBlock";
      SubscriptionEventType2["NewBlockHeader"] = "NewBlockHeader";
      SubscriptionEventType2["Tx"] = "Tx";
    })(SubscriptionEventType || (exports.SubscriptionEventType = SubscriptionEventType = {}));
    function buildQuery(components) {
      const tags = components.tags ? components.tags : [];
      const tagComponents = tags.map((tag) => `${tag.key}='${tag.value}'`);
      const rawComponents = components.raw ? [components.raw] : [];
      return [...tagComponents, ...rawComponents].join(" AND ");
    }
  }
});

// ../../node_modules/.pnpm/@cosmjs+tendermint-rpc@0.34.0/node_modules/@cosmjs/tendermint-rpc/build/tendermint37/responses.js
var require_responses5 = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+tendermint-rpc@0.34.0/node_modules/@cosmjs/tendermint-rpc/build/tendermint37/responses.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.VoteType = void 0;
    exports.broadcastTxSyncSuccess = broadcastTxSyncSuccess;
    exports.broadcastTxCommitSuccess = broadcastTxCommitSuccess;
    function broadcastTxSyncSuccess(res) {
      return res.code === 0;
    }
    function broadcastTxCommitSuccess(response) {
      return response.checkTx.code === 0 && !!response.deliverTx && response.deliverTx.code === 0;
    }
    var VoteType;
    (function(VoteType2) {
      VoteType2[VoteType2["PreVote"] = 1] = "PreVote";
      VoteType2[VoteType2["PreCommit"] = 2] = "PreCommit";
    })(VoteType || (exports.VoteType = VoteType = {}));
  }
});

// ../../node_modules/.pnpm/@cosmjs+tendermint-rpc@0.34.0/node_modules/@cosmjs/tendermint-rpc/build/tendermint37/encodings.js
var require_encodings3 = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+tendermint-rpc@0.34.0/node_modules/@cosmjs/tendermint-rpc/build/tendermint37/encodings.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.assertSet = assertSet;
    exports.assertBoolean = assertBoolean;
    exports.assertString = assertString;
    exports.assertNumber = assertNumber;
    exports.assertArray = assertArray;
    exports.assertObject = assertObject;
    exports.assertNotEmpty = assertNotEmpty;
    exports.may = may;
    exports.dictionaryToStringMap = dictionaryToStringMap;
    exports.encodeString = encodeString;
    exports.encodeUvarint = encodeUvarint;
    exports.encodeTime = encodeTime;
    exports.encodeBytes = encodeBytes;
    exports.encodeVersion = encodeVersion;
    exports.encodeBlockId = encodeBlockId;
    var encoding_1 = require_build();
    function assertSet(value) {
      if (value === void 0) {
        throw new Error("Value must not be undefined");
      }
      if (value === null) {
        throw new Error("Value must not be null");
      }
      return value;
    }
    function assertBoolean(value) {
      assertSet(value);
      if (typeof value !== "boolean") {
        throw new Error("Value must be a boolean");
      }
      return value;
    }
    function assertString(value) {
      assertSet(value);
      if (typeof value !== "string") {
        throw new Error("Value must be a string");
      }
      return value;
    }
    function assertNumber(value) {
      assertSet(value);
      if (typeof value !== "number") {
        throw new Error("Value must be a number");
      }
      return value;
    }
    function assertArray(value) {
      assertSet(value);
      if (!Array.isArray(value)) {
        throw new Error("Value must be a an array");
      }
      return value;
    }
    function assertObject(value) {
      assertSet(value);
      if (typeof value !== "object") {
        throw new Error("Value must be an object");
      }
      if (Object.prototype.toString.call(value) !== "[object Object]") {
        throw new Error("Value must be a simple object");
      }
      return value;
    }
    function assertNotEmpty(value) {
      assertSet(value);
      if (typeof value === "number" && value === 0) {
        throw new Error("must provide a non-zero value");
      } else if (value.length === 0) {
        throw new Error("must provide a non-empty value");
      }
      return value;
    }
    function may(transform, value) {
      return value === void 0 || value === null ? void 0 : transform(value);
    }
    function dictionaryToStringMap(obj) {
      const out = /* @__PURE__ */ new Map();
      for (const key of Object.keys(obj)) {
        const value = obj[key];
        if (typeof value !== "string") {
          throw new Error("Found dictionary value of type other than string");
        }
        out.set(key, value);
      }
      return out;
    }
    function encodeString(s) {
      const utf8 = (0, encoding_1.toUtf8)(s);
      return Uint8Array.from([utf8.length, ...utf8]);
    }
    function encodeUvarint(n) {
      return n >= 128 ? (
        // eslint-disable-next-line no-bitwise
        Uint8Array.from([n & 255 | 128, ...encodeUvarint(n >> 7)])
      ) : (
        // eslint-disable-next-line no-bitwise
        Uint8Array.from([n & 255])
      );
    }
    function encodeTime(time) {
      const milliseconds = time.getTime();
      const seconds = Math.floor(milliseconds / 1e3);
      const secondsArray = seconds ? [8, ...encodeUvarint(seconds)] : new Uint8Array();
      const nanoseconds = (time.nanoseconds || 0) + milliseconds % 1e3 * 1e6;
      const nanosecondsArray = nanoseconds ? [16, ...encodeUvarint(nanoseconds)] : new Uint8Array();
      return Uint8Array.from([...secondsArray, ...nanosecondsArray]);
    }
    function encodeBytes(bytes) {
      if (bytes.length >= 128)
        throw new Error("Not implemented for byte arrays of length 128 or more");
      return bytes.length ? Uint8Array.from([bytes.length, ...bytes]) : new Uint8Array();
    }
    function encodeVersion(version) {
      const blockArray = version.block ? Uint8Array.from([8, ...encodeUvarint(version.block)]) : new Uint8Array();
      const appArray = version.app ? Uint8Array.from([16, ...encodeUvarint(version.app)]) : new Uint8Array();
      return Uint8Array.from([...blockArray, ...appArray]);
    }
    function encodeBlockId(blockId) {
      return Uint8Array.from([
        10,
        blockId.hash.length,
        ...blockId.hash,
        18,
        blockId.parts.hash.length + 4,
        8,
        blockId.parts.total,
        18,
        blockId.parts.hash.length,
        ...blockId.parts.hash
      ]);
    }
  }
});

// ../../node_modules/.pnpm/@cosmjs+tendermint-rpc@0.34.0/node_modules/@cosmjs/tendermint-rpc/build/tendermint37/adaptor/requests.js
var require_requests6 = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+tendermint-rpc@0.34.0/node_modules/@cosmjs/tendermint-rpc/build/tendermint37/adaptor/requests.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function() {
      var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o2) {
          var ar = [];
          for (var k in o2)
            if (Object.prototype.hasOwnProperty.call(o2, k))
              ar[ar.length] = k;
          return ar;
        };
        return ownKeys(o);
      };
      return function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k = ownKeys(mod), i = 0; i < k.length; i++)
            if (k[i] !== "default")
              __createBinding(result, mod, k[i]);
        }
        __setModuleDefault(result, mod);
        return result;
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Params = void 0;
    var encoding_1 = require_build();
    var inthelpers_1 = require_inthelpers();
    var jsonrpc_1 = require_jsonrpc();
    var encodings_1 = require_encodings3();
    var requests = __importStar(require_requests5());
    function encodeHeightParam(param) {
      return {
        height: (0, encodings_1.may)(inthelpers_1.smallIntToApi, param.height)
      };
    }
    function encodeBlockchainRequestParams(param) {
      return {
        minHeight: (0, encodings_1.may)(inthelpers_1.smallIntToApi, param.minHeight),
        maxHeight: (0, encodings_1.may)(inthelpers_1.smallIntToApi, param.maxHeight)
      };
    }
    function encodeBlockSearchParams(params) {
      return {
        query: params.query,
        page: (0, encodings_1.may)(inthelpers_1.smallIntToApi, params.page),
        per_page: (0, encodings_1.may)(inthelpers_1.smallIntToApi, params.per_page),
        order_by: params.order_by
      };
    }
    function encodeAbciQueryParams(params) {
      return {
        path: (0, encodings_1.assertNotEmpty)(params.path),
        data: (0, encoding_1.toHex)(params.data),
        height: (0, encodings_1.may)(inthelpers_1.smallIntToApi, params.height),
        prove: params.prove
      };
    }
    function encodeBroadcastTxParams(params) {
      return {
        tx: (0, encoding_1.toBase64)((0, encodings_1.assertNotEmpty)(params.tx))
      };
    }
    function encodeTxParams(params) {
      return {
        hash: (0, encoding_1.toBase64)((0, encodings_1.assertNotEmpty)(params.hash)),
        prove: params.prove
      };
    }
    function encodeTxSearchParams(params) {
      return {
        query: params.query,
        prove: params.prove,
        page: (0, encodings_1.may)(inthelpers_1.smallIntToApi, params.page),
        per_page: (0, encodings_1.may)(inthelpers_1.smallIntToApi, params.per_page),
        order_by: params.order_by
      };
    }
    function encodeValidatorsParams(params) {
      return {
        height: (0, encodings_1.may)(inthelpers_1.smallIntToApi, params.height),
        page: (0, encodings_1.may)(inthelpers_1.smallIntToApi, params.page),
        per_page: (0, encodings_1.may)(inthelpers_1.smallIntToApi, params.per_page)
      };
    }
    var Params = class {
      static encodeAbciInfo(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method);
      }
      static encodeAbciQuery(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeAbciQueryParams(req.params));
      }
      static encodeBlock(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeHeightParam(req.params));
      }
      static encodeBlockchain(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeBlockchainRequestParams(req.params));
      }
      static encodeBlockResults(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeHeightParam(req.params));
      }
      static encodeBlockSearch(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeBlockSearchParams(req.params));
      }
      static encodeBroadcastTx(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeBroadcastTxParams(req.params));
      }
      static encodeCommit(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeHeightParam(req.params));
      }
      static encodeGenesis(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method);
      }
      static encodeHealth(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method);
      }
      static encodeNumUnconfirmedTxs(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method);
      }
      static encodeStatus(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method);
      }
      static encodeSubscribe(req) {
        const eventTag = { key: "tm.event", value: req.query.type };
        const query = requests.buildQuery({ tags: [eventTag], raw: req.query.raw });
        return (0, jsonrpc_1.createJsonRpcRequest)("subscribe", { query });
      }
      static encodeTx(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeTxParams(req.params));
      }
      // TODO: encode params for query string???
      static encodeTxSearch(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeTxSearchParams(req.params));
      }
      static encodeValidators(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeValidatorsParams(req.params));
      }
    };
    exports.Params = Params;
  }
});

// ../../node_modules/.pnpm/@cosmjs+tendermint-rpc@0.34.0/node_modules/@cosmjs/tendermint-rpc/build/tendermint37/hasher.js
var require_hasher3 = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+tendermint-rpc@0.34.0/node_modules/@cosmjs/tendermint-rpc/build/tendermint37/hasher.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.hashTx = hashTx;
    exports.hashBlock = hashBlock;
    var crypto_1 = require_build4();
    var encodings_1 = require_encodings3();
    function hashTx(tx) {
      return (0, crypto_1.sha256)(tx);
    }
    function getSplitPoint(n) {
      if (n < 1)
        throw new Error("Cannot split an empty tree");
      const largestPowerOf2 = 2 ** Math.floor(Math.log2(n));
      return largestPowerOf2 < n ? largestPowerOf2 : largestPowerOf2 / 2;
    }
    function hashLeaf(leaf) {
      const hash = new crypto_1.Sha256(Uint8Array.from([0]));
      hash.update(leaf);
      return hash.digest();
    }
    function hashInner(left, right) {
      const hash = new crypto_1.Sha256(Uint8Array.from([1]));
      hash.update(left);
      hash.update(right);
      return hash.digest();
    }
    function hashTree(hashes) {
      switch (hashes.length) {
        case 0:
          throw new Error("Cannot hash empty tree");
        case 1:
          return hashLeaf(hashes[0]);
        default: {
          const slicePoint = getSplitPoint(hashes.length);
          const left = hashTree(hashes.slice(0, slicePoint));
          const right = hashTree(hashes.slice(slicePoint));
          return hashInner(left, right);
        }
      }
    }
    function hashBlock(header) {
      if (!header.lastBlockId) {
        throw new Error("Hashing a block header with no last block ID (i.e. header at height 1) is not supported. If you need this, contributions are welcome. Please add documentation and test vectors for this case.");
      }
      const encodedFields = [
        (0, encodings_1.encodeVersion)(header.version),
        (0, encodings_1.encodeString)(header.chainId),
        (0, encodings_1.encodeUvarint)(header.height),
        (0, encodings_1.encodeTime)(header.time),
        (0, encodings_1.encodeBlockId)(header.lastBlockId),
        (0, encodings_1.encodeBytes)(header.lastCommitHash),
        (0, encodings_1.encodeBytes)(header.dataHash),
        (0, encodings_1.encodeBytes)(header.validatorsHash),
        (0, encodings_1.encodeBytes)(header.nextValidatorsHash),
        (0, encodings_1.encodeBytes)(header.consensusHash),
        (0, encodings_1.encodeBytes)(header.appHash),
        (0, encodings_1.encodeBytes)(header.lastResultsHash),
        (0, encodings_1.encodeBytes)(header.evidenceHash),
        (0, encodings_1.encodeBytes)(header.proposerAddress)
      ];
      return hashTree(encodedFields);
    }
  }
});

// ../../node_modules/.pnpm/@cosmjs+tendermint-rpc@0.34.0/node_modules/@cosmjs/tendermint-rpc/build/tendermint37/adaptor/responses.js
var require_responses6 = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+tendermint-rpc@0.34.0/node_modules/@cosmjs/tendermint-rpc/build/tendermint37/adaptor/responses.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Responses = void 0;
    exports.decodeEvent = decodeEvent;
    exports.decodeValidatorUpdate = decodeValidatorUpdate;
    exports.decodeValidatorGenesis = decodeValidatorGenesis;
    exports.decodeValidatorInfo = decodeValidatorInfo;
    var encoding_1 = require_build();
    var utils_1 = require_build3();
    var dates_1 = require_dates();
    var inthelpers_1 = require_inthelpers();
    var types_1 = require_types3();
    var encodings_1 = require_encodings3();
    var hasher_1 = require_hasher3();
    function decodeAbciInfo(data) {
      return {
        data: data.data,
        lastBlockHeight: (0, encodings_1.may)(inthelpers_1.apiToSmallInt, data.last_block_height),
        lastBlockAppHash: (0, encodings_1.may)(encoding_1.fromBase64, data.last_block_app_hash)
      };
    }
    function decodeQueryProof(data) {
      return {
        ops: data.ops.map((op) => ({
          type: op.type,
          key: (0, encoding_1.fromBase64)(op.key),
          data: (0, encoding_1.fromBase64)(op.data)
        }))
      };
    }
    function decodeAbciQuery(data) {
      return {
        key: (0, encoding_1.fromBase64)((0, encodings_1.assertString)(data.key ?? "")),
        value: (0, encoding_1.fromBase64)((0, encodings_1.assertString)(data.value ?? "")),
        proof: (0, encodings_1.may)(decodeQueryProof, data.proofOps),
        height: (0, encodings_1.may)(inthelpers_1.apiToSmallInt, data.height),
        code: (0, encodings_1.may)(inthelpers_1.apiToSmallInt, data.code),
        codespace: (0, encodings_1.assertString)(data.codespace ?? ""),
        index: (0, encodings_1.may)(inthelpers_1.apiToSmallInt, data.index),
        log: data.log,
        info: (0, encodings_1.assertString)(data.info ?? "")
      };
    }
    function decodeEventAttribute(attribute) {
      return {
        key: (0, encodings_1.assertNotEmpty)(attribute.key),
        value: attribute.value ?? ""
      };
    }
    function decodeAttributes(attributes) {
      return (0, encodings_1.assertArray)(attributes).map(decodeEventAttribute);
    }
    function decodeEvent(event) {
      return {
        type: event.type,
        attributes: event.attributes ? decodeAttributes(event.attributes) : []
      };
    }
    function decodeEvents(events) {
      return (0, encodings_1.assertArray)(events).map(decodeEvent);
    }
    function decodeTxData(data) {
      return {
        code: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNumber)(data.code ?? 0)),
        codespace: data.codespace,
        log: data.log,
        data: (0, encodings_1.may)(encoding_1.fromBase64, data.data),
        events: data.events ? decodeEvents(data.events) : [],
        gasWanted: (0, inthelpers_1.apiToBigInt)(data.gas_wanted ?? "0"),
        gasUsed: (0, inthelpers_1.apiToBigInt)(data.gas_used ?? "0")
      };
    }
    function decodePubkey(data) {
      if ("Sum" in data) {
        const [[algorithm, value]] = Object.entries(data.Sum.value);
        (0, utils_1.assert)(algorithm === "ed25519" || algorithm === "secp256k1", `unknown pubkey type: ${algorithm}`);
        return {
          algorithm,
          data: (0, encoding_1.fromBase64)((0, encodings_1.assertNotEmpty)(value))
        };
      } else {
        switch (data.type) {
          case "tendermint/PubKeyEd25519":
            return {
              algorithm: "ed25519",
              data: (0, encoding_1.fromBase64)((0, encodings_1.assertNotEmpty)(data.value))
            };
          case "tendermint/PubKeySecp256k1":
            return {
              algorithm: "secp256k1",
              data: (0, encoding_1.fromBase64)((0, encodings_1.assertNotEmpty)(data.value))
            };
          default:
            throw new Error(`unknown pubkey type: ${data.type}`);
        }
      }
    }
    function decodeBlockParams(data) {
      return {
        maxBytes: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.max_bytes)),
        maxGas: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.max_gas))
      };
    }
    function decodeEvidenceParams(data) {
      return {
        maxAgeNumBlocks: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.max_age_num_blocks)),
        maxAgeDuration: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.max_age_duration))
      };
    }
    function decodeConsensusParams(data) {
      return {
        block: decodeBlockParams((0, encodings_1.assertObject)(data.block)),
        evidence: decodeEvidenceParams((0, encodings_1.assertObject)(data.evidence))
      };
    }
    function decodeValidatorUpdate(data) {
      return {
        pubkey: decodePubkey((0, encodings_1.assertObject)(data.pub_key)),
        votingPower: (0, inthelpers_1.apiToBigInt)(data.power ?? "0")
      };
    }
    function decodeBlockResults(data) {
      return {
        height: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.height)),
        results: (data.txs_results || []).map(decodeTxData),
        validatorUpdates: (data.validator_updates || []).map(decodeValidatorUpdate),
        consensusUpdates: (0, encodings_1.may)(decodeConsensusParams, data.consensus_param_updates),
        beginBlockEvents: decodeEvents(data.begin_block_events || []),
        endBlockEvents: decodeEvents(data.end_block_events || [])
      };
    }
    function decodeBlockId(data) {
      return {
        hash: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data.hash)),
        parts: {
          total: (0, encodings_1.assertNotEmpty)(data.parts.total),
          hash: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data.parts.hash))
        }
      };
    }
    function decodeBlockVersion(data) {
      return {
        block: (0, inthelpers_1.apiToSmallInt)(data.block),
        app: (0, inthelpers_1.apiToSmallInt)(data.app ?? 0)
      };
    }
    function decodeHeader(data) {
      return {
        version: decodeBlockVersion(data.version),
        chainId: (0, encodings_1.assertNotEmpty)(data.chain_id),
        height: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.height)),
        time: (0, dates_1.fromRfc3339WithNanoseconds)((0, encodings_1.assertNotEmpty)(data.time)),
        // When there is no last block ID (i.e. this block's height is 1), we get an empty structure like this:
        // { hash: '', parts: { total: 0, hash: '' } }
        lastBlockId: data.last_block_id.hash ? decodeBlockId(data.last_block_id) : null,
        lastCommitHash: (0, encoding_1.fromHex)((0, encodings_1.assertSet)(data.last_commit_hash)),
        dataHash: (0, encoding_1.fromHex)((0, encodings_1.assertSet)(data.data_hash)),
        validatorsHash: (0, encoding_1.fromHex)((0, encodings_1.assertSet)(data.validators_hash)),
        nextValidatorsHash: (0, encoding_1.fromHex)((0, encodings_1.assertSet)(data.next_validators_hash)),
        consensusHash: (0, encoding_1.fromHex)((0, encodings_1.assertSet)(data.consensus_hash)),
        appHash: (0, encoding_1.fromHex)((0, encodings_1.assertSet)(data.app_hash)),
        lastResultsHash: (0, encoding_1.fromHex)((0, encodings_1.assertSet)(data.last_results_hash)),
        evidenceHash: (0, encoding_1.fromHex)((0, encodings_1.assertSet)(data.evidence_hash)),
        proposerAddress: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data.proposer_address))
      };
    }
    function decodeBlockMeta(data) {
      return {
        blockId: decodeBlockId(data.block_id),
        blockSize: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.block_size)),
        header: decodeHeader(data.header),
        numTxs: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.num_txs))
      };
    }
    function decodeBlockchain(data) {
      return {
        lastHeight: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.last_height)),
        blockMetas: (0, encodings_1.assertArray)(data.block_metas).map(decodeBlockMeta)
      };
    }
    function decodeBroadcastTxSync(data) {
      return {
        ...decodeTxData(data),
        hash: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data.hash))
      };
    }
    function decodeBroadcastTxCommit(data) {
      return {
        height: (0, inthelpers_1.apiToSmallInt)(data.height),
        hash: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data.hash)),
        checkTx: decodeTxData((0, encodings_1.assertObject)(data.check_tx)),
        deliverTx: (0, encodings_1.may)(decodeTxData, data.deliver_tx)
      };
    }
    function decodeBlockIdFlag(blockIdFlag) {
      (0, utils_1.assert)(blockIdFlag in types_1.BlockIdFlag);
      return blockIdFlag;
    }
    function decodeCommitSignature(data) {
      return {
        blockIdFlag: decodeBlockIdFlag(data.block_id_flag),
        validatorAddress: data.validator_address ? (0, encoding_1.fromHex)(data.validator_address) : void 0,
        timestamp: data.timestamp ? (0, dates_1.fromRfc3339WithNanoseconds)(data.timestamp) : void 0,
        signature: data.signature ? (0, encoding_1.fromBase64)(data.signature) : void 0
      };
    }
    function decodeCommit(data) {
      return {
        blockId: decodeBlockId((0, encodings_1.assertObject)(data.block_id)),
        height: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.height)),
        round: (0, inthelpers_1.apiToSmallInt)(data.round),
        signatures: (0, encodings_1.assertArray)(data.signatures).map(decodeCommitSignature)
      };
    }
    function decodeCommitResponse(data) {
      return {
        canonical: (0, encodings_1.assertBoolean)(data.canonical),
        header: decodeHeader(data.signed_header.header),
        commit: decodeCommit(data.signed_header.commit)
      };
    }
    function decodeValidatorGenesis(data) {
      return {
        address: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data.address)),
        pubkey: decodePubkey((0, encodings_1.assertObject)(data.pub_key)),
        votingPower: (0, inthelpers_1.apiToBigInt)((0, encodings_1.assertNotEmpty)(data.power))
      };
    }
    function decodeGenesis(data) {
      return {
        genesisTime: (0, dates_1.fromRfc3339WithNanoseconds)((0, encodings_1.assertNotEmpty)(data.genesis_time)),
        chainId: (0, encodings_1.assertNotEmpty)(data.chain_id),
        consensusParams: decodeConsensusParams(data.consensus_params),
        validators: data.validators ? (0, encodings_1.assertArray)(data.validators).map(decodeValidatorGenesis) : [],
        appHash: (0, encoding_1.fromHex)((0, encodings_1.assertSet)(data.app_hash)),
        // empty string in kvstore app
        appState: data.app_state
      };
    }
    function decodeValidatorInfo(data) {
      return {
        pubkey: decodePubkey((0, encodings_1.assertObject)(data.pub_key)),
        votingPower: (0, inthelpers_1.apiToBigInt)((0, encodings_1.assertNotEmpty)(data.voting_power)),
        address: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data.address)),
        proposerPriority: data.proposer_priority ? (0, inthelpers_1.apiToSmallInt)(data.proposer_priority) : void 0
      };
    }
    function decodeNodeInfo(data) {
      return {
        id: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data.id)),
        listenAddr: (0, encodings_1.assertNotEmpty)(data.listen_addr),
        network: (0, encodings_1.assertNotEmpty)(data.network),
        version: (0, encodings_1.assertString)(data.version),
        // Can be empty (https://github.com/cosmos/cosmos-sdk/issues/7963)
        channels: (0, encodings_1.assertString)(data.channels),
        // can be empty
        moniker: (0, encodings_1.assertNotEmpty)(data.moniker),
        other: (0, encodings_1.dictionaryToStringMap)(data.other),
        protocolVersion: {
          app: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.protocol_version.app)),
          block: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.protocol_version.block)),
          p2p: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.protocol_version.p2p))
        }
      };
    }
    function decodeSyncInfo(data) {
      const earliestBlockHeight = data.earliest_block_height ? (0, inthelpers_1.apiToSmallInt)(data.earliest_block_height) : void 0;
      const earliestBlockTime = data.earliest_block_time ? (0, dates_1.fromRfc3339WithNanoseconds)(data.earliest_block_time) : void 0;
      return {
        earliestAppHash: data.earliest_app_hash ? (0, encoding_1.fromHex)(data.earliest_app_hash) : void 0,
        earliestBlockHash: data.earliest_block_hash ? (0, encoding_1.fromHex)(data.earliest_block_hash) : void 0,
        earliestBlockHeight: earliestBlockHeight || void 0,
        earliestBlockTime: (earliestBlockTime == null ? void 0 : earliestBlockTime.getTime()) ? earliestBlockTime : void 0,
        latestBlockHash: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data.latest_block_hash)),
        latestAppHash: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data.latest_app_hash)),
        latestBlockTime: (0, dates_1.fromRfc3339WithNanoseconds)((0, encodings_1.assertNotEmpty)(data.latest_block_time)),
        latestBlockHeight: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.latest_block_height)),
        catchingUp: (0, encodings_1.assertBoolean)(data.catching_up)
      };
    }
    function decodeStatus(data) {
      return {
        nodeInfo: decodeNodeInfo(data.node_info),
        syncInfo: decodeSyncInfo(data.sync_info),
        validatorInfo: decodeValidatorInfo(data.validator_info)
      };
    }
    function decodeTxProof(data) {
      return {
        data: (0, encoding_1.fromBase64)((0, encodings_1.assertNotEmpty)(data.data)),
        rootHash: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data.root_hash)),
        proof: {
          total: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.proof.total)),
          index: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.proof.index)),
          leafHash: (0, encoding_1.fromBase64)((0, encodings_1.assertNotEmpty)(data.proof.leaf_hash)),
          aunts: (0, encodings_1.assertArray)(data.proof.aunts).map(encoding_1.fromBase64)
        }
      };
    }
    function decodeTxResponse(data) {
      return {
        tx: (0, encoding_1.fromBase64)((0, encodings_1.assertNotEmpty)(data.tx)),
        result: decodeTxData((0, encodings_1.assertObject)(data.tx_result)),
        height: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.height)),
        index: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNumber)(data.index)),
        hash: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data.hash)),
        proof: (0, encodings_1.may)(decodeTxProof, data.proof)
      };
    }
    function decodeTxSearch(data) {
      return {
        totalCount: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.total_count)),
        txs: (0, encodings_1.assertArray)(data.txs).map(decodeTxResponse)
      };
    }
    function decodeTxEvent(data) {
      const tx = (0, encoding_1.fromBase64)((0, encodings_1.assertNotEmpty)(data.tx));
      return {
        tx,
        hash: (0, hasher_1.hashTx)(tx),
        result: decodeTxData(data.result),
        height: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.height))
      };
    }
    function decodeValidators(data) {
      return {
        blockHeight: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.block_height)),
        validators: (0, encodings_1.assertArray)(data.validators).map(decodeValidatorInfo),
        count: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.count)),
        total: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.total))
      };
    }
    function decodeBlock(data) {
      var _a;
      return {
        header: decodeHeader((0, encodings_1.assertObject)(data.header)),
        // For the block at height 1, last commit is not set. This is represented in an empty object like this:
        // { height: '0', round: 0, block_id: { hash: '', parts: [Object] }, signatures: [] }
        lastCommit: data.last_commit.block_id.hash ? decodeCommit((0, encodings_1.assertObject)(data.last_commit)) : null,
        txs: data.data.txs ? (0, encodings_1.assertArray)(data.data.txs).map(encoding_1.fromBase64) : [],
        // Lift up .evidence.evidence to just .evidence
        // See https://github.com/tendermint/tendermint/issues/7697
        evidence: ((_a = data.evidence) == null ? void 0 : _a.evidence) ?? []
      };
    }
    function decodeBlockResponse(data) {
      return {
        blockId: decodeBlockId(data.block_id),
        block: decodeBlock(data.block)
      };
    }
    function decodeBlockSearch(data) {
      return {
        totalCount: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.total_count)),
        blocks: (0, encodings_1.assertArray)(data.blocks).map(decodeBlockResponse)
      };
    }
    function decodeNumUnconfirmedTxs(data) {
      return {
        total: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.total)),
        totalBytes: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.total_bytes))
      };
    }
    var Responses = class _Responses {
      static decodeAbciInfo(response) {
        return decodeAbciInfo((0, encodings_1.assertObject)(response.result.response));
      }
      static decodeAbciQuery(response) {
        return decodeAbciQuery((0, encodings_1.assertObject)(response.result.response));
      }
      static decodeBlock(response) {
        return decodeBlockResponse(response.result);
      }
      static decodeBlockResults(response) {
        return decodeBlockResults(response.result);
      }
      static decodeBlockSearch(response) {
        return decodeBlockSearch(response.result);
      }
      static decodeBlockchain(response) {
        return decodeBlockchain(response.result);
      }
      static decodeBroadcastTxSync(response) {
        return decodeBroadcastTxSync(response.result);
      }
      static decodeBroadcastTxAsync(response) {
        return _Responses.decodeBroadcastTxSync(response);
      }
      static decodeBroadcastTxCommit(response) {
        return decodeBroadcastTxCommit(response.result);
      }
      static decodeCommit(response) {
        return decodeCommitResponse(response.result);
      }
      static decodeGenesis(response) {
        return decodeGenesis((0, encodings_1.assertObject)(response.result.genesis));
      }
      static decodeHealth() {
        return null;
      }
      static decodeNumUnconfirmedTxs(response) {
        return decodeNumUnconfirmedTxs(response.result);
      }
      static decodeStatus(response) {
        return decodeStatus(response.result);
      }
      static decodeNewBlockEvent(event) {
        return decodeBlock(event.data.value.block);
      }
      static decodeNewBlockHeaderEvent(event) {
        return decodeHeader(event.data.value.header);
      }
      static decodeTxEvent(event) {
        return decodeTxEvent(event.data.value.TxResult);
      }
      static decodeTx(response) {
        return decodeTxResponse(response.result);
      }
      static decodeTxSearch(response) {
        return decodeTxSearch(response.result);
      }
      static decodeValidators(response) {
        return decodeValidators(response.result);
      }
    };
    exports.Responses = Responses;
  }
});

// ../../node_modules/.pnpm/@cosmjs+tendermint-rpc@0.34.0/node_modules/@cosmjs/tendermint-rpc/build/tendermint37/adaptor/index.js
var require_adaptor3 = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+tendermint-rpc@0.34.0/node_modules/@cosmjs/tendermint-rpc/build/tendermint37/adaptor/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Responses = exports.Params = void 0;
    var requests_1 = require_requests6();
    Object.defineProperty(exports, "Params", { enumerable: true, get: function() {
      return requests_1.Params;
    } });
    var responses_1 = require_responses6();
    Object.defineProperty(exports, "Responses", { enumerable: true, get: function() {
      return responses_1.Responses;
    } });
  }
});

// ../../node_modules/.pnpm/@cosmjs+tendermint-rpc@0.34.0/node_modules/@cosmjs/tendermint-rpc/build/tendermint37/tendermint37client.js
var require_tendermint37client = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+tendermint-rpc@0.34.0/node_modules/@cosmjs/tendermint-rpc/build/tendermint37/tendermint37client.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function() {
      var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o2) {
          var ar = [];
          for (var k in o2)
            if (Object.prototype.hasOwnProperty.call(o2, k))
              ar[ar.length] = k;
          return ar;
        };
        return ownKeys(o);
      };
      return function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k = ownKeys(mod), i = 0; i < k.length; i++)
            if (k[i] !== "default")
              __createBinding(result, mod, k[i]);
        }
        __setModuleDefault(result, mod);
        return result;
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Tendermint37Client = void 0;
    var jsonrpc_1 = require_jsonrpc();
    var rpcclients_1 = require_rpcclients();
    var adaptor_1 = require_adaptor3();
    var requests = __importStar(require_requests5());
    var Tendermint37Client = class _Tendermint37Client {
      /**
       * Creates a new Tendermint client for the given endpoint.
       *
       * Uses HTTP when the URL schema is http or https. Uses WebSockets otherwise.
       */
      static async connect(endpoint) {
        let rpcClient;
        if (typeof endpoint === "object") {
          rpcClient = new rpcclients_1.HttpClient(endpoint);
        } else {
          const useHttp = endpoint.startsWith("http://") || endpoint.startsWith("https://");
          rpcClient = useHttp ? new rpcclients_1.HttpClient(endpoint) : new rpcclients_1.WebsocketClient(endpoint);
        }
        const _version = await this.detectVersion(rpcClient);
        return _Tendermint37Client.create(rpcClient);
      }
      /**
       * Creates a new Tendermint client given an RPC client.
       */
      static async create(rpcClient) {
        return new _Tendermint37Client(rpcClient);
      }
      static async detectVersion(client) {
        const req = (0, jsonrpc_1.createJsonRpcRequest)(requests.Method.Status);
        const response = await client.execute(req);
        const result = response.result;
        if (!result || !result.node_info) {
          throw new Error("Unrecognized format for status response");
        }
        const version = result.node_info.version;
        if (typeof version !== "string") {
          throw new Error("Unrecognized version format: must be string");
        }
        return version;
      }
      /**
       * Use `Tendermint37Client.connect` or `Tendermint37Client.create` to create an instance.
       */
      constructor(client) {
        this.client = client;
      }
      disconnect() {
        this.client.disconnect();
      }
      async abciInfo() {
        const query = { method: requests.Method.AbciInfo };
        return this.doCall(query, adaptor_1.Params.encodeAbciInfo, adaptor_1.Responses.decodeAbciInfo);
      }
      async abciQuery(params) {
        const query = { params, method: requests.Method.AbciQuery };
        return this.doCall(query, adaptor_1.Params.encodeAbciQuery, adaptor_1.Responses.decodeAbciQuery);
      }
      async block(height) {
        const query = { method: requests.Method.Block, params: { height } };
        return this.doCall(query, adaptor_1.Params.encodeBlock, adaptor_1.Responses.decodeBlock);
      }
      async blockResults(height) {
        const query = {
          method: requests.Method.BlockResults,
          params: { height }
        };
        return this.doCall(query, adaptor_1.Params.encodeBlockResults, adaptor_1.Responses.decodeBlockResults);
      }
      /**
       * Search for events that are in a block.
       *
       * NOTE
       * This method will error on any node that is running a Tendermint version lower than 0.34.9.
       *
       * @see https://docs.tendermint.com/master/rpc/#/Info/block_search
       */
      async blockSearch(params) {
        const query = { params, method: requests.Method.BlockSearch };
        const resp = await this.doCall(query, adaptor_1.Params.encodeBlockSearch, adaptor_1.Responses.decodeBlockSearch);
        return {
          ...resp,
          // make sure we sort by height, as tendermint may be sorting by string value of the height
          blocks: [...resp.blocks].sort((a, b) => a.block.header.height - b.block.header.height)
        };
      }
      // this should paginate through all blockSearch options to ensure it returns all results.
      // starts with page 1 or whatever was provided (eg. to start on page 7)
      //
      // NOTE
      // This method will error on any node that is running a Tendermint version lower than 0.34.9.
      async blockSearchAll(params) {
        let page = params.page || 1;
        const blocks = [];
        let done = false;
        while (!done) {
          const resp = await this.blockSearch({ ...params, page });
          blocks.push(...resp.blocks);
          if (blocks.length < resp.totalCount) {
            page++;
          } else {
            done = true;
          }
        }
        blocks.sort((a, b) => a.block.header.height - b.block.header.height);
        return {
          totalCount: blocks.length,
          blocks
        };
      }
      /**
       * Queries block headers filtered by minHeight <= height <= maxHeight.
       *
       * @param minHeight The minimum height to be included in the result. Defaults to 0.
       * @param maxHeight The maximum height to be included in the result. Defaults to infinity.
       */
      async blockchain(minHeight, maxHeight) {
        const query = {
          method: requests.Method.Blockchain,
          params: {
            minHeight,
            maxHeight
          }
        };
        return this.doCall(query, adaptor_1.Params.encodeBlockchain, adaptor_1.Responses.decodeBlockchain);
      }
      /**
       * Broadcast transaction to mempool and wait for response
       *
       * @see https://docs.tendermint.com/master/rpc/#/Tx/broadcast_tx_sync
       */
      async broadcastTxSync(params) {
        const query = { params, method: requests.Method.BroadcastTxSync };
        return this.doCall(query, adaptor_1.Params.encodeBroadcastTx, adaptor_1.Responses.decodeBroadcastTxSync);
      }
      /**
       * Broadcast transaction to mempool and do not wait for result
       *
       * @see https://docs.tendermint.com/master/rpc/#/Tx/broadcast_tx_async
       */
      async broadcastTxAsync(params) {
        const query = { params, method: requests.Method.BroadcastTxAsync };
        return this.doCall(query, adaptor_1.Params.encodeBroadcastTx, adaptor_1.Responses.decodeBroadcastTxAsync);
      }
      /**
       * Broadcast transaction to mempool and wait for block
       *
       * @see https://docs.tendermint.com/master/rpc/#/Tx/broadcast_tx_commit
       */
      async broadcastTxCommit(params) {
        const query = { params, method: requests.Method.BroadcastTxCommit };
        return this.doCall(query, adaptor_1.Params.encodeBroadcastTx, adaptor_1.Responses.decodeBroadcastTxCommit);
      }
      async commit(height) {
        const query = { method: requests.Method.Commit, params: { height } };
        return this.doCall(query, adaptor_1.Params.encodeCommit, adaptor_1.Responses.decodeCommit);
      }
      async genesis() {
        const query = { method: requests.Method.Genesis };
        return this.doCall(query, adaptor_1.Params.encodeGenesis, adaptor_1.Responses.decodeGenesis);
      }
      async health() {
        const query = { method: requests.Method.Health };
        return this.doCall(query, adaptor_1.Params.encodeHealth, adaptor_1.Responses.decodeHealth);
      }
      async numUnconfirmedTxs() {
        const query = { method: requests.Method.NumUnconfirmedTxs };
        return this.doCall(query, adaptor_1.Params.encodeNumUnconfirmedTxs, adaptor_1.Responses.decodeNumUnconfirmedTxs);
      }
      async status() {
        const query = { method: requests.Method.Status };
        return this.doCall(query, adaptor_1.Params.encodeStatus, adaptor_1.Responses.decodeStatus);
      }
      subscribeNewBlock() {
        const request = {
          method: requests.Method.Subscribe,
          query: { type: requests.SubscriptionEventType.NewBlock }
        };
        return this.subscribe(request, adaptor_1.Responses.decodeNewBlockEvent);
      }
      subscribeNewBlockHeader() {
        const request = {
          method: requests.Method.Subscribe,
          query: { type: requests.SubscriptionEventType.NewBlockHeader }
        };
        return this.subscribe(request, adaptor_1.Responses.decodeNewBlockHeaderEvent);
      }
      subscribeTx(query) {
        const request = {
          method: requests.Method.Subscribe,
          query: {
            type: requests.SubscriptionEventType.Tx,
            raw: query
          }
        };
        return this.subscribe(request, adaptor_1.Responses.decodeTxEvent);
      }
      /**
       * Get a single transaction by hash
       *
       * @see https://docs.tendermint.com/master/rpc/#/Info/tx
       */
      async tx(params) {
        const query = { params, method: requests.Method.Tx };
        return this.doCall(query, adaptor_1.Params.encodeTx, adaptor_1.Responses.decodeTx);
      }
      /**
       * Search for transactions that are in a block
       *
       * @see https://docs.tendermint.com/master/rpc/#/Info/tx_search
       */
      async txSearch(params) {
        const query = { params, method: requests.Method.TxSearch };
        return this.doCall(query, adaptor_1.Params.encodeTxSearch, adaptor_1.Responses.decodeTxSearch);
      }
      // this should paginate through all txSearch options to ensure it returns all results.
      // starts with page 1 or whatever was provided (eg. to start on page 7)
      async txSearchAll(params) {
        let page = params.page || 1;
        const txs = [];
        let done = false;
        while (!done) {
          const resp = await this.txSearch({ ...params, page });
          txs.push(...resp.txs);
          if (txs.length < resp.totalCount) {
            page++;
          } else {
            done = true;
          }
        }
        return {
          totalCount: txs.length,
          txs
        };
      }
      async validators(params) {
        const query = {
          method: requests.Method.Validators,
          params
        };
        return this.doCall(query, adaptor_1.Params.encodeValidators, adaptor_1.Responses.decodeValidators);
      }
      async validatorsAll(height) {
        const validators = [];
        let page = 1;
        let done = false;
        let blockHeight = height;
        while (!done) {
          const response = await this.validators({
            per_page: 50,
            height: blockHeight,
            page
          });
          validators.push(...response.validators);
          blockHeight = blockHeight || response.blockHeight;
          if (validators.length < response.total) {
            page++;
          } else {
            done = true;
          }
        }
        return {
          // NOTE: Default value is for type safety but this should always be set
          blockHeight: blockHeight ?? 0,
          count: validators.length,
          total: validators.length,
          validators
        };
      }
      // doCall is a helper to handle the encode/call/decode logic
      async doCall(request, encode, decode) {
        const req = encode(request);
        const result = await this.client.execute(req);
        return decode(result);
      }
      subscribe(request, decode) {
        if (!(0, rpcclients_1.instanceOfRpcStreamingClient)(this.client)) {
          throw new Error("This RPC client type cannot subscribe to events");
        }
        const req = adaptor_1.Params.encodeSubscribe(request);
        const eventStream = this.client.listen(req);
        return eventStream.map((event) => {
          return decode(event);
        });
      }
    };
    exports.Tendermint37Client = Tendermint37Client;
  }
});

// ../../node_modules/.pnpm/@cosmjs+tendermint-rpc@0.34.0/node_modules/@cosmjs/tendermint-rpc/build/tendermint37/index.js
var require_tendermint37 = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+tendermint-rpc@0.34.0/node_modules/@cosmjs/tendermint-rpc/build/tendermint37/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Tendermint37Client = exports.VoteType = exports.broadcastTxSyncSuccess = exports.broadcastTxCommitSuccess = exports.SubscriptionEventType = exports.Method = void 0;
    var requests_1 = require_requests5();
    Object.defineProperty(exports, "Method", { enumerable: true, get: function() {
      return requests_1.Method;
    } });
    Object.defineProperty(exports, "SubscriptionEventType", { enumerable: true, get: function() {
      return requests_1.SubscriptionEventType;
    } });
    var responses_1 = require_responses5();
    Object.defineProperty(exports, "broadcastTxCommitSuccess", { enumerable: true, get: function() {
      return responses_1.broadcastTxCommitSuccess;
    } });
    Object.defineProperty(exports, "broadcastTxSyncSuccess", { enumerable: true, get: function() {
      return responses_1.broadcastTxSyncSuccess;
    } });
    Object.defineProperty(exports, "VoteType", { enumerable: true, get: function() {
      return responses_1.VoteType;
    } });
    var tendermint37client_1 = require_tendermint37client();
    Object.defineProperty(exports, "Tendermint37Client", { enumerable: true, get: function() {
      return tendermint37client_1.Tendermint37Client;
    } });
  }
});

// ../../node_modules/.pnpm/@cosmjs+tendermint-rpc@0.34.0/node_modules/@cosmjs/tendermint-rpc/build/tendermintclient.js
var require_tendermintclient = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+tendermint-rpc@0.34.0/node_modules/@cosmjs/tendermint-rpc/build/tendermintclient.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isTendermint34Client = isTendermint34Client;
    exports.isTendermint37Client = isTendermint37Client;
    exports.isComet38Client = isComet38Client;
    exports.connectComet = connectComet;
    var comet38_1 = require_comet38();
    var tendermint34_1 = require_tendermint34();
    var tendermint37_1 = require_tendermint37();
    function isTendermint34Client(client) {
      return client instanceof tendermint34_1.Tendermint34Client;
    }
    function isTendermint37Client(client) {
      return client instanceof tendermint37_1.Tendermint37Client;
    }
    function isComet38Client(client) {
      return client instanceof comet38_1.Comet38Client;
    }
    async function connectComet(endpoint) {
      let out;
      const tm37Client = await tendermint37_1.Tendermint37Client.connect(endpoint);
      const version = (await tm37Client.status()).nodeInfo.version;
      if (version.startsWith("0.37.")) {
        out = tm37Client;
      } else if (version.startsWith("0.38.") || version.startsWith("1.0.")) {
        tm37Client.disconnect();
        out = await comet38_1.Comet38Client.connect(endpoint);
      } else {
        tm37Client.disconnect();
        out = await tendermint34_1.Tendermint34Client.connect(endpoint);
      }
      return out;
    }
  }
});

// ../../node_modules/.pnpm/@cosmjs+tendermint-rpc@0.34.0/node_modules/@cosmjs/tendermint-rpc/build/index.js
var require_build10 = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+tendermint-rpc@0.34.0/node_modules/@cosmjs/tendermint-rpc/build/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function() {
      var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o2) {
          var ar = [];
          for (var k in o2)
            if (Object.prototype.hasOwnProperty.call(o2, k))
              ar[ar.length] = k;
          return ar;
        };
        return ownKeys(o);
      };
      return function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k = ownKeys(mod), i = 0; i < k.length; i++)
            if (k[i] !== "default")
              __createBinding(result, mod, k[i]);
        }
        __setModuleDefault(result, mod);
        return result;
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BlockIdFlag = exports.isTendermint37Client = exports.isTendermint34Client = exports.isComet38Client = exports.connectComet = exports.Tendermint37Client = exports.tendermint37 = exports.Tendermint34Client = exports.tendermint34 = exports.VoteType = exports.SubscriptionEventType = exports.Method = exports.broadcastTxSyncSuccess = exports.broadcastTxCommitSuccess = exports.WebsocketClient = exports.HttpClient = exports.HttpBatchClient = exports.Comet38Client = exports.comet38 = exports.toSeconds = exports.toRfc3339WithNanoseconds = exports.fromSeconds = exports.fromRfc3339WithNanoseconds = exports.DateTime = exports.rawSecp256k1PubkeyToRawAddress = exports.rawEd25519PubkeyToRawAddress = exports.pubkeyToRawAddress = exports.pubkeyToAddress = void 0;
    var addresses_1 = require_addresses2();
    Object.defineProperty(exports, "pubkeyToAddress", { enumerable: true, get: function() {
      return addresses_1.pubkeyToAddress;
    } });
    Object.defineProperty(exports, "pubkeyToRawAddress", { enumerable: true, get: function() {
      return addresses_1.pubkeyToRawAddress;
    } });
    Object.defineProperty(exports, "rawEd25519PubkeyToRawAddress", { enumerable: true, get: function() {
      return addresses_1.rawEd25519PubkeyToRawAddress;
    } });
    Object.defineProperty(exports, "rawSecp256k1PubkeyToRawAddress", { enumerable: true, get: function() {
      return addresses_1.rawSecp256k1PubkeyToRawAddress;
    } });
    var dates_1 = require_dates();
    Object.defineProperty(exports, "DateTime", { enumerable: true, get: function() {
      return dates_1.DateTime;
    } });
    Object.defineProperty(exports, "fromRfc3339WithNanoseconds", { enumerable: true, get: function() {
      return dates_1.fromRfc3339WithNanoseconds;
    } });
    Object.defineProperty(exports, "fromSeconds", { enumerable: true, get: function() {
      return dates_1.fromSeconds;
    } });
    Object.defineProperty(exports, "toRfc3339WithNanoseconds", { enumerable: true, get: function() {
      return dates_1.toRfc3339WithNanoseconds;
    } });
    Object.defineProperty(exports, "toSeconds", { enumerable: true, get: function() {
      return dates_1.toSeconds;
    } });
    exports.comet38 = __importStar(require_comet38());
    var comet38_1 = require_comet38();
    Object.defineProperty(exports, "Comet38Client", { enumerable: true, get: function() {
      return comet38_1.Comet38Client;
    } });
    var rpcclients_1 = require_rpcclients();
    Object.defineProperty(exports, "HttpBatchClient", { enumerable: true, get: function() {
      return rpcclients_1.HttpBatchClient;
    } });
    Object.defineProperty(exports, "HttpClient", { enumerable: true, get: function() {
      return rpcclients_1.HttpClient;
    } });
    Object.defineProperty(exports, "WebsocketClient", { enumerable: true, get: function() {
      return rpcclients_1.WebsocketClient;
    } });
    var tendermint34_1 = require_tendermint34();
    Object.defineProperty(exports, "broadcastTxCommitSuccess", { enumerable: true, get: function() {
      return tendermint34_1.broadcastTxCommitSuccess;
    } });
    Object.defineProperty(exports, "broadcastTxSyncSuccess", { enumerable: true, get: function() {
      return tendermint34_1.broadcastTxSyncSuccess;
    } });
    Object.defineProperty(exports, "Method", { enumerable: true, get: function() {
      return tendermint34_1.Method;
    } });
    Object.defineProperty(exports, "SubscriptionEventType", { enumerable: true, get: function() {
      return tendermint34_1.SubscriptionEventType;
    } });
    Object.defineProperty(exports, "VoteType", { enumerable: true, get: function() {
      return tendermint34_1.VoteType;
    } });
    exports.tendermint34 = __importStar(require_tendermint34());
    var tendermint34_2 = require_tendermint34();
    Object.defineProperty(exports, "Tendermint34Client", { enumerable: true, get: function() {
      return tendermint34_2.Tendermint34Client;
    } });
    exports.tendermint37 = __importStar(require_tendermint37());
    var tendermint37_1 = require_tendermint37();
    Object.defineProperty(exports, "Tendermint37Client", { enumerable: true, get: function() {
      return tendermint37_1.Tendermint37Client;
    } });
    var tendermintclient_1 = require_tendermintclient();
    Object.defineProperty(exports, "connectComet", { enumerable: true, get: function() {
      return tendermintclient_1.connectComet;
    } });
    Object.defineProperty(exports, "isComet38Client", { enumerable: true, get: function() {
      return tendermintclient_1.isComet38Client;
    } });
    Object.defineProperty(exports, "isTendermint34Client", { enumerable: true, get: function() {
      return tendermintclient_1.isTendermint34Client;
    } });
    Object.defineProperty(exports, "isTendermint37Client", { enumerable: true, get: function() {
      return tendermintclient_1.isTendermint37Client;
    } });
    var types_1 = require_types3();
    Object.defineProperty(exports, "BlockIdFlag", { enumerable: true, get: function() {
      return types_1.BlockIdFlag;
    } });
  }
});

// ../../node_modules/.pnpm/@cosmjs+stargate@0.34.0/node_modules/@cosmjs/stargate/build/stargateclient.js
var require_stargateclient = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+stargate@0.34.0/node_modules/@cosmjs/stargate/build/stargateclient.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.StargateClient = exports.BroadcastTxError = exports.TimeoutError = void 0;
    exports.isDeliverTxFailure = isDeliverTxFailure;
    exports.isDeliverTxSuccess = isDeliverTxSuccess;
    exports.assertIsDeliverTxSuccess = assertIsDeliverTxSuccess;
    exports.assertIsDeliverTxFailure = assertIsDeliverTxFailure;
    var amino_1 = require_build5();
    var encoding_1 = require_build();
    var math_1 = require_build2();
    var tendermint_rpc_1 = require_build10();
    var utils_1 = require_build3();
    var abci_1 = require_abci();
    var accounts_1 = require_accounts();
    var events_1 = require_events();
    var modules_1 = require_modules();
    var queryclient_1 = require_queryclient2();
    var search_1 = require_search();
    var TimeoutError = class extends Error {
      constructor(message, txId) {
        super(message);
        this.txId = txId;
      }
    };
    exports.TimeoutError = TimeoutError;
    function isDeliverTxFailure(result) {
      return !!result.code;
    }
    function isDeliverTxSuccess(result) {
      return !isDeliverTxFailure(result);
    }
    function assertIsDeliverTxSuccess(result) {
      if (isDeliverTxFailure(result)) {
        throw new Error(`Error when broadcasting tx ${result.transactionHash} at height ${result.height}. Code: ${result.code}; Raw log: ${result.rawLog}`);
      }
    }
    function assertIsDeliverTxFailure(result) {
      if (isDeliverTxSuccess(result)) {
        throw new Error(`Transaction ${result.transactionHash} did not fail at height ${result.height}. Code: ${result.code}; Raw log: ${result.rawLog}`);
      }
    }
    var BroadcastTxError = class extends Error {
      constructor(code, codespace, log) {
        super(`Broadcasting transaction failed with code ${code} (codespace: ${codespace}). Log: ${log}`);
        this.code = code;
        this.codespace = codespace;
        this.log = log;
      }
    };
    exports.BroadcastTxError = BroadcastTxError;
    var StargateClient = class _StargateClient {
      /**
       * Creates an instance by connecting to the given CometBFT RPC endpoint.
       *
       * This uses auto-detection to decide between a CometBFT 0.38, Tendermint 0.37 and 0.34 client.
       * To set the Comet client explicitly, use `create`.
       */
      static async connect(endpoint, options = {}) {
        const cometClient = await (0, tendermint_rpc_1.connectComet)(endpoint);
        return _StargateClient.create(cometClient, options);
      }
      /**
       * Creates an instance from a manually created Comet client.
       * Use this to use `Comet38Client` or `Tendermint37Client` instead of `Tendermint34Client`.
       */
      static async create(cometClient, options = {}) {
        return new _StargateClient(cometClient, options);
      }
      constructor(cometClient, options) {
        if (cometClient) {
          this.cometClient = cometClient;
          this.queryClient = queryclient_1.QueryClient.withExtensions(cometClient, modules_1.setupAuthExtension, modules_1.setupBankExtension, modules_1.setupStakingExtension, modules_1.setupTxExtension);
        }
        const { accountParser = accounts_1.accountFromAny } = options;
        this.accountParser = accountParser;
      }
      getCometClient() {
        return this.cometClient;
      }
      forceGetCometClient() {
        if (!this.cometClient) {
          throw new Error("Comet client not available. You cannot use online functionality in offline mode.");
        }
        return this.cometClient;
      }
      getQueryClient() {
        return this.queryClient;
      }
      forceGetQueryClient() {
        if (!this.queryClient) {
          throw new Error("Query client not available. You cannot use online functionality in offline mode.");
        }
        return this.queryClient;
      }
      async getChainId() {
        if (!this.chainId) {
          const response = await this.forceGetCometClient().status();
          const chainId = response.nodeInfo.network;
          if (!chainId)
            throw new Error("Chain ID must not be empty");
          this.chainId = chainId;
        }
        return this.chainId;
      }
      async getHeight() {
        const status = await this.forceGetCometClient().status();
        return status.syncInfo.latestBlockHeight;
      }
      async getAccount(searchAddress) {
        try {
          const account = await this.forceGetQueryClient().auth.account(searchAddress);
          return account ? this.accountParser(account) : null;
        } catch (error) {
          if (/rpc error: code = NotFound/i.test(error.toString())) {
            return null;
          }
          throw error;
        }
      }
      async getSequence(address) {
        const account = await this.getAccount(address);
        if (!account) {
          throw new Error(`Account '${address}' does not exist on chain. Send some tokens there before trying to query sequence.`);
        }
        return {
          accountNumber: account.accountNumber,
          sequence: account.sequence
        };
      }
      async getBlock(height) {
        const response = await this.forceGetCometClient().block(height);
        return {
          id: (0, encoding_1.toHex)(response.blockId.hash).toUpperCase(),
          header: {
            version: {
              block: new math_1.Uint53(response.block.header.version.block).toString(),
              app: new math_1.Uint53(response.block.header.version.app).toString()
            },
            height: response.block.header.height,
            chainId: response.block.header.chainId,
            time: (0, tendermint_rpc_1.toRfc3339WithNanoseconds)(response.block.header.time)
          },
          txs: response.block.txs
        };
      }
      async getBalance(address, searchDenom) {
        return this.forceGetQueryClient().bank.balance(address, searchDenom);
      }
      /**
       * Queries all balances for all denoms that belong to this address.
       *
       * Uses the grpc queries (which iterates over the store internally), and we cannot get
       * proofs from such a method.
       */
      async getAllBalances(address) {
        return this.forceGetQueryClient().bank.allBalances(address);
      }
      async getBalanceStaked(address) {
        const allDelegations = [];
        let startAtKey = void 0;
        do {
          const { delegationResponses, pagination } = await this.forceGetQueryClient().staking.delegatorDelegations(address, startAtKey);
          const loadedDelegations = delegationResponses || [];
          allDelegations.push(...loadedDelegations);
          startAtKey = pagination == null ? void 0 : pagination.nextKey;
        } while (startAtKey !== void 0 && startAtKey.length !== 0);
        const sumValues = allDelegations.reduce((previousValue, currentValue) => {
          (0, utils_1.assert)(currentValue.balance);
          return previousValue !== null ? (0, amino_1.addCoins)(previousValue, currentValue.balance) : currentValue.balance;
        }, null);
        return sumValues;
      }
      async getDelegation(delegatorAddress, validatorAddress) {
        var _a;
        let delegatedAmount;
        try {
          delegatedAmount = (_a = (await this.forceGetQueryClient().staking.delegation(delegatorAddress, validatorAddress)).delegationResponse) == null ? void 0 : _a.balance;
        } catch (e) {
          if (e.toString().includes("key not found")) {
          } else {
            throw e;
          }
        }
        return delegatedAmount || null;
      }
      async getTx(id) {
        const results = await this.txsQuery(`tx.hash='${id}'`);
        return results[0] ?? null;
      }
      async searchTx(query) {
        let rawQuery;
        if (typeof query === "string") {
          rawQuery = query;
        } else if ((0, search_1.isSearchTxQueryArray)(query)) {
          rawQuery = query.map((t) => {
            if (typeof t.value === "string")
              return `${t.key}='${t.value}'`;
            else
              return `${t.key}=${t.value}`;
          }).join(" AND ");
        } else {
          throw new Error("Got unsupported query type. See CosmJS 0.31 CHANGELOG for API breaking changes here.");
        }
        return this.txsQuery(rawQuery);
      }
      disconnect() {
        if (this.cometClient)
          this.cometClient.disconnect();
      }
      /**
       * Broadcasts a signed transaction to the network and monitors its inclusion in a block.
       *
       * If broadcasting is rejected by the node for some reason (e.g. because of a CheckTx failure),
       * an error is thrown.
       *
       * If the transaction is not included in a block before the provided timeout, this errors with a `TimeoutError`.
       *
       * If the transaction is included in a block, a `DeliverTxResponse` is returned. The caller then
       * usually needs to check for execution success or failure.
       */
      async broadcastTx(tx, timeoutMs = 6e4, pollIntervalMs = 3e3) {
        let timedOut = false;
        const txPollTimeout = setTimeout(() => {
          timedOut = true;
        }, timeoutMs);
        const pollForTx = async (txId) => {
          if (timedOut) {
            throw new TimeoutError(`Transaction with ID ${txId} was submitted but was not yet found on the chain. You might want to check later. There was a wait of ${timeoutMs / 1e3} seconds.`, txId);
          }
          await (0, utils_1.sleep)(pollIntervalMs);
          const result = await this.getTx(txId);
          return result ? {
            code: result.code,
            height: result.height,
            txIndex: result.txIndex,
            events: result.events,
            rawLog: result.rawLog,
            transactionHash: txId,
            msgResponses: result.msgResponses,
            gasUsed: result.gasUsed,
            gasWanted: result.gasWanted
          } : pollForTx(txId);
        };
        const transactionId = await this.broadcastTxSync(tx);
        return new Promise((resolve, reject) => pollForTx(transactionId).then((value) => {
          clearTimeout(txPollTimeout);
          resolve(value);
        }, (error) => {
          clearTimeout(txPollTimeout);
          reject(error);
        }));
      }
      /**
       * Broadcasts a signed transaction to the network without monitoring it.
       *
       * If broadcasting is rejected by the node for some reason (e.g. because of a CheckTx failure),
       * an error is thrown.
       *
       * If the transaction is broadcasted, a `string` containing the hash of the transaction is returned. The caller then
       * usually needs to check if the transaction was included in a block and was successful.
       *
       * @returns Returns the hash of the transaction
       */
      async broadcastTxSync(tx) {
        const broadcasted = await this.forceGetCometClient().broadcastTxSync({ tx });
        if (broadcasted.code) {
          return Promise.reject(new BroadcastTxError(broadcasted.code, broadcasted.codespace ?? "", broadcasted.log));
        }
        const transactionId = (0, encoding_1.toHex)(broadcasted.hash).toUpperCase();
        return transactionId;
      }
      async txsQuery(query) {
        const results = await this.forceGetCometClient().txSearchAll({ query });
        return results.txs.map((tx) => {
          const txMsgData = abci_1.TxMsgData.decode(tx.result.data ?? new Uint8Array());
          return {
            height: tx.height,
            txIndex: tx.index,
            hash: (0, encoding_1.toHex)(tx.hash).toUpperCase(),
            code: tx.result.code,
            events: tx.result.events.map(events_1.fromTendermintEvent),
            rawLog: tx.result.log || "",
            tx: tx.tx,
            msgResponses: txMsgData.msgResponses,
            gasUsed: tx.result.gasUsed,
            gasWanted: tx.result.gasWanted
          };
        });
      }
    };
    exports.StargateClient = StargateClient;
  }
});

// ../../node_modules/.pnpm/@cosmjs+stargate@0.34.0/node_modules/@cosmjs/stargate/build/signingstargateclient.js
var require_signingstargateclient = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+stargate@0.34.0/node_modules/@cosmjs/stargate/build/signingstargateclient.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SigningStargateClient = exports.defaultRegistryTypes = void 0;
    exports.createDefaultAminoConverters = createDefaultAminoConverters;
    var amino_1 = require_build5();
    var encoding_1 = require_build();
    var math_1 = require_build2();
    var proto_signing_1 = require_build6();
    var tendermint_rpc_1 = require_build10();
    var utils_1 = require_build3();
    var coin_1 = require_coin();
    var tx_1 = require_tx4();
    var tx_2 = require_tx13();
    var signing_1 = require_signing();
    var tx_3 = require_tx();
    var tx_4 = require_tx9();
    var aminotypes_1 = require_aminotypes();
    var fee_1 = require_fee();
    var modules_1 = require_modules();
    var modules_2 = require_modules();
    var stargateclient_1 = require_stargateclient();
    exports.defaultRegistryTypes = [
      ["/cosmos.base.v1beta1.Coin", coin_1.Coin],
      ...modules_1.authzTypes,
      ...modules_1.bankTypes,
      ...modules_1.distributionTypes,
      ...modules_1.feegrantTypes,
      ...modules_1.govTypes,
      ...modules_1.groupTypes,
      ...modules_1.stakingTypes,
      ...modules_1.ibcTypes,
      ...modules_1.vestingTypes
    ];
    function createDefaultAminoConverters() {
      return {
        ...(0, modules_2.createAuthzAminoConverters)(),
        ...(0, modules_2.createBankAminoConverters)(),
        ...(0, modules_2.createDistributionAminoConverters)(),
        ...(0, modules_2.createGovAminoConverters)(),
        ...(0, modules_2.createStakingAminoConverters)(),
        ...(0, modules_2.createIbcAminoConverters)(),
        ...(0, modules_2.createFeegrantAminoConverters)(),
        ...(0, modules_2.createVestingAminoConverters)()
      };
    }
    var SigningStargateClient = class _SigningStargateClient extends stargateclient_1.StargateClient {
      /**
       * Creates an instance by connecting to the given CometBFT RPC endpoint.
       *
       * This uses auto-detection to decide between a CometBFT 0.38, Tendermint 0.37 and 0.34 client.
       * To set the Comet client explicitly, use `createWithSigner`.
       */
      static async connectWithSigner(endpoint, signer, options = {}) {
        const cometClient = await (0, tendermint_rpc_1.connectComet)(endpoint);
        return _SigningStargateClient.createWithSigner(cometClient, signer, options);
      }
      /**
       * Creates an instance from a manually created Comet client.
       * Use this to use `Comet38Client` or `Tendermint37Client` instead of `Tendermint34Client`.
       */
      static async createWithSigner(cometClient, signer, options = {}) {
        return new _SigningStargateClient(cometClient, signer, options);
      }
      /**
       * Creates a client in offline mode.
       *
       * This should only be used in niche cases where you know exactly what you're doing,
       * e.g. when building an offline signing application.
       *
       * When you try to use online functionality with such a signer, an
       * exception will be raised.
       */
      static async offline(signer, options = {}) {
        return new _SigningStargateClient(void 0, signer, options);
      }
      constructor(cometClient, signer, options) {
        super(cometClient, options);
        this.defaultGasMultiplier = 1.4;
        const { registry = new proto_signing_1.Registry(exports.defaultRegistryTypes), aminoTypes = new aminotypes_1.AminoTypes(createDefaultAminoConverters()) } = options;
        this.registry = registry;
        this.aminoTypes = aminoTypes;
        this.signer = signer;
        this.broadcastTimeoutMs = options.broadcastTimeoutMs;
        this.broadcastPollIntervalMs = options.broadcastPollIntervalMs;
        this.gasPrice = options.gasPrice;
      }
      async simulate(signerAddress, messages, memo) {
        const anyMsgs = messages.map((m) => this.registry.encodeAsAny(m));
        const accountFromSigner = (await this.signer.getAccounts()).find((account) => account.address === signerAddress);
        if (!accountFromSigner) {
          throw new Error("Failed to retrieve account from signer");
        }
        const pubkey = (0, amino_1.encodeSecp256k1Pubkey)(accountFromSigner.pubkey);
        const { sequence } = await this.getSequence(signerAddress);
        const { gasInfo } = await this.forceGetQueryClient().tx.simulate(anyMsgs, memo, pubkey, sequence);
        (0, utils_1.assertDefined)(gasInfo);
        return math_1.Uint53.fromString(gasInfo.gasUsed.toString()).toNumber();
      }
      async sendTokens(senderAddress, recipientAddress, amount, fee, memo = "") {
        const sendMsg = {
          typeUrl: "/cosmos.bank.v1beta1.MsgSend",
          value: {
            fromAddress: senderAddress,
            toAddress: recipientAddress,
            amount: [...amount]
          }
        };
        return this.signAndBroadcast(senderAddress, [sendMsg], fee, memo);
      }
      async delegateTokens(delegatorAddress, validatorAddress, amount, fee, memo = "") {
        const delegateMsg = {
          typeUrl: "/cosmos.staking.v1beta1.MsgDelegate",
          value: tx_2.MsgDelegate.fromPartial({
            delegatorAddress,
            validatorAddress,
            amount
          })
        };
        return this.signAndBroadcast(delegatorAddress, [delegateMsg], fee, memo);
      }
      async undelegateTokens(delegatorAddress, validatorAddress, amount, fee, memo = "") {
        const undelegateMsg = {
          typeUrl: "/cosmos.staking.v1beta1.MsgUndelegate",
          value: tx_2.MsgUndelegate.fromPartial({
            delegatorAddress,
            validatorAddress,
            amount
          })
        };
        return this.signAndBroadcast(delegatorAddress, [undelegateMsg], fee, memo);
      }
      async withdrawRewards(delegatorAddress, validatorAddress, fee, memo = "") {
        const withdrawMsg = {
          typeUrl: "/cosmos.distribution.v1beta1.MsgWithdrawDelegatorReward",
          value: tx_1.MsgWithdrawDelegatorReward.fromPartial({
            delegatorAddress,
            validatorAddress
          })
        };
        return this.signAndBroadcast(delegatorAddress, [withdrawMsg], fee, memo);
      }
      /**
       * @deprecated This API does not support setting the memo field of `MsgTransfer` (only the transaction memo).
       * We'll remove this method at some point because trying to wrap the various message types is a losing strategy.
       * Please migrate to `signAndBroadcast` with an `MsgTransferEncodeObject` created in the caller code instead.
       * @see https://github.com/cosmos/cosmjs/issues/1493
       */
      async sendIbcTokens(senderAddress, recipientAddress, transferAmount, sourcePort, sourceChannel, timeoutHeight, timeoutTimestamp, fee, memo = "") {
        const timeoutTimestampNanoseconds = timeoutTimestamp ? BigInt(timeoutTimestamp) * BigInt(1e9) : void 0;
        const transferMsg = {
          typeUrl: "/ibc.applications.transfer.v1.MsgTransfer",
          value: tx_4.MsgTransfer.fromPartial({
            sourcePort,
            sourceChannel,
            sender: senderAddress,
            receiver: recipientAddress,
            token: transferAmount,
            timeoutHeight,
            timeoutTimestamp: timeoutTimestampNanoseconds
          })
        };
        return this.signAndBroadcast(senderAddress, [transferMsg], fee, memo);
      }
      async signAndBroadcast(signerAddress, messages, fee, memo = "", timeoutHeight) {
        let usedFee;
        if (fee == "auto" || typeof fee === "number") {
          (0, utils_1.assertDefined)(this.gasPrice, "Gas price must be set in the client options when auto gas is used.");
          const gasEstimation = await this.simulate(signerAddress, messages, memo);
          const multiplier = typeof fee === "number" ? fee : this.defaultGasMultiplier;
          usedFee = (0, fee_1.calculateFee)(Math.round(gasEstimation * multiplier), this.gasPrice);
        } else {
          usedFee = fee;
        }
        const txRaw = await this.sign(signerAddress, messages, usedFee, memo, void 0, timeoutHeight);
        const txBytes = tx_3.TxRaw.encode(txRaw).finish();
        return this.broadcastTx(txBytes, this.broadcastTimeoutMs, this.broadcastPollIntervalMs);
      }
      /**
       * This method is useful if you want to send a transaction in broadcast,
       * without waiting for it to be placed inside a block, because for example
       * I would like to receive the hash to later track the transaction with another tool.
       * @returns Returns the hash of the transaction
       */
      async signAndBroadcastSync(signerAddress, messages, fee, memo = "", timeoutHeight) {
        let usedFee;
        if (fee == "auto" || typeof fee === "number") {
          (0, utils_1.assertDefined)(this.gasPrice, "Gas price must be set in the client options when auto gas is used.");
          const gasEstimation = await this.simulate(signerAddress, messages, memo);
          const multiplier = typeof fee === "number" ? fee : this.defaultGasMultiplier;
          usedFee = (0, fee_1.calculateFee)(Math.round(gasEstimation * multiplier), this.gasPrice);
        } else {
          usedFee = fee;
        }
        const txRaw = await this.sign(signerAddress, messages, usedFee, memo, void 0, timeoutHeight);
        const txBytes = tx_3.TxRaw.encode(txRaw).finish();
        return this.broadcastTxSync(txBytes);
      }
      /**
       * Gets account number and sequence from the API, creates a sign doc,
       * creates a single signature and assembles the signed transaction.
       *
       * The sign mode (SIGN_MODE_DIRECT or SIGN_MODE_LEGACY_AMINO_JSON) is determined by this client's signer.
       *
       * You can pass signer data (account number, sequence and chain ID) explicitly instead of querying them
       * from the chain. This is needed when signing for a multisig account, but it also allows for offline signing
       * (See the SigningStargateClient.offline constructor).
       */
      async sign(signerAddress, messages, fee, memo, explicitSignerData, timeoutHeight) {
        let signerData;
        if (explicitSignerData) {
          signerData = explicitSignerData;
        } else {
          const { accountNumber, sequence } = await this.getSequence(signerAddress);
          const chainId = await this.getChainId();
          signerData = {
            accountNumber,
            sequence,
            chainId
          };
        }
        return (0, proto_signing_1.isOfflineDirectSigner)(this.signer) ? this.signDirect(signerAddress, messages, fee, memo, signerData, timeoutHeight) : this.signAmino(signerAddress, messages, fee, memo, signerData, timeoutHeight);
      }
      async signAmino(signerAddress, messages, fee, memo, { accountNumber, sequence, chainId }, timeoutHeight) {
        (0, utils_1.assert)(!(0, proto_signing_1.isOfflineDirectSigner)(this.signer));
        const accountFromSigner = (await this.signer.getAccounts()).find((account) => account.address === signerAddress);
        if (!accountFromSigner) {
          throw new Error("Failed to retrieve account from signer");
        }
        const pubkey = (0, proto_signing_1.encodePubkey)((0, amino_1.encodeSecp256k1Pubkey)(accountFromSigner.pubkey));
        const signMode = signing_1.SignMode.SIGN_MODE_LEGACY_AMINO_JSON;
        const msgs = messages.map((msg) => this.aminoTypes.toAmino(msg));
        const signDoc = (0, amino_1.makeSignDoc)(msgs, fee, chainId, memo, accountNumber, sequence, timeoutHeight);
        const { signature, signed } = await this.signer.signAmino(signerAddress, signDoc);
        const signedTxBody = {
          messages: signed.msgs.map((msg) => this.aminoTypes.fromAmino(msg)),
          memo: signed.memo,
          timeoutHeight
        };
        const signedTxBodyEncodeObject = {
          typeUrl: "/cosmos.tx.v1beta1.TxBody",
          value: signedTxBody
        };
        const signedTxBodyBytes = this.registry.encode(signedTxBodyEncodeObject);
        const signedGasLimit = math_1.Int53.fromString(signed.fee.gas).toNumber();
        const signedSequence = math_1.Int53.fromString(signed.sequence).toNumber();
        const signedAuthInfoBytes = (0, proto_signing_1.makeAuthInfoBytes)([{ pubkey, sequence: signedSequence }], signed.fee.amount, signedGasLimit, signed.fee.granter, signed.fee.payer, signMode);
        return tx_3.TxRaw.fromPartial({
          bodyBytes: signedTxBodyBytes,
          authInfoBytes: signedAuthInfoBytes,
          signatures: [(0, encoding_1.fromBase64)(signature.signature)]
        });
      }
      async signDirect(signerAddress, messages, fee, memo, { accountNumber, sequence, chainId }, timeoutHeight) {
        (0, utils_1.assert)((0, proto_signing_1.isOfflineDirectSigner)(this.signer));
        const accountFromSigner = (await this.signer.getAccounts()).find((account) => account.address === signerAddress);
        if (!accountFromSigner) {
          throw new Error("Failed to retrieve account from signer");
        }
        const pubkey = (0, proto_signing_1.encodePubkey)((0, amino_1.encodeSecp256k1Pubkey)(accountFromSigner.pubkey));
        const txBodyEncodeObject = {
          typeUrl: "/cosmos.tx.v1beta1.TxBody",
          value: {
            messages,
            memo,
            timeoutHeight
          }
        };
        const txBodyBytes = this.registry.encode(txBodyEncodeObject);
        const gasLimit = math_1.Int53.fromString(fee.gas).toNumber();
        const authInfoBytes = (0, proto_signing_1.makeAuthInfoBytes)([{ pubkey, sequence }], fee.amount, gasLimit, fee.granter, fee.payer);
        const signDoc = (0, proto_signing_1.makeSignDoc)(txBodyBytes, authInfoBytes, chainId, accountNumber);
        const { signature, signed } = await this.signer.signDirect(signerAddress, signDoc);
        return tx_3.TxRaw.fromPartial({
          bodyBytes: signed.bodyBytes,
          authInfoBytes: signed.authInfoBytes,
          signatures: [(0, encoding_1.fromBase64)(signature.signature)]
        });
      }
    };
    exports.SigningStargateClient = SigningStargateClient;
  }
});

// ../../node_modules/.pnpm/@cosmjs+stargate@0.34.0/node_modules/@cosmjs/stargate/build/index.js
var require_build11 = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+stargate@0.34.0/node_modules/@cosmjs/stargate/build/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function() {
      var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o2) {
          var ar = [];
          for (var k in o2)
            if (Object.prototype.hasOwnProperty.call(o2, k))
              ar[ar.length] = k;
          return ar;
        };
        return ownKeys(o);
      };
      return function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k = ownKeys(mod), i = 0; i < k.length; i++)
            if (k[i] !== "default")
              __createBinding(result, mod, k[i]);
        }
        __setModuleDefault(result, mod);
        return result;
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isMsgVoteWeightedEncodeObject = exports.isMsgVoteEncodeObject = exports.isMsgUndelegateEncodeObject = exports.isMsgTransferEncodeObject = exports.isMsgSubmitProposalEncodeObject = exports.isMsgSendEncodeObject = exports.isMsgEditValidatorEncodeObject = exports.isMsgDepositEncodeObject = exports.isMsgDelegateEncodeObject = exports.isMsgCreateValidatorEncodeObject = exports.isMsgCancelUnbondingDelegationEncodeObject = exports.isMsgBeginRedelegateEncodeObject = exports.isAminoMsgWithdrawValidatorCommission = exports.isAminoMsgWithdrawDelegatorReward = exports.isAminoMsgVoteWeighted = exports.isAminoMsgVote = exports.isAminoMsgVerifyInvariant = exports.isAminoMsgUnjail = exports.isAminoMsgUndelegate = exports.isAminoMsgTransfer = exports.isAminoMsgSubmitProposal = exports.isAminoMsgSubmitEvidence = exports.isAminoMsgSetWithdrawAddress = exports.isAminoMsgSend = exports.isAminoMsgMultiSend = exports.isAminoMsgFundCommunityPool = exports.isAminoMsgEditValidator = exports.isAminoMsgDeposit = exports.isAminoMsgDelegate = exports.isAminoMsgCreateVestingAccount = exports.isAminoMsgCreateValidator = exports.isAminoMsgBeginRedelegate = exports.createVestingAminoConverters = exports.createStakingAminoConverters = exports.createSlashingAminoConverters = exports.createIbcAminoConverters = exports.createGroupAminoConverters = exports.createGovAminoConverters = exports.createFeegrantAminoConverters = exports.createEvidenceAminoConverters = exports.createDistributionAminoConverters = exports.createCrysisAminoConverters = exports.createBankAminoConverters = exports.createAuthzAminoConverters = exports.logs = exports.GasPrice = exports.calculateFee = exports.fromTendermintEvent = exports.AminoTypes = exports.accountFromAny = void 0;
    exports.parseCoins = exports.makeCosmoshubPath = exports.coins = exports.coin = exports.TimeoutError = exports.StargateClient = exports.isDeliverTxSuccess = exports.isDeliverTxFailure = exports.BroadcastTxError = exports.assertIsDeliverTxSuccess = exports.assertIsDeliverTxFailure = exports.SigningStargateClient = exports.defaultRegistryTypes = exports.createDefaultAminoConverters = exports.isSearchTxQueryArray = exports.QueryClient = exports.decodeCosmosSdkDecFromProto = exports.createProtobufRpcClient = exports.createPagination = exports.makeMultisignedTxBytes = exports.makeMultisignedTx = exports.setupTxExtension = exports.setupStakingExtension = exports.setupSlashingExtension = exports.setupMintExtension = exports.setupIbcExtension = exports.setupGovExtension = exports.setupFeegrantExtension = exports.setupDistributionExtension = exports.setupBankExtension = exports.setupAuthzExtension = exports.setupAuthExtension = exports.isMsgWithdrawDelegatorRewardEncodeObject = void 0;
    var accounts_1 = require_accounts();
    Object.defineProperty(exports, "accountFromAny", { enumerable: true, get: function() {
      return accounts_1.accountFromAny;
    } });
    var aminotypes_1 = require_aminotypes();
    Object.defineProperty(exports, "AminoTypes", { enumerable: true, get: function() {
      return aminotypes_1.AminoTypes;
    } });
    var events_1 = require_events();
    Object.defineProperty(exports, "fromTendermintEvent", { enumerable: true, get: function() {
      return events_1.fromTendermintEvent;
    } });
    var fee_1 = require_fee();
    Object.defineProperty(exports, "calculateFee", { enumerable: true, get: function() {
      return fee_1.calculateFee;
    } });
    Object.defineProperty(exports, "GasPrice", { enumerable: true, get: function() {
      return fee_1.GasPrice;
    } });
    exports.logs = __importStar(require_logs());
    var modules_1 = require_modules();
    Object.defineProperty(exports, "createAuthzAminoConverters", { enumerable: true, get: function() {
      return modules_1.createAuthzAminoConverters;
    } });
    Object.defineProperty(exports, "createBankAminoConverters", { enumerable: true, get: function() {
      return modules_1.createBankAminoConverters;
    } });
    Object.defineProperty(exports, "createCrysisAminoConverters", { enumerable: true, get: function() {
      return modules_1.createCrysisAminoConverters;
    } });
    Object.defineProperty(exports, "createDistributionAminoConverters", { enumerable: true, get: function() {
      return modules_1.createDistributionAminoConverters;
    } });
    Object.defineProperty(exports, "createEvidenceAminoConverters", { enumerable: true, get: function() {
      return modules_1.createEvidenceAminoConverters;
    } });
    Object.defineProperty(exports, "createFeegrantAminoConverters", { enumerable: true, get: function() {
      return modules_1.createFeegrantAminoConverters;
    } });
    Object.defineProperty(exports, "createGovAminoConverters", { enumerable: true, get: function() {
      return modules_1.createGovAminoConverters;
    } });
    Object.defineProperty(exports, "createGroupAminoConverters", { enumerable: true, get: function() {
      return modules_1.createGroupAminoConverters;
    } });
    Object.defineProperty(exports, "createIbcAminoConverters", { enumerable: true, get: function() {
      return modules_1.createIbcAminoConverters;
    } });
    Object.defineProperty(exports, "createSlashingAminoConverters", { enumerable: true, get: function() {
      return modules_1.createSlashingAminoConverters;
    } });
    Object.defineProperty(exports, "createStakingAminoConverters", { enumerable: true, get: function() {
      return modules_1.createStakingAminoConverters;
    } });
    Object.defineProperty(exports, "createVestingAminoConverters", { enumerable: true, get: function() {
      return modules_1.createVestingAminoConverters;
    } });
    Object.defineProperty(exports, "isAminoMsgBeginRedelegate", { enumerable: true, get: function() {
      return modules_1.isAminoMsgBeginRedelegate;
    } });
    Object.defineProperty(exports, "isAminoMsgCreateValidator", { enumerable: true, get: function() {
      return modules_1.isAminoMsgCreateValidator;
    } });
    Object.defineProperty(exports, "isAminoMsgCreateVestingAccount", { enumerable: true, get: function() {
      return modules_1.isAminoMsgCreateVestingAccount;
    } });
    Object.defineProperty(exports, "isAminoMsgDelegate", { enumerable: true, get: function() {
      return modules_1.isAminoMsgDelegate;
    } });
    Object.defineProperty(exports, "isAminoMsgDeposit", { enumerable: true, get: function() {
      return modules_1.isAminoMsgDeposit;
    } });
    Object.defineProperty(exports, "isAminoMsgEditValidator", { enumerable: true, get: function() {
      return modules_1.isAminoMsgEditValidator;
    } });
    Object.defineProperty(exports, "isAminoMsgFundCommunityPool", { enumerable: true, get: function() {
      return modules_1.isAminoMsgFundCommunityPool;
    } });
    Object.defineProperty(exports, "isAminoMsgMultiSend", { enumerable: true, get: function() {
      return modules_1.isAminoMsgMultiSend;
    } });
    Object.defineProperty(exports, "isAminoMsgSend", { enumerable: true, get: function() {
      return modules_1.isAminoMsgSend;
    } });
    Object.defineProperty(exports, "isAminoMsgSetWithdrawAddress", { enumerable: true, get: function() {
      return modules_1.isAminoMsgSetWithdrawAddress;
    } });
    Object.defineProperty(exports, "isAminoMsgSubmitEvidence", { enumerable: true, get: function() {
      return modules_1.isAminoMsgSubmitEvidence;
    } });
    Object.defineProperty(exports, "isAminoMsgSubmitProposal", { enumerable: true, get: function() {
      return modules_1.isAminoMsgSubmitProposal;
    } });
    Object.defineProperty(exports, "isAminoMsgTransfer", { enumerable: true, get: function() {
      return modules_1.isAminoMsgTransfer;
    } });
    Object.defineProperty(exports, "isAminoMsgUndelegate", { enumerable: true, get: function() {
      return modules_1.isAminoMsgUndelegate;
    } });
    Object.defineProperty(exports, "isAminoMsgUnjail", { enumerable: true, get: function() {
      return modules_1.isAminoMsgUnjail;
    } });
    Object.defineProperty(exports, "isAminoMsgVerifyInvariant", { enumerable: true, get: function() {
      return modules_1.isAminoMsgVerifyInvariant;
    } });
    Object.defineProperty(exports, "isAminoMsgVote", { enumerable: true, get: function() {
      return modules_1.isAminoMsgVote;
    } });
    Object.defineProperty(exports, "isAminoMsgVoteWeighted", { enumerable: true, get: function() {
      return modules_1.isAminoMsgVoteWeighted;
    } });
    Object.defineProperty(exports, "isAminoMsgWithdrawDelegatorReward", { enumerable: true, get: function() {
      return modules_1.isAminoMsgWithdrawDelegatorReward;
    } });
    Object.defineProperty(exports, "isAminoMsgWithdrawValidatorCommission", { enumerable: true, get: function() {
      return modules_1.isAminoMsgWithdrawValidatorCommission;
    } });
    Object.defineProperty(exports, "isMsgBeginRedelegateEncodeObject", { enumerable: true, get: function() {
      return modules_1.isMsgBeginRedelegateEncodeObject;
    } });
    Object.defineProperty(exports, "isMsgCancelUnbondingDelegationEncodeObject", { enumerable: true, get: function() {
      return modules_1.isMsgCancelUnbondingDelegationEncodeObject;
    } });
    Object.defineProperty(exports, "isMsgCreateValidatorEncodeObject", { enumerable: true, get: function() {
      return modules_1.isMsgCreateValidatorEncodeObject;
    } });
    Object.defineProperty(exports, "isMsgDelegateEncodeObject", { enumerable: true, get: function() {
      return modules_1.isMsgDelegateEncodeObject;
    } });
    Object.defineProperty(exports, "isMsgDepositEncodeObject", { enumerable: true, get: function() {
      return modules_1.isMsgDepositEncodeObject;
    } });
    Object.defineProperty(exports, "isMsgEditValidatorEncodeObject", { enumerable: true, get: function() {
      return modules_1.isMsgEditValidatorEncodeObject;
    } });
    Object.defineProperty(exports, "isMsgSendEncodeObject", { enumerable: true, get: function() {
      return modules_1.isMsgSendEncodeObject;
    } });
    Object.defineProperty(exports, "isMsgSubmitProposalEncodeObject", { enumerable: true, get: function() {
      return modules_1.isMsgSubmitProposalEncodeObject;
    } });
    Object.defineProperty(exports, "isMsgTransferEncodeObject", { enumerable: true, get: function() {
      return modules_1.isMsgTransferEncodeObject;
    } });
    Object.defineProperty(exports, "isMsgUndelegateEncodeObject", { enumerable: true, get: function() {
      return modules_1.isMsgUndelegateEncodeObject;
    } });
    Object.defineProperty(exports, "isMsgVoteEncodeObject", { enumerable: true, get: function() {
      return modules_1.isMsgVoteEncodeObject;
    } });
    Object.defineProperty(exports, "isMsgVoteWeightedEncodeObject", { enumerable: true, get: function() {
      return modules_1.isMsgVoteWeightedEncodeObject;
    } });
    Object.defineProperty(exports, "isMsgWithdrawDelegatorRewardEncodeObject", { enumerable: true, get: function() {
      return modules_1.isMsgWithdrawDelegatorRewardEncodeObject;
    } });
    Object.defineProperty(exports, "setupAuthExtension", { enumerable: true, get: function() {
      return modules_1.setupAuthExtension;
    } });
    Object.defineProperty(exports, "setupAuthzExtension", { enumerable: true, get: function() {
      return modules_1.setupAuthzExtension;
    } });
    Object.defineProperty(exports, "setupBankExtension", { enumerable: true, get: function() {
      return modules_1.setupBankExtension;
    } });
    Object.defineProperty(exports, "setupDistributionExtension", { enumerable: true, get: function() {
      return modules_1.setupDistributionExtension;
    } });
    Object.defineProperty(exports, "setupFeegrantExtension", { enumerable: true, get: function() {
      return modules_1.setupFeegrantExtension;
    } });
    Object.defineProperty(exports, "setupGovExtension", { enumerable: true, get: function() {
      return modules_1.setupGovExtension;
    } });
    Object.defineProperty(exports, "setupIbcExtension", { enumerable: true, get: function() {
      return modules_1.setupIbcExtension;
    } });
    Object.defineProperty(exports, "setupMintExtension", { enumerable: true, get: function() {
      return modules_1.setupMintExtension;
    } });
    Object.defineProperty(exports, "setupSlashingExtension", { enumerable: true, get: function() {
      return modules_1.setupSlashingExtension;
    } });
    Object.defineProperty(exports, "setupStakingExtension", { enumerable: true, get: function() {
      return modules_1.setupStakingExtension;
    } });
    Object.defineProperty(exports, "setupTxExtension", { enumerable: true, get: function() {
      return modules_1.setupTxExtension;
    } });
    var multisignature_1 = require_multisignature();
    Object.defineProperty(exports, "makeMultisignedTx", { enumerable: true, get: function() {
      return multisignature_1.makeMultisignedTx;
    } });
    Object.defineProperty(exports, "makeMultisignedTxBytes", { enumerable: true, get: function() {
      return multisignature_1.makeMultisignedTxBytes;
    } });
    var queryclient_1 = require_queryclient2();
    Object.defineProperty(exports, "createPagination", { enumerable: true, get: function() {
      return queryclient_1.createPagination;
    } });
    Object.defineProperty(exports, "createProtobufRpcClient", { enumerable: true, get: function() {
      return queryclient_1.createProtobufRpcClient;
    } });
    Object.defineProperty(exports, "decodeCosmosSdkDecFromProto", { enumerable: true, get: function() {
      return queryclient_1.decodeCosmosSdkDecFromProto;
    } });
    Object.defineProperty(exports, "QueryClient", { enumerable: true, get: function() {
      return queryclient_1.QueryClient;
    } });
    var search_1 = require_search();
    Object.defineProperty(exports, "isSearchTxQueryArray", { enumerable: true, get: function() {
      return search_1.isSearchTxQueryArray;
    } });
    var signingstargateclient_1 = require_signingstargateclient();
    Object.defineProperty(exports, "createDefaultAminoConverters", { enumerable: true, get: function() {
      return signingstargateclient_1.createDefaultAminoConverters;
    } });
    Object.defineProperty(exports, "defaultRegistryTypes", { enumerable: true, get: function() {
      return signingstargateclient_1.defaultRegistryTypes;
    } });
    Object.defineProperty(exports, "SigningStargateClient", { enumerable: true, get: function() {
      return signingstargateclient_1.SigningStargateClient;
    } });
    var stargateclient_1 = require_stargateclient();
    Object.defineProperty(exports, "assertIsDeliverTxFailure", { enumerable: true, get: function() {
      return stargateclient_1.assertIsDeliverTxFailure;
    } });
    Object.defineProperty(exports, "assertIsDeliverTxSuccess", { enumerable: true, get: function() {
      return stargateclient_1.assertIsDeliverTxSuccess;
    } });
    Object.defineProperty(exports, "BroadcastTxError", { enumerable: true, get: function() {
      return stargateclient_1.BroadcastTxError;
    } });
    Object.defineProperty(exports, "isDeliverTxFailure", { enumerable: true, get: function() {
      return stargateclient_1.isDeliverTxFailure;
    } });
    Object.defineProperty(exports, "isDeliverTxSuccess", { enumerable: true, get: function() {
      return stargateclient_1.isDeliverTxSuccess;
    } });
    Object.defineProperty(exports, "StargateClient", { enumerable: true, get: function() {
      return stargateclient_1.StargateClient;
    } });
    Object.defineProperty(exports, "TimeoutError", { enumerable: true, get: function() {
      return stargateclient_1.TimeoutError;
    } });
    var proto_signing_1 = require_build6();
    Object.defineProperty(exports, "coin", { enumerable: true, get: function() {
      return proto_signing_1.coin;
    } });
    Object.defineProperty(exports, "coins", { enumerable: true, get: function() {
      return proto_signing_1.coins;
    } });
    Object.defineProperty(exports, "makeCosmoshubPath", { enumerable: true, get: function() {
      return proto_signing_1.makeCosmoshubPath;
    } });
    Object.defineProperty(exports, "parseCoins", { enumerable: true, get: function() {
      return proto_signing_1.parseCoins;
    } });
  }
});

// ../../node_modules/.pnpm/@cosmjs+cosmwasm-stargate@0.34.0/node_modules/@cosmjs/cosmwasm-stargate/build/modules/wasm/aminomessages.js
var require_aminomessages13 = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+cosmwasm-stargate@0.34.0/node_modules/@cosmjs/cosmwasm-stargate/build/modules/wasm/aminomessages.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.accessTypeFromString = accessTypeFromString;
    exports.accessTypeToString = accessTypeToString;
    exports.createWasmAminoConverters = createWasmAminoConverters;
    var amino_1 = require_build5();
    var encoding_1 = require_build();
    var types_1 = require_types();
    function accessTypeFromString(str) {
      switch (str) {
        case "Unspecified":
          return types_1.AccessType.ACCESS_TYPE_UNSPECIFIED;
        case "Nobody":
          return types_1.AccessType.ACCESS_TYPE_NOBODY;
        case "OnlyAddress":
          return types_1.AccessType.ACCESS_TYPE_ONLY_ADDRESS;
        case "Everybody":
          return types_1.AccessType.ACCESS_TYPE_EVERYBODY;
        case "AnyOfAddresses":
          return types_1.AccessType.ACCESS_TYPE_ANY_OF_ADDRESSES;
        default:
          return types_1.AccessType.UNRECOGNIZED;
      }
    }
    function accessTypeToString(object) {
      switch (object) {
        case types_1.AccessType.ACCESS_TYPE_UNSPECIFIED:
          return "Unspecified";
        case types_1.AccessType.ACCESS_TYPE_NOBODY:
          return "Nobody";
        case types_1.AccessType.ACCESS_TYPE_ONLY_ADDRESS:
          return "OnlyAddress";
        case types_1.AccessType.ACCESS_TYPE_EVERYBODY:
          return "Everybody";
        case types_1.AccessType.ACCESS_TYPE_ANY_OF_ADDRESSES:
          return "AnyOfAddresses";
        case types_1.AccessType.UNRECOGNIZED:
        default:
          return "UNRECOGNIZED";
      }
    }
    function createWasmAminoConverters() {
      return {
        "/cosmwasm.wasm.v1.MsgStoreCode": {
          aminoType: "wasm/MsgStoreCode",
          toAmino: ({ sender, wasmByteCode, instantiatePermission }) => ({
            sender,
            wasm_byte_code: (0, encoding_1.toBase64)(wasmByteCode),
            instantiate_permission: instantiatePermission ? {
              permission: accessTypeToString(instantiatePermission.permission),
              address: instantiatePermission.address || void 0,
              addresses: instantiatePermission.addresses.length !== 0 ? instantiatePermission.addresses : void 0
            } : void 0
          }),
          fromAmino: ({ sender, wasm_byte_code, instantiate_permission }) => ({
            sender,
            wasmByteCode: (0, encoding_1.fromBase64)(wasm_byte_code),
            instantiatePermission: instantiate_permission ? types_1.AccessConfig.fromPartial({
              permission: accessTypeFromString(instantiate_permission.permission),
              address: instantiate_permission.address ?? "",
              addresses: instantiate_permission.addresses ?? []
            }) : void 0
          })
        },
        "/cosmwasm.wasm.v1.MsgInstantiateContract": {
          aminoType: "wasm/MsgInstantiateContract",
          toAmino: ({ sender, codeId, label, msg, funds, admin }) => ({
            sender,
            code_id: codeId.toString(),
            label,
            msg: JSON.parse((0, encoding_1.fromUtf8)(msg)),
            funds,
            admin: (0, amino_1.omitDefault)(admin)
          }),
          fromAmino: ({ sender, code_id, label, msg, funds, admin }) => ({
            sender,
            codeId: BigInt(code_id),
            label,
            msg: (0, encoding_1.toUtf8)(JSON.stringify(msg)),
            funds: [...funds],
            admin: admin ?? ""
          })
        },
        "/cosmwasm.wasm.v1.MsgInstantiateContract2": {
          aminoType: "wasm/MsgInstantiateContract2",
          toAmino: ({ sender, codeId, label, msg, funds, admin, salt, fixMsg }) => ({
            sender,
            code_id: codeId.toString(),
            label,
            msg: JSON.parse((0, encoding_1.fromUtf8)(msg)),
            funds,
            admin: (0, amino_1.omitDefault)(admin),
            salt: (0, encoding_1.toBase64)(salt),
            fix_msg: (0, amino_1.omitDefault)(fixMsg)
          }),
          fromAmino: ({ sender, code_id, label, msg, funds, admin, salt, fix_msg }) => ({
            sender,
            codeId: BigInt(code_id),
            label,
            msg: (0, encoding_1.toUtf8)(JSON.stringify(msg)),
            funds: [...funds],
            admin: admin ?? "",
            salt: (0, encoding_1.fromBase64)(salt),
            fixMsg: fix_msg ?? false
          })
        },
        "/cosmwasm.wasm.v1.MsgUpdateAdmin": {
          aminoType: "wasm/MsgUpdateAdmin",
          toAmino: ({ sender, newAdmin, contract }) => ({
            sender,
            new_admin: newAdmin,
            contract
          }),
          fromAmino: ({ sender, new_admin, contract }) => ({
            sender,
            newAdmin: new_admin,
            contract
          })
        },
        "/cosmwasm.wasm.v1.MsgClearAdmin": {
          aminoType: "wasm/MsgClearAdmin",
          toAmino: ({ sender, contract }) => ({
            sender,
            contract
          }),
          fromAmino: ({ sender, contract }) => ({
            sender,
            contract
          })
        },
        "/cosmwasm.wasm.v1.MsgExecuteContract": {
          aminoType: "wasm/MsgExecuteContract",
          toAmino: ({ sender, contract, msg, funds }) => ({
            sender,
            contract,
            msg: JSON.parse((0, encoding_1.fromUtf8)(msg)),
            funds
          }),
          fromAmino: ({ sender, contract, msg, funds }) => ({
            sender,
            contract,
            msg: (0, encoding_1.toUtf8)(JSON.stringify(msg)),
            funds: [...funds]
          })
        },
        "/cosmwasm.wasm.v1.MsgMigrateContract": {
          aminoType: "wasm/MsgMigrateContract",
          toAmino: ({ sender, contract, codeId, msg }) => ({
            sender,
            contract,
            code_id: codeId.toString(),
            msg: JSON.parse((0, encoding_1.fromUtf8)(msg))
          }),
          fromAmino: ({ sender, contract, code_id, msg }) => ({
            sender,
            contract,
            codeId: BigInt(code_id),
            msg: (0, encoding_1.toUtf8)(JSON.stringify(msg))
          })
        }
      };
    }
  }
});

// ../../node_modules/.pnpm/@cosmjs+cosmwasm-stargate@0.34.0/node_modules/@cosmjs/cosmwasm-stargate/build/modules/wasm/messages.js
var require_messages10 = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+cosmwasm-stargate@0.34.0/node_modules/@cosmjs/cosmwasm-stargate/build/modules/wasm/messages.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.wasmTypes = void 0;
    exports.isMsgStoreCodeEncodeObject = isMsgStoreCodeEncodeObject;
    exports.isMsgInstantiateContractEncodeObject = isMsgInstantiateContractEncodeObject;
    exports.isMsgInstantiateContract2EncodeObject = isMsgInstantiateContract2EncodeObject;
    exports.isMsgUpdateAdminEncodeObject = isMsgUpdateAdminEncodeObject;
    exports.isMsgClearAdminEncodeObject = isMsgClearAdminEncodeObject;
    exports.isMsgMigrateEncodeObject = isMsgMigrateEncodeObject;
    exports.isMsgExecuteEncodeObject = isMsgExecuteEncodeObject;
    var tx_1 = require_tx15();
    exports.wasmTypes = [
      ["/cosmwasm.wasm.v1.MsgClearAdmin", tx_1.MsgClearAdmin],
      ["/cosmwasm.wasm.v1.MsgExecuteContract", tx_1.MsgExecuteContract],
      ["/cosmwasm.wasm.v1.MsgMigrateContract", tx_1.MsgMigrateContract],
      ["/cosmwasm.wasm.v1.MsgStoreCode", tx_1.MsgStoreCode],
      ["/cosmwasm.wasm.v1.MsgInstantiateContract", tx_1.MsgInstantiateContract],
      ["/cosmwasm.wasm.v1.MsgInstantiateContract2", tx_1.MsgInstantiateContract2],
      ["/cosmwasm.wasm.v1.MsgUpdateAdmin", tx_1.MsgUpdateAdmin]
    ];
    function isMsgStoreCodeEncodeObject(object) {
      return object.typeUrl === "/cosmwasm.wasm.v1.MsgStoreCode";
    }
    function isMsgInstantiateContractEncodeObject(object) {
      return object.typeUrl === "/cosmwasm.wasm.v1.MsgInstantiateContract";
    }
    function isMsgInstantiateContract2EncodeObject(object) {
      return object.typeUrl === "/cosmwasm.wasm.v1.MsgInstantiateContract2";
    }
    function isMsgUpdateAdminEncodeObject(object) {
      return object.typeUrl === "/cosmwasm.wasm.v1.MsgUpdateAdmin";
    }
    function isMsgClearAdminEncodeObject(object) {
      return object.typeUrl === "/cosmwasm.wasm.v1.MsgClearAdmin";
    }
    function isMsgMigrateEncodeObject(object) {
      return object.typeUrl === "/cosmwasm.wasm.v1.MsgMigrateContract";
    }
    function isMsgExecuteEncodeObject(object) {
      return object.typeUrl === "/cosmwasm.wasm.v1.MsgExecuteContract";
    }
  }
});

// ../../node_modules/.pnpm/@cosmjs+cosmwasm-stargate@0.34.0/node_modules/@cosmjs/cosmwasm-stargate/build/modules/wasm/queries.js
var require_queries12 = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+cosmwasm-stargate@0.34.0/node_modules/@cosmjs/cosmwasm-stargate/build/modules/wasm/queries.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.setupWasmExtension = setupWasmExtension;
    var encoding_1 = require_build();
    var stargate_1 = require_build11();
    var query_1 = require_query14();
    function setupWasmExtension(base) {
      const rpc = (0, stargate_1.createProtobufRpcClient)(base);
      const queryService = new query_1.QueryClientImpl(rpc);
      return {
        wasm: {
          listCodeInfo: async (paginationKey) => {
            const request = {
              pagination: (0, stargate_1.createPagination)(paginationKey)
            };
            return queryService.Codes(request);
          },
          getCode: async (id) => {
            const request = query_1.QueryCodeRequest.fromPartial({ codeId: BigInt(id) });
            return queryService.Code(request);
          },
          listContractsByCodeId: async (id, paginationKey) => {
            const request = query_1.QueryContractsByCodeRequest.fromPartial({
              codeId: BigInt(id),
              pagination: (0, stargate_1.createPagination)(paginationKey)
            });
            return queryService.ContractsByCode(request);
          },
          listContractsByCreator: async (creator, paginationKey) => {
            const request = {
              creatorAddress: creator,
              pagination: (0, stargate_1.createPagination)(paginationKey)
            };
            return queryService.ContractsByCreator(request);
          },
          getContractInfo: async (address) => {
            const request = { address };
            return queryService.ContractInfo(request);
          },
          getContractCodeHistory: async (address, paginationKey) => {
            const request = {
              address,
              pagination: (0, stargate_1.createPagination)(paginationKey)
            };
            return queryService.ContractHistory(request);
          },
          getAllContractState: async (address, paginationKey) => {
            const request = {
              address,
              pagination: (0, stargate_1.createPagination)(paginationKey)
            };
            return queryService.AllContractState(request);
          },
          queryContractRaw: async (address, key) => {
            const request = { address, queryData: key };
            return queryService.RawContractState(request);
          },
          queryContractSmart: async (address, query) => {
            const request = { address, queryData: (0, encoding_1.toUtf8)(JSON.stringify(query)) };
            const { data } = await queryService.SmartContractState(request);
            let responseText;
            try {
              responseText = (0, encoding_1.fromUtf8)(data);
            } catch (error) {
              throw new Error(`Could not UTF-8 decode smart query response from contract: ${error}`);
            }
            try {
              return JSON.parse(responseText);
            } catch (error) {
              throw new Error(`Could not JSON parse smart query response from contract: ${error}`);
            }
          }
        }
      };
    }
  }
});

// ../../node_modules/.pnpm/@cosmjs+cosmwasm-stargate@0.34.0/node_modules/@cosmjs/cosmwasm-stargate/build/modules/index.js
var require_modules2 = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+cosmwasm-stargate@0.34.0/node_modules/@cosmjs/cosmwasm-stargate/build/modules/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.setupWasmExtension = exports.wasmTypes = exports.isMsgUpdateAdminEncodeObject = exports.isMsgStoreCodeEncodeObject = exports.isMsgMigrateEncodeObject = exports.isMsgInstantiateContractEncodeObject = exports.isMsgInstantiateContract2EncodeObject = exports.isMsgExecuteEncodeObject = exports.isMsgClearAdminEncodeObject = exports.createWasmAminoConverters = void 0;
    var aminomessages_1 = require_aminomessages13();
    Object.defineProperty(exports, "createWasmAminoConverters", { enumerable: true, get: function() {
      return aminomessages_1.createWasmAminoConverters;
    } });
    var messages_1 = require_messages10();
    Object.defineProperty(exports, "isMsgClearAdminEncodeObject", { enumerable: true, get: function() {
      return messages_1.isMsgClearAdminEncodeObject;
    } });
    Object.defineProperty(exports, "isMsgExecuteEncodeObject", { enumerable: true, get: function() {
      return messages_1.isMsgExecuteEncodeObject;
    } });
    Object.defineProperty(exports, "isMsgInstantiateContract2EncodeObject", { enumerable: true, get: function() {
      return messages_1.isMsgInstantiateContract2EncodeObject;
    } });
    Object.defineProperty(exports, "isMsgInstantiateContractEncodeObject", { enumerable: true, get: function() {
      return messages_1.isMsgInstantiateContractEncodeObject;
    } });
    Object.defineProperty(exports, "isMsgMigrateEncodeObject", { enumerable: true, get: function() {
      return messages_1.isMsgMigrateEncodeObject;
    } });
    Object.defineProperty(exports, "isMsgStoreCodeEncodeObject", { enumerable: true, get: function() {
      return messages_1.isMsgStoreCodeEncodeObject;
    } });
    Object.defineProperty(exports, "isMsgUpdateAdminEncodeObject", { enumerable: true, get: function() {
      return messages_1.isMsgUpdateAdminEncodeObject;
    } });
    Object.defineProperty(exports, "wasmTypes", { enumerable: true, get: function() {
      return messages_1.wasmTypes;
    } });
    var queries_1 = require_queries12();
    Object.defineProperty(exports, "setupWasmExtension", { enumerable: true, get: function() {
      return queries_1.setupWasmExtension;
    } });
  }
});

// ../../node_modules/.pnpm/@cosmjs+cosmwasm-stargate@0.34.0/node_modules/@cosmjs/cosmwasm-stargate/build/cosmwasmclient.js
var require_cosmwasmclient = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+cosmwasm-stargate@0.34.0/node_modules/@cosmjs/cosmwasm-stargate/build/cosmwasmclient.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CosmWasmClient = void 0;
    var encoding_1 = require_build();
    var math_1 = require_build2();
    var stargate_1 = require_build11();
    var tendermint_rpc_1 = require_build10();
    var utils_1 = require_build3();
    var abci_1 = require_abci();
    var types_1 = require_types();
    var modules_1 = require_modules2();
    var CosmWasmClient = class _CosmWasmClient {
      /**
       * Creates an instance by connecting to the given CometBFT RPC endpoint.
       *
       * This uses auto-detection to decide between a CometBFT 0.38, Tendermint 0.37 and 0.34 client.
       * To set the Comet client explicitly, use `create`.
       */
      static async connect(endpoint) {
        const cometClient = await (0, tendermint_rpc_1.connectComet)(endpoint);
        return _CosmWasmClient.create(cometClient);
      }
      /**
       * Creates an instance from a manually created Comet client.
       * Use this to use `Comet38Client` or `Tendermint37Client` instead of `Tendermint34Client`.
       */
      static async create(cometClient) {
        return new _CosmWasmClient(cometClient);
      }
      constructor(cometClient) {
        this.codesCache = /* @__PURE__ */ new Map();
        if (cometClient) {
          this.cometClient = cometClient;
          this.queryClient = stargate_1.QueryClient.withExtensions(cometClient, stargate_1.setupAuthExtension, stargate_1.setupBankExtension, modules_1.setupWasmExtension, stargate_1.setupTxExtension);
        }
      }
      getCometClient() {
        return this.cometClient;
      }
      forceGetCometClient() {
        if (!this.cometClient) {
          throw new Error("Comet client not available. You cannot use online functionality in offline mode.");
        }
        return this.cometClient;
      }
      getQueryClient() {
        return this.queryClient;
      }
      forceGetQueryClient() {
        if (!this.queryClient) {
          throw new Error("Query client not available. You cannot use online functionality in offline mode.");
        }
        return this.queryClient;
      }
      async getChainId() {
        if (!this.chainId) {
          const response = await this.forceGetCometClient().status();
          const chainId = response.nodeInfo.network;
          if (!chainId)
            throw new Error("Chain ID must not be empty");
          this.chainId = chainId;
        }
        return this.chainId;
      }
      async getHeight() {
        const status = await this.forceGetCometClient().status();
        return status.syncInfo.latestBlockHeight;
      }
      async getAccount(searchAddress) {
        try {
          const account = await this.forceGetQueryClient().auth.account(searchAddress);
          return account ? (0, stargate_1.accountFromAny)(account) : null;
        } catch (error) {
          if (/rpc error: code = NotFound/i.test(error.toString())) {
            return null;
          }
          throw error;
        }
      }
      async getSequence(address) {
        const account = await this.getAccount(address);
        if (!account) {
          throw new Error(`Account '${address}' does not exist on chain. Send some tokens there before trying to query sequence.`);
        }
        return {
          accountNumber: account.accountNumber,
          sequence: account.sequence
        };
      }
      async getBlock(height) {
        const response = await this.forceGetCometClient().block(height);
        return {
          id: (0, encoding_1.toHex)(response.blockId.hash).toUpperCase(),
          header: {
            version: {
              block: new math_1.Uint53(response.block.header.version.block).toString(),
              app: new math_1.Uint53(response.block.header.version.app).toString()
            },
            height: response.block.header.height,
            chainId: response.block.header.chainId,
            time: (0, tendermint_rpc_1.toRfc3339WithNanoseconds)(response.block.header.time)
          },
          txs: response.block.txs
        };
      }
      async getBalance(address, searchDenom) {
        return this.forceGetQueryClient().bank.balance(address, searchDenom);
      }
      async getTx(id) {
        const results = await this.txsQuery(`tx.hash='${id}'`);
        return results[0] ?? null;
      }
      async searchTx(query) {
        let rawQuery;
        if (typeof query === "string") {
          rawQuery = query;
        } else if ((0, stargate_1.isSearchTxQueryArray)(query)) {
          rawQuery = query.map((t) => {
            if (typeof t.value === "string")
              return `${t.key}='${t.value}'`;
            else
              return `${t.key}=${t.value}`;
          }).join(" AND ");
        } else {
          throw new Error("Got unsupported query type. See CosmJS 0.31 CHANGELOG for API breaking changes here.");
        }
        return this.txsQuery(rawQuery);
      }
      disconnect() {
        if (this.cometClient)
          this.cometClient.disconnect();
      }
      /**
       * Broadcasts a signed transaction to the network and monitors its inclusion in a block.
       *
       * If broadcasting is rejected by the node for some reason (e.g. because of a CheckTx failure),
       * an error is thrown.
       *
       * If the transaction is not included in a block before the provided timeout, this errors with a `TimeoutError`.
       *
       * If the transaction is included in a block, a `DeliverTxResponse` is returned. The caller then
       * usually needs to check for execution success or failure.
       */
      // NOTE: This method is tested against slow chains and timeouts in the @cosmjs/stargate package.
      // Make sure it is kept in sync!
      async broadcastTx(tx, timeoutMs = 6e4, pollIntervalMs = 3e3) {
        let timedOut = false;
        const txPollTimeout = setTimeout(() => {
          timedOut = true;
        }, timeoutMs);
        const pollForTx = async (txId) => {
          if (timedOut) {
            throw new stargate_1.TimeoutError(`Transaction with ID ${txId} was submitted but was not yet found on the chain. You might want to check later. There was a wait of ${timeoutMs / 1e3} seconds.`, txId);
          }
          await (0, utils_1.sleep)(pollIntervalMs);
          const result = await this.getTx(txId);
          return result ? {
            code: result.code,
            height: result.height,
            txIndex: result.txIndex,
            rawLog: result.rawLog,
            transactionHash: txId,
            events: result.events,
            msgResponses: result.msgResponses,
            gasUsed: result.gasUsed,
            gasWanted: result.gasWanted
          } : pollForTx(txId);
        };
        const transactionId = await this.broadcastTxSync(tx);
        return new Promise((resolve, reject) => pollForTx(transactionId).then((value) => {
          clearTimeout(txPollTimeout);
          resolve(value);
        }, (error) => {
          clearTimeout(txPollTimeout);
          reject(error);
        }));
      }
      /**
       * Broadcasts a signed transaction to the network without monitoring it.
       *
       * If broadcasting is rejected by the node for some reason (e.g. because of a CheckTx failure),
       * an error is thrown.
       *
       * If the transaction is broadcasted, a `string` containing the hash of the transaction is returned. The caller then
       * usually needs to check if the transaction was included in a block and was successful.
       *
       * @returns Returns the hash of the transaction
       */
      async broadcastTxSync(tx) {
        const broadcasted = await this.forceGetCometClient().broadcastTxSync({ tx });
        if (broadcasted.code) {
          return Promise.reject(new stargate_1.BroadcastTxError(broadcasted.code, broadcasted.codespace ?? "", broadcasted.log));
        }
        const transactionId = (0, encoding_1.toHex)(broadcasted.hash).toUpperCase();
        return transactionId;
      }
      /**
       * getCodes() returns all codes and is just looping through all pagination pages.
       *
       * This is potentially inefficient and advanced apps should consider creating
       * their own query client to handle pagination together with the app's screens.
       */
      async getCodes() {
        const allCodes = [];
        let startAtKey = void 0;
        do {
          const { codeInfos, pagination } = await this.forceGetQueryClient().wasm.listCodeInfo(startAtKey);
          const loadedCodes = codeInfos || [];
          allCodes.push(...loadedCodes);
          startAtKey = pagination == null ? void 0 : pagination.nextKey;
        } while ((startAtKey == null ? void 0 : startAtKey.length) !== 0);
        return allCodes.map((entry) => {
          (0, utils_1.assert)(entry.creator && entry.codeId && entry.dataHash, "entry incomplete");
          return {
            id: Number(entry.codeId),
            creator: entry.creator,
            checksum: (0, encoding_1.toHex)(entry.dataHash)
          };
        });
      }
      async getCodeDetails(codeId) {
        const cached = this.codesCache.get(codeId);
        if (cached)
          return cached;
        const { codeInfo, data } = await this.forceGetQueryClient().wasm.getCode(codeId);
        (0, utils_1.assert)(codeInfo && codeInfo.codeId && codeInfo.creator && codeInfo.dataHash && data, "codeInfo missing or incomplete");
        const codeDetails = {
          id: Number(codeInfo.codeId),
          creator: codeInfo.creator,
          checksum: (0, encoding_1.toHex)(codeInfo.dataHash),
          data
        };
        this.codesCache.set(codeId, codeDetails);
        return codeDetails;
      }
      /**
       * getContracts() returns all contract instances for one code and is just looping through all pagination pages.
       *
       * This is potentially inefficient and advanced apps should consider creating
       * their own query client to handle pagination together with the app's screens.
       */
      async getContracts(codeId) {
        const allContracts = [];
        let startAtKey = void 0;
        do {
          const { contracts, pagination } = await this.forceGetQueryClient().wasm.listContractsByCodeId(codeId, startAtKey);
          allContracts.push(...contracts);
          startAtKey = pagination == null ? void 0 : pagination.nextKey;
        } while ((startAtKey == null ? void 0 : startAtKey.length) !== 0 && startAtKey !== void 0);
        return allContracts;
      }
      /**
       * Returns a list of contract addresses created by the given creator.
       * This just loops through all pagination pages.
       */
      async getContractsByCreator(creator) {
        const allContracts = [];
        let startAtKey = void 0;
        do {
          const { contractAddresses, pagination } = await this.forceGetQueryClient().wasm.listContractsByCreator(creator, startAtKey);
          allContracts.push(...contractAddresses);
          startAtKey = pagination == null ? void 0 : pagination.nextKey;
        } while ((startAtKey == null ? void 0 : startAtKey.length) !== 0 && startAtKey !== void 0);
        return allContracts;
      }
      /**
       * Throws an error if no contract was found at the address
       */
      async getContract(address) {
        const { address: retrievedAddress, contractInfo } = await this.forceGetQueryClient().wasm.getContractInfo(address);
        if (!contractInfo)
          throw new Error(`No contract found at address "${address}"`);
        (0, utils_1.assert)(retrievedAddress, "address missing");
        (0, utils_1.assert)(contractInfo.codeId && contractInfo.creator && contractInfo.label, "contractInfo incomplete");
        return {
          address: retrievedAddress,
          codeId: Number(contractInfo.codeId),
          creator: contractInfo.creator,
          admin: contractInfo.admin || void 0,
          label: contractInfo.label,
          ibcPortId: contractInfo.ibcPortId || void 0
        };
      }
      /**
       * Throws an error if no contract was found at the address
       */
      async getContractCodeHistory(address) {
        const result = await this.forceGetQueryClient().wasm.getContractCodeHistory(address);
        if (!result)
          throw new Error(`No contract history found for address "${address}"`);
        const operations = {
          [types_1.ContractCodeHistoryOperationType.CONTRACT_CODE_HISTORY_OPERATION_TYPE_INIT]: "Init",
          [types_1.ContractCodeHistoryOperationType.CONTRACT_CODE_HISTORY_OPERATION_TYPE_GENESIS]: "Genesis",
          [types_1.ContractCodeHistoryOperationType.CONTRACT_CODE_HISTORY_OPERATION_TYPE_MIGRATE]: "Migrate"
        };
        return (result.entries || []).map((entry) => {
          (0, utils_1.assert)(entry.operation && entry.codeId && entry.msg);
          return {
            operation: operations[entry.operation],
            codeId: Number(entry.codeId),
            msg: JSON.parse((0, encoding_1.fromUtf8)(entry.msg))
          };
        });
      }
      /**
       * Returns the data at the key if present (raw contract dependent storage data)
       * or null if no data at this key.
       *
       * Promise is rejected when contract does not exist.
       */
      async queryContractRaw(address, key) {
        await this.getContract(address);
        const { data } = await this.forceGetQueryClient().wasm.queryContractRaw(address, key);
        return data ?? null;
      }
      /**
       * Makes a smart query on the contract, returns the parsed JSON document.
       *
       * Promise is rejected when contract does not exist.
       * Promise is rejected for invalid query format.
       * Promise is rejected for invalid response format.
       */
      async queryContractSmart(address, queryMsg) {
        try {
          return await this.forceGetQueryClient().wasm.queryContractSmart(address, queryMsg);
        } catch (error) {
          if (error instanceof Error) {
            if (error.message.startsWith("not found: contract")) {
              throw new Error(`No contract found at address "${address}"`);
            } else {
              throw error;
            }
          } else {
            throw error;
          }
        }
      }
      async txsQuery(query) {
        const results = await this.forceGetCometClient().txSearchAll({ query });
        return results.txs.map((tx) => {
          const txMsgData = abci_1.TxMsgData.decode(tx.result.data ?? new Uint8Array());
          return {
            height: tx.height,
            txIndex: tx.index,
            hash: (0, encoding_1.toHex)(tx.hash).toUpperCase(),
            code: tx.result.code,
            events: tx.result.events.map(stargate_1.fromTendermintEvent),
            rawLog: tx.result.log || "",
            tx: tx.tx,
            msgResponses: txMsgData.msgResponses,
            gasUsed: tx.result.gasUsed,
            gasWanted: tx.result.gasWanted
          };
        });
      }
    };
    exports.CosmWasmClient = CosmWasmClient;
  }
});

// ../../node_modules/.pnpm/@cosmjs+cosmwasm-stargate@0.34.0/node_modules/@cosmjs/cosmwasm-stargate/build/encoding.js
var require_encoding2 = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+cosmwasm-stargate@0.34.0/node_modules/@cosmjs/cosmwasm-stargate/build/encoding.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.toBinary = toBinary;
    exports.fromBinary = fromBinary;
    var encoding_1 = require_build();
    function toBinary(obj) {
      return (0, encoding_1.toBase64)((0, encoding_1.toUtf8)(JSON.stringify(obj)));
    }
    function fromBinary(base64) {
      return JSON.parse((0, encoding_1.fromUtf8)((0, encoding_1.fromBase64)(base64)));
    }
  }
});

// ../../node_modules/.pnpm/@cosmjs+cosmwasm-stargate@0.34.0/node_modules/@cosmjs/cosmwasm-stargate/build/instantiate2.js
var require_instantiate2 = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+cosmwasm-stargate@0.34.0/node_modules/@cosmjs/cosmwasm-stargate/build/instantiate2.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports._instantiate2AddressIntermediate = _instantiate2AddressIntermediate;
    exports.instantiate2Address = instantiate2Address;
    var crypto_1 = require_build4();
    var encoding_1 = require_build();
    var math_1 = require_build2();
    var utils_1 = require_build3();
    function hash(type, key) {
      return new crypto_1.Sha256((0, crypto_1.sha256)((0, encoding_1.toAscii)(type))).update(key).digest();
    }
    function toUint64(int) {
      return math_1.Uint64.fromNumber(int).toBytesBigEndian();
    }
    function _instantiate2AddressIntermediate(checksum, creator, salt, msg, prefix) {
      (0, utils_1.assert)(checksum.length === 32);
      const creatorData = (0, encoding_1.fromBech32)(creator).data;
      const msgData = typeof msg === "string" ? (0, encoding_1.toUtf8)(msg) : new Uint8Array();
      if (salt.length < 1 || salt.length > 64)
        throw new Error("Salt must be between 1 and 64 bytes");
      const key = new Uint8Array([
        ...(0, encoding_1.toAscii)("wasm"),
        0,
        ...toUint64(checksum.length),
        ...checksum,
        ...toUint64(creatorData.length),
        ...creatorData,
        ...toUint64(salt.length),
        ...salt,
        ...toUint64(msgData.length),
        ...msgData
      ]);
      const addressData = hash("module", key);
      const address = (0, encoding_1.toBech32)(prefix, addressData);
      return { key, addressData, address };
    }
    function instantiate2Address(checksum, creator, salt, bech32Prefix) {
      const msg = null;
      return _instantiate2AddressIntermediate(checksum, creator, salt, msg, bech32Prefix).address;
    }
  }
});

// ../../node_modules/.pnpm/@cosmjs+cosmwasm-stargate@0.34.0/node_modules/@cosmjs/cosmwasm-stargate/build/signingcosmwasmclient.js
var require_signingcosmwasmclient = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+cosmwasm-stargate@0.34.0/node_modules/@cosmjs/cosmwasm-stargate/build/signingcosmwasmclient.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SigningCosmWasmClient = void 0;
    exports.findAttribute = findAttribute;
    var amino_1 = require_build5();
    var crypto_1 = require_build4();
    var encoding_1 = require_build();
    var math_1 = require_build2();
    var proto_signing_1 = require_build6();
    var stargate_1 = require_build11();
    var tendermint_rpc_1 = require_build10();
    var utils_1 = require_build3();
    var tx_1 = require_tx4();
    var tx_2 = require_tx13();
    var signing_1 = require_signing();
    var tx_3 = require_tx();
    var tx_4 = require_tx15();
    var pako_1 = __importDefault(require_pako());
    var cosmwasmclient_1 = require_cosmwasmclient();
    var modules_1 = require_modules2();
    function findAttribute(events, eventType, attrKey) {
      const attributes = events.filter((event) => event.type === eventType).flatMap((e) => e.attributes);
      const out = attributes.find((attr) => attr.key === attrKey);
      if (!out) {
        throw new Error(`Could not find attribute '${attrKey}' in first event of type '${eventType}' in first log.`);
      }
      return out;
    }
    function createDeliverTxResponseErrorMessage(result) {
      return `Error when broadcasting tx ${result.transactionHash} at height ${result.height}. Code: ${result.code}; Raw log: ${result.rawLog}`;
    }
    var SigningCosmWasmClient = class _SigningCosmWasmClient extends cosmwasmclient_1.CosmWasmClient {
      /**
       * Creates an instance by connecting to the given CometBFT RPC endpoint.
       *
       * This uses auto-detection to decide between a CometBFT 0.38, Tendermint 0.37 and 0.34 client.
       * To set the Comet client explicitly, use `createWithSigner`.
       */
      static async connectWithSigner(endpoint, signer, options = {}) {
        const cometClient = await (0, tendermint_rpc_1.connectComet)(endpoint);
        return _SigningCosmWasmClient.createWithSigner(cometClient, signer, options);
      }
      /**
       * Creates an instance from a manually created Comet client.
       * Use this to use `Comet38Client` or `Tendermint37Client` instead of `Tendermint34Client`.
       */
      static async createWithSigner(cometClient, signer, options = {}) {
        return new _SigningCosmWasmClient(cometClient, signer, options);
      }
      /**
       * Creates a client in offline mode.
       *
       * This should only be used in niche cases where you know exactly what you're doing,
       * e.g. when building an offline signing application.
       *
       * When you try to use online functionality with such a signer, an
       * exception will be raised.
       */
      static async offline(signer, options = {}) {
        return new _SigningCosmWasmClient(void 0, signer, options);
      }
      constructor(cometClient, signer, options) {
        super(cometClient);
        this.defaultGasMultiplier = 1.4;
        const { registry = new proto_signing_1.Registry([...stargate_1.defaultRegistryTypes, ...modules_1.wasmTypes]), aminoTypes = new stargate_1.AminoTypes({
          ...(0, stargate_1.createDefaultAminoConverters)(),
          ...(0, modules_1.createWasmAminoConverters)()
        }) } = options;
        this.registry = registry;
        this.aminoTypes = aminoTypes;
        this.signer = signer;
        this.broadcastTimeoutMs = options.broadcastTimeoutMs;
        this.broadcastPollIntervalMs = options.broadcastPollIntervalMs;
        this.gasPrice = options.gasPrice;
      }
      async simulate(signerAddress, messages, memo) {
        const anyMsgs = messages.map((m) => this.registry.encodeAsAny(m));
        const accountFromSigner = (await this.signer.getAccounts()).find((account) => account.address === signerAddress);
        if (!accountFromSigner) {
          throw new Error("Failed to retrieve account from signer");
        }
        const pubkey = (0, amino_1.encodeSecp256k1Pubkey)(accountFromSigner.pubkey);
        const { sequence } = await this.getSequence(signerAddress);
        const { gasInfo } = await this.forceGetQueryClient().tx.simulate(anyMsgs, memo, pubkey, sequence);
        (0, utils_1.assertDefined)(gasInfo);
        return math_1.Uint53.fromString(gasInfo.gasUsed.toString()).toNumber();
      }
      /** Uploads code and returns a receipt, including the code ID */
      async upload(senderAddress, wasmCode, fee, memo = "", instantiatePermission) {
        const compressed = pako_1.default.gzip(wasmCode, { level: 9 });
        const storeCodeMsg = {
          typeUrl: "/cosmwasm.wasm.v1.MsgStoreCode",
          value: tx_4.MsgStoreCode.fromPartial({
            sender: senderAddress,
            wasmByteCode: compressed,
            instantiatePermission
          })
        };
        const usedFee = fee == "auto" ? 1.1 : fee;
        const result = await this.signAndBroadcast(senderAddress, [storeCodeMsg], usedFee, memo);
        if ((0, stargate_1.isDeliverTxFailure)(result)) {
          throw new Error(createDeliverTxResponseErrorMessage(result));
        }
        const codeIdAttr = findAttribute(result.events, "store_code", "code_id");
        return {
          checksum: (0, encoding_1.toHex)((0, crypto_1.sha256)(wasmCode)),
          originalSize: wasmCode.length,
          compressedSize: compressed.length,
          codeId: Number.parseInt(codeIdAttr.value, 10),
          logs: stargate_1.logs.parseRawLog(result.rawLog),
          height: result.height,
          transactionHash: result.transactionHash,
          events: result.events,
          gasWanted: result.gasWanted,
          gasUsed: result.gasUsed
        };
      }
      async instantiate(senderAddress, codeId, msg, label, fee, options = {}) {
        const instantiateContractMsg = {
          typeUrl: "/cosmwasm.wasm.v1.MsgInstantiateContract",
          value: tx_4.MsgInstantiateContract.fromPartial({
            sender: senderAddress,
            codeId: BigInt(new math_1.Uint53(codeId).toString()),
            label,
            msg: (0, encoding_1.toUtf8)(JSON.stringify(msg)),
            funds: [...options.funds || []],
            admin: options.admin
          })
        };
        const result = await this.signAndBroadcast(senderAddress, [instantiateContractMsg], fee, options.memo);
        if ((0, stargate_1.isDeliverTxFailure)(result)) {
          throw new Error(createDeliverTxResponseErrorMessage(result));
        }
        const contractAddressAttr = findAttribute(result.events, "instantiate", "_contract_address");
        return {
          contractAddress: contractAddressAttr.value,
          logs: stargate_1.logs.parseRawLog(result.rawLog),
          height: result.height,
          transactionHash: result.transactionHash,
          events: result.events,
          gasWanted: result.gasWanted,
          gasUsed: result.gasUsed
        };
      }
      async instantiate2(senderAddress, codeId, salt, msg, label, fee, options = {}) {
        const instantiateContract2Msg = {
          typeUrl: "/cosmwasm.wasm.v1.MsgInstantiateContract2",
          value: tx_4.MsgInstantiateContract2.fromPartial({
            sender: senderAddress,
            codeId: BigInt(new math_1.Uint53(codeId).toString()),
            label,
            msg: (0, encoding_1.toUtf8)(JSON.stringify(msg)),
            funds: [...options.funds || []],
            admin: options.admin,
            salt,
            fixMsg: false
          })
        };
        const result = await this.signAndBroadcast(senderAddress, [instantiateContract2Msg], fee, options.memo);
        if ((0, stargate_1.isDeliverTxFailure)(result)) {
          throw new Error(createDeliverTxResponseErrorMessage(result));
        }
        const contractAddressAttr = findAttribute(result.events, "instantiate", "_contract_address");
        return {
          contractAddress: contractAddressAttr.value,
          logs: stargate_1.logs.parseRawLog(result.rawLog),
          height: result.height,
          transactionHash: result.transactionHash,
          events: result.events,
          gasWanted: result.gasWanted,
          gasUsed: result.gasUsed
        };
      }
      async updateAdmin(senderAddress, contractAddress, newAdmin, fee, memo = "") {
        const updateAdminMsg = {
          typeUrl: "/cosmwasm.wasm.v1.MsgUpdateAdmin",
          value: tx_4.MsgUpdateAdmin.fromPartial({
            sender: senderAddress,
            contract: contractAddress,
            newAdmin
          })
        };
        const result = await this.signAndBroadcast(senderAddress, [updateAdminMsg], fee, memo);
        if ((0, stargate_1.isDeliverTxFailure)(result)) {
          throw new Error(createDeliverTxResponseErrorMessage(result));
        }
        return {
          logs: stargate_1.logs.parseRawLog(result.rawLog),
          height: result.height,
          transactionHash: result.transactionHash,
          events: result.events,
          gasWanted: result.gasWanted,
          gasUsed: result.gasUsed
        };
      }
      async clearAdmin(senderAddress, contractAddress, fee, memo = "") {
        const clearAdminMsg = {
          typeUrl: "/cosmwasm.wasm.v1.MsgClearAdmin",
          value: tx_4.MsgClearAdmin.fromPartial({
            sender: senderAddress,
            contract: contractAddress
          })
        };
        const result = await this.signAndBroadcast(senderAddress, [clearAdminMsg], fee, memo);
        if ((0, stargate_1.isDeliverTxFailure)(result)) {
          throw new Error(createDeliverTxResponseErrorMessage(result));
        }
        return {
          logs: stargate_1.logs.parseRawLog(result.rawLog),
          height: result.height,
          transactionHash: result.transactionHash,
          events: result.events,
          gasWanted: result.gasWanted,
          gasUsed: result.gasUsed
        };
      }
      async migrate(senderAddress, contractAddress, codeId, migrateMsg, fee, memo = "") {
        const migrateContractMsg = {
          typeUrl: "/cosmwasm.wasm.v1.MsgMigrateContract",
          value: tx_4.MsgMigrateContract.fromPartial({
            sender: senderAddress,
            contract: contractAddress,
            codeId: BigInt(new math_1.Uint53(codeId).toString()),
            msg: (0, encoding_1.toUtf8)(JSON.stringify(migrateMsg))
          })
        };
        const result = await this.signAndBroadcast(senderAddress, [migrateContractMsg], fee, memo);
        if ((0, stargate_1.isDeliverTxFailure)(result)) {
          throw new Error(createDeliverTxResponseErrorMessage(result));
        }
        return {
          logs: stargate_1.logs.parseRawLog(result.rawLog),
          height: result.height,
          transactionHash: result.transactionHash,
          events: result.events,
          gasWanted: result.gasWanted,
          gasUsed: result.gasUsed
        };
      }
      async execute(senderAddress, contractAddress, msg, fee, memo = "", funds) {
        const instruction = {
          contractAddress,
          msg,
          funds
        };
        return this.executeMultiple(senderAddress, [instruction], fee, memo);
      }
      /**
       * Like `execute` but allows executing multiple messages in one transaction.
       */
      async executeMultiple(senderAddress, instructions, fee, memo = "") {
        const msgs = instructions.map((i) => ({
          typeUrl: "/cosmwasm.wasm.v1.MsgExecuteContract",
          value: tx_4.MsgExecuteContract.fromPartial({
            sender: senderAddress,
            contract: i.contractAddress,
            msg: (0, encoding_1.toUtf8)(JSON.stringify(i.msg)),
            funds: [...i.funds || []]
          })
        }));
        const result = await this.signAndBroadcast(senderAddress, msgs, fee, memo);
        if ((0, stargate_1.isDeliverTxFailure)(result)) {
          throw new Error(createDeliverTxResponseErrorMessage(result));
        }
        return {
          logs: stargate_1.logs.parseRawLog(result.rawLog),
          height: result.height,
          transactionHash: result.transactionHash,
          events: result.events,
          gasWanted: result.gasWanted,
          gasUsed: result.gasUsed
        };
      }
      async sendTokens(senderAddress, recipientAddress, amount, fee, memo = "") {
        const sendMsg = {
          typeUrl: "/cosmos.bank.v1beta1.MsgSend",
          value: {
            fromAddress: senderAddress,
            toAddress: recipientAddress,
            amount: [...amount]
          }
        };
        return this.signAndBroadcast(senderAddress, [sendMsg], fee, memo);
      }
      async delegateTokens(delegatorAddress, validatorAddress, amount, fee, memo = "") {
        const delegateMsg = {
          typeUrl: "/cosmos.staking.v1beta1.MsgDelegate",
          value: tx_2.MsgDelegate.fromPartial({ delegatorAddress, validatorAddress, amount })
        };
        return this.signAndBroadcast(delegatorAddress, [delegateMsg], fee, memo);
      }
      async undelegateTokens(delegatorAddress, validatorAddress, amount, fee, memo = "") {
        const undelegateMsg = {
          typeUrl: "/cosmos.staking.v1beta1.MsgUndelegate",
          value: tx_2.MsgUndelegate.fromPartial({ delegatorAddress, validatorAddress, amount })
        };
        return this.signAndBroadcast(delegatorAddress, [undelegateMsg], fee, memo);
      }
      async withdrawRewards(delegatorAddress, validatorAddress, fee, memo = "") {
        const withdrawDelegatorRewardMsg = {
          typeUrl: "/cosmos.distribution.v1beta1.MsgWithdrawDelegatorReward",
          value: tx_1.MsgWithdrawDelegatorReward.fromPartial({ delegatorAddress, validatorAddress })
        };
        return this.signAndBroadcast(delegatorAddress, [withdrawDelegatorRewardMsg], fee, memo);
      }
      /**
       * Creates a transaction with the given messages, fee, memo and timeout height. Then signs and broadcasts the transaction.
       *
       * @param signerAddress The address that will sign transactions using this instance. The signer must be able to sign with this address.
       * @param messages
       * @param fee
       * @param memo
       * @param timeoutHeight (optional) timeout height to prevent the tx from being committed past a certain height
       */
      async signAndBroadcast(signerAddress, messages, fee, memo = "", timeoutHeight) {
        let usedFee;
        if (fee == "auto" || typeof fee === "number") {
          (0, utils_1.assertDefined)(this.gasPrice, "Gas price must be set in the client options when auto gas is used.");
          const gasEstimation = await this.simulate(signerAddress, messages, memo);
          const multiplier = typeof fee === "number" ? fee : this.defaultGasMultiplier;
          usedFee = (0, stargate_1.calculateFee)(Math.round(gasEstimation * multiplier), this.gasPrice);
        } else {
          usedFee = fee;
        }
        const txRaw = await this.sign(signerAddress, messages, usedFee, memo, void 0, timeoutHeight);
        const txBytes = tx_3.TxRaw.encode(txRaw).finish();
        return this.broadcastTx(txBytes, this.broadcastTimeoutMs, this.broadcastPollIntervalMs);
      }
      /**
       * Creates a transaction with the given messages, fee, memo and timeout height. Then signs and broadcasts the transaction.
       *
       * This method is useful if you want to send a transaction in broadcast,
       * without waiting for it to be placed inside a block, because for example
       * I would like to receive the hash to later track the transaction with another tool.
       *
       * @param signerAddress The address that will sign transactions using this instance. The signer must be able to sign with this address.
       * @param messages
       * @param fee
       * @param memo
       * @param timeoutHeight (optional) timeout height to prevent the tx from being committed past a certain height
       *
       * @returns Returns the hash of the transaction
       */
      async signAndBroadcastSync(signerAddress, messages, fee, memo = "", timeoutHeight) {
        let usedFee;
        if (fee == "auto" || typeof fee === "number") {
          (0, utils_1.assertDefined)(this.gasPrice, "Gas price must be set in the client options when auto gas is used.");
          const gasEstimation = await this.simulate(signerAddress, messages, memo);
          const multiplier = typeof fee === "number" ? fee : this.defaultGasMultiplier;
          usedFee = (0, stargate_1.calculateFee)(Math.round(gasEstimation * multiplier), this.gasPrice);
        } else {
          usedFee = fee;
        }
        const txRaw = await this.sign(signerAddress, messages, usedFee, memo, void 0, timeoutHeight);
        const txBytes = tx_3.TxRaw.encode(txRaw).finish();
        return this.broadcastTxSync(txBytes);
      }
      async sign(signerAddress, messages, fee, memo, explicitSignerData, timeoutHeight) {
        let signerData;
        if (explicitSignerData) {
          signerData = explicitSignerData;
        } else {
          const { accountNumber, sequence } = await this.getSequence(signerAddress);
          const chainId = await this.getChainId();
          signerData = {
            accountNumber,
            sequence,
            chainId
          };
        }
        return (0, proto_signing_1.isOfflineDirectSigner)(this.signer) ? this.signDirect(signerAddress, messages, fee, memo, signerData, timeoutHeight) : this.signAmino(signerAddress, messages, fee, memo, signerData, timeoutHeight);
      }
      async signAmino(signerAddress, messages, fee, memo, { accountNumber, sequence, chainId }, timeoutHeight) {
        (0, utils_1.assert)(!(0, proto_signing_1.isOfflineDirectSigner)(this.signer));
        const accountFromSigner = (await this.signer.getAccounts()).find((account) => account.address === signerAddress);
        if (!accountFromSigner) {
          throw new Error("Failed to retrieve account from signer");
        }
        const pubkey = (0, proto_signing_1.encodePubkey)((0, amino_1.encodeSecp256k1Pubkey)(accountFromSigner.pubkey));
        const signMode = signing_1.SignMode.SIGN_MODE_LEGACY_AMINO_JSON;
        const msgs = messages.map((msg) => this.aminoTypes.toAmino(msg));
        const signDoc = (0, amino_1.makeSignDoc)(msgs, fee, chainId, memo, accountNumber, sequence, timeoutHeight);
        const { signature, signed } = await this.signer.signAmino(signerAddress, signDoc);
        const signedTxBody = {
          typeUrl: "/cosmos.tx.v1beta1.TxBody",
          value: {
            messages: signed.msgs.map((msg) => this.aminoTypes.fromAmino(msg)),
            memo: signed.memo,
            timeoutHeight
          }
        };
        const signedTxBodyBytes = this.registry.encode(signedTxBody);
        const signedGasLimit = math_1.Int53.fromString(signed.fee.gas).toNumber();
        const signedSequence = math_1.Int53.fromString(signed.sequence).toNumber();
        const signedAuthInfoBytes = (0, proto_signing_1.makeAuthInfoBytes)([{ pubkey, sequence: signedSequence }], signed.fee.amount, signedGasLimit, signed.fee.granter, signed.fee.payer, signMode);
        return tx_3.TxRaw.fromPartial({
          bodyBytes: signedTxBodyBytes,
          authInfoBytes: signedAuthInfoBytes,
          signatures: [(0, encoding_1.fromBase64)(signature.signature)]
        });
      }
      async signDirect(signerAddress, messages, fee, memo, { accountNumber, sequence, chainId }, timeoutHeight) {
        (0, utils_1.assert)((0, proto_signing_1.isOfflineDirectSigner)(this.signer));
        const accountFromSigner = (await this.signer.getAccounts()).find((account) => account.address === signerAddress);
        if (!accountFromSigner) {
          throw new Error("Failed to retrieve account from signer");
        }
        const pubkey = (0, proto_signing_1.encodePubkey)((0, amino_1.encodeSecp256k1Pubkey)(accountFromSigner.pubkey));
        const txBody = {
          typeUrl: "/cosmos.tx.v1beta1.TxBody",
          value: {
            messages,
            memo,
            timeoutHeight
          }
        };
        const txBodyBytes = this.registry.encode(txBody);
        const gasLimit = math_1.Int53.fromString(fee.gas).toNumber();
        const authInfoBytes = (0, proto_signing_1.makeAuthInfoBytes)([{ pubkey, sequence }], fee.amount, gasLimit, fee.granter, fee.payer);
        const signDoc = (0, proto_signing_1.makeSignDoc)(txBodyBytes, authInfoBytes, chainId, accountNumber);
        const { signature, signed } = await this.signer.signDirect(signerAddress, signDoc);
        return tx_3.TxRaw.fromPartial({
          bodyBytes: signed.bodyBytes,
          authInfoBytes: signed.authInfoBytes,
          signatures: [(0, encoding_1.fromBase64)(signature.signature)]
        });
      }
    };
    exports.SigningCosmWasmClient = SigningCosmWasmClient;
  }
});

// ../../node_modules/.pnpm/@cosmjs+cosmwasm-stargate@0.34.0/node_modules/@cosmjs/cosmwasm-stargate/build/index.js
var require_build12 = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+cosmwasm-stargate@0.34.0/node_modules/@cosmjs/cosmwasm-stargate/build/index.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SigningCosmWasmClient = exports.wasmTypes = exports.setupWasmExtension = exports.isMsgUpdateAdminEncodeObject = exports.isMsgStoreCodeEncodeObject = exports.isMsgMigrateEncodeObject = exports.isMsgInstantiateContractEncodeObject = exports.isMsgInstantiateContract2EncodeObject = exports.isMsgExecuteEncodeObject = exports.isMsgClearAdminEncodeObject = exports.createWasmAminoConverters = exports.instantiate2Address = exports._instantiate2AddressIntermediate = exports.toBinary = exports.fromBinary = exports.CosmWasmClient = void 0;
    var cosmwasmclient_1 = require_cosmwasmclient();
    Object.defineProperty(exports, "CosmWasmClient", { enumerable: true, get: function() {
      return cosmwasmclient_1.CosmWasmClient;
    } });
    var encoding_1 = require_encoding2();
    Object.defineProperty(exports, "fromBinary", { enumerable: true, get: function() {
      return encoding_1.fromBinary;
    } });
    Object.defineProperty(exports, "toBinary", { enumerable: true, get: function() {
      return encoding_1.toBinary;
    } });
    var instantiate2_1 = require_instantiate2();
    Object.defineProperty(exports, "_instantiate2AddressIntermediate", { enumerable: true, get: function() {
      return instantiate2_1._instantiate2AddressIntermediate;
    } });
    Object.defineProperty(exports, "instantiate2Address", { enumerable: true, get: function() {
      return instantiate2_1.instantiate2Address;
    } });
    var modules_1 = require_modules2();
    Object.defineProperty(exports, "createWasmAminoConverters", { enumerable: true, get: function() {
      return modules_1.createWasmAminoConverters;
    } });
    Object.defineProperty(exports, "isMsgClearAdminEncodeObject", { enumerable: true, get: function() {
      return modules_1.isMsgClearAdminEncodeObject;
    } });
    Object.defineProperty(exports, "isMsgExecuteEncodeObject", { enumerable: true, get: function() {
      return modules_1.isMsgExecuteEncodeObject;
    } });
    Object.defineProperty(exports, "isMsgInstantiateContract2EncodeObject", { enumerable: true, get: function() {
      return modules_1.isMsgInstantiateContract2EncodeObject;
    } });
    Object.defineProperty(exports, "isMsgInstantiateContractEncodeObject", { enumerable: true, get: function() {
      return modules_1.isMsgInstantiateContractEncodeObject;
    } });
    Object.defineProperty(exports, "isMsgMigrateEncodeObject", { enumerable: true, get: function() {
      return modules_1.isMsgMigrateEncodeObject;
    } });
    Object.defineProperty(exports, "isMsgStoreCodeEncodeObject", { enumerable: true, get: function() {
      return modules_1.isMsgStoreCodeEncodeObject;
    } });
    Object.defineProperty(exports, "isMsgUpdateAdminEncodeObject", { enumerable: true, get: function() {
      return modules_1.isMsgUpdateAdminEncodeObject;
    } });
    Object.defineProperty(exports, "setupWasmExtension", { enumerable: true, get: function() {
      return modules_1.setupWasmExtension;
    } });
    Object.defineProperty(exports, "wasmTypes", { enumerable: true, get: function() {
      return modules_1.wasmTypes;
    } });
    var signingcosmwasmclient_1 = require_signingcosmwasmclient();
    Object.defineProperty(exports, "SigningCosmWasmClient", { enumerable: true, get: function() {
      return signingcosmwasmclient_1.SigningCosmWasmClient;
    } });
  }
});
export default require_build12();
/*! Bundled license information:

@noble/curves/utils.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/abstract/modular.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/abstract/curve.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/abstract/weierstrass.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/_shortw_utils.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/secp256k1.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)
*/
//# sourceMappingURL=@cosmjs_cosmwasm-stargate.js.map
