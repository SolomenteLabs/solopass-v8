import {
  require_elliptic,
  require_minimal
} from "./chunk-3MQ3WXIC.js";
import {
  require_abci,
  require_auth,
  require_browser,
  require_channel,
  require_gov,
  require_keys,
  require_keys2,
  require_keys3,
  require_libsodium_wrappers,
  require_pagination,
  require_query,
  require_query10,
  require_query11,
  require_query12,
  require_query13,
  require_query2,
  require_query3,
  require_query4,
  require_query5,
  require_query6,
  require_query7,
  require_query8,
  require_query9,
  require_ripemd160,
  require_service,
  require_sha3,
  require_tendermint,
  require_tx as require_tx2,
  require_tx10 as require_tx11,
  require_tx11 as require_tx12,
  require_tx12 as require_tx13,
  require_tx13 as require_tx14,
  require_tx2 as require_tx3,
  require_tx3 as require_tx4,
  require_tx4 as require_tx5,
  require_tx5 as require_tx6,
  require_tx6 as require_tx7,
  require_tx7 as require_tx8,
  require_tx8 as require_tx9,
  require_tx9 as require_tx10,
  require_vesting,
  require_xstream
} from "./chunk-P5FOV5JM.js";
import {
  require_any,
  require_coin,
  require_multisig,
  require_signing,
  require_tx
} from "./chunk-VL4JX4WA.js";
import {
  require_bech32,
  require_bn,
  require_crypto,
  require_pbkdf2,
  require_sha256,
  require_sha512
} from "./chunk-2OGY5FFR.js";
import {
  require_base64_js
} from "./chunk-N6KZBFW2.js";
import {
  __commonJS
} from "./chunk-JE6AHIQZ.js";

// ../../node_modules/.pnpm/@cosmjs+math@0.32.4/node_modules/@cosmjs/math/build/decimal.js
var require_decimal = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+math@0.32.4/node_modules/@cosmjs/math/build/decimal.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Decimal = void 0;
    var bn_js_1 = __importDefault(require_bn());
    var maxFractionalDigits = 100;
    var Decimal = class _Decimal {
      static fromUserInput(input, fractionalDigits) {
        _Decimal.verifyFractionalDigits(fractionalDigits);
        const badCharacter = input.match(/[^0-9.]/);
        if (badCharacter) {
          throw new Error(`Invalid character at position ${badCharacter.index + 1}`);
        }
        let whole;
        let fractional;
        if (input === "") {
          whole = "0";
          fractional = "";
        } else if (input.search(/\./) === -1) {
          whole = input;
          fractional = "";
        } else {
          const parts = input.split(".");
          switch (parts.length) {
            case 0:
            case 1:
              throw new Error("Fewer than two elements in split result. This must not happen here.");
            case 2:
              if (!parts[1])
                throw new Error("Fractional part missing");
              whole = parts[0];
              fractional = parts[1].replace(/0+$/, "");
              break;
            default:
              throw new Error("More than one separator found");
          }
        }
        if (fractional.length > fractionalDigits) {
          throw new Error("Got more fractional digits than supported");
        }
        const quantity = `${whole}${fractional.padEnd(fractionalDigits, "0")}`;
        return new _Decimal(quantity, fractionalDigits);
      }
      static fromAtomics(atomics, fractionalDigits) {
        _Decimal.verifyFractionalDigits(fractionalDigits);
        return new _Decimal(atomics, fractionalDigits);
      }
      /**
       * Creates a Decimal with value 0.0 and the given number of fractial digits.
       *
       * Fractional digits are not relevant for the value but needed to be able
       * to perform arithmetic operations with other decimals.
       */
      static zero(fractionalDigits) {
        _Decimal.verifyFractionalDigits(fractionalDigits);
        return new _Decimal("0", fractionalDigits);
      }
      /**
       * Creates a Decimal with value 1.0 and the given number of fractial digits.
       *
       * Fractional digits are not relevant for the value but needed to be able
       * to perform arithmetic operations with other decimals.
       */
      static one(fractionalDigits) {
        _Decimal.verifyFractionalDigits(fractionalDigits);
        return new _Decimal("1" + "0".repeat(fractionalDigits), fractionalDigits);
      }
      static verifyFractionalDigits(fractionalDigits) {
        if (!Number.isInteger(fractionalDigits))
          throw new Error("Fractional digits is not an integer");
        if (fractionalDigits < 0)
          throw new Error("Fractional digits must not be negative");
        if (fractionalDigits > maxFractionalDigits) {
          throw new Error(`Fractional digits must not exceed ${maxFractionalDigits}`);
        }
      }
      static compare(a, b) {
        if (a.fractionalDigits !== b.fractionalDigits)
          throw new Error("Fractional digits do not match");
        return a.data.atomics.cmp(new bn_js_1.default(b.atomics));
      }
      get atomics() {
        return this.data.atomics.toString();
      }
      get fractionalDigits() {
        return this.data.fractionalDigits;
      }
      constructor(atomics, fractionalDigits) {
        if (!atomics.match(/^[0-9]+$/)) {
          throw new Error("Invalid string format. Only non-negative integers in decimal representation supported.");
        }
        this.data = {
          atomics: new bn_js_1.default(atomics),
          fractionalDigits
        };
      }
      /** Creates a new instance with the same value */
      clone() {
        return new _Decimal(this.atomics, this.fractionalDigits);
      }
      /** Returns the greatest decimal <= this which has no fractional part (rounding down) */
      floor() {
        const factor = new bn_js_1.default(10).pow(new bn_js_1.default(this.data.fractionalDigits));
        const whole = this.data.atomics.div(factor);
        const fractional = this.data.atomics.mod(factor);
        if (fractional.isZero()) {
          return this.clone();
        } else {
          return _Decimal.fromAtomics(whole.mul(factor).toString(), this.fractionalDigits);
        }
      }
      /** Returns the smallest decimal >= this which has no fractional part (rounding up) */
      ceil() {
        const factor = new bn_js_1.default(10).pow(new bn_js_1.default(this.data.fractionalDigits));
        const whole = this.data.atomics.div(factor);
        const fractional = this.data.atomics.mod(factor);
        if (fractional.isZero()) {
          return this.clone();
        } else {
          return _Decimal.fromAtomics(whole.addn(1).mul(factor).toString(), this.fractionalDigits);
        }
      }
      toString() {
        const factor = new bn_js_1.default(10).pow(new bn_js_1.default(this.data.fractionalDigits));
        const whole = this.data.atomics.div(factor);
        const fractional = this.data.atomics.mod(factor);
        if (fractional.isZero()) {
          return whole.toString();
        } else {
          const fullFractionalPart = fractional.toString().padStart(this.data.fractionalDigits, "0");
          const trimmedFractionalPart = fullFractionalPart.replace(/0+$/, "");
          return `${whole.toString()}.${trimmedFractionalPart}`;
        }
      }
      /**
       * Returns an approximation as a float type. Only use this if no
       * exact calculation is required.
       */
      toFloatApproximation() {
        const out = Number(this.toString());
        if (Number.isNaN(out))
          throw new Error("Conversion to number failed");
        return out;
      }
      /**
       * a.plus(b) returns a+b.
       *
       * Both values need to have the same fractional digits.
       */
      plus(b) {
        if (this.fractionalDigits !== b.fractionalDigits)
          throw new Error("Fractional digits do not match");
        const sum = this.data.atomics.add(new bn_js_1.default(b.atomics));
        return new _Decimal(sum.toString(), this.fractionalDigits);
      }
      /**
       * a.minus(b) returns a-b.
       *
       * Both values need to have the same fractional digits.
       * The resulting difference needs to be non-negative.
       */
      minus(b) {
        if (this.fractionalDigits !== b.fractionalDigits)
          throw new Error("Fractional digits do not match");
        const difference = this.data.atomics.sub(new bn_js_1.default(b.atomics));
        if (difference.ltn(0))
          throw new Error("Difference must not be negative");
        return new _Decimal(difference.toString(), this.fractionalDigits);
      }
      /**
       * a.multiply(b) returns a*b.
       *
       * We only allow multiplication by unsigned integers to avoid rounding errors.
       */
      multiply(b) {
        const product = this.data.atomics.mul(new bn_js_1.default(b.toString()));
        return new _Decimal(product.toString(), this.fractionalDigits);
      }
      equals(b) {
        return _Decimal.compare(this, b) === 0;
      }
      isLessThan(b) {
        return _Decimal.compare(this, b) < 0;
      }
      isLessThanOrEqual(b) {
        return _Decimal.compare(this, b) <= 0;
      }
      isGreaterThan(b) {
        return _Decimal.compare(this, b) > 0;
      }
      isGreaterThanOrEqual(b) {
        return _Decimal.compare(this, b) >= 0;
      }
    };
    exports.Decimal = Decimal;
  }
});

// ../../node_modules/.pnpm/@cosmjs+math@0.32.4/node_modules/@cosmjs/math/build/integers.js
var require_integers = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+math@0.32.4/node_modules/@cosmjs/math/build/integers.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Uint64 = exports.Uint53 = exports.Int53 = exports.Uint32 = void 0;
    var bn_js_1 = __importDefault(require_bn());
    var uint64MaxValue = new bn_js_1.default("18446744073709551615", 10, "be");
    var Uint32 = class _Uint32 {
      /** @deprecated use Uint32.fromBytes */
      static fromBigEndianBytes(bytes) {
        return _Uint32.fromBytes(bytes);
      }
      /**
       * Creates a Uint32 from a fixed length byte array.
       *
       * @param bytes a list of exactly 4 bytes
       * @param endianess defaults to big endian
       */
      static fromBytes(bytes, endianess = "be") {
        if (bytes.length !== 4) {
          throw new Error("Invalid input length. Expected 4 bytes.");
        }
        for (let i = 0; i < bytes.length; ++i) {
          if (!Number.isInteger(bytes[i]) || bytes[i] > 255 || bytes[i] < 0) {
            throw new Error("Invalid value in byte. Found: " + bytes[i]);
          }
        }
        const beBytes = endianess === "be" ? bytes : Array.from(bytes).reverse();
        return new _Uint32(beBytes[0] * 2 ** 24 + beBytes[1] * 2 ** 16 + beBytes[2] * 2 ** 8 + beBytes[3]);
      }
      static fromString(str) {
        if (!str.match(/^[0-9]+$/)) {
          throw new Error("Invalid string format");
        }
        return new _Uint32(Number.parseInt(str, 10));
      }
      constructor(input) {
        if (Number.isNaN(input)) {
          throw new Error("Input is not a number");
        }
        if (!Number.isInteger(input)) {
          throw new Error("Input is not an integer");
        }
        if (input < 0 || input > 4294967295) {
          throw new Error("Input not in uint32 range: " + input.toString());
        }
        this.data = input;
      }
      toBytesBigEndian() {
        return new Uint8Array([
          Math.floor(this.data / 2 ** 24) & 255,
          Math.floor(this.data / 2 ** 16) & 255,
          Math.floor(this.data / 2 ** 8) & 255,
          Math.floor(this.data / 2 ** 0) & 255
        ]);
      }
      toBytesLittleEndian() {
        return new Uint8Array([
          Math.floor(this.data / 2 ** 0) & 255,
          Math.floor(this.data / 2 ** 8) & 255,
          Math.floor(this.data / 2 ** 16) & 255,
          Math.floor(this.data / 2 ** 24) & 255
        ]);
      }
      toNumber() {
        return this.data;
      }
      toBigInt() {
        return BigInt(this.toNumber());
      }
      toString() {
        return this.data.toString();
      }
    };
    exports.Uint32 = Uint32;
    var Int53 = class _Int53 {
      static fromString(str) {
        if (!str.match(/^-?[0-9]+$/)) {
          throw new Error("Invalid string format");
        }
        return new _Int53(Number.parseInt(str, 10));
      }
      constructor(input) {
        if (Number.isNaN(input)) {
          throw new Error("Input is not a number");
        }
        if (!Number.isInteger(input)) {
          throw new Error("Input is not an integer");
        }
        if (input < Number.MIN_SAFE_INTEGER || input > Number.MAX_SAFE_INTEGER) {
          throw new Error("Input not in int53 range: " + input.toString());
        }
        this.data = input;
      }
      toNumber() {
        return this.data;
      }
      toBigInt() {
        return BigInt(this.toNumber());
      }
      toString() {
        return this.data.toString();
      }
    };
    exports.Int53 = Int53;
    var Uint53 = class _Uint53 {
      static fromString(str) {
        const signed = Int53.fromString(str);
        return new _Uint53(signed.toNumber());
      }
      constructor(input) {
        const signed = new Int53(input);
        if (signed.toNumber() < 0) {
          throw new Error("Input is negative");
        }
        this.data = signed;
      }
      toNumber() {
        return this.data.toNumber();
      }
      toBigInt() {
        return BigInt(this.toNumber());
      }
      toString() {
        return this.data.toString();
      }
    };
    exports.Uint53 = Uint53;
    var Uint64 = class _Uint64 {
      /** @deprecated use Uint64.fromBytes */
      static fromBytesBigEndian(bytes) {
        return _Uint64.fromBytes(bytes);
      }
      /**
       * Creates a Uint64 from a fixed length byte array.
       *
       * @param bytes a list of exactly 8 bytes
       * @param endianess defaults to big endian
       */
      static fromBytes(bytes, endianess = "be") {
        if (bytes.length !== 8) {
          throw new Error("Invalid input length. Expected 8 bytes.");
        }
        for (let i = 0; i < bytes.length; ++i) {
          if (!Number.isInteger(bytes[i]) || bytes[i] > 255 || bytes[i] < 0) {
            throw new Error("Invalid value in byte. Found: " + bytes[i]);
          }
        }
        const beBytes = endianess === "be" ? Array.from(bytes) : Array.from(bytes).reverse();
        return new _Uint64(new bn_js_1.default(beBytes));
      }
      static fromString(str) {
        if (!str.match(/^[0-9]+$/)) {
          throw new Error("Invalid string format");
        }
        return new _Uint64(new bn_js_1.default(str, 10, "be"));
      }
      static fromNumber(input) {
        if (Number.isNaN(input)) {
          throw new Error("Input is not a number");
        }
        if (!Number.isInteger(input)) {
          throw new Error("Input is not an integer");
        }
        let bigint;
        try {
          bigint = new bn_js_1.default(input);
        } catch {
          throw new Error("Input is not a safe integer");
        }
        return new _Uint64(bigint);
      }
      constructor(data) {
        if (data.isNeg()) {
          throw new Error("Input is negative");
        }
        if (data.gt(uint64MaxValue)) {
          throw new Error("Input exceeds uint64 range");
        }
        this.data = data;
      }
      toBytesBigEndian() {
        return Uint8Array.from(this.data.toArray("be", 8));
      }
      toBytesLittleEndian() {
        return Uint8Array.from(this.data.toArray("le", 8));
      }
      toString() {
        return this.data.toString(10);
      }
      toBigInt() {
        return BigInt(this.toString());
      }
      toNumber() {
        return this.data.toNumber();
      }
    };
    exports.Uint64 = Uint64;
  }
});

// ../../node_modules/.pnpm/@cosmjs+math@0.32.4/node_modules/@cosmjs/math/build/index.js
var require_build = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+math@0.32.4/node_modules/@cosmjs/math/build/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Uint64 = exports.Uint53 = exports.Uint32 = exports.Int53 = exports.Decimal = void 0;
    var decimal_1 = require_decimal();
    Object.defineProperty(exports, "Decimal", { enumerable: true, get: function() {
      return decimal_1.Decimal;
    } });
    var integers_1 = require_integers();
    Object.defineProperty(exports, "Int53", { enumerable: true, get: function() {
      return integers_1.Int53;
    } });
    Object.defineProperty(exports, "Uint32", { enumerable: true, get: function() {
      return integers_1.Uint32;
    } });
    Object.defineProperty(exports, "Uint53", { enumerable: true, get: function() {
      return integers_1.Uint53;
    } });
    Object.defineProperty(exports, "Uint64", { enumerable: true, get: function() {
      return integers_1.Uint64;
    } });
  }
});

// ../../node_modules/.pnpm/@cosmjs+proto-signing@0.32.4/node_modules/@cosmjs/proto-signing/build/decode.js
var require_decode = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+proto-signing@0.32.4/node_modules/@cosmjs/proto-signing/build/decode.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.decodeTxRaw = void 0;
    var tx_1 = require_tx();
    function decodeTxRaw(tx) {
      const txRaw = tx_1.TxRaw.decode(tx);
      return {
        authInfo: tx_1.AuthInfo.decode(txRaw.authInfoBytes),
        body: tx_1.TxBody.decode(txRaw.bodyBytes),
        signatures: txRaw.signatures
      };
    }
    exports.decodeTxRaw = decodeTxRaw;
  }
});

// ../../node_modules/.pnpm/@cosmjs+encoding@0.32.4/node_modules/@cosmjs/encoding/build/ascii.js
var require_ascii = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+encoding@0.32.4/node_modules/@cosmjs/encoding/build/ascii.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.fromAscii = exports.toAscii = void 0;
    function toAscii(input) {
      const toNums = (str) => str.split("").map((x) => {
        const charCode = x.charCodeAt(0);
        if (charCode < 32 || charCode > 126) {
          throw new Error("Cannot encode character that is out of printable ASCII range: " + charCode);
        }
        return charCode;
      });
      return Uint8Array.from(toNums(input));
    }
    exports.toAscii = toAscii;
    function fromAscii(data) {
      const fromNums = (listOfNumbers) => listOfNumbers.map((x) => {
        if (x < 32 || x > 126) {
          throw new Error("Cannot decode character that is out of printable ASCII range: " + x);
        }
        return String.fromCharCode(x);
      });
      return fromNums(Array.from(data)).join("");
    }
    exports.fromAscii = fromAscii;
  }
});

// ../../node_modules/.pnpm/@cosmjs+encoding@0.32.4/node_modules/@cosmjs/encoding/build/base64.js
var require_base64 = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+encoding@0.32.4/node_modules/@cosmjs/encoding/build/base64.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.fromBase64 = exports.toBase64 = void 0;
    var base64js = __importStar(require_base64_js());
    function toBase64(data) {
      return base64js.fromByteArray(data);
    }
    exports.toBase64 = toBase64;
    function fromBase64(base64String) {
      if (!base64String.match(/^[a-zA-Z0-9+/]*={0,2}$/)) {
        throw new Error("Invalid base64 string format");
      }
      return base64js.toByteArray(base64String);
    }
    exports.fromBase64 = fromBase64;
  }
});

// ../../node_modules/.pnpm/@cosmjs+encoding@0.32.4/node_modules/@cosmjs/encoding/build/bech32.js
var require_bech322 = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+encoding@0.32.4/node_modules/@cosmjs/encoding/build/bech32.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.normalizeBech32 = exports.fromBech32 = exports.toBech32 = void 0;
    var bech32 = __importStar(require_bech32());
    function toBech32(prefix, data, limit) {
      const address = bech32.encode(prefix, bech32.toWords(data), limit);
      return address;
    }
    exports.toBech32 = toBech32;
    function fromBech32(address, limit = Infinity) {
      const decodedAddress = bech32.decode(address, limit);
      return {
        prefix: decodedAddress.prefix,
        data: new Uint8Array(bech32.fromWords(decodedAddress.words))
      };
    }
    exports.fromBech32 = fromBech32;
    function normalizeBech32(address) {
      const { prefix, data } = fromBech32(address);
      return toBech32(prefix, data);
    }
    exports.normalizeBech32 = normalizeBech32;
  }
});

// ../../node_modules/.pnpm/@cosmjs+encoding@0.32.4/node_modules/@cosmjs/encoding/build/hex.js
var require_hex = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+encoding@0.32.4/node_modules/@cosmjs/encoding/build/hex.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.fromHex = exports.toHex = void 0;
    function toHex(data) {
      let out = "";
      for (const byte of data) {
        out += ("0" + byte.toString(16)).slice(-2);
      }
      return out;
    }
    exports.toHex = toHex;
    function fromHex(hexstring) {
      if (hexstring.length % 2 !== 0) {
        throw new Error("hex string length must be a multiple of 2");
      }
      const out = new Uint8Array(hexstring.length / 2);
      for (let i = 0; i < out.length; i++) {
        const j = 2 * i;
        const hexByteAsString = hexstring.slice(j, j + 2);
        if (!hexByteAsString.match(/[0-9a-f]{2}/i)) {
          throw new Error("hex string contains invalid characters");
        }
        out[i] = parseInt(hexByteAsString, 16);
      }
      return out;
    }
    exports.fromHex = fromHex;
  }
});

// ../../node_modules/.pnpm/@cosmjs+encoding@0.32.4/node_modules/@cosmjs/encoding/build/rfc3339.js
var require_rfc3339 = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+encoding@0.32.4/node_modules/@cosmjs/encoding/build/rfc3339.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.toRfc3339 = exports.fromRfc3339 = void 0;
    var rfc3339Matcher = /^(\d{4})-(\d{2})-(\d{2})[T ](\d{2}):(\d{2}):(\d{2})(\.\d{1,9})?((?:[+-]\d{2}:\d{2})|Z)$/;
    function padded(integer, length = 2) {
      return integer.toString().padStart(length, "0");
    }
    function fromRfc3339(str) {
      const matches = rfc3339Matcher.exec(str);
      if (!matches) {
        throw new Error("Date string is not in RFC3339 format");
      }
      const year = +matches[1];
      const month = +matches[2];
      const day = +matches[3];
      const hour = +matches[4];
      const minute = +matches[5];
      const second = +matches[6];
      const milliSeconds = matches[7] ? Math.floor(+matches[7] * 1e3) : 0;
      let tzOffsetSign;
      let tzOffsetHours;
      let tzOffsetMinutes;
      if (matches[8] === "Z") {
        tzOffsetSign = 1;
        tzOffsetHours = 0;
        tzOffsetMinutes = 0;
      } else {
        tzOffsetSign = matches[8].substring(0, 1) === "-" ? -1 : 1;
        tzOffsetHours = +matches[8].substring(1, 3);
        tzOffsetMinutes = +matches[8].substring(4, 6);
      }
      const tzOffset = tzOffsetSign * (tzOffsetHours * 60 + tzOffsetMinutes) * 60;
      const date = /* @__PURE__ */ new Date();
      date.setUTCFullYear(year, month - 1, day);
      date.setUTCHours(hour, minute, second, milliSeconds);
      return new Date(date.getTime() - tzOffset * 1e3);
    }
    exports.fromRfc3339 = fromRfc3339;
    function toRfc3339(date) {
      const year = date.getUTCFullYear();
      const month = padded(date.getUTCMonth() + 1);
      const day = padded(date.getUTCDate());
      const hour = padded(date.getUTCHours());
      const minute = padded(date.getUTCMinutes());
      const second = padded(date.getUTCSeconds());
      const ms = padded(date.getUTCMilliseconds(), 3);
      return `${year}-${month}-${day}T${hour}:${minute}:${second}.${ms}Z`;
    }
    exports.toRfc3339 = toRfc3339;
  }
});

// ../../node_modules/.pnpm/@cosmjs+encoding@0.32.4/node_modules/@cosmjs/encoding/build/utf8.js
var require_utf8 = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+encoding@0.32.4/node_modules/@cosmjs/encoding/build/utf8.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.fromUtf8 = exports.toUtf8 = void 0;
    function toUtf8(str) {
      return new TextEncoder().encode(str);
    }
    exports.toUtf8 = toUtf8;
    function fromUtf8(data, lossy = false) {
      const fatal = !lossy;
      return new TextDecoder("utf-8", { fatal }).decode(data);
    }
    exports.fromUtf8 = fromUtf8;
  }
});

// ../../node_modules/.pnpm/@cosmjs+encoding@0.32.4/node_modules/@cosmjs/encoding/build/index.js
var require_build2 = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+encoding@0.32.4/node_modules/@cosmjs/encoding/build/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.toUtf8 = exports.fromUtf8 = exports.toRfc3339 = exports.fromRfc3339 = exports.toHex = exports.fromHex = exports.toBech32 = exports.normalizeBech32 = exports.fromBech32 = exports.toBase64 = exports.fromBase64 = exports.toAscii = exports.fromAscii = void 0;
    var ascii_1 = require_ascii();
    Object.defineProperty(exports, "fromAscii", { enumerable: true, get: function() {
      return ascii_1.fromAscii;
    } });
    Object.defineProperty(exports, "toAscii", { enumerable: true, get: function() {
      return ascii_1.toAscii;
    } });
    var base64_1 = require_base64();
    Object.defineProperty(exports, "fromBase64", { enumerable: true, get: function() {
      return base64_1.fromBase64;
    } });
    Object.defineProperty(exports, "toBase64", { enumerable: true, get: function() {
      return base64_1.toBase64;
    } });
    var bech32_1 = require_bech322();
    Object.defineProperty(exports, "fromBech32", { enumerable: true, get: function() {
      return bech32_1.fromBech32;
    } });
    Object.defineProperty(exports, "normalizeBech32", { enumerable: true, get: function() {
      return bech32_1.normalizeBech32;
    } });
    Object.defineProperty(exports, "toBech32", { enumerable: true, get: function() {
      return bech32_1.toBech32;
    } });
    var hex_1 = require_hex();
    Object.defineProperty(exports, "fromHex", { enumerable: true, get: function() {
      return hex_1.fromHex;
    } });
    Object.defineProperty(exports, "toHex", { enumerable: true, get: function() {
      return hex_1.toHex;
    } });
    var rfc3339_1 = require_rfc3339();
    Object.defineProperty(exports, "fromRfc3339", { enumerable: true, get: function() {
      return rfc3339_1.fromRfc3339;
    } });
    Object.defineProperty(exports, "toRfc3339", { enumerable: true, get: function() {
      return rfc3339_1.toRfc3339;
    } });
    var utf8_1 = require_utf8();
    Object.defineProperty(exports, "fromUtf8", { enumerable: true, get: function() {
      return utf8_1.fromUtf8;
    } });
    Object.defineProperty(exports, "toUtf8", { enumerable: true, get: function() {
      return utf8_1.toUtf8;
    } });
  }
});

// ../../node_modules/.pnpm/@cosmjs+utils@0.32.4/node_modules/@cosmjs/utils/build/arrays.js
var require_arrays = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+utils@0.32.4/node_modules/@cosmjs/utils/build/arrays.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.arrayContentStartsWith = exports.arrayContentEquals = void 0;
    function arrayContentEquals(a, b) {
      if (a.length !== b.length)
        return false;
      for (let i = 0; i < a.length; ++i) {
        if (a[i] !== b[i])
          return false;
      }
      return true;
    }
    exports.arrayContentEquals = arrayContentEquals;
    function arrayContentStartsWith(a, b) {
      if (a.length < b.length)
        return false;
      for (let i = 0; i < b.length; ++i) {
        if (a[i] !== b[i])
          return false;
      }
      return true;
    }
    exports.arrayContentStartsWith = arrayContentStartsWith;
  }
});

// ../../node_modules/.pnpm/@cosmjs+utils@0.32.4/node_modules/@cosmjs/utils/build/assert.js
var require_assert = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+utils@0.32.4/node_modules/@cosmjs/utils/build/assert.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.assertDefinedAndNotNull = exports.assertDefined = exports.assert = void 0;
    function assert(condition, msg) {
      if (!condition) {
        throw new Error(msg || "condition is not truthy");
      }
    }
    exports.assert = assert;
    function assertDefined(value, msg) {
      if (value === void 0) {
        throw new Error(msg ?? "value is undefined");
      }
    }
    exports.assertDefined = assertDefined;
    function assertDefinedAndNotNull(value, msg) {
      if (value === void 0 || value === null) {
        throw new Error(msg ?? "value is undefined or null");
      }
    }
    exports.assertDefinedAndNotNull = assertDefinedAndNotNull;
  }
});

// ../../node_modules/.pnpm/@cosmjs+utils@0.32.4/node_modules/@cosmjs/utils/build/sleep.js
var require_sleep = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+utils@0.32.4/node_modules/@cosmjs/utils/build/sleep.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.sleep = void 0;
    async function sleep(ms) {
      return new Promise((resolve) => setTimeout(resolve, ms));
    }
    exports.sleep = sleep;
  }
});

// ../../node_modules/.pnpm/@cosmjs+utils@0.32.4/node_modules/@cosmjs/utils/build/typechecks.js
var require_typechecks = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+utils@0.32.4/node_modules/@cosmjs/utils/build/typechecks.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isDefined = exports.isUint8Array = exports.isNonNullObject = void 0;
    function isNonNullObject(data) {
      return typeof data === "object" && data !== null;
    }
    exports.isNonNullObject = isNonNullObject;
    function isUint8Array(data) {
      if (!isNonNullObject(data))
        return false;
      if (Object.prototype.toString.call(data) !== "[object Uint8Array]")
        return false;
      if (typeof Buffer !== "undefined" && typeof Buffer.isBuffer !== "undefined") {
        if (Buffer.isBuffer(data))
          return false;
      }
      return true;
    }
    exports.isUint8Array = isUint8Array;
    function isDefined(value) {
      return value !== void 0;
    }
    exports.isDefined = isDefined;
  }
});

// ../../node_modules/.pnpm/@cosmjs+utils@0.32.4/node_modules/@cosmjs/utils/build/index.js
var require_build3 = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+utils@0.32.4/node_modules/@cosmjs/utils/build/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isUint8Array = exports.isNonNullObject = exports.isDefined = exports.sleep = exports.assertDefinedAndNotNull = exports.assertDefined = exports.assert = exports.arrayContentStartsWith = exports.arrayContentEquals = void 0;
    var arrays_1 = require_arrays();
    Object.defineProperty(exports, "arrayContentEquals", { enumerable: true, get: function() {
      return arrays_1.arrayContentEquals;
    } });
    Object.defineProperty(exports, "arrayContentStartsWith", { enumerable: true, get: function() {
      return arrays_1.arrayContentStartsWith;
    } });
    var assert_1 = require_assert();
    Object.defineProperty(exports, "assert", { enumerable: true, get: function() {
      return assert_1.assert;
    } });
    Object.defineProperty(exports, "assertDefined", { enumerable: true, get: function() {
      return assert_1.assertDefined;
    } });
    Object.defineProperty(exports, "assertDefinedAndNotNull", { enumerable: true, get: function() {
      return assert_1.assertDefinedAndNotNull;
    } });
    var sleep_1 = require_sleep();
    Object.defineProperty(exports, "sleep", { enumerable: true, get: function() {
      return sleep_1.sleep;
    } });
    var typechecks_1 = require_typechecks();
    Object.defineProperty(exports, "isDefined", { enumerable: true, get: function() {
      return typechecks_1.isDefined;
    } });
    Object.defineProperty(exports, "isNonNullObject", { enumerable: true, get: function() {
      return typechecks_1.isNonNullObject;
    } });
    Object.defineProperty(exports, "isUint8Array", { enumerable: true, get: function() {
      return typechecks_1.isUint8Array;
    } });
  }
});

// ../../node_modules/.pnpm/@cosmjs+crypto@0.32.4/node_modules/@cosmjs/crypto/build/pbkdf2.js
var require_pbkdf22 = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+crypto@0.32.4/node_modules/@cosmjs/crypto/build/pbkdf2.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.pbkdf2Sha512 = exports.pbkdf2Sha512Noble = exports.pbkdf2Sha512NodeCrypto = exports.pbkdf2Sha512Subtle = exports.getSubtle = exports.getNodeCrypto = void 0;
    var utils_1 = require_build3();
    var pbkdf2_1 = require_pbkdf2();
    var sha512_1 = require_sha512();
    async function getNodeCrypto() {
      try {
        const nodeCrypto = await Promise.resolve().then(() => __importStar(require_crypto()));
        if (typeof nodeCrypto === "object" && Object.keys(nodeCrypto).length <= 1) {
          return void 0;
        }
        return nodeCrypto;
      } catch {
        return void 0;
      }
    }
    exports.getNodeCrypto = getNodeCrypto;
    async function getSubtle() {
      var _a, _b, _c;
      let subtle = (_a = globalThis == null ? void 0 : globalThis.crypto) == null ? void 0 : _a.subtle;
      if (!subtle)
        subtle = (_c = (_b = globalThis == null ? void 0 : globalThis.crypto) == null ? void 0 : _b.webcrypto) == null ? void 0 : _c.subtle;
      return subtle;
    }
    exports.getSubtle = getSubtle;
    async function pbkdf2Sha512Subtle(subtle, secret, salt, iterations, keylen) {
      (0, utils_1.assert)(subtle, "Argument subtle is falsy");
      (0, utils_1.assert)(typeof subtle === "object", "Argument subtle is not of type object");
      (0, utils_1.assert)(typeof subtle.importKey === "function", "subtle.importKey is not a function");
      (0, utils_1.assert)(typeof subtle.deriveBits === "function", "subtle.deriveBits is not a function");
      return subtle.importKey("raw", secret, { name: "PBKDF2" }, false, ["deriveBits"]).then((key) => subtle.deriveBits({
        name: "PBKDF2",
        salt,
        iterations,
        hash: { name: "SHA-512" }
      }, key, keylen * 8).then((buffer) => new Uint8Array(buffer)));
    }
    exports.pbkdf2Sha512Subtle = pbkdf2Sha512Subtle;
    async function pbkdf2Sha512NodeCrypto(nodeCrypto, secret, salt, iterations, keylen) {
      (0, utils_1.assert)(nodeCrypto, "Argument nodeCrypto is falsy");
      (0, utils_1.assert)(typeof nodeCrypto === "object", "Argument nodeCrypto is not of type object");
      (0, utils_1.assert)(typeof nodeCrypto.pbkdf2 === "function", "nodeCrypto.pbkdf2 is not a function");
      return new Promise((resolve, reject) => {
        nodeCrypto.pbkdf2(secret, salt, iterations, keylen, "sha512", (error, result) => {
          if (error) {
            reject(error);
          } else {
            resolve(Uint8Array.from(result));
          }
        });
      });
    }
    exports.pbkdf2Sha512NodeCrypto = pbkdf2Sha512NodeCrypto;
    async function pbkdf2Sha512Noble(secret, salt, iterations, keylen) {
      return (0, pbkdf2_1.pbkdf2Async)(sha512_1.sha512, secret, salt, { c: iterations, dkLen: keylen });
    }
    exports.pbkdf2Sha512Noble = pbkdf2Sha512Noble;
    async function pbkdf2Sha512(secret, salt, iterations, keylen) {
      const subtle = await getSubtle();
      if (subtle) {
        return pbkdf2Sha512Subtle(subtle, secret, salt, iterations, keylen);
      } else {
        const nodeCrypto = await getNodeCrypto();
        if (nodeCrypto) {
          return pbkdf2Sha512NodeCrypto(nodeCrypto, secret, salt, iterations, keylen);
        } else {
          return pbkdf2Sha512Noble(secret, salt, iterations, keylen);
        }
      }
    }
    exports.pbkdf2Sha512 = pbkdf2Sha512;
  }
});

// ../../node_modules/.pnpm/@cosmjs+crypto@0.32.4/node_modules/@cosmjs/crypto/build/utils.js
var require_utils = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+crypto@0.32.4/node_modules/@cosmjs/crypto/build/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.toRealUint8Array = void 0;
    function toRealUint8Array(data) {
      if (data instanceof Uint8Array)
        return data;
      else
        return Uint8Array.from(data);
    }
    exports.toRealUint8Array = toRealUint8Array;
  }
});

// ../../node_modules/.pnpm/@cosmjs+crypto@0.32.4/node_modules/@cosmjs/crypto/build/sha.js
var require_sha = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+crypto@0.32.4/node_modules/@cosmjs/crypto/build/sha.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.sha512 = exports.Sha512 = exports.sha256 = exports.Sha256 = void 0;
    var sha256_1 = require_sha256();
    var sha512_1 = require_sha512();
    var utils_1 = require_utils();
    var Sha256 = class {
      constructor(firstData) {
        this.blockSize = 512 / 8;
        this.impl = sha256_1.sha256.create();
        if (firstData) {
          this.update(firstData);
        }
      }
      update(data) {
        this.impl.update((0, utils_1.toRealUint8Array)(data));
        return this;
      }
      digest() {
        return this.impl.digest();
      }
    };
    exports.Sha256 = Sha256;
    function sha256(data) {
      return new Sha256(data).digest();
    }
    exports.sha256 = sha256;
    var Sha512 = class {
      constructor(firstData) {
        this.blockSize = 1024 / 8;
        this.impl = sha512_1.sha512.create();
        if (firstData) {
          this.update(firstData);
        }
      }
      update(data) {
        this.impl.update((0, utils_1.toRealUint8Array)(data));
        return this;
      }
      digest() {
        return this.impl.digest();
      }
    };
    exports.Sha512 = Sha512;
    function sha512(data) {
      return new Sha512(data).digest();
    }
    exports.sha512 = sha512;
  }
});

// ../../node_modules/.pnpm/@cosmjs+crypto@0.32.4/node_modules/@cosmjs/crypto/build/bip39.js
var require_bip39 = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+crypto@0.32.4/node_modules/@cosmjs/crypto/build/bip39.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Bip39 = exports.EnglishMnemonic = exports.mnemonicToEntropy = exports.entropyToMnemonic = void 0;
    var encoding_1 = require_build2();
    var pbkdf2_1 = require_pbkdf22();
    var sha_1 = require_sha();
    var wordlist = [
      "abandon",
      "ability",
      "able",
      "about",
      "above",
      "absent",
      "absorb",
      "abstract",
      "absurd",
      "abuse",
      "access",
      "accident",
      "account",
      "accuse",
      "achieve",
      "acid",
      "acoustic",
      "acquire",
      "across",
      "act",
      "action",
      "actor",
      "actress",
      "actual",
      "adapt",
      "add",
      "addict",
      "address",
      "adjust",
      "admit",
      "adult",
      "advance",
      "advice",
      "aerobic",
      "affair",
      "afford",
      "afraid",
      "again",
      "age",
      "agent",
      "agree",
      "ahead",
      "aim",
      "air",
      "airport",
      "aisle",
      "alarm",
      "album",
      "alcohol",
      "alert",
      "alien",
      "all",
      "alley",
      "allow",
      "almost",
      "alone",
      "alpha",
      "already",
      "also",
      "alter",
      "always",
      "amateur",
      "amazing",
      "among",
      "amount",
      "amused",
      "analyst",
      "anchor",
      "ancient",
      "anger",
      "angle",
      "angry",
      "animal",
      "ankle",
      "announce",
      "annual",
      "another",
      "answer",
      "antenna",
      "antique",
      "anxiety",
      "any",
      "apart",
      "apology",
      "appear",
      "apple",
      "approve",
      "april",
      "arch",
      "arctic",
      "area",
      "arena",
      "argue",
      "arm",
      "armed",
      "armor",
      "army",
      "around",
      "arrange",
      "arrest",
      "arrive",
      "arrow",
      "art",
      "artefact",
      "artist",
      "artwork",
      "ask",
      "aspect",
      "assault",
      "asset",
      "assist",
      "assume",
      "asthma",
      "athlete",
      "atom",
      "attack",
      "attend",
      "attitude",
      "attract",
      "auction",
      "audit",
      "august",
      "aunt",
      "author",
      "auto",
      "autumn",
      "average",
      "avocado",
      "avoid",
      "awake",
      "aware",
      "away",
      "awesome",
      "awful",
      "awkward",
      "axis",
      "baby",
      "bachelor",
      "bacon",
      "badge",
      "bag",
      "balance",
      "balcony",
      "ball",
      "bamboo",
      "banana",
      "banner",
      "bar",
      "barely",
      "bargain",
      "barrel",
      "base",
      "basic",
      "basket",
      "battle",
      "beach",
      "bean",
      "beauty",
      "because",
      "become",
      "beef",
      "before",
      "begin",
      "behave",
      "behind",
      "believe",
      "below",
      "belt",
      "bench",
      "benefit",
      "best",
      "betray",
      "better",
      "between",
      "beyond",
      "bicycle",
      "bid",
      "bike",
      "bind",
      "biology",
      "bird",
      "birth",
      "bitter",
      "black",
      "blade",
      "blame",
      "blanket",
      "blast",
      "bleak",
      "bless",
      "blind",
      "blood",
      "blossom",
      "blouse",
      "blue",
      "blur",
      "blush",
      "board",
      "boat",
      "body",
      "boil",
      "bomb",
      "bone",
      "bonus",
      "book",
      "boost",
      "border",
      "boring",
      "borrow",
      "boss",
      "bottom",
      "bounce",
      "box",
      "boy",
      "bracket",
      "brain",
      "brand",
      "brass",
      "brave",
      "bread",
      "breeze",
      "brick",
      "bridge",
      "brief",
      "bright",
      "bring",
      "brisk",
      "broccoli",
      "broken",
      "bronze",
      "broom",
      "brother",
      "brown",
      "brush",
      "bubble",
      "buddy",
      "budget",
      "buffalo",
      "build",
      "bulb",
      "bulk",
      "bullet",
      "bundle",
      "bunker",
      "burden",
      "burger",
      "burst",
      "bus",
      "business",
      "busy",
      "butter",
      "buyer",
      "buzz",
      "cabbage",
      "cabin",
      "cable",
      "cactus",
      "cage",
      "cake",
      "call",
      "calm",
      "camera",
      "camp",
      "can",
      "canal",
      "cancel",
      "candy",
      "cannon",
      "canoe",
      "canvas",
      "canyon",
      "capable",
      "capital",
      "captain",
      "car",
      "carbon",
      "card",
      "cargo",
      "carpet",
      "carry",
      "cart",
      "case",
      "cash",
      "casino",
      "castle",
      "casual",
      "cat",
      "catalog",
      "catch",
      "category",
      "cattle",
      "caught",
      "cause",
      "caution",
      "cave",
      "ceiling",
      "celery",
      "cement",
      "census",
      "century",
      "cereal",
      "certain",
      "chair",
      "chalk",
      "champion",
      "change",
      "chaos",
      "chapter",
      "charge",
      "chase",
      "chat",
      "cheap",
      "check",
      "cheese",
      "chef",
      "cherry",
      "chest",
      "chicken",
      "chief",
      "child",
      "chimney",
      "choice",
      "choose",
      "chronic",
      "chuckle",
      "chunk",
      "churn",
      "cigar",
      "cinnamon",
      "circle",
      "citizen",
      "city",
      "civil",
      "claim",
      "clap",
      "clarify",
      "claw",
      "clay",
      "clean",
      "clerk",
      "clever",
      "click",
      "client",
      "cliff",
      "climb",
      "clinic",
      "clip",
      "clock",
      "clog",
      "close",
      "cloth",
      "cloud",
      "clown",
      "club",
      "clump",
      "cluster",
      "clutch",
      "coach",
      "coast",
      "coconut",
      "code",
      "coffee",
      "coil",
      "coin",
      "collect",
      "color",
      "column",
      "combine",
      "come",
      "comfort",
      "comic",
      "common",
      "company",
      "concert",
      "conduct",
      "confirm",
      "congress",
      "connect",
      "consider",
      "control",
      "convince",
      "cook",
      "cool",
      "copper",
      "copy",
      "coral",
      "core",
      "corn",
      "correct",
      "cost",
      "cotton",
      "couch",
      "country",
      "couple",
      "course",
      "cousin",
      "cover",
      "coyote",
      "crack",
      "cradle",
      "craft",
      "cram",
      "crane",
      "crash",
      "crater",
      "crawl",
      "crazy",
      "cream",
      "credit",
      "creek",
      "crew",
      "cricket",
      "crime",
      "crisp",
      "critic",
      "crop",
      "cross",
      "crouch",
      "crowd",
      "crucial",
      "cruel",
      "cruise",
      "crumble",
      "crunch",
      "crush",
      "cry",
      "crystal",
      "cube",
      "culture",
      "cup",
      "cupboard",
      "curious",
      "current",
      "curtain",
      "curve",
      "cushion",
      "custom",
      "cute",
      "cycle",
      "dad",
      "damage",
      "damp",
      "dance",
      "danger",
      "daring",
      "dash",
      "daughter",
      "dawn",
      "day",
      "deal",
      "debate",
      "debris",
      "decade",
      "december",
      "decide",
      "decline",
      "decorate",
      "decrease",
      "deer",
      "defense",
      "define",
      "defy",
      "degree",
      "delay",
      "deliver",
      "demand",
      "demise",
      "denial",
      "dentist",
      "deny",
      "depart",
      "depend",
      "deposit",
      "depth",
      "deputy",
      "derive",
      "describe",
      "desert",
      "design",
      "desk",
      "despair",
      "destroy",
      "detail",
      "detect",
      "develop",
      "device",
      "devote",
      "diagram",
      "dial",
      "diamond",
      "diary",
      "dice",
      "diesel",
      "diet",
      "differ",
      "digital",
      "dignity",
      "dilemma",
      "dinner",
      "dinosaur",
      "direct",
      "dirt",
      "disagree",
      "discover",
      "disease",
      "dish",
      "dismiss",
      "disorder",
      "display",
      "distance",
      "divert",
      "divide",
      "divorce",
      "dizzy",
      "doctor",
      "document",
      "dog",
      "doll",
      "dolphin",
      "domain",
      "donate",
      "donkey",
      "donor",
      "door",
      "dose",
      "double",
      "dove",
      "draft",
      "dragon",
      "drama",
      "drastic",
      "draw",
      "dream",
      "dress",
      "drift",
      "drill",
      "drink",
      "drip",
      "drive",
      "drop",
      "drum",
      "dry",
      "duck",
      "dumb",
      "dune",
      "during",
      "dust",
      "dutch",
      "duty",
      "dwarf",
      "dynamic",
      "eager",
      "eagle",
      "early",
      "earn",
      "earth",
      "easily",
      "east",
      "easy",
      "echo",
      "ecology",
      "economy",
      "edge",
      "edit",
      "educate",
      "effort",
      "egg",
      "eight",
      "either",
      "elbow",
      "elder",
      "electric",
      "elegant",
      "element",
      "elephant",
      "elevator",
      "elite",
      "else",
      "embark",
      "embody",
      "embrace",
      "emerge",
      "emotion",
      "employ",
      "empower",
      "empty",
      "enable",
      "enact",
      "end",
      "endless",
      "endorse",
      "enemy",
      "energy",
      "enforce",
      "engage",
      "engine",
      "enhance",
      "enjoy",
      "enlist",
      "enough",
      "enrich",
      "enroll",
      "ensure",
      "enter",
      "entire",
      "entry",
      "envelope",
      "episode",
      "equal",
      "equip",
      "era",
      "erase",
      "erode",
      "erosion",
      "error",
      "erupt",
      "escape",
      "essay",
      "essence",
      "estate",
      "eternal",
      "ethics",
      "evidence",
      "evil",
      "evoke",
      "evolve",
      "exact",
      "example",
      "excess",
      "exchange",
      "excite",
      "exclude",
      "excuse",
      "execute",
      "exercise",
      "exhaust",
      "exhibit",
      "exile",
      "exist",
      "exit",
      "exotic",
      "expand",
      "expect",
      "expire",
      "explain",
      "expose",
      "express",
      "extend",
      "extra",
      "eye",
      "eyebrow",
      "fabric",
      "face",
      "faculty",
      "fade",
      "faint",
      "faith",
      "fall",
      "false",
      "fame",
      "family",
      "famous",
      "fan",
      "fancy",
      "fantasy",
      "farm",
      "fashion",
      "fat",
      "fatal",
      "father",
      "fatigue",
      "fault",
      "favorite",
      "feature",
      "february",
      "federal",
      "fee",
      "feed",
      "feel",
      "female",
      "fence",
      "festival",
      "fetch",
      "fever",
      "few",
      "fiber",
      "fiction",
      "field",
      "figure",
      "file",
      "film",
      "filter",
      "final",
      "find",
      "fine",
      "finger",
      "finish",
      "fire",
      "firm",
      "first",
      "fiscal",
      "fish",
      "fit",
      "fitness",
      "fix",
      "flag",
      "flame",
      "flash",
      "flat",
      "flavor",
      "flee",
      "flight",
      "flip",
      "float",
      "flock",
      "floor",
      "flower",
      "fluid",
      "flush",
      "fly",
      "foam",
      "focus",
      "fog",
      "foil",
      "fold",
      "follow",
      "food",
      "foot",
      "force",
      "forest",
      "forget",
      "fork",
      "fortune",
      "forum",
      "forward",
      "fossil",
      "foster",
      "found",
      "fox",
      "fragile",
      "frame",
      "frequent",
      "fresh",
      "friend",
      "fringe",
      "frog",
      "front",
      "frost",
      "frown",
      "frozen",
      "fruit",
      "fuel",
      "fun",
      "funny",
      "furnace",
      "fury",
      "future",
      "gadget",
      "gain",
      "galaxy",
      "gallery",
      "game",
      "gap",
      "garage",
      "garbage",
      "garden",
      "garlic",
      "garment",
      "gas",
      "gasp",
      "gate",
      "gather",
      "gauge",
      "gaze",
      "general",
      "genius",
      "genre",
      "gentle",
      "genuine",
      "gesture",
      "ghost",
      "giant",
      "gift",
      "giggle",
      "ginger",
      "giraffe",
      "girl",
      "give",
      "glad",
      "glance",
      "glare",
      "glass",
      "glide",
      "glimpse",
      "globe",
      "gloom",
      "glory",
      "glove",
      "glow",
      "glue",
      "goat",
      "goddess",
      "gold",
      "good",
      "goose",
      "gorilla",
      "gospel",
      "gossip",
      "govern",
      "gown",
      "grab",
      "grace",
      "grain",
      "grant",
      "grape",
      "grass",
      "gravity",
      "great",
      "green",
      "grid",
      "grief",
      "grit",
      "grocery",
      "group",
      "grow",
      "grunt",
      "guard",
      "guess",
      "guide",
      "guilt",
      "guitar",
      "gun",
      "gym",
      "habit",
      "hair",
      "half",
      "hammer",
      "hamster",
      "hand",
      "happy",
      "harbor",
      "hard",
      "harsh",
      "harvest",
      "hat",
      "have",
      "hawk",
      "hazard",
      "head",
      "health",
      "heart",
      "heavy",
      "hedgehog",
      "height",
      "hello",
      "helmet",
      "help",
      "hen",
      "hero",
      "hidden",
      "high",
      "hill",
      "hint",
      "hip",
      "hire",
      "history",
      "hobby",
      "hockey",
      "hold",
      "hole",
      "holiday",
      "hollow",
      "home",
      "honey",
      "hood",
      "hope",
      "horn",
      "horror",
      "horse",
      "hospital",
      "host",
      "hotel",
      "hour",
      "hover",
      "hub",
      "huge",
      "human",
      "humble",
      "humor",
      "hundred",
      "hungry",
      "hunt",
      "hurdle",
      "hurry",
      "hurt",
      "husband",
      "hybrid",
      "ice",
      "icon",
      "idea",
      "identify",
      "idle",
      "ignore",
      "ill",
      "illegal",
      "illness",
      "image",
      "imitate",
      "immense",
      "immune",
      "impact",
      "impose",
      "improve",
      "impulse",
      "inch",
      "include",
      "income",
      "increase",
      "index",
      "indicate",
      "indoor",
      "industry",
      "infant",
      "inflict",
      "inform",
      "inhale",
      "inherit",
      "initial",
      "inject",
      "injury",
      "inmate",
      "inner",
      "innocent",
      "input",
      "inquiry",
      "insane",
      "insect",
      "inside",
      "inspire",
      "install",
      "intact",
      "interest",
      "into",
      "invest",
      "invite",
      "involve",
      "iron",
      "island",
      "isolate",
      "issue",
      "item",
      "ivory",
      "jacket",
      "jaguar",
      "jar",
      "jazz",
      "jealous",
      "jeans",
      "jelly",
      "jewel",
      "job",
      "join",
      "joke",
      "journey",
      "joy",
      "judge",
      "juice",
      "jump",
      "jungle",
      "junior",
      "junk",
      "just",
      "kangaroo",
      "keen",
      "keep",
      "ketchup",
      "key",
      "kick",
      "kid",
      "kidney",
      "kind",
      "kingdom",
      "kiss",
      "kit",
      "kitchen",
      "kite",
      "kitten",
      "kiwi",
      "knee",
      "knife",
      "knock",
      "know",
      "lab",
      "label",
      "labor",
      "ladder",
      "lady",
      "lake",
      "lamp",
      "language",
      "laptop",
      "large",
      "later",
      "latin",
      "laugh",
      "laundry",
      "lava",
      "law",
      "lawn",
      "lawsuit",
      "layer",
      "lazy",
      "leader",
      "leaf",
      "learn",
      "leave",
      "lecture",
      "left",
      "leg",
      "legal",
      "legend",
      "leisure",
      "lemon",
      "lend",
      "length",
      "lens",
      "leopard",
      "lesson",
      "letter",
      "level",
      "liar",
      "liberty",
      "library",
      "license",
      "life",
      "lift",
      "light",
      "like",
      "limb",
      "limit",
      "link",
      "lion",
      "liquid",
      "list",
      "little",
      "live",
      "lizard",
      "load",
      "loan",
      "lobster",
      "local",
      "lock",
      "logic",
      "lonely",
      "long",
      "loop",
      "lottery",
      "loud",
      "lounge",
      "love",
      "loyal",
      "lucky",
      "luggage",
      "lumber",
      "lunar",
      "lunch",
      "luxury",
      "lyrics",
      "machine",
      "mad",
      "magic",
      "magnet",
      "maid",
      "mail",
      "main",
      "major",
      "make",
      "mammal",
      "man",
      "manage",
      "mandate",
      "mango",
      "mansion",
      "manual",
      "maple",
      "marble",
      "march",
      "margin",
      "marine",
      "market",
      "marriage",
      "mask",
      "mass",
      "master",
      "match",
      "material",
      "math",
      "matrix",
      "matter",
      "maximum",
      "maze",
      "meadow",
      "mean",
      "measure",
      "meat",
      "mechanic",
      "medal",
      "media",
      "melody",
      "melt",
      "member",
      "memory",
      "mention",
      "menu",
      "mercy",
      "merge",
      "merit",
      "merry",
      "mesh",
      "message",
      "metal",
      "method",
      "middle",
      "midnight",
      "milk",
      "million",
      "mimic",
      "mind",
      "minimum",
      "minor",
      "minute",
      "miracle",
      "mirror",
      "misery",
      "miss",
      "mistake",
      "mix",
      "mixed",
      "mixture",
      "mobile",
      "model",
      "modify",
      "mom",
      "moment",
      "monitor",
      "monkey",
      "monster",
      "month",
      "moon",
      "moral",
      "more",
      "morning",
      "mosquito",
      "mother",
      "motion",
      "motor",
      "mountain",
      "mouse",
      "move",
      "movie",
      "much",
      "muffin",
      "mule",
      "multiply",
      "muscle",
      "museum",
      "mushroom",
      "music",
      "must",
      "mutual",
      "myself",
      "mystery",
      "myth",
      "naive",
      "name",
      "napkin",
      "narrow",
      "nasty",
      "nation",
      "nature",
      "near",
      "neck",
      "need",
      "negative",
      "neglect",
      "neither",
      "nephew",
      "nerve",
      "nest",
      "net",
      "network",
      "neutral",
      "never",
      "news",
      "next",
      "nice",
      "night",
      "noble",
      "noise",
      "nominee",
      "noodle",
      "normal",
      "north",
      "nose",
      "notable",
      "note",
      "nothing",
      "notice",
      "novel",
      "now",
      "nuclear",
      "number",
      "nurse",
      "nut",
      "oak",
      "obey",
      "object",
      "oblige",
      "obscure",
      "observe",
      "obtain",
      "obvious",
      "occur",
      "ocean",
      "october",
      "odor",
      "off",
      "offer",
      "office",
      "often",
      "oil",
      "okay",
      "old",
      "olive",
      "olympic",
      "omit",
      "once",
      "one",
      "onion",
      "online",
      "only",
      "open",
      "opera",
      "opinion",
      "oppose",
      "option",
      "orange",
      "orbit",
      "orchard",
      "order",
      "ordinary",
      "organ",
      "orient",
      "original",
      "orphan",
      "ostrich",
      "other",
      "outdoor",
      "outer",
      "output",
      "outside",
      "oval",
      "oven",
      "over",
      "own",
      "owner",
      "oxygen",
      "oyster",
      "ozone",
      "pact",
      "paddle",
      "page",
      "pair",
      "palace",
      "palm",
      "panda",
      "panel",
      "panic",
      "panther",
      "paper",
      "parade",
      "parent",
      "park",
      "parrot",
      "party",
      "pass",
      "patch",
      "path",
      "patient",
      "patrol",
      "pattern",
      "pause",
      "pave",
      "payment",
      "peace",
      "peanut",
      "pear",
      "peasant",
      "pelican",
      "pen",
      "penalty",
      "pencil",
      "people",
      "pepper",
      "perfect",
      "permit",
      "person",
      "pet",
      "phone",
      "photo",
      "phrase",
      "physical",
      "piano",
      "picnic",
      "picture",
      "piece",
      "pig",
      "pigeon",
      "pill",
      "pilot",
      "pink",
      "pioneer",
      "pipe",
      "pistol",
      "pitch",
      "pizza",
      "place",
      "planet",
      "plastic",
      "plate",
      "play",
      "please",
      "pledge",
      "pluck",
      "plug",
      "plunge",
      "poem",
      "poet",
      "point",
      "polar",
      "pole",
      "police",
      "pond",
      "pony",
      "pool",
      "popular",
      "portion",
      "position",
      "possible",
      "post",
      "potato",
      "pottery",
      "poverty",
      "powder",
      "power",
      "practice",
      "praise",
      "predict",
      "prefer",
      "prepare",
      "present",
      "pretty",
      "prevent",
      "price",
      "pride",
      "primary",
      "print",
      "priority",
      "prison",
      "private",
      "prize",
      "problem",
      "process",
      "produce",
      "profit",
      "program",
      "project",
      "promote",
      "proof",
      "property",
      "prosper",
      "protect",
      "proud",
      "provide",
      "public",
      "pudding",
      "pull",
      "pulp",
      "pulse",
      "pumpkin",
      "punch",
      "pupil",
      "puppy",
      "purchase",
      "purity",
      "purpose",
      "purse",
      "push",
      "put",
      "puzzle",
      "pyramid",
      "quality",
      "quantum",
      "quarter",
      "question",
      "quick",
      "quit",
      "quiz",
      "quote",
      "rabbit",
      "raccoon",
      "race",
      "rack",
      "radar",
      "radio",
      "rail",
      "rain",
      "raise",
      "rally",
      "ramp",
      "ranch",
      "random",
      "range",
      "rapid",
      "rare",
      "rate",
      "rather",
      "raven",
      "raw",
      "razor",
      "ready",
      "real",
      "reason",
      "rebel",
      "rebuild",
      "recall",
      "receive",
      "recipe",
      "record",
      "recycle",
      "reduce",
      "reflect",
      "reform",
      "refuse",
      "region",
      "regret",
      "regular",
      "reject",
      "relax",
      "release",
      "relief",
      "rely",
      "remain",
      "remember",
      "remind",
      "remove",
      "render",
      "renew",
      "rent",
      "reopen",
      "repair",
      "repeat",
      "replace",
      "report",
      "require",
      "rescue",
      "resemble",
      "resist",
      "resource",
      "response",
      "result",
      "retire",
      "retreat",
      "return",
      "reunion",
      "reveal",
      "review",
      "reward",
      "rhythm",
      "rib",
      "ribbon",
      "rice",
      "rich",
      "ride",
      "ridge",
      "rifle",
      "right",
      "rigid",
      "ring",
      "riot",
      "ripple",
      "risk",
      "ritual",
      "rival",
      "river",
      "road",
      "roast",
      "robot",
      "robust",
      "rocket",
      "romance",
      "roof",
      "rookie",
      "room",
      "rose",
      "rotate",
      "rough",
      "round",
      "route",
      "royal",
      "rubber",
      "rude",
      "rug",
      "rule",
      "run",
      "runway",
      "rural",
      "sad",
      "saddle",
      "sadness",
      "safe",
      "sail",
      "salad",
      "salmon",
      "salon",
      "salt",
      "salute",
      "same",
      "sample",
      "sand",
      "satisfy",
      "satoshi",
      "sauce",
      "sausage",
      "save",
      "say",
      "scale",
      "scan",
      "scare",
      "scatter",
      "scene",
      "scheme",
      "school",
      "science",
      "scissors",
      "scorpion",
      "scout",
      "scrap",
      "screen",
      "script",
      "scrub",
      "sea",
      "search",
      "season",
      "seat",
      "second",
      "secret",
      "section",
      "security",
      "seed",
      "seek",
      "segment",
      "select",
      "sell",
      "seminar",
      "senior",
      "sense",
      "sentence",
      "series",
      "service",
      "session",
      "settle",
      "setup",
      "seven",
      "shadow",
      "shaft",
      "shallow",
      "share",
      "shed",
      "shell",
      "sheriff",
      "shield",
      "shift",
      "shine",
      "ship",
      "shiver",
      "shock",
      "shoe",
      "shoot",
      "shop",
      "short",
      "shoulder",
      "shove",
      "shrimp",
      "shrug",
      "shuffle",
      "shy",
      "sibling",
      "sick",
      "side",
      "siege",
      "sight",
      "sign",
      "silent",
      "silk",
      "silly",
      "silver",
      "similar",
      "simple",
      "since",
      "sing",
      "siren",
      "sister",
      "situate",
      "six",
      "size",
      "skate",
      "sketch",
      "ski",
      "skill",
      "skin",
      "skirt",
      "skull",
      "slab",
      "slam",
      "sleep",
      "slender",
      "slice",
      "slide",
      "slight",
      "slim",
      "slogan",
      "slot",
      "slow",
      "slush",
      "small",
      "smart",
      "smile",
      "smoke",
      "smooth",
      "snack",
      "snake",
      "snap",
      "sniff",
      "snow",
      "soap",
      "soccer",
      "social",
      "sock",
      "soda",
      "soft",
      "solar",
      "soldier",
      "solid",
      "solution",
      "solve",
      "someone",
      "song",
      "soon",
      "sorry",
      "sort",
      "soul",
      "sound",
      "soup",
      "source",
      "south",
      "space",
      "spare",
      "spatial",
      "spawn",
      "speak",
      "special",
      "speed",
      "spell",
      "spend",
      "sphere",
      "spice",
      "spider",
      "spike",
      "spin",
      "spirit",
      "split",
      "spoil",
      "sponsor",
      "spoon",
      "sport",
      "spot",
      "spray",
      "spread",
      "spring",
      "spy",
      "square",
      "squeeze",
      "squirrel",
      "stable",
      "stadium",
      "staff",
      "stage",
      "stairs",
      "stamp",
      "stand",
      "start",
      "state",
      "stay",
      "steak",
      "steel",
      "stem",
      "step",
      "stereo",
      "stick",
      "still",
      "sting",
      "stock",
      "stomach",
      "stone",
      "stool",
      "story",
      "stove",
      "strategy",
      "street",
      "strike",
      "strong",
      "struggle",
      "student",
      "stuff",
      "stumble",
      "style",
      "subject",
      "submit",
      "subway",
      "success",
      "such",
      "sudden",
      "suffer",
      "sugar",
      "suggest",
      "suit",
      "summer",
      "sun",
      "sunny",
      "sunset",
      "super",
      "supply",
      "supreme",
      "sure",
      "surface",
      "surge",
      "surprise",
      "surround",
      "survey",
      "suspect",
      "sustain",
      "swallow",
      "swamp",
      "swap",
      "swarm",
      "swear",
      "sweet",
      "swift",
      "swim",
      "swing",
      "switch",
      "sword",
      "symbol",
      "symptom",
      "syrup",
      "system",
      "table",
      "tackle",
      "tag",
      "tail",
      "talent",
      "talk",
      "tank",
      "tape",
      "target",
      "task",
      "taste",
      "tattoo",
      "taxi",
      "teach",
      "team",
      "tell",
      "ten",
      "tenant",
      "tennis",
      "tent",
      "term",
      "test",
      "text",
      "thank",
      "that",
      "theme",
      "then",
      "theory",
      "there",
      "they",
      "thing",
      "this",
      "thought",
      "three",
      "thrive",
      "throw",
      "thumb",
      "thunder",
      "ticket",
      "tide",
      "tiger",
      "tilt",
      "timber",
      "time",
      "tiny",
      "tip",
      "tired",
      "tissue",
      "title",
      "toast",
      "tobacco",
      "today",
      "toddler",
      "toe",
      "together",
      "toilet",
      "token",
      "tomato",
      "tomorrow",
      "tone",
      "tongue",
      "tonight",
      "tool",
      "tooth",
      "top",
      "topic",
      "topple",
      "torch",
      "tornado",
      "tortoise",
      "toss",
      "total",
      "tourist",
      "toward",
      "tower",
      "town",
      "toy",
      "track",
      "trade",
      "traffic",
      "tragic",
      "train",
      "transfer",
      "trap",
      "trash",
      "travel",
      "tray",
      "treat",
      "tree",
      "trend",
      "trial",
      "tribe",
      "trick",
      "trigger",
      "trim",
      "trip",
      "trophy",
      "trouble",
      "truck",
      "true",
      "truly",
      "trumpet",
      "trust",
      "truth",
      "try",
      "tube",
      "tuition",
      "tumble",
      "tuna",
      "tunnel",
      "turkey",
      "turn",
      "turtle",
      "twelve",
      "twenty",
      "twice",
      "twin",
      "twist",
      "two",
      "type",
      "typical",
      "ugly",
      "umbrella",
      "unable",
      "unaware",
      "uncle",
      "uncover",
      "under",
      "undo",
      "unfair",
      "unfold",
      "unhappy",
      "uniform",
      "unique",
      "unit",
      "universe",
      "unknown",
      "unlock",
      "until",
      "unusual",
      "unveil",
      "update",
      "upgrade",
      "uphold",
      "upon",
      "upper",
      "upset",
      "urban",
      "urge",
      "usage",
      "use",
      "used",
      "useful",
      "useless",
      "usual",
      "utility",
      "vacant",
      "vacuum",
      "vague",
      "valid",
      "valley",
      "valve",
      "van",
      "vanish",
      "vapor",
      "various",
      "vast",
      "vault",
      "vehicle",
      "velvet",
      "vendor",
      "venture",
      "venue",
      "verb",
      "verify",
      "version",
      "very",
      "vessel",
      "veteran",
      "viable",
      "vibrant",
      "vicious",
      "victory",
      "video",
      "view",
      "village",
      "vintage",
      "violin",
      "virtual",
      "virus",
      "visa",
      "visit",
      "visual",
      "vital",
      "vivid",
      "vocal",
      "voice",
      "void",
      "volcano",
      "volume",
      "vote",
      "voyage",
      "wage",
      "wagon",
      "wait",
      "walk",
      "wall",
      "walnut",
      "want",
      "warfare",
      "warm",
      "warrior",
      "wash",
      "wasp",
      "waste",
      "water",
      "wave",
      "way",
      "wealth",
      "weapon",
      "wear",
      "weasel",
      "weather",
      "web",
      "wedding",
      "weekend",
      "weird",
      "welcome",
      "west",
      "wet",
      "whale",
      "what",
      "wheat",
      "wheel",
      "when",
      "where",
      "whip",
      "whisper",
      "wide",
      "width",
      "wife",
      "wild",
      "will",
      "win",
      "window",
      "wine",
      "wing",
      "wink",
      "winner",
      "winter",
      "wire",
      "wisdom",
      "wise",
      "wish",
      "witness",
      "wolf",
      "woman",
      "wonder",
      "wood",
      "wool",
      "word",
      "work",
      "world",
      "worry",
      "worth",
      "wrap",
      "wreck",
      "wrestle",
      "wrist",
      "write",
      "wrong",
      "yard",
      "year",
      "yellow",
      "you",
      "young",
      "youth",
      "zebra",
      "zero",
      "zone",
      "zoo"
    ];
    function bytesToBitstring(bytes) {
      return Array.from(bytes).map((byte) => byte.toString(2).padStart(8, "0")).join("");
    }
    function deriveChecksumBits(entropy) {
      const entropyLengthBits = entropy.length * 8;
      const checksumLengthBits = entropyLengthBits / 32;
      const hash = (0, sha_1.sha256)(entropy);
      return bytesToBitstring(hash).slice(0, checksumLengthBits);
    }
    function bitstringToByte(bin) {
      return parseInt(bin, 2);
    }
    var allowedEntropyLengths = [16, 20, 24, 28, 32];
    var allowedWordLengths = [12, 15, 18, 21, 24];
    function entropyToMnemonic(entropy) {
      if (allowedEntropyLengths.indexOf(entropy.length) === -1) {
        throw new Error("invalid input length");
      }
      const entropyBits = bytesToBitstring(entropy);
      const checksumBits = deriveChecksumBits(entropy);
      const bits = entropyBits + checksumBits;
      const chunks = bits.match(/(.{11})/g);
      const words = chunks.map((binary) => {
        const index = bitstringToByte(binary);
        return wordlist[index];
      });
      return words.join(" ");
    }
    exports.entropyToMnemonic = entropyToMnemonic;
    var invalidNumberOfWorks = "Invalid number of words";
    var wordNotInWordlist = "Found word that is not in the wordlist";
    var invalidEntropy = "Invalid entropy";
    var invalidChecksum = "Invalid mnemonic checksum";
    function normalize(str) {
      return str.normalize("NFKD");
    }
    function mnemonicToEntropy(mnemonic) {
      const words = normalize(mnemonic).split(" ");
      if (!allowedWordLengths.includes(words.length)) {
        throw new Error(invalidNumberOfWorks);
      }
      const bits = words.map((word) => {
        const index = wordlist.indexOf(word);
        if (index === -1) {
          throw new Error(wordNotInWordlist);
        }
        return index.toString(2).padStart(11, "0");
      }).join("");
      const dividerIndex = Math.floor(bits.length / 33) * 32;
      const entropyBits = bits.slice(0, dividerIndex);
      const checksumBits = bits.slice(dividerIndex);
      const entropyBytes = entropyBits.match(/(.{1,8})/g).map(bitstringToByte);
      if (entropyBytes.length < 16 || entropyBytes.length > 32 || entropyBytes.length % 4 !== 0) {
        throw new Error(invalidEntropy);
      }
      const entropy = Uint8Array.from(entropyBytes);
      const newChecksum = deriveChecksumBits(entropy);
      if (newChecksum !== checksumBits) {
        throw new Error(invalidChecksum);
      }
      return entropy;
    }
    exports.mnemonicToEntropy = mnemonicToEntropy;
    var EnglishMnemonic = class _EnglishMnemonic {
      constructor(mnemonic) {
        if (!_EnglishMnemonic.mnemonicMatcher.test(mnemonic)) {
          throw new Error("Invalid mnemonic format");
        }
        const words = mnemonic.split(" ");
        const allowedWordsLengths = [12, 15, 18, 21, 24];
        if (allowedWordsLengths.indexOf(words.length) === -1) {
          throw new Error(`Invalid word count in mnemonic (allowed: ${allowedWordsLengths} got: ${words.length})`);
        }
        for (const word of words) {
          if (_EnglishMnemonic.wordlist.indexOf(word) === -1) {
            throw new Error("Mnemonic contains invalid word");
          }
        }
        mnemonicToEntropy(mnemonic);
        this.data = mnemonic;
      }
      toString() {
        return this.data;
      }
    };
    exports.EnglishMnemonic = EnglishMnemonic;
    EnglishMnemonic.wordlist = wordlist;
    EnglishMnemonic.mnemonicMatcher = /^[a-z]+( [a-z]+)*$/;
    var Bip39 = class {
      /**
       * Encodes raw entropy of length 16, 20, 24, 28 or 32 bytes as an English mnemonic between 12 and 24 words.
       *
       * | Entropy            | Words |
       * |--------------------|-------|
       * | 128 bit (16 bytes) |    12 |
       * | 160 bit (20 bytes) |    15 |
       * | 192 bit (24 bytes) |    18 |
       * | 224 bit (28 bytes) |    21 |
       * | 256 bit (32 bytes) |    24 |
       *
       *
       * @see https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki#generating-the-mnemonic
       * @param entropy The entropy to be encoded. This must be cryptographically secure.
       */
      static encode(entropy) {
        return new EnglishMnemonic(entropyToMnemonic(entropy));
      }
      static decode(mnemonic) {
        return mnemonicToEntropy(mnemonic.toString());
      }
      static async mnemonicToSeed(mnemonic, password) {
        const mnemonicBytes = (0, encoding_1.toUtf8)(normalize(mnemonic.toString()));
        const salt = "mnemonic" + (password ? normalize(password) : "");
        const saltBytes = (0, encoding_1.toUtf8)(salt);
        return (0, pbkdf2_1.pbkdf2Sha512)(mnemonicBytes, saltBytes, 2048, 64);
      }
    };
    exports.Bip39 = Bip39;
  }
});

// ../../node_modules/.pnpm/@cosmjs+crypto@0.32.4/node_modules/@cosmjs/crypto/build/hmac.js
var require_hmac = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+crypto@0.32.4/node_modules/@cosmjs/crypto/build/hmac.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Hmac = void 0;
    var Hmac = class {
      constructor(hashFunctionConstructor, originalKey) {
        const blockSize = new hashFunctionConstructor().blockSize;
        this.hash = (data) => new hashFunctionConstructor().update(data).digest();
        let key = originalKey;
        if (key.length > blockSize) {
          key = this.hash(key);
        }
        if (key.length < blockSize) {
          const zeroPadding = new Uint8Array(blockSize - key.length);
          key = new Uint8Array([...key, ...zeroPadding]);
        }
        this.oKeyPad = key.map((keyByte) => keyByte ^ 92);
        this.iKeyPad = key.map((keyByte) => keyByte ^ 54);
        this.messageHasher = new hashFunctionConstructor();
        this.blockSize = blockSize;
        this.update(this.iKeyPad);
      }
      update(data) {
        this.messageHasher.update(data);
        return this;
      }
      digest() {
        const innerHash = this.messageHasher.digest();
        return this.hash(new Uint8Array([...this.oKeyPad, ...innerHash]));
      }
    };
    exports.Hmac = Hmac;
  }
});

// ../../node_modules/.pnpm/@cosmjs+crypto@0.32.4/node_modules/@cosmjs/crypto/build/keccak.js
var require_keccak = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+crypto@0.32.4/node_modules/@cosmjs/crypto/build/keccak.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.keccak256 = exports.Keccak256 = void 0;
    var sha3_1 = require_sha3();
    var utils_1 = require_utils();
    var Keccak256 = class {
      constructor(firstData) {
        this.blockSize = 512 / 8;
        this.impl = sha3_1.keccak_256.create();
        if (firstData) {
          this.update(firstData);
        }
      }
      update(data) {
        this.impl.update((0, utils_1.toRealUint8Array)(data));
        return this;
      }
      digest() {
        return this.impl.digest();
      }
    };
    exports.Keccak256 = Keccak256;
    function keccak256(data) {
      return new Keccak256(data).digest();
    }
    exports.keccak256 = keccak256;
  }
});

// ../../node_modules/.pnpm/@cosmjs+crypto@0.32.4/node_modules/@cosmjs/crypto/build/libsodium.js
var require_libsodium = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+crypto@0.32.4/node_modules/@cosmjs/crypto/build/libsodium.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Xchacha20poly1305Ietf = exports.xchacha20NonceLength = exports.Ed25519 = exports.Ed25519Keypair = exports.Argon2id = exports.isArgon2idOptions = void 0;
    var utils_1 = require_build3();
    var libsodium_wrappers_sumo_1 = __importDefault(require_libsodium_wrappers());
    function isArgon2idOptions(thing) {
      if (!(0, utils_1.isNonNullObject)(thing))
        return false;
      if (typeof thing.outputLength !== "number")
        return false;
      if (typeof thing.opsLimit !== "number")
        return false;
      if (typeof thing.memLimitKib !== "number")
        return false;
      return true;
    }
    exports.isArgon2idOptions = isArgon2idOptions;
    var Argon2id = class {
      static async execute(password, salt, options) {
        await libsodium_wrappers_sumo_1.default.ready;
        return libsodium_wrappers_sumo_1.default.crypto_pwhash(
          options.outputLength,
          password,
          salt,
          // libsodium only supports 16 byte salts and will throw when you don't respect that
          options.opsLimit,
          options.memLimitKib * 1024,
          libsodium_wrappers_sumo_1.default.crypto_pwhash_ALG_ARGON2ID13
        );
      }
    };
    exports.Argon2id = Argon2id;
    var Ed25519Keypair = class _Ed25519Keypair {
      // a libsodium privkey has the format `<ed25519 privkey> + <ed25519 pubkey>`
      static fromLibsodiumPrivkey(libsodiumPrivkey) {
        if (libsodiumPrivkey.length !== 64) {
          throw new Error(`Unexpected key length ${libsodiumPrivkey.length}. Must be 64.`);
        }
        return new _Ed25519Keypair(libsodiumPrivkey.slice(0, 32), libsodiumPrivkey.slice(32, 64));
      }
      constructor(privkey, pubkey) {
        this.privkey = privkey;
        this.pubkey = pubkey;
      }
      toLibsodiumPrivkey() {
        return new Uint8Array([...this.privkey, ...this.pubkey]);
      }
    };
    exports.Ed25519Keypair = Ed25519Keypair;
    var Ed25519 = class {
      /**
       * Generates a keypair deterministically from a given 32 bytes seed.
       *
       * This seed equals the Ed25519 private key.
       * For implementation details see crypto_sign_seed_keypair in
       * https://download.libsodium.org/doc/public-key_cryptography/public-key_signatures.html
       * and diagram on https://blog.mozilla.org/warner/2011/11/29/ed25519-keys/
       */
      static async makeKeypair(seed) {
        await libsodium_wrappers_sumo_1.default.ready;
        const keypair = libsodium_wrappers_sumo_1.default.crypto_sign_seed_keypair(seed);
        return Ed25519Keypair.fromLibsodiumPrivkey(keypair.privateKey);
      }
      static async createSignature(message, keyPair) {
        await libsodium_wrappers_sumo_1.default.ready;
        return libsodium_wrappers_sumo_1.default.crypto_sign_detached(message, keyPair.toLibsodiumPrivkey());
      }
      static async verifySignature(signature, message, pubkey) {
        await libsodium_wrappers_sumo_1.default.ready;
        return libsodium_wrappers_sumo_1.default.crypto_sign_verify_detached(signature, message, pubkey);
      }
    };
    exports.Ed25519 = Ed25519;
    exports.xchacha20NonceLength = 24;
    var Xchacha20poly1305Ietf = class {
      static async encrypt(message, key, nonce) {
        await libsodium_wrappers_sumo_1.default.ready;
        const additionalData = null;
        return libsodium_wrappers_sumo_1.default.crypto_aead_xchacha20poly1305_ietf_encrypt(
          message,
          additionalData,
          null,
          // secret nonce: unused and should be null (https://download.libsodium.org/doc/secret-key_cryptography/aead/chacha20-poly1305/xchacha20-poly1305_construction)
          nonce,
          key
        );
      }
      static async decrypt(ciphertext, key, nonce) {
        await libsodium_wrappers_sumo_1.default.ready;
        const additionalData = null;
        return libsodium_wrappers_sumo_1.default.crypto_aead_xchacha20poly1305_ietf_decrypt(
          null,
          // secret nonce: unused and should be null (https://download.libsodium.org/doc/secret-key_cryptography/aead/chacha20-poly1305/xchacha20-poly1305_construction)
          ciphertext,
          additionalData,
          nonce,
          key
        );
      }
    };
    exports.Xchacha20poly1305Ietf = Xchacha20poly1305Ietf;
  }
});

// ../../node_modules/.pnpm/@cosmjs+crypto@0.32.4/node_modules/@cosmjs/crypto/build/random.js
var require_random = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+crypto@0.32.4/node_modules/@cosmjs/crypto/build/random.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Random = void 0;
    var Random = class {
      /**
       * Returns `count` cryptographically secure random bytes
       */
      static getBytes(count) {
        try {
          const globalObject = typeof window === "object" ? window : self;
          const cryptoApi = typeof globalObject.crypto !== "undefined" ? globalObject.crypto : globalObject.msCrypto;
          const out = new Uint8Array(count);
          cryptoApi.getRandomValues(out);
          return out;
        } catch {
          try {
            const crypto = require_crypto();
            return new Uint8Array([...crypto.randomBytes(count)]);
          } catch {
            throw new Error("No secure random number generator found");
          }
        }
      }
    };
    exports.Random = Random;
  }
});

// ../../node_modules/.pnpm/@cosmjs+crypto@0.32.4/node_modules/@cosmjs/crypto/build/ripemd.js
var require_ripemd = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+crypto@0.32.4/node_modules/@cosmjs/crypto/build/ripemd.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ripemd160 = exports.Ripemd160 = void 0;
    var ripemd160_1 = require_ripemd160();
    var utils_1 = require_utils();
    var Ripemd160 = class {
      constructor(firstData) {
        this.blockSize = 512 / 8;
        this.impl = ripemd160_1.ripemd160.create();
        if (firstData) {
          this.update(firstData);
        }
      }
      update(data) {
        this.impl.update((0, utils_1.toRealUint8Array)(data));
        return this;
      }
      digest() {
        return this.impl.digest();
      }
    };
    exports.Ripemd160 = Ripemd160;
    function ripemd160(data) {
      return new Ripemd160(data).digest();
    }
    exports.ripemd160 = ripemd160;
  }
});

// ../../node_modules/.pnpm/@cosmjs+crypto@0.32.4/node_modules/@cosmjs/crypto/build/secp256k1signature.js
var require_secp256k1signature = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+crypto@0.32.4/node_modules/@cosmjs/crypto/build/secp256k1signature.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ExtendedSecp256k1Signature = exports.Secp256k1Signature = void 0;
    function trimLeadingNullBytes(inData) {
      let numberOfLeadingNullBytes = 0;
      for (const byte of inData) {
        if (byte === 0) {
          numberOfLeadingNullBytes++;
        } else {
          break;
        }
      }
      return inData.slice(numberOfLeadingNullBytes);
    }
    var derTagInteger = 2;
    var Secp256k1Signature = class _Secp256k1Signature {
      /**
       * Takes the pair of integers (r, s) as 2x32 byte of binary data.
       *
       * Note: This is the format Cosmos SDK uses natively.
       *
       * @param data a 64 byte value containing integers r and s.
       */
      static fromFixedLength(data) {
        if (data.length !== 64) {
          throw new Error(`Got invalid data length: ${data.length}. Expected 2x 32 bytes for the pair (r, s)`);
        }
        return new _Secp256k1Signature(trimLeadingNullBytes(data.slice(0, 32)), trimLeadingNullBytes(data.slice(32, 64)));
      }
      static fromDer(data) {
        let pos = 0;
        if (data[pos++] !== 48) {
          throw new Error("Prefix 0x30 expected");
        }
        const bodyLength = data[pos++];
        if (data.length - pos !== bodyLength) {
          throw new Error("Data length mismatch detected");
        }
        const rTag = data[pos++];
        if (rTag !== derTagInteger) {
          throw new Error("INTEGER tag expected");
        }
        const rLength = data[pos++];
        if (rLength >= 128) {
          throw new Error("Decoding length values above 127 not supported");
        }
        const rData = data.slice(pos, pos + rLength);
        pos += rLength;
        const sTag = data[pos++];
        if (sTag !== derTagInteger) {
          throw new Error("INTEGER tag expected");
        }
        const sLength = data[pos++];
        if (sLength >= 128) {
          throw new Error("Decoding length values above 127 not supported");
        }
        const sData = data.slice(pos, pos + sLength);
        pos += sLength;
        return new _Secp256k1Signature(
          // r/s data can contain leading 0 bytes to express integers being non-negative in DER
          trimLeadingNullBytes(rData),
          trimLeadingNullBytes(sData)
        );
      }
      constructor(r, s) {
        if (r.length > 32 || r.length === 0 || r[0] === 0) {
          throw new Error("Unsigned integer r must be encoded as unpadded big endian.");
        }
        if (s.length > 32 || s.length === 0 || s[0] === 0) {
          throw new Error("Unsigned integer s must be encoded as unpadded big endian.");
        }
        this.data = {
          r,
          s
        };
      }
      r(length) {
        if (length === void 0) {
          return this.data.r;
        } else {
          const paddingLength = length - this.data.r.length;
          if (paddingLength < 0) {
            throw new Error("Length too small to hold parameter r");
          }
          const padding = new Uint8Array(paddingLength);
          return new Uint8Array([...padding, ...this.data.r]);
        }
      }
      s(length) {
        if (length === void 0) {
          return this.data.s;
        } else {
          const paddingLength = length - this.data.s.length;
          if (paddingLength < 0) {
            throw new Error("Length too small to hold parameter s");
          }
          const padding = new Uint8Array(paddingLength);
          return new Uint8Array([...padding, ...this.data.s]);
        }
      }
      toFixedLength() {
        return new Uint8Array([...this.r(32), ...this.s(32)]);
      }
      toDer() {
        const rEncoded = this.data.r[0] >= 128 ? new Uint8Array([0, ...this.data.r]) : this.data.r;
        const sEncoded = this.data.s[0] >= 128 ? new Uint8Array([0, ...this.data.s]) : this.data.s;
        const rLength = rEncoded.length;
        const sLength = sEncoded.length;
        const data = new Uint8Array([derTagInteger, rLength, ...rEncoded, derTagInteger, sLength, ...sEncoded]);
        return new Uint8Array([48, data.length, ...data]);
      }
    };
    exports.Secp256k1Signature = Secp256k1Signature;
    var ExtendedSecp256k1Signature = class _ExtendedSecp256k1Signature extends Secp256k1Signature {
      /**
       * Decode extended signature from the simple fixed length encoding
       * described in toFixedLength().
       */
      static fromFixedLength(data) {
        if (data.length !== 65) {
          throw new Error(`Got invalid data length ${data.length}. Expected 32 + 32 + 1`);
        }
        return new _ExtendedSecp256k1Signature(trimLeadingNullBytes(data.slice(0, 32)), trimLeadingNullBytes(data.slice(32, 64)), data[64]);
      }
      constructor(r, s, recovery) {
        super(r, s);
        if (!Number.isInteger(recovery)) {
          throw new Error("The recovery parameter must be an integer.");
        }
        if (recovery < 0 || recovery > 4) {
          throw new Error("The recovery parameter must be one of 0, 1, 2, 3.");
        }
        this.recovery = recovery;
      }
      /**
       * A simple custom encoding that encodes the extended signature as
       * r (32 bytes) | s (32 bytes) | recovery param (1 byte)
       * where | denotes concatenation of bonary data.
       */
      toFixedLength() {
        return new Uint8Array([...this.r(32), ...this.s(32), this.recovery]);
      }
    };
    exports.ExtendedSecp256k1Signature = ExtendedSecp256k1Signature;
  }
});

// ../../node_modules/.pnpm/@cosmjs+crypto@0.32.4/node_modules/@cosmjs/crypto/build/secp256k1.js
var require_secp256k1 = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+crypto@0.32.4/node_modules/@cosmjs/crypto/build/secp256k1.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Secp256k1 = void 0;
    var encoding_1 = require_build2();
    var bn_js_1 = __importDefault(require_bn());
    var elliptic_1 = __importDefault(require_elliptic());
    var secp256k1signature_1 = require_secp256k1signature();
    var secp256k1 = new elliptic_1.default.ec("secp256k1");
    var secp256k1N = new bn_js_1.default("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141", "hex");
    var Secp256k1 = class {
      /**
       * Takes a 32 byte private key and returns a privkey/pubkey pair.
       *
       * The resulting pubkey is uncompressed. For the use in Cosmos it should
       * be compressed first using `Secp256k1.compressPubkey`.
       */
      static async makeKeypair(privkey) {
        if (privkey.length !== 32) {
          throw new Error("input data is not a valid secp256k1 private key");
        }
        const keypair = secp256k1.keyFromPrivate(privkey);
        if (keypair.validate().result !== true) {
          throw new Error("input data is not a valid secp256k1 private key");
        }
        const privkeyAsBigInteger = new bn_js_1.default(privkey);
        if (privkeyAsBigInteger.gte(secp256k1N)) {
          throw new Error("input data is not a valid secp256k1 private key");
        }
        const out = {
          privkey: (0, encoding_1.fromHex)(keypair.getPrivate("hex")),
          // encodes uncompressed as
          // - 1-byte prefix "04"
          // - 32-byte x coordinate
          // - 32-byte y coordinate
          pubkey: Uint8Array.from(keypair.getPublic("array"))
        };
        return out;
      }
      /**
       * Creates a signature that is
       * - deterministic (RFC 6979)
       * - lowS signature
       * - DER encoded
       */
      static async createSignature(messageHash, privkey) {
        if (messageHash.length === 0) {
          throw new Error("Message hash must not be empty");
        }
        if (messageHash.length > 32) {
          throw new Error("Message hash length must not exceed 32 bytes");
        }
        const keypair = secp256k1.keyFromPrivate(privkey);
        const { r, s, recoveryParam } = keypair.sign(messageHash, { canonical: true });
        if (typeof recoveryParam !== "number")
          throw new Error("Recovery param missing");
        return new secp256k1signature_1.ExtendedSecp256k1Signature(Uint8Array.from(r.toArray()), Uint8Array.from(s.toArray()), recoveryParam);
      }
      static async verifySignature(signature, messageHash, pubkey) {
        if (messageHash.length === 0) {
          throw new Error("Message hash must not be empty");
        }
        if (messageHash.length > 32) {
          throw new Error("Message hash length must not exceed 32 bytes");
        }
        const keypair = secp256k1.keyFromPublic(pubkey);
        try {
          return keypair.verify(messageHash, signature.toDer());
        } catch (error) {
          return false;
        }
      }
      static recoverPubkey(signature, messageHash) {
        const signatureForElliptic = { r: (0, encoding_1.toHex)(signature.r()), s: (0, encoding_1.toHex)(signature.s()) };
        const point = secp256k1.recoverPubKey(messageHash, signatureForElliptic, signature.recovery);
        const keypair = secp256k1.keyFromPublic(point);
        return (0, encoding_1.fromHex)(keypair.getPublic(false, "hex"));
      }
      /**
       * Takes a compressed or uncompressed pubkey and return a compressed one.
       *
       * This function is idempotent.
       */
      static compressPubkey(pubkey) {
        switch (pubkey.length) {
          case 33:
            return pubkey;
          case 65:
            return Uint8Array.from(secp256k1.keyFromPublic(pubkey).getPublic(true, "array"));
          default:
            throw new Error("Invalid pubkey length");
        }
      }
      /**
       * Takes a compressed or uncompressed pubkey and returns an uncompressed one.
       *
       * This function is idempotent.
       */
      static uncompressPubkey(pubkey) {
        switch (pubkey.length) {
          case 33:
            return Uint8Array.from(secp256k1.keyFromPublic(pubkey).getPublic(false, "array"));
          case 65:
            return pubkey;
          default:
            throw new Error("Invalid pubkey length");
        }
      }
      static trimRecoveryByte(signature) {
        switch (signature.length) {
          case 64:
            return signature;
          case 65:
            return signature.slice(0, 64);
          default:
            throw new Error("Invalid signature length");
        }
      }
    };
    exports.Secp256k1 = Secp256k1;
  }
});

// ../../node_modules/.pnpm/@cosmjs+crypto@0.32.4/node_modules/@cosmjs/crypto/build/slip10.js
var require_slip10 = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+crypto@0.32.4/node_modules/@cosmjs/crypto/build/slip10.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.stringToPath = exports.pathToString = exports.Slip10 = exports.Slip10RawIndex = exports.slip10CurveFromString = exports.Slip10Curve = void 0;
    var encoding_1 = require_build2();
    var math_1 = require_build();
    var bn_js_1 = __importDefault(require_bn());
    var elliptic_1 = __importDefault(require_elliptic());
    var hmac_1 = require_hmac();
    var sha_1 = require_sha();
    var Slip10Curve;
    (function(Slip10Curve2) {
      Slip10Curve2["Secp256k1"] = "Bitcoin seed";
      Slip10Curve2["Ed25519"] = "ed25519 seed";
    })(Slip10Curve = exports.Slip10Curve || (exports.Slip10Curve = {}));
    function slip10CurveFromString(curveString) {
      switch (curveString) {
        case Slip10Curve.Ed25519:
          return Slip10Curve.Ed25519;
        case Slip10Curve.Secp256k1:
          return Slip10Curve.Secp256k1;
        default:
          throw new Error(`Unknown curve string: '${curveString}'`);
      }
    }
    exports.slip10CurveFromString = slip10CurveFromString;
    var Slip10RawIndex = class _Slip10RawIndex extends math_1.Uint32 {
      static hardened(hardenedIndex) {
        return new _Slip10RawIndex(hardenedIndex + 2 ** 31);
      }
      static normal(normalIndex) {
        return new _Slip10RawIndex(normalIndex);
      }
      isHardened() {
        return this.data >= 2 ** 31;
      }
    };
    exports.Slip10RawIndex = Slip10RawIndex;
    var secp256k1 = new elliptic_1.default.ec("secp256k1");
    var Slip10 = class _Slip10 {
      static derivePath(curve, seed, path) {
        let result = this.master(curve, seed);
        for (const rawIndex of path) {
          result = this.child(curve, result.privkey, result.chainCode, rawIndex);
        }
        return result;
      }
      static master(curve, seed) {
        const i = new hmac_1.Hmac(sha_1.Sha512, (0, encoding_1.toAscii)(curve)).update(seed).digest();
        const il = i.slice(0, 32);
        const ir = i.slice(32, 64);
        if (curve !== Slip10Curve.Ed25519 && (this.isZero(il) || this.isGteN(curve, il))) {
          return this.master(curve, i);
        }
        return {
          chainCode: ir,
          privkey: il
        };
      }
      static child(curve, parentPrivkey, parentChainCode, rawIndex) {
        let i;
        if (rawIndex.isHardened()) {
          const payload = new Uint8Array([0, ...parentPrivkey, ...rawIndex.toBytesBigEndian()]);
          i = new hmac_1.Hmac(sha_1.Sha512, parentChainCode).update(payload).digest();
        } else {
          if (curve === Slip10Curve.Ed25519) {
            throw new Error("Normal keys are not allowed with ed25519");
          } else {
            const data = new Uint8Array([
              ..._Slip10.serializedPoint(curve, new bn_js_1.default(parentPrivkey)),
              ...rawIndex.toBytesBigEndian()
            ]);
            i = new hmac_1.Hmac(sha_1.Sha512, parentChainCode).update(data).digest();
          }
        }
        return this.childImpl(curve, parentPrivkey, parentChainCode, rawIndex, i);
      }
      /**
       * Implementation of ser_P(point(k_par)) from BIP-0032
       *
       * @see https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki
       */
      static serializedPoint(curve, p) {
        switch (curve) {
          case Slip10Curve.Secp256k1:
            return (0, encoding_1.fromHex)(secp256k1.g.mul(p).encodeCompressed("hex"));
          default:
            throw new Error("curve not supported");
        }
      }
      static childImpl(curve, parentPrivkey, parentChainCode, rawIndex, i) {
        const il = i.slice(0, 32);
        const ir = i.slice(32, 64);
        const returnChainCode = ir;
        if (curve === Slip10Curve.Ed25519) {
          return {
            chainCode: returnChainCode,
            privkey: il
          };
        }
        const n = this.n(curve);
        const returnChildKeyAsNumber = new bn_js_1.default(il).add(new bn_js_1.default(parentPrivkey)).mod(n);
        const returnChildKey = Uint8Array.from(returnChildKeyAsNumber.toArray("be", 32));
        if (this.isGteN(curve, il) || this.isZero(returnChildKey)) {
          const newI = new hmac_1.Hmac(sha_1.Sha512, parentChainCode).update(new Uint8Array([1, ...ir, ...rawIndex.toBytesBigEndian()])).digest();
          return this.childImpl(curve, parentPrivkey, parentChainCode, rawIndex, newI);
        }
        return {
          chainCode: returnChainCode,
          privkey: returnChildKey
        };
      }
      static isZero(privkey) {
        return privkey.every((byte) => byte === 0);
      }
      static isGteN(curve, privkey) {
        const keyAsNumber = new bn_js_1.default(privkey);
        return keyAsNumber.gte(this.n(curve));
      }
      static n(curve) {
        switch (curve) {
          case Slip10Curve.Secp256k1:
            return new bn_js_1.default("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141", 16);
          default:
            throw new Error("curve not supported");
        }
      }
    };
    exports.Slip10 = Slip10;
    function pathToString(path) {
      return path.reduce((current, component) => {
        const componentString = component.isHardened() ? `${component.toNumber() - 2 ** 31}'` : component.toString();
        return current + "/" + componentString;
      }, "m");
    }
    exports.pathToString = pathToString;
    function stringToPath(input) {
      if (!input.startsWith("m"))
        throw new Error("Path string must start with 'm'");
      let rest = input.slice(1);
      const out = new Array();
      while (rest) {
        const match = rest.match(/^\/([0-9]+)('?)/);
        if (!match)
          throw new Error("Syntax error while reading path component");
        const [fullMatch, numberString, apostrophe] = match;
        const value = math_1.Uint53.fromString(numberString).toNumber();
        if (value >= 2 ** 31)
          throw new Error("Component value too high. Must not exceed 2**31-1.");
        if (apostrophe)
          out.push(Slip10RawIndex.hardened(value));
        else
          out.push(Slip10RawIndex.normal(value));
        rest = rest.slice(fullMatch.length);
      }
      return out;
    }
    exports.stringToPath = stringToPath;
  }
});

// ../../node_modules/.pnpm/@cosmjs+crypto@0.32.4/node_modules/@cosmjs/crypto/build/index.js
var require_build4 = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+crypto@0.32.4/node_modules/@cosmjs/crypto/build/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.stringToPath = exports.Slip10RawIndex = exports.slip10CurveFromString = exports.Slip10Curve = exports.Slip10 = exports.pathToString = exports.sha512 = exports.Sha512 = exports.sha256 = exports.Sha256 = exports.Secp256k1Signature = exports.ExtendedSecp256k1Signature = exports.Secp256k1 = exports.ripemd160 = exports.Ripemd160 = exports.Random = exports.Xchacha20poly1305Ietf = exports.xchacha20NonceLength = exports.isArgon2idOptions = exports.Ed25519Keypair = exports.Ed25519 = exports.Argon2id = exports.keccak256 = exports.Keccak256 = exports.Hmac = exports.EnglishMnemonic = exports.Bip39 = void 0;
    var bip39_1 = require_bip39();
    Object.defineProperty(exports, "Bip39", { enumerable: true, get: function() {
      return bip39_1.Bip39;
    } });
    Object.defineProperty(exports, "EnglishMnemonic", { enumerable: true, get: function() {
      return bip39_1.EnglishMnemonic;
    } });
    var hmac_1 = require_hmac();
    Object.defineProperty(exports, "Hmac", { enumerable: true, get: function() {
      return hmac_1.Hmac;
    } });
    var keccak_1 = require_keccak();
    Object.defineProperty(exports, "Keccak256", { enumerable: true, get: function() {
      return keccak_1.Keccak256;
    } });
    Object.defineProperty(exports, "keccak256", { enumerable: true, get: function() {
      return keccak_1.keccak256;
    } });
    var libsodium_1 = require_libsodium();
    Object.defineProperty(exports, "Argon2id", { enumerable: true, get: function() {
      return libsodium_1.Argon2id;
    } });
    Object.defineProperty(exports, "Ed25519", { enumerable: true, get: function() {
      return libsodium_1.Ed25519;
    } });
    Object.defineProperty(exports, "Ed25519Keypair", { enumerable: true, get: function() {
      return libsodium_1.Ed25519Keypair;
    } });
    Object.defineProperty(exports, "isArgon2idOptions", { enumerable: true, get: function() {
      return libsodium_1.isArgon2idOptions;
    } });
    Object.defineProperty(exports, "xchacha20NonceLength", { enumerable: true, get: function() {
      return libsodium_1.xchacha20NonceLength;
    } });
    Object.defineProperty(exports, "Xchacha20poly1305Ietf", { enumerable: true, get: function() {
      return libsodium_1.Xchacha20poly1305Ietf;
    } });
    var random_1 = require_random();
    Object.defineProperty(exports, "Random", { enumerable: true, get: function() {
      return random_1.Random;
    } });
    var ripemd_1 = require_ripemd();
    Object.defineProperty(exports, "Ripemd160", { enumerable: true, get: function() {
      return ripemd_1.Ripemd160;
    } });
    Object.defineProperty(exports, "ripemd160", { enumerable: true, get: function() {
      return ripemd_1.ripemd160;
    } });
    var secp256k1_1 = require_secp256k1();
    Object.defineProperty(exports, "Secp256k1", { enumerable: true, get: function() {
      return secp256k1_1.Secp256k1;
    } });
    var secp256k1signature_1 = require_secp256k1signature();
    Object.defineProperty(exports, "ExtendedSecp256k1Signature", { enumerable: true, get: function() {
      return secp256k1signature_1.ExtendedSecp256k1Signature;
    } });
    Object.defineProperty(exports, "Secp256k1Signature", { enumerable: true, get: function() {
      return secp256k1signature_1.Secp256k1Signature;
    } });
    var sha_1 = require_sha();
    Object.defineProperty(exports, "Sha256", { enumerable: true, get: function() {
      return sha_1.Sha256;
    } });
    Object.defineProperty(exports, "sha256", { enumerable: true, get: function() {
      return sha_1.sha256;
    } });
    Object.defineProperty(exports, "Sha512", { enumerable: true, get: function() {
      return sha_1.Sha512;
    } });
    Object.defineProperty(exports, "sha512", { enumerable: true, get: function() {
      return sha_1.sha512;
    } });
    var slip10_1 = require_slip10();
    Object.defineProperty(exports, "pathToString", { enumerable: true, get: function() {
      return slip10_1.pathToString;
    } });
    Object.defineProperty(exports, "Slip10", { enumerable: true, get: function() {
      return slip10_1.Slip10;
    } });
    Object.defineProperty(exports, "Slip10Curve", { enumerable: true, get: function() {
      return slip10_1.Slip10Curve;
    } });
    Object.defineProperty(exports, "slip10CurveFromString", { enumerable: true, get: function() {
      return slip10_1.slip10CurveFromString;
    } });
    Object.defineProperty(exports, "Slip10RawIndex", { enumerable: true, get: function() {
      return slip10_1.Slip10RawIndex;
    } });
    Object.defineProperty(exports, "stringToPath", { enumerable: true, get: function() {
      return slip10_1.stringToPath;
    } });
  }
});

// ../../node_modules/.pnpm/@cosmjs+amino@0.32.4/node_modules/@cosmjs/amino/build/pubkeys.js
var require_pubkeys = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+amino@0.32.4/node_modules/@cosmjs/amino/build/pubkeys.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isMultisigThresholdPubkey = exports.isSinglePubkey = exports.pubkeyType = exports.isSecp256k1Pubkey = exports.isEd25519Pubkey = void 0;
    function isEd25519Pubkey(pubkey) {
      return pubkey.type === "tendermint/PubKeyEd25519";
    }
    exports.isEd25519Pubkey = isEd25519Pubkey;
    function isSecp256k1Pubkey(pubkey) {
      return pubkey.type === "tendermint/PubKeySecp256k1";
    }
    exports.isSecp256k1Pubkey = isSecp256k1Pubkey;
    exports.pubkeyType = {
      /** @see https://github.com/tendermint/tendermint/blob/v0.33.0/crypto/ed25519/ed25519.go#L22 */
      secp256k1: "tendermint/PubKeySecp256k1",
      /** @see https://github.com/tendermint/tendermint/blob/v0.33.0/crypto/secp256k1/secp256k1.go#L23 */
      ed25519: "tendermint/PubKeyEd25519",
      /** @see https://github.com/tendermint/tendermint/blob/v0.33.0/crypto/sr25519/codec.go#L12 */
      sr25519: "tendermint/PubKeySr25519",
      multisigThreshold: "tendermint/PubKeyMultisigThreshold"
    };
    function isSinglePubkey(pubkey) {
      const singPubkeyTypes = [exports.pubkeyType.ed25519, exports.pubkeyType.secp256k1, exports.pubkeyType.sr25519];
      return singPubkeyTypes.includes(pubkey.type);
    }
    exports.isSinglePubkey = isSinglePubkey;
    function isMultisigThresholdPubkey(pubkey) {
      return pubkey.type === "tendermint/PubKeyMultisigThreshold";
    }
    exports.isMultisigThresholdPubkey = isMultisigThresholdPubkey;
  }
});

// ../../node_modules/.pnpm/@cosmjs+amino@0.32.4/node_modules/@cosmjs/amino/build/encoding.js
var require_encoding = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+amino@0.32.4/node_modules/@cosmjs/amino/build/encoding.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.encodeBech32Pubkey = exports.encodeAminoPubkey = exports.decodeBech32Pubkey = exports.decodeAminoPubkey = exports.encodeEd25519Pubkey = exports.encodeSecp256k1Pubkey = void 0;
    var encoding_1 = require_build2();
    var math_1 = require_build();
    var utils_1 = require_build3();
    var pubkeys_1 = require_pubkeys();
    function encodeSecp256k1Pubkey(pubkey) {
      if (pubkey.length !== 33 || pubkey[0] !== 2 && pubkey[0] !== 3) {
        throw new Error("Public key must be compressed secp256k1, i.e. 33 bytes starting with 0x02 or 0x03");
      }
      return {
        type: pubkeys_1.pubkeyType.secp256k1,
        value: (0, encoding_1.toBase64)(pubkey)
      };
    }
    exports.encodeSecp256k1Pubkey = encodeSecp256k1Pubkey;
    function encodeEd25519Pubkey(pubkey) {
      if (pubkey.length !== 32) {
        throw new Error("Ed25519 public key must be 32 bytes long");
      }
      return {
        type: pubkeys_1.pubkeyType.ed25519,
        value: (0, encoding_1.toBase64)(pubkey)
      };
    }
    exports.encodeEd25519Pubkey = encodeEd25519Pubkey;
    var pubkeyAminoPrefixSecp256k1 = (0, encoding_1.fromHex)(
      "eb5ae98721"
      /* fixed length */
    );
    var pubkeyAminoPrefixEd25519 = (0, encoding_1.fromHex)(
      "1624de6420"
      /* fixed length */
    );
    var pubkeyAminoPrefixSr25519 = (0, encoding_1.fromHex)(
      "0dfb100520"
      /* fixed length */
    );
    var pubkeyAminoPrefixMultisigThreshold = (0, encoding_1.fromHex)(
      "22c1f7e2"
      /* variable length not included */
    );
    function decodeAminoPubkey(data) {
      if ((0, utils_1.arrayContentStartsWith)(data, pubkeyAminoPrefixSecp256k1)) {
        const rest = data.slice(pubkeyAminoPrefixSecp256k1.length);
        if (rest.length !== 33) {
          throw new Error("Invalid rest data length. Expected 33 bytes (compressed secp256k1 pubkey).");
        }
        return {
          type: pubkeys_1.pubkeyType.secp256k1,
          value: (0, encoding_1.toBase64)(rest)
        };
      } else if ((0, utils_1.arrayContentStartsWith)(data, pubkeyAminoPrefixEd25519)) {
        const rest = data.slice(pubkeyAminoPrefixEd25519.length);
        if (rest.length !== 32) {
          throw new Error("Invalid rest data length. Expected 32 bytes (Ed25519 pubkey).");
        }
        return {
          type: pubkeys_1.pubkeyType.ed25519,
          value: (0, encoding_1.toBase64)(rest)
        };
      } else if ((0, utils_1.arrayContentStartsWith)(data, pubkeyAminoPrefixSr25519)) {
        const rest = data.slice(pubkeyAminoPrefixSr25519.length);
        if (rest.length !== 32) {
          throw new Error("Invalid rest data length. Expected 32 bytes (Sr25519 pubkey).");
        }
        return {
          type: pubkeys_1.pubkeyType.sr25519,
          value: (0, encoding_1.toBase64)(rest)
        };
      } else if ((0, utils_1.arrayContentStartsWith)(data, pubkeyAminoPrefixMultisigThreshold)) {
        return decodeMultisigPubkey(data);
      } else {
        throw new Error("Unsupported public key type. Amino data starts with: " + (0, encoding_1.toHex)(data.slice(0, 5)));
      }
    }
    exports.decodeAminoPubkey = decodeAminoPubkey;
    function decodeBech32Pubkey(bechEncoded) {
      const { data } = (0, encoding_1.fromBech32)(bechEncoded);
      return decodeAminoPubkey(data);
    }
    exports.decodeBech32Pubkey = decodeBech32Pubkey;
    function decodeUvarint(reader) {
      if (reader.length < 1) {
        throw new Error("Can't decode varint. EOF");
      }
      if (reader[0] > 127) {
        throw new Error("Decoding numbers > 127 is not supported here. Please tell those lazy CosmJS maintainers to port the binary.Varint implementation from the Go standard library and write some tests.");
      }
      return [reader[0], 1];
    }
    function decodeMultisigPubkey(data) {
      const reader = Array.from(data);
      const prefixFromReader = reader.splice(0, pubkeyAminoPrefixMultisigThreshold.length);
      if (!(0, utils_1.arrayContentStartsWith)(prefixFromReader, pubkeyAminoPrefixMultisigThreshold)) {
        throw new Error("Invalid multisig prefix.");
      }
      if (reader.shift() != 8) {
        throw new Error("Invalid multisig data. Expecting 0x08 prefix before threshold.");
      }
      const [threshold, thresholdBytesLength] = decodeUvarint(reader);
      reader.splice(0, thresholdBytesLength);
      const pubkeys = [];
      while (reader.length > 0) {
        if (reader.shift() != 18) {
          throw new Error("Invalid multisig data. Expecting 0x12 prefix before participant pubkey length.");
        }
        const [pubkeyLength, pubkeyLengthBytesSize] = decodeUvarint(reader);
        reader.splice(0, pubkeyLengthBytesSize);
        if (reader.length < pubkeyLength) {
          throw new Error("Invalid multisig data length.");
        }
        const encodedPubkey = reader.splice(0, pubkeyLength);
        const pubkey = decodeAminoPubkey(Uint8Array.from(encodedPubkey));
        pubkeys.push(pubkey);
      }
      return {
        type: pubkeys_1.pubkeyType.multisigThreshold,
        value: {
          threshold: threshold.toString(),
          pubkeys
        }
      };
    }
    function encodeUvarint(value) {
      const checked = math_1.Uint53.fromString(value.toString()).toNumber();
      if (checked > 127) {
        throw new Error("Encoding numbers > 127 is not supported here. Please tell those lazy CosmJS maintainers to port the binary.PutUvarint implementation from the Go standard library and write some tests.");
      }
      return [checked];
    }
    function encodeAminoPubkey(pubkey) {
      if ((0, pubkeys_1.isMultisigThresholdPubkey)(pubkey)) {
        const out = Array.from(pubkeyAminoPrefixMultisigThreshold);
        out.push(8);
        out.push(...encodeUvarint(pubkey.value.threshold));
        for (const pubkeyData of pubkey.value.pubkeys.map((p) => encodeAminoPubkey(p))) {
          out.push(18);
          out.push(...encodeUvarint(pubkeyData.length));
          out.push(...pubkeyData);
        }
        return new Uint8Array(out);
      } else if ((0, pubkeys_1.isEd25519Pubkey)(pubkey)) {
        return new Uint8Array([...pubkeyAminoPrefixEd25519, ...(0, encoding_1.fromBase64)(pubkey.value)]);
      } else if ((0, pubkeys_1.isSecp256k1Pubkey)(pubkey)) {
        return new Uint8Array([...pubkeyAminoPrefixSecp256k1, ...(0, encoding_1.fromBase64)(pubkey.value)]);
      } else {
        throw new Error("Unsupported pubkey type");
      }
    }
    exports.encodeAminoPubkey = encodeAminoPubkey;
    function encodeBech32Pubkey(pubkey, prefix) {
      return (0, encoding_1.toBech32)(prefix, encodeAminoPubkey(pubkey));
    }
    exports.encodeBech32Pubkey = encodeBech32Pubkey;
  }
});

// ../../node_modules/.pnpm/@cosmjs+amino@0.32.4/node_modules/@cosmjs/amino/build/addresses.js
var require_addresses = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+amino@0.32.4/node_modules/@cosmjs/amino/build/addresses.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.pubkeyToAddress = exports.pubkeyToRawAddress = exports.rawSecp256k1PubkeyToRawAddress = exports.rawEd25519PubkeyToRawAddress = void 0;
    var crypto_1 = require_build4();
    var encoding_1 = require_build2();
    var encoding_2 = require_encoding();
    var pubkeys_1 = require_pubkeys();
    function rawEd25519PubkeyToRawAddress(pubkeyData) {
      if (pubkeyData.length !== 32) {
        throw new Error(`Invalid Ed25519 pubkey length: ${pubkeyData.length}`);
      }
      return (0, crypto_1.sha256)(pubkeyData).slice(0, 20);
    }
    exports.rawEd25519PubkeyToRawAddress = rawEd25519PubkeyToRawAddress;
    function rawSecp256k1PubkeyToRawAddress(pubkeyData) {
      if (pubkeyData.length !== 33) {
        throw new Error(`Invalid Secp256k1 pubkey length (compressed): ${pubkeyData.length}`);
      }
      return (0, crypto_1.ripemd160)((0, crypto_1.sha256)(pubkeyData));
    }
    exports.rawSecp256k1PubkeyToRawAddress = rawSecp256k1PubkeyToRawAddress;
    function pubkeyToRawAddress(pubkey) {
      if ((0, pubkeys_1.isSecp256k1Pubkey)(pubkey)) {
        const pubkeyData = (0, encoding_1.fromBase64)(pubkey.value);
        return rawSecp256k1PubkeyToRawAddress(pubkeyData);
      } else if ((0, pubkeys_1.isEd25519Pubkey)(pubkey)) {
        const pubkeyData = (0, encoding_1.fromBase64)(pubkey.value);
        return rawEd25519PubkeyToRawAddress(pubkeyData);
      } else if ((0, pubkeys_1.isMultisigThresholdPubkey)(pubkey)) {
        const pubkeyData = (0, encoding_2.encodeAminoPubkey)(pubkey);
        return (0, crypto_1.sha256)(pubkeyData).slice(0, 20);
      } else {
        throw new Error("Unsupported public key type");
      }
    }
    exports.pubkeyToRawAddress = pubkeyToRawAddress;
    function pubkeyToAddress(pubkey, prefix) {
      return (0, encoding_1.toBech32)(prefix, pubkeyToRawAddress(pubkey));
    }
    exports.pubkeyToAddress = pubkeyToAddress;
  }
});

// ../../node_modules/.pnpm/@cosmjs+amino@0.32.4/node_modules/@cosmjs/amino/build/coins.js
var require_coins = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+amino@0.32.4/node_modules/@cosmjs/amino/build/coins.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.addCoins = exports.parseCoins = exports.coins = exports.coin = void 0;
    var math_1 = require_build();
    function coin(amount, denom) {
      let outAmount;
      if (typeof amount === "number") {
        try {
          outAmount = new math_1.Uint53(amount).toString();
        } catch (_err) {
          throw new Error("Given amount is not a safe integer. Consider using a string instead to overcome the limitations of JS numbers.");
        }
      } else {
        if (!amount.match(/^[0-9]+$/)) {
          throw new Error("Invalid unsigned integer string format");
        }
        outAmount = amount.replace(/^0*/, "") || "0";
      }
      return {
        amount: outAmount,
        denom
      };
    }
    exports.coin = coin;
    function coins(amount, denom) {
      return [coin(amount, denom)];
    }
    exports.coins = coins;
    function parseCoins(input) {
      return input.replace(/\s/g, "").split(",").filter(Boolean).map((part) => {
        const match = part.match(/^([0-9]+)([a-zA-Z][a-zA-Z0-9/]{2,127})$/);
        if (!match)
          throw new Error("Got an invalid coin string");
        return {
          amount: match[1].replace(/^0+/, "") || "0",
          denom: match[2]
        };
      });
    }
    exports.parseCoins = parseCoins;
    function addCoins(lhs, rhs) {
      if (lhs.denom !== rhs.denom)
        throw new Error("Trying to add two coins with different denoms");
      return {
        amount: math_1.Decimal.fromAtomics(lhs.amount, 0).plus(math_1.Decimal.fromAtomics(rhs.amount, 0)).atomics,
        denom: lhs.denom
      };
    }
    exports.addCoins = addCoins;
  }
});

// ../../node_modules/.pnpm/@cosmjs+amino@0.32.4/node_modules/@cosmjs/amino/build/multisig.js
var require_multisig2 = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+amino@0.32.4/node_modules/@cosmjs/amino/build/multisig.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createMultisigThresholdPubkey = exports.compareArrays = void 0;
    var encoding_1 = require_build2();
    var math_1 = require_build();
    var addresses_1 = require_addresses();
    function compareArrays(a, b) {
      const aHex = (0, encoding_1.toHex)(a);
      const bHex = (0, encoding_1.toHex)(b);
      return aHex === bHex ? 0 : aHex < bHex ? -1 : 1;
    }
    exports.compareArrays = compareArrays;
    function createMultisigThresholdPubkey(pubkeys, threshold, nosort = false) {
      const uintThreshold = new math_1.Uint53(threshold);
      if (uintThreshold.toNumber() > pubkeys.length) {
        throw new Error(`Threshold k = ${uintThreshold.toNumber()} exceeds number of keys n = ${pubkeys.length}`);
      }
      const outPubkeys = nosort ? pubkeys : Array.from(pubkeys).sort((lhs, rhs) => {
        const addressLhs = (0, addresses_1.pubkeyToRawAddress)(lhs);
        const addressRhs = (0, addresses_1.pubkeyToRawAddress)(rhs);
        return compareArrays(addressLhs, addressRhs);
      });
      return {
        type: "tendermint/PubKeyMultisigThreshold",
        value: {
          threshold: uintThreshold.toString(),
          pubkeys: outPubkeys
        }
      };
    }
    exports.createMultisigThresholdPubkey = createMultisigThresholdPubkey;
  }
});

// ../../node_modules/.pnpm/@cosmjs+amino@0.32.4/node_modules/@cosmjs/amino/build/omitdefault.js
var require_omitdefault = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+amino@0.32.4/node_modules/@cosmjs/amino/build/omitdefault.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.omitDefault = void 0;
    function omitDefault(input) {
      switch (typeof input) {
        case "string":
          return input === "" ? void 0 : input;
        case "number":
          return input === 0 ? void 0 : input;
        case "bigint":
          return input === BigInt(0) ? void 0 : input;
        case "boolean":
          return !input ? void 0 : input;
        default:
          throw new Error(`Got unsupported type '${typeof input}'`);
      }
    }
    exports.omitDefault = omitDefault;
  }
});

// ../../node_modules/.pnpm/@cosmjs+amino@0.32.4/node_modules/@cosmjs/amino/build/paths.js
var require_paths = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+amino@0.32.4/node_modules/@cosmjs/amino/build/paths.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.makeCosmoshubPath = void 0;
    var crypto_1 = require_build4();
    function makeCosmoshubPath(a) {
      return [
        crypto_1.Slip10RawIndex.hardened(44),
        crypto_1.Slip10RawIndex.hardened(118),
        crypto_1.Slip10RawIndex.hardened(0),
        crypto_1.Slip10RawIndex.normal(0),
        crypto_1.Slip10RawIndex.normal(a)
      ];
    }
    exports.makeCosmoshubPath = makeCosmoshubPath;
  }
});

// ../../node_modules/.pnpm/@cosmjs+amino@0.32.4/node_modules/@cosmjs/amino/build/signature.js
var require_signature = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+amino@0.32.4/node_modules/@cosmjs/amino/build/signature.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.decodeSignature = exports.encodeSecp256k1Signature = void 0;
    var encoding_1 = require_build2();
    var encoding_2 = require_encoding();
    var pubkeys_1 = require_pubkeys();
    function encodeSecp256k1Signature(pubkey, signature) {
      if (signature.length !== 64) {
        throw new Error("Signature must be 64 bytes long. Cosmos SDK uses a 2x32 byte fixed length encoding for the secp256k1 signature integers r and s.");
      }
      return {
        pub_key: (0, encoding_2.encodeSecp256k1Pubkey)(pubkey),
        signature: (0, encoding_1.toBase64)(signature)
      };
    }
    exports.encodeSecp256k1Signature = encodeSecp256k1Signature;
    function decodeSignature(signature) {
      switch (signature.pub_key.type) {
        case pubkeys_1.pubkeyType.secp256k1:
          return {
            pubkey: (0, encoding_1.fromBase64)(signature.pub_key.value),
            signature: (0, encoding_1.fromBase64)(signature.signature)
          };
        default:
          throw new Error("Unsupported pubkey type");
      }
    }
    exports.decodeSignature = decodeSignature;
  }
});

// ../../node_modules/.pnpm/@cosmjs+amino@0.32.4/node_modules/@cosmjs/amino/build/signdoc.js
var require_signdoc = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+amino@0.32.4/node_modules/@cosmjs/amino/build/signdoc.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.serializeSignDoc = exports.escapeCharacters = exports.makeSignDoc = exports.sortedJsonStringify = void 0;
    var encoding_1 = require_build2();
    var math_1 = require_build();
    function sortedObject(obj) {
      if (typeof obj !== "object" || obj === null) {
        return obj;
      }
      if (Array.isArray(obj)) {
        return obj.map(sortedObject);
      }
      const sortedKeys = Object.keys(obj).sort();
      const result = {};
      sortedKeys.forEach((key) => {
        result[key] = sortedObject(obj[key]);
      });
      return result;
    }
    function sortedJsonStringify(obj) {
      return JSON.stringify(sortedObject(obj));
    }
    exports.sortedJsonStringify = sortedJsonStringify;
    function makeSignDoc(msgs, fee, chainId, memo, accountNumber, sequence, timeout_height) {
      return {
        chain_id: chainId,
        account_number: math_1.Uint53.fromString(accountNumber.toString()).toString(),
        sequence: math_1.Uint53.fromString(sequence.toString()).toString(),
        fee,
        msgs,
        memo: memo || "",
        ...timeout_height && { timeout_height: timeout_height.toString() }
      };
    }
    exports.makeSignDoc = makeSignDoc;
    function escapeCharacters(input) {
      const amp = /&/g;
      const lt = /</g;
      const gt = />/g;
      return input.replace(amp, "\\u0026").replace(lt, "\\u003c").replace(gt, "\\u003e");
    }
    exports.escapeCharacters = escapeCharacters;
    function serializeSignDoc(signDoc) {
      const serialized = escapeCharacters(sortedJsonStringify(signDoc));
      return (0, encoding_1.toUtf8)(serialized);
    }
    exports.serializeSignDoc = serializeSignDoc;
  }
});

// ../../node_modules/.pnpm/@cosmjs+amino@0.32.4/node_modules/@cosmjs/amino/build/wallet.js
var require_wallet = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+amino@0.32.4/node_modules/@cosmjs/amino/build/wallet.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.decrypt = exports.encrypt = exports.supportedAlgorithms = exports.executeKdf = exports.cosmjsSalt = void 0;
    var crypto_1 = require_build4();
    var encoding_1 = require_build2();
    exports.cosmjsSalt = (0, encoding_1.toAscii)("The CosmJS salt.");
    async function executeKdf(password, configuration) {
      switch (configuration.algorithm) {
        case "argon2id": {
          const options = configuration.params;
          if (!(0, crypto_1.isArgon2idOptions)(options))
            throw new Error("Invalid format of argon2id params");
          return crypto_1.Argon2id.execute(password, exports.cosmjsSalt, options);
        }
        default:
          throw new Error("Unsupported KDF algorithm");
      }
    }
    exports.executeKdf = executeKdf;
    exports.supportedAlgorithms = {
      xchacha20poly1305Ietf: "xchacha20poly1305-ietf"
    };
    async function encrypt(plaintext, encryptionKey, config) {
      switch (config.algorithm) {
        case exports.supportedAlgorithms.xchacha20poly1305Ietf: {
          const nonce = crypto_1.Random.getBytes(crypto_1.xchacha20NonceLength);
          return new Uint8Array([
            ...nonce,
            ...await crypto_1.Xchacha20poly1305Ietf.encrypt(plaintext, encryptionKey, nonce)
          ]);
        }
        default:
          throw new Error(`Unsupported encryption algorithm: '${config.algorithm}'`);
      }
    }
    exports.encrypt = encrypt;
    async function decrypt(ciphertext, encryptionKey, config) {
      switch (config.algorithm) {
        case exports.supportedAlgorithms.xchacha20poly1305Ietf: {
          const nonce = ciphertext.slice(0, crypto_1.xchacha20NonceLength);
          return crypto_1.Xchacha20poly1305Ietf.decrypt(ciphertext.slice(crypto_1.xchacha20NonceLength), encryptionKey, nonce);
        }
        default:
          throw new Error(`Unsupported encryption algorithm: '${config.algorithm}'`);
      }
    }
    exports.decrypt = decrypt;
  }
});

// ../../node_modules/.pnpm/@cosmjs+amino@0.32.4/node_modules/@cosmjs/amino/build/secp256k1hdwallet.js
var require_secp256k1hdwallet = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+amino@0.32.4/node_modules/@cosmjs/amino/build/secp256k1hdwallet.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Secp256k1HdWallet = exports.extractKdfConfiguration = void 0;
    var crypto_1 = require_build4();
    var encoding_1 = require_build2();
    var utils_1 = require_build3();
    var addresses_1 = require_addresses();
    var paths_1 = require_paths();
    var signature_1 = require_signature();
    var signdoc_1 = require_signdoc();
    var wallet_1 = require_wallet();
    var serializationTypeV1 = "secp256k1wallet-v1";
    var basicPasswordHashingOptions = {
      algorithm: "argon2id",
      params: {
        outputLength: 32,
        opsLimit: 24,
        memLimitKib: 12 * 1024
      }
    };
    function isDerivationJson(thing) {
      if (!(0, utils_1.isNonNullObject)(thing))
        return false;
      if (typeof thing.hdPath !== "string")
        return false;
      if (typeof thing.prefix !== "string")
        return false;
      return true;
    }
    function extractKdfConfigurationV1(doc) {
      return doc.kdf;
    }
    function extractKdfConfiguration(serialization) {
      const root = JSON.parse(serialization);
      if (!(0, utils_1.isNonNullObject)(root))
        throw new Error("Root document is not an object.");
      switch (root.type) {
        case serializationTypeV1:
          return extractKdfConfigurationV1(root);
        default:
          throw new Error("Unsupported serialization type");
      }
    }
    exports.extractKdfConfiguration = extractKdfConfiguration;
    var defaultOptions = {
      bip39Password: "",
      hdPaths: [(0, paths_1.makeCosmoshubPath)(0)],
      prefix: "cosmos"
    };
    var Secp256k1HdWallet = class _Secp256k1HdWallet {
      /**
       * Restores a wallet from the given BIP39 mnemonic.
       *
       * @param mnemonic Any valid English mnemonic.
       * @param options An optional `Secp256k1HdWalletOptions` object optionally containing a bip39Password, hdPaths, and prefix.
       */
      static async fromMnemonic(mnemonic, options = {}) {
        const mnemonicChecked = new crypto_1.EnglishMnemonic(mnemonic);
        const seed = await crypto_1.Bip39.mnemonicToSeed(mnemonicChecked, options.bip39Password);
        return new _Secp256k1HdWallet(mnemonicChecked, {
          ...options,
          seed
        });
      }
      /**
       * Generates a new wallet with a BIP39 mnemonic of the given length.
       *
       * @param length The number of words in the mnemonic (12, 15, 18, 21 or 24).
       * @param options An optional `Secp256k1HdWalletOptions` object optionally containing a bip39Password, hdPaths, and prefix.
       */
      static async generate(length = 12, options = {}) {
        const entropyLength = 4 * Math.floor(11 * length / 33);
        const entropy = crypto_1.Random.getBytes(entropyLength);
        const mnemonic = crypto_1.Bip39.encode(entropy);
        return _Secp256k1HdWallet.fromMnemonic(mnemonic.toString(), options);
      }
      /**
       * Restores a wallet from an encrypted serialization.
       *
       * @param password The user provided password used to generate an encryption key via a KDF.
       *                 This is not normalized internally (see "Unicode normalization" to learn more).
       */
      static async deserialize(serialization, password) {
        const root = JSON.parse(serialization);
        if (!(0, utils_1.isNonNullObject)(root))
          throw new Error("Root document is not an object.");
        switch (root.type) {
          case serializationTypeV1:
            return _Secp256k1HdWallet.deserializeTypeV1(serialization, password);
          default:
            throw new Error("Unsupported serialization type");
        }
      }
      /**
       * Restores a wallet from an encrypted serialization.
       *
       * This is an advanced alternative to calling `deserialize(serialization, password)` directly, which allows
       * you to offload the KDF execution to a non-UI thread (e.g. in a WebWorker).
       *
       * The caller is responsible for ensuring the key was derived with the given KDF configuration. This can be
       * done using `extractKdfConfiguration(serialization)` and `executeKdf(password, kdfConfiguration)` from this package.
       */
      static async deserializeWithEncryptionKey(serialization, encryptionKey) {
        const root = JSON.parse(serialization);
        if (!(0, utils_1.isNonNullObject)(root))
          throw new Error("Root document is not an object.");
        const untypedRoot = root;
        switch (untypedRoot.type) {
          case serializationTypeV1: {
            const decryptedBytes = await (0, wallet_1.decrypt)((0, encoding_1.fromBase64)(untypedRoot.data), encryptionKey, untypedRoot.encryption);
            const decryptedDocument = JSON.parse((0, encoding_1.fromUtf8)(decryptedBytes));
            const { mnemonic, accounts } = decryptedDocument;
            (0, utils_1.assert)(typeof mnemonic === "string");
            if (!Array.isArray(accounts))
              throw new Error("Property 'accounts' is not an array");
            if (!accounts.every((account) => isDerivationJson(account))) {
              throw new Error("Account is not in the correct format.");
            }
            const firstPrefix = accounts[0].prefix;
            if (!accounts.every(({ prefix }) => prefix === firstPrefix)) {
              throw new Error("Accounts do not all have the same prefix");
            }
            const hdPaths = accounts.map(({ hdPath }) => (0, crypto_1.stringToPath)(hdPath));
            return _Secp256k1HdWallet.fromMnemonic(mnemonic, {
              hdPaths,
              prefix: firstPrefix
            });
          }
          default:
            throw new Error("Unsupported serialization type");
        }
      }
      static async deserializeTypeV1(serialization, password) {
        const root = JSON.parse(serialization);
        if (!(0, utils_1.isNonNullObject)(root))
          throw new Error("Root document is not an object.");
        const encryptionKey = await (0, wallet_1.executeKdf)(password, root.kdf);
        return _Secp256k1HdWallet.deserializeWithEncryptionKey(serialization, encryptionKey);
      }
      constructor(mnemonic, options) {
        const hdPaths = options.hdPaths ?? defaultOptions.hdPaths;
        const prefix = options.prefix ?? defaultOptions.prefix;
        this.secret = mnemonic;
        this.seed = options.seed;
        this.accounts = hdPaths.map((hdPath) => ({
          hdPath,
          prefix
        }));
      }
      get mnemonic() {
        return this.secret.toString();
      }
      async getAccounts() {
        const accountsWithPrivkeys = await this.getAccountsWithPrivkeys();
        return accountsWithPrivkeys.map(({ algo, pubkey, address }) => ({
          algo,
          pubkey,
          address
        }));
      }
      async signAmino(signerAddress, signDoc) {
        const accounts = await this.getAccountsWithPrivkeys();
        const account = accounts.find(({ address }) => address === signerAddress);
        if (account === void 0) {
          throw new Error(`Address ${signerAddress} not found in wallet`);
        }
        const { privkey, pubkey } = account;
        const message = (0, crypto_1.sha256)((0, signdoc_1.serializeSignDoc)(signDoc));
        const signature = await crypto_1.Secp256k1.createSignature(message, privkey);
        const signatureBytes = new Uint8Array([...signature.r(32), ...signature.s(32)]);
        return {
          signed: signDoc,
          signature: (0, signature_1.encodeSecp256k1Signature)(pubkey, signatureBytes)
        };
      }
      /**
       * Generates an encrypted serialization of this wallet.
       *
       * @param password The user provided password used to generate an encryption key via a KDF.
       *                 This is not normalized internally (see "Unicode normalization" to learn more).
       */
      async serialize(password) {
        const kdfConfiguration = basicPasswordHashingOptions;
        const encryptionKey = await (0, wallet_1.executeKdf)(password, kdfConfiguration);
        return this.serializeWithEncryptionKey(encryptionKey, kdfConfiguration);
      }
      /**
       * Generates an encrypted serialization of this wallet.
       *
       * This is an advanced alternative to calling `serialize(password)` directly, which allows you to
       * offload the KDF execution to a non-UI thread (e.g. in a WebWorker).
       *
       * The caller is responsible for ensuring the key was derived with the given KDF options. If this
       * is not the case, the wallet cannot be restored with the original password.
       */
      async serializeWithEncryptionKey(encryptionKey, kdfConfiguration) {
        const dataToEncrypt = {
          mnemonic: this.mnemonic,
          accounts: this.accounts.map(({ hdPath, prefix }) => ({
            hdPath: (0, crypto_1.pathToString)(hdPath),
            prefix
          }))
        };
        const dataToEncryptRaw = (0, encoding_1.toUtf8)(JSON.stringify(dataToEncrypt));
        const encryptionConfiguration = {
          algorithm: wallet_1.supportedAlgorithms.xchacha20poly1305Ietf
        };
        const encryptedData = await (0, wallet_1.encrypt)(dataToEncryptRaw, encryptionKey, encryptionConfiguration);
        const out = {
          type: serializationTypeV1,
          kdf: kdfConfiguration,
          encryption: encryptionConfiguration,
          data: (0, encoding_1.toBase64)(encryptedData)
        };
        return JSON.stringify(out);
      }
      async getKeyPair(hdPath) {
        const { privkey } = crypto_1.Slip10.derivePath(crypto_1.Slip10Curve.Secp256k1, this.seed, hdPath);
        const { pubkey } = await crypto_1.Secp256k1.makeKeypair(privkey);
        return {
          privkey,
          pubkey: crypto_1.Secp256k1.compressPubkey(pubkey)
        };
      }
      async getAccountsWithPrivkeys() {
        return Promise.all(this.accounts.map(async ({ hdPath, prefix }) => {
          const { privkey, pubkey } = await this.getKeyPair(hdPath);
          const address = (0, encoding_1.toBech32)(prefix, (0, addresses_1.rawSecp256k1PubkeyToRawAddress)(pubkey));
          return {
            algo: "secp256k1",
            privkey,
            pubkey,
            address
          };
        }));
      }
    };
    exports.Secp256k1HdWallet = Secp256k1HdWallet;
  }
});

// ../../node_modules/.pnpm/@cosmjs+amino@0.32.4/node_modules/@cosmjs/amino/build/secp256k1wallet.js
var require_secp256k1wallet = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+amino@0.32.4/node_modules/@cosmjs/amino/build/secp256k1wallet.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Secp256k1Wallet = void 0;
    var crypto_1 = require_build4();
    var encoding_1 = require_build2();
    var addresses_1 = require_addresses();
    var signature_1 = require_signature();
    var signdoc_1 = require_signdoc();
    var Secp256k1Wallet = class _Secp256k1Wallet {
      /**
       * Creates a Secp256k1Wallet from the given private key
       *
       * @param privkey The private key.
       * @param prefix The bech32 address prefix (human readable part). Defaults to "cosmos".
       */
      static async fromKey(privkey, prefix = "cosmos") {
        const uncompressed = (await crypto_1.Secp256k1.makeKeypair(privkey)).pubkey;
        return new _Secp256k1Wallet(privkey, crypto_1.Secp256k1.compressPubkey(uncompressed), prefix);
      }
      constructor(privkey, pubkey, prefix) {
        this.privkey = privkey;
        this.pubkey = pubkey;
        this.prefix = prefix;
      }
      get address() {
        return (0, encoding_1.toBech32)(this.prefix, (0, addresses_1.rawSecp256k1PubkeyToRawAddress)(this.pubkey));
      }
      async getAccounts() {
        return [
          {
            algo: "secp256k1",
            address: this.address,
            pubkey: this.pubkey
          }
        ];
      }
      async signAmino(signerAddress, signDoc) {
        if (signerAddress !== this.address) {
          throw new Error(`Address ${signerAddress} not found in wallet`);
        }
        const message = new crypto_1.Sha256((0, signdoc_1.serializeSignDoc)(signDoc)).digest();
        const signature = await crypto_1.Secp256k1.createSignature(message, this.privkey);
        const signatureBytes = new Uint8Array([...signature.r(32), ...signature.s(32)]);
        return {
          signed: signDoc,
          signature: (0, signature_1.encodeSecp256k1Signature)(this.pubkey, signatureBytes)
        };
      }
    };
    exports.Secp256k1Wallet = Secp256k1Wallet;
  }
});

// ../../node_modules/.pnpm/@cosmjs+amino@0.32.4/node_modules/@cosmjs/amino/build/stdtx.js
var require_stdtx = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+amino@0.32.4/node_modules/@cosmjs/amino/build/stdtx.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.makeStdTx = exports.isStdTx = void 0;
    function isStdTx(txValue) {
      const { memo, msg, fee, signatures } = txValue;
      return typeof memo === "string" && Array.isArray(msg) && typeof fee === "object" && Array.isArray(signatures);
    }
    exports.isStdTx = isStdTx;
    function makeStdTx(content, signatures) {
      return {
        msg: content.msgs,
        fee: content.fee,
        memo: content.memo,
        signatures: Array.isArray(signatures) ? signatures : [signatures]
      };
    }
    exports.makeStdTx = makeStdTx;
  }
});

// ../../node_modules/.pnpm/@cosmjs+amino@0.32.4/node_modules/@cosmjs/amino/build/index.js
var require_build5 = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+amino@0.32.4/node_modules/@cosmjs/amino/build/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.executeKdf = exports.makeStdTx = exports.isStdTx = exports.serializeSignDoc = exports.makeSignDoc = exports.encodeSecp256k1Signature = exports.decodeSignature = exports.Secp256k1Wallet = exports.Secp256k1HdWallet = exports.extractKdfConfiguration = exports.pubkeyType = exports.isSinglePubkey = exports.isSecp256k1Pubkey = exports.isMultisigThresholdPubkey = exports.isEd25519Pubkey = exports.makeCosmoshubPath = exports.omitDefault = exports.createMultisigThresholdPubkey = exports.encodeSecp256k1Pubkey = exports.encodeEd25519Pubkey = exports.encodeBech32Pubkey = exports.encodeAminoPubkey = exports.decodeBech32Pubkey = exports.decodeAminoPubkey = exports.parseCoins = exports.coins = exports.coin = exports.addCoins = exports.rawSecp256k1PubkeyToRawAddress = exports.rawEd25519PubkeyToRawAddress = exports.pubkeyToRawAddress = exports.pubkeyToAddress = void 0;
    var addresses_1 = require_addresses();
    Object.defineProperty(exports, "pubkeyToAddress", { enumerable: true, get: function() {
      return addresses_1.pubkeyToAddress;
    } });
    Object.defineProperty(exports, "pubkeyToRawAddress", { enumerable: true, get: function() {
      return addresses_1.pubkeyToRawAddress;
    } });
    Object.defineProperty(exports, "rawEd25519PubkeyToRawAddress", { enumerable: true, get: function() {
      return addresses_1.rawEd25519PubkeyToRawAddress;
    } });
    Object.defineProperty(exports, "rawSecp256k1PubkeyToRawAddress", { enumerable: true, get: function() {
      return addresses_1.rawSecp256k1PubkeyToRawAddress;
    } });
    var coins_1 = require_coins();
    Object.defineProperty(exports, "addCoins", { enumerable: true, get: function() {
      return coins_1.addCoins;
    } });
    Object.defineProperty(exports, "coin", { enumerable: true, get: function() {
      return coins_1.coin;
    } });
    Object.defineProperty(exports, "coins", { enumerable: true, get: function() {
      return coins_1.coins;
    } });
    Object.defineProperty(exports, "parseCoins", { enumerable: true, get: function() {
      return coins_1.parseCoins;
    } });
    var encoding_1 = require_encoding();
    Object.defineProperty(exports, "decodeAminoPubkey", { enumerable: true, get: function() {
      return encoding_1.decodeAminoPubkey;
    } });
    Object.defineProperty(exports, "decodeBech32Pubkey", { enumerable: true, get: function() {
      return encoding_1.decodeBech32Pubkey;
    } });
    Object.defineProperty(exports, "encodeAminoPubkey", { enumerable: true, get: function() {
      return encoding_1.encodeAminoPubkey;
    } });
    Object.defineProperty(exports, "encodeBech32Pubkey", { enumerable: true, get: function() {
      return encoding_1.encodeBech32Pubkey;
    } });
    Object.defineProperty(exports, "encodeEd25519Pubkey", { enumerable: true, get: function() {
      return encoding_1.encodeEd25519Pubkey;
    } });
    Object.defineProperty(exports, "encodeSecp256k1Pubkey", { enumerable: true, get: function() {
      return encoding_1.encodeSecp256k1Pubkey;
    } });
    var multisig_1 = require_multisig2();
    Object.defineProperty(exports, "createMultisigThresholdPubkey", { enumerable: true, get: function() {
      return multisig_1.createMultisigThresholdPubkey;
    } });
    var omitdefault_1 = require_omitdefault();
    Object.defineProperty(exports, "omitDefault", { enumerable: true, get: function() {
      return omitdefault_1.omitDefault;
    } });
    var paths_1 = require_paths();
    Object.defineProperty(exports, "makeCosmoshubPath", { enumerable: true, get: function() {
      return paths_1.makeCosmoshubPath;
    } });
    var pubkeys_1 = require_pubkeys();
    Object.defineProperty(exports, "isEd25519Pubkey", { enumerable: true, get: function() {
      return pubkeys_1.isEd25519Pubkey;
    } });
    Object.defineProperty(exports, "isMultisigThresholdPubkey", { enumerable: true, get: function() {
      return pubkeys_1.isMultisigThresholdPubkey;
    } });
    Object.defineProperty(exports, "isSecp256k1Pubkey", { enumerable: true, get: function() {
      return pubkeys_1.isSecp256k1Pubkey;
    } });
    Object.defineProperty(exports, "isSinglePubkey", { enumerable: true, get: function() {
      return pubkeys_1.isSinglePubkey;
    } });
    Object.defineProperty(exports, "pubkeyType", { enumerable: true, get: function() {
      return pubkeys_1.pubkeyType;
    } });
    var secp256k1hdwallet_1 = require_secp256k1hdwallet();
    Object.defineProperty(exports, "extractKdfConfiguration", { enumerable: true, get: function() {
      return secp256k1hdwallet_1.extractKdfConfiguration;
    } });
    Object.defineProperty(exports, "Secp256k1HdWallet", { enumerable: true, get: function() {
      return secp256k1hdwallet_1.Secp256k1HdWallet;
    } });
    var secp256k1wallet_1 = require_secp256k1wallet();
    Object.defineProperty(exports, "Secp256k1Wallet", { enumerable: true, get: function() {
      return secp256k1wallet_1.Secp256k1Wallet;
    } });
    var signature_1 = require_signature();
    Object.defineProperty(exports, "decodeSignature", { enumerable: true, get: function() {
      return signature_1.decodeSignature;
    } });
    Object.defineProperty(exports, "encodeSecp256k1Signature", { enumerable: true, get: function() {
      return signature_1.encodeSecp256k1Signature;
    } });
    var signdoc_1 = require_signdoc();
    Object.defineProperty(exports, "makeSignDoc", { enumerable: true, get: function() {
      return signdoc_1.makeSignDoc;
    } });
    Object.defineProperty(exports, "serializeSignDoc", { enumerable: true, get: function() {
      return signdoc_1.serializeSignDoc;
    } });
    var stdtx_1 = require_stdtx();
    Object.defineProperty(exports, "isStdTx", { enumerable: true, get: function() {
      return stdtx_1.isStdTx;
    } });
    Object.defineProperty(exports, "makeStdTx", { enumerable: true, get: function() {
      return stdtx_1.makeStdTx;
    } });
    var wallet_1 = require_wallet();
    Object.defineProperty(exports, "executeKdf", { enumerable: true, get: function() {
      return wallet_1.executeKdf;
    } });
  }
});

// ../../node_modules/.pnpm/@cosmjs+proto-signing@0.32.4/node_modules/@cosmjs/proto-signing/build/signing.js
var require_signing2 = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+proto-signing@0.32.4/node_modules/@cosmjs/proto-signing/build/signing.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.makeSignBytes = exports.makeSignDoc = exports.makeAuthInfoBytes = void 0;
    var utils_1 = require_build3();
    var signing_1 = require_signing();
    var tx_1 = require_tx();
    function makeSignerInfos(signers, signMode) {
      return signers.map(({ pubkey, sequence }) => ({
        publicKey: pubkey,
        modeInfo: {
          single: { mode: signMode }
        },
        sequence: BigInt(sequence)
      }));
    }
    function makeAuthInfoBytes(signers, feeAmount, gasLimit, feeGranter, feePayer, signMode = signing_1.SignMode.SIGN_MODE_DIRECT) {
      (0, utils_1.assert)(feeGranter === void 0 || typeof feeGranter === "string", "feeGranter must be undefined or string");
      (0, utils_1.assert)(feePayer === void 0 || typeof feePayer === "string", "feePayer must be undefined or string");
      const authInfo = tx_1.AuthInfo.fromPartial({
        signerInfos: makeSignerInfos(signers, signMode),
        fee: {
          amount: [...feeAmount],
          gasLimit: BigInt(gasLimit),
          granter: feeGranter,
          payer: feePayer
        }
      });
      return tx_1.AuthInfo.encode(authInfo).finish();
    }
    exports.makeAuthInfoBytes = makeAuthInfoBytes;
    function makeSignDoc(bodyBytes, authInfoBytes, chainId, accountNumber) {
      return {
        bodyBytes,
        authInfoBytes,
        chainId,
        accountNumber: BigInt(accountNumber)
      };
    }
    exports.makeSignDoc = makeSignDoc;
    function makeSignBytes({ accountNumber, authInfoBytes, bodyBytes, chainId }) {
      const signDoc = tx_1.SignDoc.fromPartial({
        accountNumber,
        authInfoBytes,
        bodyBytes,
        chainId
      });
      return tx_1.SignDoc.encode(signDoc).finish();
    }
    exports.makeSignBytes = makeSignBytes;
  }
});

// ../../node_modules/.pnpm/@cosmjs+proto-signing@0.32.4/node_modules/@cosmjs/proto-signing/build/wallet.js
var require_wallet2 = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+proto-signing@0.32.4/node_modules/@cosmjs/proto-signing/build/wallet.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.decrypt = exports.encrypt = exports.supportedAlgorithms = exports.executeKdf = exports.cosmjsSalt = void 0;
    var crypto_1 = require_build4();
    var encoding_1 = require_build2();
    exports.cosmjsSalt = (0, encoding_1.toAscii)("The CosmJS salt.");
    async function executeKdf(password, configuration) {
      switch (configuration.algorithm) {
        case "argon2id": {
          const options = configuration.params;
          if (!(0, crypto_1.isArgon2idOptions)(options))
            throw new Error("Invalid format of argon2id params");
          return crypto_1.Argon2id.execute(password, exports.cosmjsSalt, options);
        }
        default:
          throw new Error("Unsupported KDF algorithm");
      }
    }
    exports.executeKdf = executeKdf;
    exports.supportedAlgorithms = {
      xchacha20poly1305Ietf: "xchacha20poly1305-ietf"
    };
    async function encrypt(plaintext, encryptionKey, config) {
      switch (config.algorithm) {
        case exports.supportedAlgorithms.xchacha20poly1305Ietf: {
          const nonce = crypto_1.Random.getBytes(crypto_1.xchacha20NonceLength);
          return new Uint8Array([
            ...nonce,
            ...await crypto_1.Xchacha20poly1305Ietf.encrypt(plaintext, encryptionKey, nonce)
          ]);
        }
        default:
          throw new Error(`Unsupported encryption algorithm: '${config.algorithm}'`);
      }
    }
    exports.encrypt = encrypt;
    async function decrypt(ciphertext, encryptionKey, config) {
      switch (config.algorithm) {
        case exports.supportedAlgorithms.xchacha20poly1305Ietf: {
          const nonce = ciphertext.slice(0, crypto_1.xchacha20NonceLength);
          return crypto_1.Xchacha20poly1305Ietf.decrypt(ciphertext.slice(crypto_1.xchacha20NonceLength), encryptionKey, nonce);
        }
        default:
          throw new Error(`Unsupported encryption algorithm: '${config.algorithm}'`);
      }
    }
    exports.decrypt = decrypt;
  }
});

// ../../node_modules/.pnpm/@cosmjs+proto-signing@0.32.4/node_modules/@cosmjs/proto-signing/build/directsecp256k1hdwallet.js
var require_directsecp256k1hdwallet = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+proto-signing@0.32.4/node_modules/@cosmjs/proto-signing/build/directsecp256k1hdwallet.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DirectSecp256k1HdWallet = exports.extractKdfConfiguration = void 0;
    var amino_1 = require_build5();
    var crypto_1 = require_build4();
    var encoding_1 = require_build2();
    var utils_1 = require_build3();
    var signing_1 = require_signing2();
    var wallet_1 = require_wallet2();
    var serializationTypeV1 = "directsecp256k1hdwallet-v1";
    var basicPasswordHashingOptions = {
      algorithm: "argon2id",
      params: {
        outputLength: 32,
        opsLimit: 24,
        memLimitKib: 12 * 1024
      }
    };
    function isDerivationJson(thing) {
      if (!(0, utils_1.isNonNullObject)(thing))
        return false;
      if (typeof thing.hdPath !== "string")
        return false;
      if (typeof thing.prefix !== "string")
        return false;
      return true;
    }
    function extractKdfConfigurationV1(doc) {
      return doc.kdf;
    }
    function extractKdfConfiguration(serialization) {
      const root = JSON.parse(serialization);
      if (!(0, utils_1.isNonNullObject)(root))
        throw new Error("Root document is not an object.");
      switch (root.type) {
        case serializationTypeV1:
          return extractKdfConfigurationV1(root);
        default:
          throw new Error("Unsupported serialization type");
      }
    }
    exports.extractKdfConfiguration = extractKdfConfiguration;
    var defaultOptions = {
      bip39Password: "",
      hdPaths: [(0, amino_1.makeCosmoshubPath)(0)],
      prefix: "cosmos"
    };
    var DirectSecp256k1HdWallet = class _DirectSecp256k1HdWallet {
      /**
       * Restores a wallet from the given BIP39 mnemonic.
       *
       * @param mnemonic Any valid English mnemonic.
       * @param options An optional `DirectSecp256k1HdWalletOptions` object optionally containing a bip39Password, hdPaths, and prefix.
       */
      static async fromMnemonic(mnemonic, options = {}) {
        const mnemonicChecked = new crypto_1.EnglishMnemonic(mnemonic);
        const seed = await crypto_1.Bip39.mnemonicToSeed(mnemonicChecked, options.bip39Password);
        return new _DirectSecp256k1HdWallet(mnemonicChecked, {
          ...options,
          seed
        });
      }
      /**
       * Generates a new wallet with a BIP39 mnemonic of the given length.
       *
       * @param length The number of words in the mnemonic (12, 15, 18, 21 or 24).
       * @param options An optional `DirectSecp256k1HdWalletOptions` object optionally containing a bip39Password, hdPaths, and prefix.
       */
      static async generate(length = 12, options = {}) {
        const entropyLength = 4 * Math.floor(11 * length / 33);
        const entropy = crypto_1.Random.getBytes(entropyLength);
        const mnemonic = crypto_1.Bip39.encode(entropy);
        return _DirectSecp256k1HdWallet.fromMnemonic(mnemonic.toString(), options);
      }
      /**
       * Restores a wallet from an encrypted serialization.
       *
       * @param password The user provided password used to generate an encryption key via a KDF.
       *                 This is not normalized internally (see "Unicode normalization" to learn more).
       */
      static async deserialize(serialization, password) {
        const root = JSON.parse(serialization);
        if (!(0, utils_1.isNonNullObject)(root))
          throw new Error("Root document is not an object.");
        switch (root.type) {
          case serializationTypeV1:
            return _DirectSecp256k1HdWallet.deserializeTypeV1(serialization, password);
          default:
            throw new Error("Unsupported serialization type");
        }
      }
      /**
       * Restores a wallet from an encrypted serialization.
       *
       * This is an advanced alternative to calling `deserialize(serialization, password)` directly, which allows
       * you to offload the KDF execution to a non-UI thread (e.g. in a WebWorker).
       *
       * The caller is responsible for ensuring the key was derived with the given KDF configuration. This can be
       * done using `extractKdfConfiguration(serialization)` and `executeKdf(password, kdfConfiguration)` from this package.
       */
      static async deserializeWithEncryptionKey(serialization, encryptionKey) {
        const root = JSON.parse(serialization);
        if (!(0, utils_1.isNonNullObject)(root))
          throw new Error("Root document is not an object.");
        const untypedRoot = root;
        switch (untypedRoot.type) {
          case serializationTypeV1: {
            const decryptedBytes = await (0, wallet_1.decrypt)((0, encoding_1.fromBase64)(untypedRoot.data), encryptionKey, untypedRoot.encryption);
            const decryptedDocument = JSON.parse((0, encoding_1.fromUtf8)(decryptedBytes));
            const { mnemonic, accounts } = decryptedDocument;
            (0, utils_1.assert)(typeof mnemonic === "string");
            if (!Array.isArray(accounts))
              throw new Error("Property 'accounts' is not an array");
            if (!accounts.every((account) => isDerivationJson(account))) {
              throw new Error("Account is not in the correct format.");
            }
            const firstPrefix = accounts[0].prefix;
            if (!accounts.every(({ prefix }) => prefix === firstPrefix)) {
              throw new Error("Accounts do not all have the same prefix");
            }
            const hdPaths = accounts.map(({ hdPath }) => (0, crypto_1.stringToPath)(hdPath));
            return _DirectSecp256k1HdWallet.fromMnemonic(mnemonic, {
              hdPaths,
              prefix: firstPrefix
            });
          }
          default:
            throw new Error("Unsupported serialization type");
        }
      }
      static async deserializeTypeV1(serialization, password) {
        const root = JSON.parse(serialization);
        if (!(0, utils_1.isNonNullObject)(root))
          throw new Error("Root document is not an object.");
        const encryptionKey = await (0, wallet_1.executeKdf)(password, root.kdf);
        return _DirectSecp256k1HdWallet.deserializeWithEncryptionKey(serialization, encryptionKey);
      }
      constructor(mnemonic, options) {
        const prefix = options.prefix ?? defaultOptions.prefix;
        const hdPaths = options.hdPaths ?? defaultOptions.hdPaths;
        this.secret = mnemonic;
        this.seed = options.seed;
        this.accounts = hdPaths.map((hdPath) => ({
          hdPath,
          prefix
        }));
      }
      get mnemonic() {
        return this.secret.toString();
      }
      async getAccounts() {
        const accountsWithPrivkeys = await this.getAccountsWithPrivkeys();
        return accountsWithPrivkeys.map(({ algo, pubkey, address }) => ({
          algo,
          pubkey,
          address
        }));
      }
      async signDirect(signerAddress, signDoc) {
        const accounts = await this.getAccountsWithPrivkeys();
        const account = accounts.find(({ address }) => address === signerAddress);
        if (account === void 0) {
          throw new Error(`Address ${signerAddress} not found in wallet`);
        }
        const { privkey, pubkey } = account;
        const signBytes = (0, signing_1.makeSignBytes)(signDoc);
        const hashedMessage = (0, crypto_1.sha256)(signBytes);
        const signature = await crypto_1.Secp256k1.createSignature(hashedMessage, privkey);
        const signatureBytes = new Uint8Array([...signature.r(32), ...signature.s(32)]);
        const stdSignature = (0, amino_1.encodeSecp256k1Signature)(pubkey, signatureBytes);
        return {
          signed: signDoc,
          signature: stdSignature
        };
      }
      /**
       * Generates an encrypted serialization of this wallet.
       *
       * @param password The user provided password used to generate an encryption key via a KDF.
       *                 This is not normalized internally (see "Unicode normalization" to learn more).
       */
      async serialize(password) {
        const kdfConfiguration = basicPasswordHashingOptions;
        const encryptionKey = await (0, wallet_1.executeKdf)(password, kdfConfiguration);
        return this.serializeWithEncryptionKey(encryptionKey, kdfConfiguration);
      }
      /**
       * Generates an encrypted serialization of this wallet.
       *
       * This is an advanced alternative to calling `serialize(password)` directly, which allows you to
       * offload the KDF execution to a non-UI thread (e.g. in a WebWorker).
       *
       * The caller is responsible for ensuring the key was derived with the given KDF options. If this
       * is not the case, the wallet cannot be restored with the original password.
       */
      async serializeWithEncryptionKey(encryptionKey, kdfConfiguration) {
        const dataToEncrypt = {
          mnemonic: this.mnemonic,
          accounts: this.accounts.map(({ hdPath, prefix }) => ({
            hdPath: (0, crypto_1.pathToString)(hdPath),
            prefix
          }))
        };
        const dataToEncryptRaw = (0, encoding_1.toUtf8)(JSON.stringify(dataToEncrypt));
        const encryptionConfiguration = {
          algorithm: wallet_1.supportedAlgorithms.xchacha20poly1305Ietf
        };
        const encryptedData = await (0, wallet_1.encrypt)(dataToEncryptRaw, encryptionKey, encryptionConfiguration);
        const out = {
          type: serializationTypeV1,
          kdf: kdfConfiguration,
          encryption: encryptionConfiguration,
          data: (0, encoding_1.toBase64)(encryptedData)
        };
        return JSON.stringify(out);
      }
      async getKeyPair(hdPath) {
        const { privkey } = crypto_1.Slip10.derivePath(crypto_1.Slip10Curve.Secp256k1, this.seed, hdPath);
        const { pubkey } = await crypto_1.Secp256k1.makeKeypair(privkey);
        return {
          privkey,
          pubkey: crypto_1.Secp256k1.compressPubkey(pubkey)
        };
      }
      async getAccountsWithPrivkeys() {
        return Promise.all(this.accounts.map(async ({ hdPath, prefix }) => {
          const { privkey, pubkey } = await this.getKeyPair(hdPath);
          const address = (0, encoding_1.toBech32)(prefix, (0, amino_1.rawSecp256k1PubkeyToRawAddress)(pubkey));
          return {
            algo: "secp256k1",
            privkey,
            pubkey,
            address
          };
        }));
      }
    };
    exports.DirectSecp256k1HdWallet = DirectSecp256k1HdWallet;
  }
});

// ../../node_modules/.pnpm/@cosmjs+proto-signing@0.32.4/node_modules/@cosmjs/proto-signing/build/directsecp256k1wallet.js
var require_directsecp256k1wallet = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+proto-signing@0.32.4/node_modules/@cosmjs/proto-signing/build/directsecp256k1wallet.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DirectSecp256k1Wallet = void 0;
    var amino_1 = require_build5();
    var crypto_1 = require_build4();
    var encoding_1 = require_build2();
    var signing_1 = require_signing2();
    var DirectSecp256k1Wallet = class _DirectSecp256k1Wallet {
      /**
       * Creates a DirectSecp256k1Wallet from the given private key
       *
       * @param privkey The private key.
       * @param prefix The bech32 address prefix (human readable part). Defaults to "cosmos".
       */
      static async fromKey(privkey, prefix = "cosmos") {
        const uncompressed = (await crypto_1.Secp256k1.makeKeypair(privkey)).pubkey;
        return new _DirectSecp256k1Wallet(privkey, crypto_1.Secp256k1.compressPubkey(uncompressed), prefix);
      }
      constructor(privkey, pubkey, prefix) {
        this.privkey = privkey;
        this.pubkey = pubkey;
        this.prefix = prefix;
      }
      get address() {
        return (0, encoding_1.toBech32)(this.prefix, (0, amino_1.rawSecp256k1PubkeyToRawAddress)(this.pubkey));
      }
      async getAccounts() {
        return [
          {
            algo: "secp256k1",
            address: this.address,
            pubkey: this.pubkey
          }
        ];
      }
      async signDirect(address, signDoc) {
        const signBytes = (0, signing_1.makeSignBytes)(signDoc);
        if (address !== this.address) {
          throw new Error(`Address ${address} not found in wallet`);
        }
        const hashedMessage = (0, crypto_1.sha256)(signBytes);
        const signature = await crypto_1.Secp256k1.createSignature(hashedMessage, this.privkey);
        const signatureBytes = new Uint8Array([...signature.r(32), ...signature.s(32)]);
        const stdSignature = (0, amino_1.encodeSecp256k1Signature)(this.pubkey, signatureBytes);
        return {
          signed: signDoc,
          signature: stdSignature
        };
      }
    };
    exports.DirectSecp256k1Wallet = DirectSecp256k1Wallet;
  }
});

// ../../node_modules/.pnpm/@cosmjs+proto-signing@0.32.4/node_modules/@cosmjs/proto-signing/build/paths.js
var require_paths2 = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+proto-signing@0.32.4/node_modules/@cosmjs/proto-signing/build/paths.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.makeCosmoshubPath = void 0;
    var crypto_1 = require_build4();
    function makeCosmoshubPath(a) {
      return [
        crypto_1.Slip10RawIndex.hardened(44),
        crypto_1.Slip10RawIndex.hardened(118),
        crypto_1.Slip10RawIndex.hardened(0),
        crypto_1.Slip10RawIndex.normal(0),
        crypto_1.Slip10RawIndex.normal(a)
      ];
    }
    exports.makeCosmoshubPath = makeCosmoshubPath;
  }
});

// ../../node_modules/.pnpm/@cosmjs+proto-signing@0.32.4/node_modules/@cosmjs/proto-signing/build/pubkey.js
var require_pubkey = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+proto-signing@0.32.4/node_modules/@cosmjs/proto-signing/build/pubkey.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.decodeOptionalPubkey = exports.decodePubkey = exports.anyToSinglePubkey = exports.encodePubkey = void 0;
    var amino_1 = require_build5();
    var encoding_1 = require_build2();
    var math_1 = require_build();
    var keys_1 = require_keys();
    var keys_2 = require_keys2();
    var keys_3 = require_keys3();
    var any_1 = require_any();
    function encodePubkey(pubkey) {
      if ((0, amino_1.isSecp256k1Pubkey)(pubkey)) {
        const pubkeyProto = keys_3.PubKey.fromPartial({
          key: (0, encoding_1.fromBase64)(pubkey.value)
        });
        return any_1.Any.fromPartial({
          typeUrl: "/cosmos.crypto.secp256k1.PubKey",
          value: Uint8Array.from(keys_3.PubKey.encode(pubkeyProto).finish())
        });
      } else if ((0, amino_1.isEd25519Pubkey)(pubkey)) {
        const pubkeyProto = keys_1.PubKey.fromPartial({
          key: (0, encoding_1.fromBase64)(pubkey.value)
        });
        return any_1.Any.fromPartial({
          typeUrl: "/cosmos.crypto.ed25519.PubKey",
          value: Uint8Array.from(keys_1.PubKey.encode(pubkeyProto).finish())
        });
      } else if ((0, amino_1.isMultisigThresholdPubkey)(pubkey)) {
        const pubkeyProto = keys_2.LegacyAminoPubKey.fromPartial({
          threshold: math_1.Uint53.fromString(pubkey.value.threshold).toNumber(),
          publicKeys: pubkey.value.pubkeys.map(encodePubkey)
        });
        return any_1.Any.fromPartial({
          typeUrl: "/cosmos.crypto.multisig.LegacyAminoPubKey",
          value: Uint8Array.from(keys_2.LegacyAminoPubKey.encode(pubkeyProto).finish())
        });
      } else {
        throw new Error(`Pubkey type ${pubkey.type} not recognized`);
      }
    }
    exports.encodePubkey = encodePubkey;
    function anyToSinglePubkey(pubkey) {
      switch (pubkey.typeUrl) {
        case "/cosmos.crypto.secp256k1.PubKey": {
          const { key } = keys_3.PubKey.decode(pubkey.value);
          return (0, amino_1.encodeSecp256k1Pubkey)(key);
        }
        case "/cosmos.crypto.ed25519.PubKey": {
          const { key } = keys_1.PubKey.decode(pubkey.value);
          return (0, amino_1.encodeEd25519Pubkey)(key);
        }
        default:
          throw new Error(`Pubkey type_url ${pubkey.typeUrl} not recognized as single public key type`);
      }
    }
    exports.anyToSinglePubkey = anyToSinglePubkey;
    function decodePubkey(pubkey) {
      switch (pubkey.typeUrl) {
        case "/cosmos.crypto.secp256k1.PubKey":
        case "/cosmos.crypto.ed25519.PubKey": {
          return anyToSinglePubkey(pubkey);
        }
        case "/cosmos.crypto.multisig.LegacyAminoPubKey": {
          const { threshold, publicKeys } = keys_2.LegacyAminoPubKey.decode(pubkey.value);
          const out = {
            type: "tendermint/PubKeyMultisigThreshold",
            value: {
              threshold: threshold.toString(),
              pubkeys: publicKeys.map(anyToSinglePubkey)
            }
          };
          return out;
        }
        default:
          throw new Error(`Pubkey type URL '${pubkey.typeUrl}' not recognized`);
      }
    }
    exports.decodePubkey = decodePubkey;
    function decodeOptionalPubkey(pubkey) {
      if (!pubkey)
        return null;
      if (pubkey.typeUrl) {
        if (pubkey.value.length) {
          return decodePubkey(pubkey);
        } else {
          throw new Error(`Pubkey is an Any with type URL '${pubkey.typeUrl}' but an empty value`);
        }
      } else {
        if (pubkey.value.length) {
          throw new Error(`Pubkey is an Any with an empty type URL but a value set`);
        } else {
          return null;
        }
      }
    }
    exports.decodeOptionalPubkey = decodeOptionalPubkey;
  }
});

// ../../node_modules/.pnpm/@cosmjs+proto-signing@0.32.4/node_modules/@cosmjs/proto-signing/build/registry.js
var require_registry = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+proto-signing@0.32.4/node_modules/@cosmjs/proto-signing/build/registry.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Registry = exports.isTxBodyEncodeObject = exports.isPbjsGeneratedType = exports.isTsProtoGeneratedType = exports.isTelescopeGeneratedType = void 0;
    var tx_1 = require_tx2();
    var coin_1 = require_coin();
    var tx_2 = require_tx();
    var any_1 = require_any();
    function isTelescopeGeneratedType(type) {
      const casted = type;
      return typeof casted.fromPartial === "function" && typeof casted.typeUrl == "string";
    }
    exports.isTelescopeGeneratedType = isTelescopeGeneratedType;
    function isTsProtoGeneratedType(type) {
      return typeof type.fromPartial === "function";
    }
    exports.isTsProtoGeneratedType = isTsProtoGeneratedType;
    function isPbjsGeneratedType(type) {
      return !isTsProtoGeneratedType(type);
    }
    exports.isPbjsGeneratedType = isPbjsGeneratedType;
    var defaultTypeUrls = {
      cosmosCoin: "/cosmos.base.v1beta1.Coin",
      cosmosMsgSend: "/cosmos.bank.v1beta1.MsgSend",
      cosmosTxBody: "/cosmos.tx.v1beta1.TxBody",
      googleAny: "/google.protobuf.Any"
    };
    function isTxBodyEncodeObject(encodeObject) {
      return encodeObject.typeUrl === "/cosmos.tx.v1beta1.TxBody";
    }
    exports.isTxBodyEncodeObject = isTxBodyEncodeObject;
    var Registry = class {
      /**
       * Creates a new Registry for mapping protobuf type identifiers/type URLs to
       * actual implementations. Those implementations are typically generated with ts-proto
       * but we also support protobuf.js as a type generator.
       *
       * If there is no parameter given, a `new Registry()` adds the types `Coin` and `MsgSend`
       * for historic reasons. Those can be overriden by customTypes.
       *
       * There are currently two methods for adding new types:
       * 1. Passing types to the constructor.
       * 2. Using the `register()` method
       */
      constructor(customTypes) {
        const { cosmosCoin, cosmosMsgSend } = defaultTypeUrls;
        this.types = customTypes ? new Map([...customTypes]) : /* @__PURE__ */ new Map([
          [cosmosCoin, coin_1.Coin],
          [cosmosMsgSend, tx_1.MsgSend]
        ]);
      }
      register(typeUrl, type) {
        this.types.set(typeUrl, type);
      }
      /**
       * Looks up a type that was previously added to the registry.
       *
       * The generator information (ts-proto or pbjs) gets lost along the way.
       * If you need to work with the result type in TypeScript, you can use:
       *
       * ```
       * import { assert } from "@cosmjs/utils";
       *
       * const Coin = registry.lookupType("/cosmos.base.v1beta1.Coin");
       * assert(Coin); // Ensures not unset
       * assert(isTsProtoGeneratedType(Coin)); // Ensures this is the type we expect
       *
       * // Coin is typed TsProtoGeneratedType now.
       * ```
       */
      lookupType(typeUrl) {
        return this.types.get(typeUrl);
      }
      lookupTypeWithError(typeUrl) {
        const type = this.lookupType(typeUrl);
        if (!type) {
          throw new Error(`Unregistered type url: ${typeUrl}`);
        }
        return type;
      }
      /**
       * Takes a typeUrl/value pair and encodes the value to protobuf if
       * the given type was previously registered.
       *
       * If the value has to be wrapped in an Any, this needs to be done
       * manually after this call. Or use `encodeAsAny` instead.
       */
      encode(encodeObject) {
        const { value, typeUrl } = encodeObject;
        if (isTxBodyEncodeObject(encodeObject)) {
          return this.encodeTxBody(value);
        }
        const type = this.lookupTypeWithError(typeUrl);
        const instance = isTelescopeGeneratedType(type) || isTsProtoGeneratedType(type) ? type.fromPartial(value) : type.create(value);
        return type.encode(instance).finish();
      }
      /**
       * Takes a typeUrl/value pair and encodes the value to an Any if
       * the given type was previously registered.
       */
      encodeAsAny(encodeObject) {
        const binaryValue = this.encode(encodeObject);
        return any_1.Any.fromPartial({
          typeUrl: encodeObject.typeUrl,
          value: binaryValue
        });
      }
      encodeTxBody(txBodyFields) {
        var _a;
        const wrappedMessages = txBodyFields.messages.map((message) => this.encodeAsAny(message));
        const txBody = tx_2.TxBody.fromPartial({
          ...txBodyFields,
          timeoutHeight: BigInt(((_a = txBodyFields.timeoutHeight) == null ? void 0 : _a.toString()) ?? "0"),
          messages: wrappedMessages
        });
        return tx_2.TxBody.encode(txBody).finish();
      }
      decode({ typeUrl, value }) {
        if (typeUrl === defaultTypeUrls.cosmosTxBody) {
          return this.decodeTxBody(value);
        }
        const type = this.lookupTypeWithError(typeUrl);
        const decoded = type.decode(value);
        Object.entries(decoded).forEach(([key, val]) => {
          if (typeof Buffer !== "undefined" && typeof Buffer.isBuffer !== "undefined" && Buffer.isBuffer(val)) {
            decoded[key] = Uint8Array.from(val);
          }
        });
        return decoded;
      }
      decodeTxBody(txBody) {
        const decodedTxBody = tx_2.TxBody.decode(txBody);
        return {
          ...decodedTxBody,
          messages: decodedTxBody.messages.map(({ typeUrl, value }) => {
            if (!typeUrl) {
              throw new Error("Missing type_url in Any");
            }
            if (!value) {
              throw new Error("Missing value in Any");
            }
            return this.decode({ typeUrl, value });
          })
        };
      }
    };
    exports.Registry = Registry;
  }
});

// ../../node_modules/.pnpm/@cosmjs+proto-signing@0.32.4/node_modules/@cosmjs/proto-signing/build/signer.js
var require_signer = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+proto-signing@0.32.4/node_modules/@cosmjs/proto-signing/build/signer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isOfflineDirectSigner = void 0;
    function isOfflineDirectSigner(signer) {
      return signer.signDirect !== void 0;
    }
    exports.isOfflineDirectSigner = isOfflineDirectSigner;
  }
});

// ../../node_modules/.pnpm/@cosmjs+proto-signing@0.32.4/node_modules/@cosmjs/proto-signing/build/index.js
var require_build6 = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+proto-signing@0.32.4/node_modules/@cosmjs/proto-signing/build/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseCoins = exports.coins = exports.coin = exports.executeKdf = exports.makeSignDoc = exports.makeSignBytes = exports.makeAuthInfoBytes = exports.isOfflineDirectSigner = exports.Registry = exports.isTxBodyEncodeObject = exports.isTsProtoGeneratedType = exports.isPbjsGeneratedType = exports.encodePubkey = exports.decodePubkey = exports.decodeOptionalPubkey = exports.anyToSinglePubkey = exports.makeCosmoshubPath = exports.DirectSecp256k1Wallet = exports.extractKdfConfiguration = exports.DirectSecp256k1HdWallet = exports.decodeTxRaw = void 0;
    var decode_1 = require_decode();
    Object.defineProperty(exports, "decodeTxRaw", { enumerable: true, get: function() {
      return decode_1.decodeTxRaw;
    } });
    var directsecp256k1hdwallet_1 = require_directsecp256k1hdwallet();
    Object.defineProperty(exports, "DirectSecp256k1HdWallet", { enumerable: true, get: function() {
      return directsecp256k1hdwallet_1.DirectSecp256k1HdWallet;
    } });
    Object.defineProperty(exports, "extractKdfConfiguration", { enumerable: true, get: function() {
      return directsecp256k1hdwallet_1.extractKdfConfiguration;
    } });
    var directsecp256k1wallet_1 = require_directsecp256k1wallet();
    Object.defineProperty(exports, "DirectSecp256k1Wallet", { enumerable: true, get: function() {
      return directsecp256k1wallet_1.DirectSecp256k1Wallet;
    } });
    var paths_1 = require_paths2();
    Object.defineProperty(exports, "makeCosmoshubPath", { enumerable: true, get: function() {
      return paths_1.makeCosmoshubPath;
    } });
    var pubkey_1 = require_pubkey();
    Object.defineProperty(exports, "anyToSinglePubkey", { enumerable: true, get: function() {
      return pubkey_1.anyToSinglePubkey;
    } });
    Object.defineProperty(exports, "decodeOptionalPubkey", { enumerable: true, get: function() {
      return pubkey_1.decodeOptionalPubkey;
    } });
    Object.defineProperty(exports, "decodePubkey", { enumerable: true, get: function() {
      return pubkey_1.decodePubkey;
    } });
    Object.defineProperty(exports, "encodePubkey", { enumerable: true, get: function() {
      return pubkey_1.encodePubkey;
    } });
    var registry_1 = require_registry();
    Object.defineProperty(exports, "isPbjsGeneratedType", { enumerable: true, get: function() {
      return registry_1.isPbjsGeneratedType;
    } });
    Object.defineProperty(exports, "isTsProtoGeneratedType", { enumerable: true, get: function() {
      return registry_1.isTsProtoGeneratedType;
    } });
    Object.defineProperty(exports, "isTxBodyEncodeObject", { enumerable: true, get: function() {
      return registry_1.isTxBodyEncodeObject;
    } });
    Object.defineProperty(exports, "Registry", { enumerable: true, get: function() {
      return registry_1.Registry;
    } });
    var signer_1 = require_signer();
    Object.defineProperty(exports, "isOfflineDirectSigner", { enumerable: true, get: function() {
      return signer_1.isOfflineDirectSigner;
    } });
    var signing_1 = require_signing2();
    Object.defineProperty(exports, "makeAuthInfoBytes", { enumerable: true, get: function() {
      return signing_1.makeAuthInfoBytes;
    } });
    Object.defineProperty(exports, "makeSignBytes", { enumerable: true, get: function() {
      return signing_1.makeSignBytes;
    } });
    Object.defineProperty(exports, "makeSignDoc", { enumerable: true, get: function() {
      return signing_1.makeSignDoc;
    } });
    var wallet_1 = require_wallet2();
    Object.defineProperty(exports, "executeKdf", { enumerable: true, get: function() {
      return wallet_1.executeKdf;
    } });
    var amino_1 = require_build5();
    Object.defineProperty(exports, "coin", { enumerable: true, get: function() {
      return amino_1.coin;
    } });
    Object.defineProperty(exports, "coins", { enumerable: true, get: function() {
      return amino_1.coins;
    } });
    Object.defineProperty(exports, "parseCoins", { enumerable: true, get: function() {
      return amino_1.parseCoins;
    } });
  }
});

// ../../node_modules/.pnpm/@cosmjs+stargate@0.32.4/node_modules/@cosmjs/stargate/build/accounts.js
var require_accounts = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+stargate@0.32.4/node_modules/@cosmjs/stargate/build/accounts.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.accountFromAny = void 0;
    var math_1 = require_build();
    var proto_signing_1 = require_build6();
    var utils_1 = require_build3();
    var auth_1 = require_auth();
    var vesting_1 = require_vesting();
    function uint64FromProto(input) {
      return math_1.Uint64.fromString(input.toString());
    }
    function accountFromBaseAccount(input) {
      const { address, pubKey, accountNumber, sequence } = input;
      const pubkey = (0, proto_signing_1.decodeOptionalPubkey)(pubKey);
      return {
        address,
        pubkey,
        accountNumber: uint64FromProto(accountNumber).toNumber(),
        sequence: uint64FromProto(sequence).toNumber()
      };
    }
    function accountFromAny(input) {
      var _a, _b, _c, _d, _e, _f, _g;
      const { typeUrl, value } = input;
      switch (typeUrl) {
        case "/cosmos.auth.v1beta1.BaseAccount":
          return accountFromBaseAccount(auth_1.BaseAccount.decode(value));
        case "/cosmos.auth.v1beta1.ModuleAccount": {
          const baseAccount = auth_1.ModuleAccount.decode(value).baseAccount;
          (0, utils_1.assert)(baseAccount);
          return accountFromBaseAccount(baseAccount);
        }
        case "/cosmos.vesting.v1beta1.BaseVestingAccount": {
          const baseAccount = (_a = vesting_1.BaseVestingAccount.decode(value)) == null ? void 0 : _a.baseAccount;
          (0, utils_1.assert)(baseAccount);
          return accountFromBaseAccount(baseAccount);
        }
        case "/cosmos.vesting.v1beta1.ContinuousVestingAccount": {
          const baseAccount = (_c = (_b = vesting_1.ContinuousVestingAccount.decode(value)) == null ? void 0 : _b.baseVestingAccount) == null ? void 0 : _c.baseAccount;
          (0, utils_1.assert)(baseAccount);
          return accountFromBaseAccount(baseAccount);
        }
        case "/cosmos.vesting.v1beta1.DelayedVestingAccount": {
          const baseAccount = (_e = (_d = vesting_1.DelayedVestingAccount.decode(value)) == null ? void 0 : _d.baseVestingAccount) == null ? void 0 : _e.baseAccount;
          (0, utils_1.assert)(baseAccount);
          return accountFromBaseAccount(baseAccount);
        }
        case "/cosmos.vesting.v1beta1.PeriodicVestingAccount": {
          const baseAccount = (_g = (_f = vesting_1.PeriodicVestingAccount.decode(value)) == null ? void 0 : _f.baseVestingAccount) == null ? void 0 : _g.baseAccount;
          (0, utils_1.assert)(baseAccount);
          return accountFromBaseAccount(baseAccount);
        }
        default:
          throw new Error(`Unsupported type: '${typeUrl}'`);
      }
    }
    exports.accountFromAny = accountFromAny;
  }
});

// ../../node_modules/.pnpm/@cosmjs+stargate@0.32.4/node_modules/@cosmjs/stargate/build/aminotypes.js
var require_aminotypes = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+stargate@0.32.4/node_modules/@cosmjs/stargate/build/aminotypes.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AminoTypes = void 0;
    var AminoTypes = class {
      constructor(types) {
        this.register = types;
      }
      toAmino({ typeUrl, value }) {
        const converter = this.register[typeUrl];
        if (!converter) {
          throw new Error(`Type URL '${typeUrl}' does not exist in the Amino message type register. If you need support for this message type, you can pass in additional entries to the AminoTypes constructor. If you think this message type should be included by default, please open an issue at https://github.com/cosmos/cosmjs/issues.`);
        }
        return {
          type: converter.aminoType,
          value: converter.toAmino(value)
        };
      }
      fromAmino({ type, value }) {
        const matches = Object.entries(this.register).filter(([_typeUrl, { aminoType }]) => aminoType === type);
        switch (matches.length) {
          case 0: {
            throw new Error(`Amino type identifier '${type}' does not exist in the Amino message type register. If you need support for this message type, you can pass in additional entries to the AminoTypes constructor. If you think this message type should be included by default, please open an issue at https://github.com/cosmos/cosmjs/issues.`);
          }
          case 1: {
            const [typeUrl, converter] = matches[0];
            return {
              typeUrl,
              value: converter.fromAmino(value)
            };
          }
          default:
            throw new Error(`Multiple types are registered with Amino type identifier '${type}': '` + matches.map(([key, _value]) => key).sort().join("', '") + "'. Thus fromAmino cannot be performed.");
        }
      }
    };
    exports.AminoTypes = AminoTypes;
  }
});

// ../../node_modules/.pnpm/@cosmjs+stargate@0.32.4/node_modules/@cosmjs/stargate/build/events.js
var require_events = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+stargate@0.32.4/node_modules/@cosmjs/stargate/build/events.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.fromTendermintEvent = void 0;
    var encoding_1 = require_build2();
    function fromTendermintEvent(event) {
      return {
        type: event.type,
        attributes: event.attributes.map((attr) => ({
          key: typeof attr.key == "string" ? attr.key : (0, encoding_1.fromUtf8)(attr.key, true),
          value: typeof attr.value == "string" ? attr.value : (0, encoding_1.fromUtf8)(attr.value, true)
        }))
      };
    }
    exports.fromTendermintEvent = fromTendermintEvent;
  }
});

// ../../node_modules/.pnpm/@cosmjs+stargate@0.32.4/node_modules/@cosmjs/stargate/build/fee.js
var require_fee = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+stargate@0.32.4/node_modules/@cosmjs/stargate/build/fee.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.calculateFee = exports.GasPrice = void 0;
    var math_1 = require_build();
    var proto_signing_1 = require_build6();
    function checkDenom(denom) {
      if (denom.length < 3 || denom.length > 128) {
        throw new Error("Denom must be between 3 and 128 characters");
      }
    }
    var GasPrice = class _GasPrice {
      constructor(amount, denom) {
        this.amount = amount;
        this.denom = denom;
      }
      /**
       * Parses a gas price formatted as `<amount><denom>`, e.g. `GasPrice.fromString("0.012utoken")`.
       *
       * The denom must match the Cosmos SDK 0.42 pattern (https://github.com/cosmos/cosmos-sdk/blob/v0.42.4/types/coin.go#L599-L601).
       * See `GasPrice` in @cosmjs/stargate for a more generic matcher.
       *
       * Separators are not yet supported.
       */
      static fromString(gasPrice) {
        const matchResult = gasPrice.match(/^([0-9.]+)([a-zA-Z][a-zA-Z0-9/:._-]*)$/);
        if (!matchResult) {
          throw new Error("Invalid gas price string");
        }
        const [_, amount, denom] = matchResult;
        checkDenom(denom);
        const fractionalDigits = 18;
        const decimalAmount = math_1.Decimal.fromUserInput(amount, fractionalDigits);
        return new _GasPrice(decimalAmount, denom);
      }
      /**
       * Returns a string representation of this gas price, e.g. "0.025uatom".
       * This can be used as an input to `GasPrice.fromString`.
       */
      toString() {
        return this.amount.toString() + this.denom;
      }
    };
    exports.GasPrice = GasPrice;
    function calculateFee(gasLimit, gasPrice) {
      const processedGasPrice = typeof gasPrice === "string" ? GasPrice.fromString(gasPrice) : gasPrice;
      const { denom, amount: gasPriceAmount } = processedGasPrice;
      const amount = gasPriceAmount.multiply(new math_1.Uint53(gasLimit)).ceil().toString();
      return {
        amount: (0, proto_signing_1.coins)(amount, denom),
        gas: gasLimit.toString()
      };
    }
    exports.calculateFee = calculateFee;
  }
});

// ../../node_modules/.pnpm/@cosmjs+stargate@0.32.4/node_modules/@cosmjs/stargate/build/logs.js
var require_logs = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+stargate@0.32.4/node_modules/@cosmjs/stargate/build/logs.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.findAttribute = exports.parseRawLog = exports.parseLogs = exports.parseLog = exports.parseEvent = exports.parseAttribute = void 0;
    var utils_1 = require_build3();
    function parseAttribute(input) {
      if (!(0, utils_1.isNonNullObject)(input))
        throw new Error("Attribute must be a non-null object");
      const { key, value } = input;
      if (typeof key !== "string" || !key)
        throw new Error("Attribute's key must be a non-empty string");
      if (typeof value !== "string" && typeof value !== "undefined") {
        throw new Error("Attribute's value must be a string or unset");
      }
      return {
        key,
        value: value || ""
      };
    }
    exports.parseAttribute = parseAttribute;
    function parseEvent(input) {
      if (!(0, utils_1.isNonNullObject)(input))
        throw new Error("Event must be a non-null object");
      const { type, attributes } = input;
      if (typeof type !== "string" || type === "") {
        throw new Error(`Event type must be a non-empty string`);
      }
      if (!Array.isArray(attributes))
        throw new Error("Event's attributes must be an array");
      return {
        type,
        attributes: attributes.map(parseAttribute)
      };
    }
    exports.parseEvent = parseEvent;
    function parseLog(input) {
      if (!(0, utils_1.isNonNullObject)(input))
        throw new Error("Log must be a non-null object");
      const { msg_index, log, events } = input;
      if (typeof msg_index !== "number")
        throw new Error("Log's msg_index must be a number");
      if (typeof log !== "string")
        throw new Error("Log's log must be a string");
      if (!Array.isArray(events))
        throw new Error("Log's events must be an array");
      return {
        msg_index,
        log,
        events: events.map(parseEvent)
      };
    }
    exports.parseLog = parseLog;
    function parseLogs(input) {
      if (!Array.isArray(input))
        throw new Error("Logs must be an array");
      return input.map(parseLog);
    }
    exports.parseLogs = parseLogs;
    function parseRawLog(input) {
      if (!input)
        return [];
      const logsToParse = JSON.parse(input).map(({ events }, i) => ({
        msg_index: i,
        events,
        log: ""
      }));
      return parseLogs(logsToParse);
    }
    exports.parseRawLog = parseRawLog;
    function findAttribute(logs, eventType, attrKey) {
      var _a;
      const firstLogs = logs.find(() => true);
      const out = (_a = firstLogs == null ? void 0 : firstLogs.events.find((event) => event.type === eventType)) == null ? void 0 : _a.attributes.find((attr) => attr.key === attrKey);
      if (!out) {
        throw new Error(`Could not find attribute '${attrKey}' in first event of type '${eventType}' in first log.`);
      }
      return out;
    }
    exports.findAttribute = findAttribute;
  }
});

// ../../node_modules/.pnpm/@confio+ics23@0.6.8/node_modules/@confio/ics23/build/generated/codecimpl.js
var require_codecimpl = __commonJS({
  "../../node_modules/.pnpm/@confio+ics23@0.6.8/node_modules/@confio/ics23/build/generated/codecimpl.js"(exports, module) {
    "use strict";
    var $protobuf = require_minimal();
    var $Reader = $protobuf.Reader;
    var $Writer = $protobuf.Writer;
    var $util = $protobuf.util;
    var $root = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});
    $root.ics23 = function() {
      var ics23 = {};
      ics23.HashOp = function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "NO_HASH"] = 0;
        values[valuesById[1] = "SHA256"] = 1;
        values[valuesById[2] = "SHA512"] = 2;
        values[valuesById[3] = "KECCAK"] = 3;
        values[valuesById[4] = "RIPEMD160"] = 4;
        values[valuesById[5] = "BITCOIN"] = 5;
        values[valuesById[6] = "SHA512_256"] = 6;
        return values;
      }();
      ics23.LengthOp = function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "NO_PREFIX"] = 0;
        values[valuesById[1] = "VAR_PROTO"] = 1;
        values[valuesById[2] = "VAR_RLP"] = 2;
        values[valuesById[3] = "FIXED32_BIG"] = 3;
        values[valuesById[4] = "FIXED32_LITTLE"] = 4;
        values[valuesById[5] = "FIXED64_BIG"] = 5;
        values[valuesById[6] = "FIXED64_LITTLE"] = 6;
        values[valuesById[7] = "REQUIRE_32_BYTES"] = 7;
        values[valuesById[8] = "REQUIRE_64_BYTES"] = 8;
        return values;
      }();
      ics23.ExistenceProof = function() {
        function ExistenceProof(properties) {
          this.path = [];
          if (properties) {
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null)
                this[keys[i]] = properties[keys[i]];
          }
        }
        ExistenceProof.prototype.key = $util.newBuffer([]);
        ExistenceProof.prototype.value = $util.newBuffer([]);
        ExistenceProof.prototype.leaf = null;
        ExistenceProof.prototype.path = $util.emptyArray;
        ExistenceProof.create = function create(properties) {
          return new ExistenceProof(properties);
        };
        ExistenceProof.encode = function encode(message, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message.key != null && message.hasOwnProperty("key"))
            writer.uint32(
              /* id 1, wireType 2 =*/
              10
            ).bytes(message.key);
          if (message.value != null && message.hasOwnProperty("value"))
            writer.uint32(
              /* id 2, wireType 2 =*/
              18
            ).bytes(message.value);
          if (message.leaf != null && message.hasOwnProperty("leaf"))
            $root.ics23.LeafOp.encode(message.leaf, writer.uint32(
              /* id 3, wireType 2 =*/
              26
            ).fork()).ldelim();
          if (message.path != null && message.path.length)
            for (var i = 0; i < message.path.length; ++i)
              $root.ics23.InnerOp.encode(message.path[i], writer.uint32(
                /* id 4, wireType 2 =*/
                34
              ).fork()).ldelim();
          return writer;
        };
        ExistenceProof.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };
        ExistenceProof.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.ics23.ExistenceProof();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.key = reader.bytes();
                break;
              case 2:
                message.value = reader.bytes();
                break;
              case 3:
                message.leaf = $root.ics23.LeafOp.decode(reader, reader.uint32());
                break;
              case 4:
                if (!(message.path && message.path.length))
                  message.path = [];
                message.path.push($root.ics23.InnerOp.decode(reader, reader.uint32()));
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };
        ExistenceProof.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };
        ExistenceProof.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
            return "object expected";
          if (message.key != null && message.hasOwnProperty("key")) {
            if (!(message.key && typeof message.key.length === "number" || $util.isString(message.key)))
              return "key: buffer expected";
          }
          if (message.value != null && message.hasOwnProperty("value")) {
            if (!(message.value && typeof message.value.length === "number" || $util.isString(message.value)))
              return "value: buffer expected";
          }
          if (message.leaf != null && message.hasOwnProperty("leaf")) {
            var error = $root.ics23.LeafOp.verify(message.leaf);
            if (error)
              return "leaf." + error;
          }
          if (message.path != null && message.hasOwnProperty("path")) {
            if (!Array.isArray(message.path))
              return "path: array expected";
            for (var i = 0; i < message.path.length; ++i) {
              var error = $root.ics23.InnerOp.verify(message.path[i]);
              if (error)
                return "path." + error;
            }
          }
          return null;
        };
        ExistenceProof.fromObject = function fromObject(object) {
          if (object instanceof $root.ics23.ExistenceProof)
            return object;
          var message = new $root.ics23.ExistenceProof();
          if (object.key != null) {
            if (typeof object.key === "string")
              $util.base64.decode(object.key, message.key = $util.newBuffer($util.base64.length(object.key)), 0);
            else if (object.key.length)
              message.key = object.key;
          }
          if (object.value != null) {
            if (typeof object.value === "string")
              $util.base64.decode(object.value, message.value = $util.newBuffer($util.base64.length(object.value)), 0);
            else if (object.value.length)
              message.value = object.value;
          }
          if (object.leaf != null) {
            if (typeof object.leaf !== "object")
              throw TypeError(".ics23.ExistenceProof.leaf: object expected");
            message.leaf = $root.ics23.LeafOp.fromObject(object.leaf);
          }
          if (object.path) {
            if (!Array.isArray(object.path))
              throw TypeError(".ics23.ExistenceProof.path: array expected");
            message.path = [];
            for (var i = 0; i < object.path.length; ++i) {
              if (typeof object.path[i] !== "object")
                throw TypeError(".ics23.ExistenceProof.path: object expected");
              message.path[i] = $root.ics23.InnerOp.fromObject(object.path[i]);
            }
          }
          return message;
        };
        ExistenceProof.toObject = function toObject(message, options) {
          if (!options)
            options = {};
          var object = {};
          if (options.arrays || options.defaults)
            object.path = [];
          if (options.defaults) {
            if (options.bytes === String)
              object.key = "";
            else {
              object.key = [];
              if (options.bytes !== Array)
                object.key = $util.newBuffer(object.key);
            }
            if (options.bytes === String)
              object.value = "";
            else {
              object.value = [];
              if (options.bytes !== Array)
                object.value = $util.newBuffer(object.value);
            }
            object.leaf = null;
          }
          if (message.key != null && message.hasOwnProperty("key"))
            object.key = options.bytes === String ? $util.base64.encode(message.key, 0, message.key.length) : options.bytes === Array ? Array.prototype.slice.call(message.key) : message.key;
          if (message.value != null && message.hasOwnProperty("value"))
            object.value = options.bytes === String ? $util.base64.encode(message.value, 0, message.value.length) : options.bytes === Array ? Array.prototype.slice.call(message.value) : message.value;
          if (message.leaf != null && message.hasOwnProperty("leaf"))
            object.leaf = $root.ics23.LeafOp.toObject(message.leaf, options);
          if (message.path && message.path.length) {
            object.path = [];
            for (var j = 0; j < message.path.length; ++j)
              object.path[j] = $root.ics23.InnerOp.toObject(message.path[j], options);
          }
          return object;
        };
        ExistenceProof.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return ExistenceProof;
      }();
      ics23.NonExistenceProof = function() {
        function NonExistenceProof(properties) {
          if (properties) {
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null)
                this[keys[i]] = properties[keys[i]];
          }
        }
        NonExistenceProof.prototype.key = $util.newBuffer([]);
        NonExistenceProof.prototype.left = null;
        NonExistenceProof.prototype.right = null;
        NonExistenceProof.create = function create(properties) {
          return new NonExistenceProof(properties);
        };
        NonExistenceProof.encode = function encode(message, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message.key != null && message.hasOwnProperty("key"))
            writer.uint32(
              /* id 1, wireType 2 =*/
              10
            ).bytes(message.key);
          if (message.left != null && message.hasOwnProperty("left"))
            $root.ics23.ExistenceProof.encode(message.left, writer.uint32(
              /* id 2, wireType 2 =*/
              18
            ).fork()).ldelim();
          if (message.right != null && message.hasOwnProperty("right"))
            $root.ics23.ExistenceProof.encode(message.right, writer.uint32(
              /* id 3, wireType 2 =*/
              26
            ).fork()).ldelim();
          return writer;
        };
        NonExistenceProof.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };
        NonExistenceProof.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.ics23.NonExistenceProof();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.key = reader.bytes();
                break;
              case 2:
                message.left = $root.ics23.ExistenceProof.decode(reader, reader.uint32());
                break;
              case 3:
                message.right = $root.ics23.ExistenceProof.decode(reader, reader.uint32());
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };
        NonExistenceProof.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };
        NonExistenceProof.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
            return "object expected";
          if (message.key != null && message.hasOwnProperty("key")) {
            if (!(message.key && typeof message.key.length === "number" || $util.isString(message.key)))
              return "key: buffer expected";
          }
          if (message.left != null && message.hasOwnProperty("left")) {
            var error = $root.ics23.ExistenceProof.verify(message.left);
            if (error)
              return "left." + error;
          }
          if (message.right != null && message.hasOwnProperty("right")) {
            var error = $root.ics23.ExistenceProof.verify(message.right);
            if (error)
              return "right." + error;
          }
          return null;
        };
        NonExistenceProof.fromObject = function fromObject(object) {
          if (object instanceof $root.ics23.NonExistenceProof)
            return object;
          var message = new $root.ics23.NonExistenceProof();
          if (object.key != null) {
            if (typeof object.key === "string")
              $util.base64.decode(object.key, message.key = $util.newBuffer($util.base64.length(object.key)), 0);
            else if (object.key.length)
              message.key = object.key;
          }
          if (object.left != null) {
            if (typeof object.left !== "object")
              throw TypeError(".ics23.NonExistenceProof.left: object expected");
            message.left = $root.ics23.ExistenceProof.fromObject(object.left);
          }
          if (object.right != null) {
            if (typeof object.right !== "object")
              throw TypeError(".ics23.NonExistenceProof.right: object expected");
            message.right = $root.ics23.ExistenceProof.fromObject(object.right);
          }
          return message;
        };
        NonExistenceProof.toObject = function toObject(message, options) {
          if (!options)
            options = {};
          var object = {};
          if (options.defaults) {
            if (options.bytes === String)
              object.key = "";
            else {
              object.key = [];
              if (options.bytes !== Array)
                object.key = $util.newBuffer(object.key);
            }
            object.left = null;
            object.right = null;
          }
          if (message.key != null && message.hasOwnProperty("key"))
            object.key = options.bytes === String ? $util.base64.encode(message.key, 0, message.key.length) : options.bytes === Array ? Array.prototype.slice.call(message.key) : message.key;
          if (message.left != null && message.hasOwnProperty("left"))
            object.left = $root.ics23.ExistenceProof.toObject(message.left, options);
          if (message.right != null && message.hasOwnProperty("right"))
            object.right = $root.ics23.ExistenceProof.toObject(message.right, options);
          return object;
        };
        NonExistenceProof.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return NonExistenceProof;
      }();
      ics23.CommitmentProof = function() {
        function CommitmentProof(properties) {
          if (properties) {
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null)
                this[keys[i]] = properties[keys[i]];
          }
        }
        CommitmentProof.prototype.exist = null;
        CommitmentProof.prototype.nonexist = null;
        CommitmentProof.prototype.batch = null;
        CommitmentProof.prototype.compressed = null;
        var $oneOfFields;
        Object.defineProperty(CommitmentProof.prototype, "proof", {
          get: $util.oneOfGetter($oneOfFields = ["exist", "nonexist", "batch", "compressed"]),
          set: $util.oneOfSetter($oneOfFields)
        });
        CommitmentProof.create = function create(properties) {
          return new CommitmentProof(properties);
        };
        CommitmentProof.encode = function encode(message, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message.exist != null && message.hasOwnProperty("exist"))
            $root.ics23.ExistenceProof.encode(message.exist, writer.uint32(
              /* id 1, wireType 2 =*/
              10
            ).fork()).ldelim();
          if (message.nonexist != null && message.hasOwnProperty("nonexist"))
            $root.ics23.NonExistenceProof.encode(message.nonexist, writer.uint32(
              /* id 2, wireType 2 =*/
              18
            ).fork()).ldelim();
          if (message.batch != null && message.hasOwnProperty("batch"))
            $root.ics23.BatchProof.encode(message.batch, writer.uint32(
              /* id 3, wireType 2 =*/
              26
            ).fork()).ldelim();
          if (message.compressed != null && message.hasOwnProperty("compressed"))
            $root.ics23.CompressedBatchProof.encode(message.compressed, writer.uint32(
              /* id 4, wireType 2 =*/
              34
            ).fork()).ldelim();
          return writer;
        };
        CommitmentProof.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };
        CommitmentProof.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.ics23.CommitmentProof();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.exist = $root.ics23.ExistenceProof.decode(reader, reader.uint32());
                break;
              case 2:
                message.nonexist = $root.ics23.NonExistenceProof.decode(reader, reader.uint32());
                break;
              case 3:
                message.batch = $root.ics23.BatchProof.decode(reader, reader.uint32());
                break;
              case 4:
                message.compressed = $root.ics23.CompressedBatchProof.decode(reader, reader.uint32());
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };
        CommitmentProof.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };
        CommitmentProof.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
            return "object expected";
          var properties = {};
          if (message.exist != null && message.hasOwnProperty("exist")) {
            properties.proof = 1;
            {
              var error = $root.ics23.ExistenceProof.verify(message.exist);
              if (error)
                return "exist." + error;
            }
          }
          if (message.nonexist != null && message.hasOwnProperty("nonexist")) {
            if (properties.proof === 1)
              return "proof: multiple values";
            properties.proof = 1;
            {
              var error = $root.ics23.NonExistenceProof.verify(message.nonexist);
              if (error)
                return "nonexist." + error;
            }
          }
          if (message.batch != null && message.hasOwnProperty("batch")) {
            if (properties.proof === 1)
              return "proof: multiple values";
            properties.proof = 1;
            {
              var error = $root.ics23.BatchProof.verify(message.batch);
              if (error)
                return "batch." + error;
            }
          }
          if (message.compressed != null && message.hasOwnProperty("compressed")) {
            if (properties.proof === 1)
              return "proof: multiple values";
            properties.proof = 1;
            {
              var error = $root.ics23.CompressedBatchProof.verify(message.compressed);
              if (error)
                return "compressed." + error;
            }
          }
          return null;
        };
        CommitmentProof.fromObject = function fromObject(object) {
          if (object instanceof $root.ics23.CommitmentProof)
            return object;
          var message = new $root.ics23.CommitmentProof();
          if (object.exist != null) {
            if (typeof object.exist !== "object")
              throw TypeError(".ics23.CommitmentProof.exist: object expected");
            message.exist = $root.ics23.ExistenceProof.fromObject(object.exist);
          }
          if (object.nonexist != null) {
            if (typeof object.nonexist !== "object")
              throw TypeError(".ics23.CommitmentProof.nonexist: object expected");
            message.nonexist = $root.ics23.NonExistenceProof.fromObject(object.nonexist);
          }
          if (object.batch != null) {
            if (typeof object.batch !== "object")
              throw TypeError(".ics23.CommitmentProof.batch: object expected");
            message.batch = $root.ics23.BatchProof.fromObject(object.batch);
          }
          if (object.compressed != null) {
            if (typeof object.compressed !== "object")
              throw TypeError(".ics23.CommitmentProof.compressed: object expected");
            message.compressed = $root.ics23.CompressedBatchProof.fromObject(object.compressed);
          }
          return message;
        };
        CommitmentProof.toObject = function toObject(message, options) {
          if (!options)
            options = {};
          var object = {};
          if (message.exist != null && message.hasOwnProperty("exist")) {
            object.exist = $root.ics23.ExistenceProof.toObject(message.exist, options);
            if (options.oneofs)
              object.proof = "exist";
          }
          if (message.nonexist != null && message.hasOwnProperty("nonexist")) {
            object.nonexist = $root.ics23.NonExistenceProof.toObject(message.nonexist, options);
            if (options.oneofs)
              object.proof = "nonexist";
          }
          if (message.batch != null && message.hasOwnProperty("batch")) {
            object.batch = $root.ics23.BatchProof.toObject(message.batch, options);
            if (options.oneofs)
              object.proof = "batch";
          }
          if (message.compressed != null && message.hasOwnProperty("compressed")) {
            object.compressed = $root.ics23.CompressedBatchProof.toObject(message.compressed, options);
            if (options.oneofs)
              object.proof = "compressed";
          }
          return object;
        };
        CommitmentProof.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return CommitmentProof;
      }();
      ics23.LeafOp = function() {
        function LeafOp(properties) {
          if (properties) {
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null)
                this[keys[i]] = properties[keys[i]];
          }
        }
        LeafOp.prototype.hash = 0;
        LeafOp.prototype.prehashKey = 0;
        LeafOp.prototype.prehashValue = 0;
        LeafOp.prototype.length = 0;
        LeafOp.prototype.prefix = $util.newBuffer([]);
        LeafOp.create = function create(properties) {
          return new LeafOp(properties);
        };
        LeafOp.encode = function encode(message, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message.hash != null && message.hasOwnProperty("hash"))
            writer.uint32(
              /* id 1, wireType 0 =*/
              8
            ).int32(message.hash);
          if (message.prehashKey != null && message.hasOwnProperty("prehashKey"))
            writer.uint32(
              /* id 2, wireType 0 =*/
              16
            ).int32(message.prehashKey);
          if (message.prehashValue != null && message.hasOwnProperty("prehashValue"))
            writer.uint32(
              /* id 3, wireType 0 =*/
              24
            ).int32(message.prehashValue);
          if (message.length != null && message.hasOwnProperty("length"))
            writer.uint32(
              /* id 4, wireType 0 =*/
              32
            ).int32(message.length);
          if (message.prefix != null && message.hasOwnProperty("prefix"))
            writer.uint32(
              /* id 5, wireType 2 =*/
              42
            ).bytes(message.prefix);
          return writer;
        };
        LeafOp.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };
        LeafOp.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.ics23.LeafOp();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.hash = reader.int32();
                break;
              case 2:
                message.prehashKey = reader.int32();
                break;
              case 3:
                message.prehashValue = reader.int32();
                break;
              case 4:
                message.length = reader.int32();
                break;
              case 5:
                message.prefix = reader.bytes();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };
        LeafOp.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };
        LeafOp.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
            return "object expected";
          if (message.hash != null && message.hasOwnProperty("hash"))
            switch (message.hash) {
              default:
                return "hash: enum value expected";
              case 0:
              case 1:
              case 2:
              case 3:
              case 4:
              case 5:
              case 6:
                break;
            }
          if (message.prehashKey != null && message.hasOwnProperty("prehashKey"))
            switch (message.prehashKey) {
              default:
                return "prehashKey: enum value expected";
              case 0:
              case 1:
              case 2:
              case 3:
              case 4:
              case 5:
              case 6:
                break;
            }
          if (message.prehashValue != null && message.hasOwnProperty("prehashValue"))
            switch (message.prehashValue) {
              default:
                return "prehashValue: enum value expected";
              case 0:
              case 1:
              case 2:
              case 3:
              case 4:
              case 5:
              case 6:
                break;
            }
          if (message.length != null && message.hasOwnProperty("length"))
            switch (message.length) {
              default:
                return "length: enum value expected";
              case 0:
              case 1:
              case 2:
              case 3:
              case 4:
              case 5:
              case 6:
              case 7:
              case 8:
                break;
            }
          if (message.prefix != null && message.hasOwnProperty("prefix")) {
            if (!(message.prefix && typeof message.prefix.length === "number" || $util.isString(message.prefix)))
              return "prefix: buffer expected";
          }
          return null;
        };
        LeafOp.fromObject = function fromObject(object) {
          if (object instanceof $root.ics23.LeafOp)
            return object;
          var message = new $root.ics23.LeafOp();
          switch (object.hash) {
            case "NO_HASH":
            case 0:
              message.hash = 0;
              break;
            case "SHA256":
            case 1:
              message.hash = 1;
              break;
            case "SHA512":
            case 2:
              message.hash = 2;
              break;
            case "KECCAK":
            case 3:
              message.hash = 3;
              break;
            case "RIPEMD160":
            case 4:
              message.hash = 4;
              break;
            case "BITCOIN":
            case 5:
              message.hash = 5;
              break;
            case "SHA512_256":
            case 6:
              message.hash = 6;
              break;
          }
          switch (object.prehashKey) {
            case "NO_HASH":
            case 0:
              message.prehashKey = 0;
              break;
            case "SHA256":
            case 1:
              message.prehashKey = 1;
              break;
            case "SHA512":
            case 2:
              message.prehashKey = 2;
              break;
            case "KECCAK":
            case 3:
              message.prehashKey = 3;
              break;
            case "RIPEMD160":
            case 4:
              message.prehashKey = 4;
              break;
            case "BITCOIN":
            case 5:
              message.prehashKey = 5;
              break;
            case "SHA512_256":
            case 6:
              message.prehashKey = 6;
              break;
          }
          switch (object.prehashValue) {
            case "NO_HASH":
            case 0:
              message.prehashValue = 0;
              break;
            case "SHA256":
            case 1:
              message.prehashValue = 1;
              break;
            case "SHA512":
            case 2:
              message.prehashValue = 2;
              break;
            case "KECCAK":
            case 3:
              message.prehashValue = 3;
              break;
            case "RIPEMD160":
            case 4:
              message.prehashValue = 4;
              break;
            case "BITCOIN":
            case 5:
              message.prehashValue = 5;
              break;
            case "SHA512_256":
            case 6:
              message.prehashValue = 6;
              break;
          }
          switch (object.length) {
            case "NO_PREFIX":
            case 0:
              message.length = 0;
              break;
            case "VAR_PROTO":
            case 1:
              message.length = 1;
              break;
            case "VAR_RLP":
            case 2:
              message.length = 2;
              break;
            case "FIXED32_BIG":
            case 3:
              message.length = 3;
              break;
            case "FIXED32_LITTLE":
            case 4:
              message.length = 4;
              break;
            case "FIXED64_BIG":
            case 5:
              message.length = 5;
              break;
            case "FIXED64_LITTLE":
            case 6:
              message.length = 6;
              break;
            case "REQUIRE_32_BYTES":
            case 7:
              message.length = 7;
              break;
            case "REQUIRE_64_BYTES":
            case 8:
              message.length = 8;
              break;
          }
          if (object.prefix != null) {
            if (typeof object.prefix === "string")
              $util.base64.decode(object.prefix, message.prefix = $util.newBuffer($util.base64.length(object.prefix)), 0);
            else if (object.prefix.length)
              message.prefix = object.prefix;
          }
          return message;
        };
        LeafOp.toObject = function toObject(message, options) {
          if (!options)
            options = {};
          var object = {};
          if (options.defaults) {
            object.hash = options.enums === String ? "NO_HASH" : 0;
            object.prehashKey = options.enums === String ? "NO_HASH" : 0;
            object.prehashValue = options.enums === String ? "NO_HASH" : 0;
            object.length = options.enums === String ? "NO_PREFIX" : 0;
            if (options.bytes === String)
              object.prefix = "";
            else {
              object.prefix = [];
              if (options.bytes !== Array)
                object.prefix = $util.newBuffer(object.prefix);
            }
          }
          if (message.hash != null && message.hasOwnProperty("hash"))
            object.hash = options.enums === String ? $root.ics23.HashOp[message.hash] : message.hash;
          if (message.prehashKey != null && message.hasOwnProperty("prehashKey"))
            object.prehashKey = options.enums === String ? $root.ics23.HashOp[message.prehashKey] : message.prehashKey;
          if (message.prehashValue != null && message.hasOwnProperty("prehashValue"))
            object.prehashValue = options.enums === String ? $root.ics23.HashOp[message.prehashValue] : message.prehashValue;
          if (message.length != null && message.hasOwnProperty("length"))
            object.length = options.enums === String ? $root.ics23.LengthOp[message.length] : message.length;
          if (message.prefix != null && message.hasOwnProperty("prefix"))
            object.prefix = options.bytes === String ? $util.base64.encode(message.prefix, 0, message.prefix.length) : options.bytes === Array ? Array.prototype.slice.call(message.prefix) : message.prefix;
          return object;
        };
        LeafOp.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return LeafOp;
      }();
      ics23.InnerOp = function() {
        function InnerOp(properties) {
          if (properties) {
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null)
                this[keys[i]] = properties[keys[i]];
          }
        }
        InnerOp.prototype.hash = 0;
        InnerOp.prototype.prefix = $util.newBuffer([]);
        InnerOp.prototype.suffix = $util.newBuffer([]);
        InnerOp.create = function create(properties) {
          return new InnerOp(properties);
        };
        InnerOp.encode = function encode(message, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message.hash != null && message.hasOwnProperty("hash"))
            writer.uint32(
              /* id 1, wireType 0 =*/
              8
            ).int32(message.hash);
          if (message.prefix != null && message.hasOwnProperty("prefix"))
            writer.uint32(
              /* id 2, wireType 2 =*/
              18
            ).bytes(message.prefix);
          if (message.suffix != null && message.hasOwnProperty("suffix"))
            writer.uint32(
              /* id 3, wireType 2 =*/
              26
            ).bytes(message.suffix);
          return writer;
        };
        InnerOp.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };
        InnerOp.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.ics23.InnerOp();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.hash = reader.int32();
                break;
              case 2:
                message.prefix = reader.bytes();
                break;
              case 3:
                message.suffix = reader.bytes();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };
        InnerOp.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };
        InnerOp.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
            return "object expected";
          if (message.hash != null && message.hasOwnProperty("hash"))
            switch (message.hash) {
              default:
                return "hash: enum value expected";
              case 0:
              case 1:
              case 2:
              case 3:
              case 4:
              case 5:
              case 6:
                break;
            }
          if (message.prefix != null && message.hasOwnProperty("prefix")) {
            if (!(message.prefix && typeof message.prefix.length === "number" || $util.isString(message.prefix)))
              return "prefix: buffer expected";
          }
          if (message.suffix != null && message.hasOwnProperty("suffix")) {
            if (!(message.suffix && typeof message.suffix.length === "number" || $util.isString(message.suffix)))
              return "suffix: buffer expected";
          }
          return null;
        };
        InnerOp.fromObject = function fromObject(object) {
          if (object instanceof $root.ics23.InnerOp)
            return object;
          var message = new $root.ics23.InnerOp();
          switch (object.hash) {
            case "NO_HASH":
            case 0:
              message.hash = 0;
              break;
            case "SHA256":
            case 1:
              message.hash = 1;
              break;
            case "SHA512":
            case 2:
              message.hash = 2;
              break;
            case "KECCAK":
            case 3:
              message.hash = 3;
              break;
            case "RIPEMD160":
            case 4:
              message.hash = 4;
              break;
            case "BITCOIN":
            case 5:
              message.hash = 5;
              break;
            case "SHA512_256":
            case 6:
              message.hash = 6;
              break;
          }
          if (object.prefix != null) {
            if (typeof object.prefix === "string")
              $util.base64.decode(object.prefix, message.prefix = $util.newBuffer($util.base64.length(object.prefix)), 0);
            else if (object.prefix.length)
              message.prefix = object.prefix;
          }
          if (object.suffix != null) {
            if (typeof object.suffix === "string")
              $util.base64.decode(object.suffix, message.suffix = $util.newBuffer($util.base64.length(object.suffix)), 0);
            else if (object.suffix.length)
              message.suffix = object.suffix;
          }
          return message;
        };
        InnerOp.toObject = function toObject(message, options) {
          if (!options)
            options = {};
          var object = {};
          if (options.defaults) {
            object.hash = options.enums === String ? "NO_HASH" : 0;
            if (options.bytes === String)
              object.prefix = "";
            else {
              object.prefix = [];
              if (options.bytes !== Array)
                object.prefix = $util.newBuffer(object.prefix);
            }
            if (options.bytes === String)
              object.suffix = "";
            else {
              object.suffix = [];
              if (options.bytes !== Array)
                object.suffix = $util.newBuffer(object.suffix);
            }
          }
          if (message.hash != null && message.hasOwnProperty("hash"))
            object.hash = options.enums === String ? $root.ics23.HashOp[message.hash] : message.hash;
          if (message.prefix != null && message.hasOwnProperty("prefix"))
            object.prefix = options.bytes === String ? $util.base64.encode(message.prefix, 0, message.prefix.length) : options.bytes === Array ? Array.prototype.slice.call(message.prefix) : message.prefix;
          if (message.suffix != null && message.hasOwnProperty("suffix"))
            object.suffix = options.bytes === String ? $util.base64.encode(message.suffix, 0, message.suffix.length) : options.bytes === Array ? Array.prototype.slice.call(message.suffix) : message.suffix;
          return object;
        };
        InnerOp.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return InnerOp;
      }();
      ics23.ProofSpec = function() {
        function ProofSpec(properties) {
          if (properties) {
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null)
                this[keys[i]] = properties[keys[i]];
          }
        }
        ProofSpec.prototype.leafSpec = null;
        ProofSpec.prototype.innerSpec = null;
        ProofSpec.prototype.maxDepth = 0;
        ProofSpec.prototype.minDepth = 0;
        ProofSpec.create = function create(properties) {
          return new ProofSpec(properties);
        };
        ProofSpec.encode = function encode(message, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message.leafSpec != null && message.hasOwnProperty("leafSpec"))
            $root.ics23.LeafOp.encode(message.leafSpec, writer.uint32(
              /* id 1, wireType 2 =*/
              10
            ).fork()).ldelim();
          if (message.innerSpec != null && message.hasOwnProperty("innerSpec"))
            $root.ics23.InnerSpec.encode(message.innerSpec, writer.uint32(
              /* id 2, wireType 2 =*/
              18
            ).fork()).ldelim();
          if (message.maxDepth != null && message.hasOwnProperty("maxDepth"))
            writer.uint32(
              /* id 3, wireType 0 =*/
              24
            ).int32(message.maxDepth);
          if (message.minDepth != null && message.hasOwnProperty("minDepth"))
            writer.uint32(
              /* id 4, wireType 0 =*/
              32
            ).int32(message.minDepth);
          return writer;
        };
        ProofSpec.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };
        ProofSpec.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.ics23.ProofSpec();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.leafSpec = $root.ics23.LeafOp.decode(reader, reader.uint32());
                break;
              case 2:
                message.innerSpec = $root.ics23.InnerSpec.decode(reader, reader.uint32());
                break;
              case 3:
                message.maxDepth = reader.int32();
                break;
              case 4:
                message.minDepth = reader.int32();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };
        ProofSpec.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };
        ProofSpec.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
            return "object expected";
          if (message.leafSpec != null && message.hasOwnProperty("leafSpec")) {
            var error = $root.ics23.LeafOp.verify(message.leafSpec);
            if (error)
              return "leafSpec." + error;
          }
          if (message.innerSpec != null && message.hasOwnProperty("innerSpec")) {
            var error = $root.ics23.InnerSpec.verify(message.innerSpec);
            if (error)
              return "innerSpec." + error;
          }
          if (message.maxDepth != null && message.hasOwnProperty("maxDepth")) {
            if (!$util.isInteger(message.maxDepth))
              return "maxDepth: integer expected";
          }
          if (message.minDepth != null && message.hasOwnProperty("minDepth")) {
            if (!$util.isInteger(message.minDepth))
              return "minDepth: integer expected";
          }
          return null;
        };
        ProofSpec.fromObject = function fromObject(object) {
          if (object instanceof $root.ics23.ProofSpec)
            return object;
          var message = new $root.ics23.ProofSpec();
          if (object.leafSpec != null) {
            if (typeof object.leafSpec !== "object")
              throw TypeError(".ics23.ProofSpec.leafSpec: object expected");
            message.leafSpec = $root.ics23.LeafOp.fromObject(object.leafSpec);
          }
          if (object.innerSpec != null) {
            if (typeof object.innerSpec !== "object")
              throw TypeError(".ics23.ProofSpec.innerSpec: object expected");
            message.innerSpec = $root.ics23.InnerSpec.fromObject(object.innerSpec);
          }
          if (object.maxDepth != null)
            message.maxDepth = object.maxDepth | 0;
          if (object.minDepth != null)
            message.minDepth = object.minDepth | 0;
          return message;
        };
        ProofSpec.toObject = function toObject(message, options) {
          if (!options)
            options = {};
          var object = {};
          if (options.defaults) {
            object.leafSpec = null;
            object.innerSpec = null;
            object.maxDepth = 0;
            object.minDepth = 0;
          }
          if (message.leafSpec != null && message.hasOwnProperty("leafSpec"))
            object.leafSpec = $root.ics23.LeafOp.toObject(message.leafSpec, options);
          if (message.innerSpec != null && message.hasOwnProperty("innerSpec"))
            object.innerSpec = $root.ics23.InnerSpec.toObject(message.innerSpec, options);
          if (message.maxDepth != null && message.hasOwnProperty("maxDepth"))
            object.maxDepth = message.maxDepth;
          if (message.minDepth != null && message.hasOwnProperty("minDepth"))
            object.minDepth = message.minDepth;
          return object;
        };
        ProofSpec.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return ProofSpec;
      }();
      ics23.InnerSpec = function() {
        function InnerSpec(properties) {
          this.childOrder = [];
          if (properties) {
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null)
                this[keys[i]] = properties[keys[i]];
          }
        }
        InnerSpec.prototype.childOrder = $util.emptyArray;
        InnerSpec.prototype.childSize = 0;
        InnerSpec.prototype.minPrefixLength = 0;
        InnerSpec.prototype.maxPrefixLength = 0;
        InnerSpec.prototype.emptyChild = $util.newBuffer([]);
        InnerSpec.prototype.hash = 0;
        InnerSpec.create = function create(properties) {
          return new InnerSpec(properties);
        };
        InnerSpec.encode = function encode(message, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message.childOrder != null && message.childOrder.length) {
            writer.uint32(
              /* id 1, wireType 2 =*/
              10
            ).fork();
            for (var i = 0; i < message.childOrder.length; ++i)
              writer.int32(message.childOrder[i]);
            writer.ldelim();
          }
          if (message.childSize != null && message.hasOwnProperty("childSize"))
            writer.uint32(
              /* id 2, wireType 0 =*/
              16
            ).int32(message.childSize);
          if (message.minPrefixLength != null && message.hasOwnProperty("minPrefixLength"))
            writer.uint32(
              /* id 3, wireType 0 =*/
              24
            ).int32(message.minPrefixLength);
          if (message.maxPrefixLength != null && message.hasOwnProperty("maxPrefixLength"))
            writer.uint32(
              /* id 4, wireType 0 =*/
              32
            ).int32(message.maxPrefixLength);
          if (message.emptyChild != null && message.hasOwnProperty("emptyChild"))
            writer.uint32(
              /* id 5, wireType 2 =*/
              42
            ).bytes(message.emptyChild);
          if (message.hash != null && message.hasOwnProperty("hash"))
            writer.uint32(
              /* id 6, wireType 0 =*/
              48
            ).int32(message.hash);
          return writer;
        };
        InnerSpec.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };
        InnerSpec.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.ics23.InnerSpec();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                if (!(message.childOrder && message.childOrder.length))
                  message.childOrder = [];
                if ((tag & 7) === 2) {
                  var end2 = reader.uint32() + reader.pos;
                  while (reader.pos < end2)
                    message.childOrder.push(reader.int32());
                } else
                  message.childOrder.push(reader.int32());
                break;
              case 2:
                message.childSize = reader.int32();
                break;
              case 3:
                message.minPrefixLength = reader.int32();
                break;
              case 4:
                message.maxPrefixLength = reader.int32();
                break;
              case 5:
                message.emptyChild = reader.bytes();
                break;
              case 6:
                message.hash = reader.int32();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };
        InnerSpec.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };
        InnerSpec.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
            return "object expected";
          if (message.childOrder != null && message.hasOwnProperty("childOrder")) {
            if (!Array.isArray(message.childOrder))
              return "childOrder: array expected";
            for (var i = 0; i < message.childOrder.length; ++i)
              if (!$util.isInteger(message.childOrder[i]))
                return "childOrder: integer[] expected";
          }
          if (message.childSize != null && message.hasOwnProperty("childSize")) {
            if (!$util.isInteger(message.childSize))
              return "childSize: integer expected";
          }
          if (message.minPrefixLength != null && message.hasOwnProperty("minPrefixLength")) {
            if (!$util.isInteger(message.minPrefixLength))
              return "minPrefixLength: integer expected";
          }
          if (message.maxPrefixLength != null && message.hasOwnProperty("maxPrefixLength")) {
            if (!$util.isInteger(message.maxPrefixLength))
              return "maxPrefixLength: integer expected";
          }
          if (message.emptyChild != null && message.hasOwnProperty("emptyChild")) {
            if (!(message.emptyChild && typeof message.emptyChild.length === "number" || $util.isString(message.emptyChild)))
              return "emptyChild: buffer expected";
          }
          if (message.hash != null && message.hasOwnProperty("hash"))
            switch (message.hash) {
              default:
                return "hash: enum value expected";
              case 0:
              case 1:
              case 2:
              case 3:
              case 4:
              case 5:
              case 6:
                break;
            }
          return null;
        };
        InnerSpec.fromObject = function fromObject(object) {
          if (object instanceof $root.ics23.InnerSpec)
            return object;
          var message = new $root.ics23.InnerSpec();
          if (object.childOrder) {
            if (!Array.isArray(object.childOrder))
              throw TypeError(".ics23.InnerSpec.childOrder: array expected");
            message.childOrder = [];
            for (var i = 0; i < object.childOrder.length; ++i)
              message.childOrder[i] = object.childOrder[i] | 0;
          }
          if (object.childSize != null)
            message.childSize = object.childSize | 0;
          if (object.minPrefixLength != null)
            message.minPrefixLength = object.minPrefixLength | 0;
          if (object.maxPrefixLength != null)
            message.maxPrefixLength = object.maxPrefixLength | 0;
          if (object.emptyChild != null) {
            if (typeof object.emptyChild === "string")
              $util.base64.decode(object.emptyChild, message.emptyChild = $util.newBuffer($util.base64.length(object.emptyChild)), 0);
            else if (object.emptyChild.length)
              message.emptyChild = object.emptyChild;
          }
          switch (object.hash) {
            case "NO_HASH":
            case 0:
              message.hash = 0;
              break;
            case "SHA256":
            case 1:
              message.hash = 1;
              break;
            case "SHA512":
            case 2:
              message.hash = 2;
              break;
            case "KECCAK":
            case 3:
              message.hash = 3;
              break;
            case "RIPEMD160":
            case 4:
              message.hash = 4;
              break;
            case "BITCOIN":
            case 5:
              message.hash = 5;
              break;
            case "SHA512_256":
            case 6:
              message.hash = 6;
              break;
          }
          return message;
        };
        InnerSpec.toObject = function toObject(message, options) {
          if (!options)
            options = {};
          var object = {};
          if (options.arrays || options.defaults)
            object.childOrder = [];
          if (options.defaults) {
            object.childSize = 0;
            object.minPrefixLength = 0;
            object.maxPrefixLength = 0;
            if (options.bytes === String)
              object.emptyChild = "";
            else {
              object.emptyChild = [];
              if (options.bytes !== Array)
                object.emptyChild = $util.newBuffer(object.emptyChild);
            }
            object.hash = options.enums === String ? "NO_HASH" : 0;
          }
          if (message.childOrder && message.childOrder.length) {
            object.childOrder = [];
            for (var j = 0; j < message.childOrder.length; ++j)
              object.childOrder[j] = message.childOrder[j];
          }
          if (message.childSize != null && message.hasOwnProperty("childSize"))
            object.childSize = message.childSize;
          if (message.minPrefixLength != null && message.hasOwnProperty("minPrefixLength"))
            object.minPrefixLength = message.minPrefixLength;
          if (message.maxPrefixLength != null && message.hasOwnProperty("maxPrefixLength"))
            object.maxPrefixLength = message.maxPrefixLength;
          if (message.emptyChild != null && message.hasOwnProperty("emptyChild"))
            object.emptyChild = options.bytes === String ? $util.base64.encode(message.emptyChild, 0, message.emptyChild.length) : options.bytes === Array ? Array.prototype.slice.call(message.emptyChild) : message.emptyChild;
          if (message.hash != null && message.hasOwnProperty("hash"))
            object.hash = options.enums === String ? $root.ics23.HashOp[message.hash] : message.hash;
          return object;
        };
        InnerSpec.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return InnerSpec;
      }();
      ics23.BatchProof = function() {
        function BatchProof(properties) {
          this.entries = [];
          if (properties) {
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null)
                this[keys[i]] = properties[keys[i]];
          }
        }
        BatchProof.prototype.entries = $util.emptyArray;
        BatchProof.create = function create(properties) {
          return new BatchProof(properties);
        };
        BatchProof.encode = function encode(message, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message.entries != null && message.entries.length)
            for (var i = 0; i < message.entries.length; ++i)
              $root.ics23.BatchEntry.encode(message.entries[i], writer.uint32(
                /* id 1, wireType 2 =*/
                10
              ).fork()).ldelim();
          return writer;
        };
        BatchProof.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };
        BatchProof.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.ics23.BatchProof();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                if (!(message.entries && message.entries.length))
                  message.entries = [];
                message.entries.push($root.ics23.BatchEntry.decode(reader, reader.uint32()));
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };
        BatchProof.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };
        BatchProof.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
            return "object expected";
          if (message.entries != null && message.hasOwnProperty("entries")) {
            if (!Array.isArray(message.entries))
              return "entries: array expected";
            for (var i = 0; i < message.entries.length; ++i) {
              var error = $root.ics23.BatchEntry.verify(message.entries[i]);
              if (error)
                return "entries." + error;
            }
          }
          return null;
        };
        BatchProof.fromObject = function fromObject(object) {
          if (object instanceof $root.ics23.BatchProof)
            return object;
          var message = new $root.ics23.BatchProof();
          if (object.entries) {
            if (!Array.isArray(object.entries))
              throw TypeError(".ics23.BatchProof.entries: array expected");
            message.entries = [];
            for (var i = 0; i < object.entries.length; ++i) {
              if (typeof object.entries[i] !== "object")
                throw TypeError(".ics23.BatchProof.entries: object expected");
              message.entries[i] = $root.ics23.BatchEntry.fromObject(object.entries[i]);
            }
          }
          return message;
        };
        BatchProof.toObject = function toObject(message, options) {
          if (!options)
            options = {};
          var object = {};
          if (options.arrays || options.defaults)
            object.entries = [];
          if (message.entries && message.entries.length) {
            object.entries = [];
            for (var j = 0; j < message.entries.length; ++j)
              object.entries[j] = $root.ics23.BatchEntry.toObject(message.entries[j], options);
          }
          return object;
        };
        BatchProof.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return BatchProof;
      }();
      ics23.BatchEntry = function() {
        function BatchEntry(properties) {
          if (properties) {
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null)
                this[keys[i]] = properties[keys[i]];
          }
        }
        BatchEntry.prototype.exist = null;
        BatchEntry.prototype.nonexist = null;
        var $oneOfFields;
        Object.defineProperty(BatchEntry.prototype, "proof", {
          get: $util.oneOfGetter($oneOfFields = ["exist", "nonexist"]),
          set: $util.oneOfSetter($oneOfFields)
        });
        BatchEntry.create = function create(properties) {
          return new BatchEntry(properties);
        };
        BatchEntry.encode = function encode(message, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message.exist != null && message.hasOwnProperty("exist"))
            $root.ics23.ExistenceProof.encode(message.exist, writer.uint32(
              /* id 1, wireType 2 =*/
              10
            ).fork()).ldelim();
          if (message.nonexist != null && message.hasOwnProperty("nonexist"))
            $root.ics23.NonExistenceProof.encode(message.nonexist, writer.uint32(
              /* id 2, wireType 2 =*/
              18
            ).fork()).ldelim();
          return writer;
        };
        BatchEntry.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };
        BatchEntry.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.ics23.BatchEntry();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.exist = $root.ics23.ExistenceProof.decode(reader, reader.uint32());
                break;
              case 2:
                message.nonexist = $root.ics23.NonExistenceProof.decode(reader, reader.uint32());
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };
        BatchEntry.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };
        BatchEntry.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
            return "object expected";
          var properties = {};
          if (message.exist != null && message.hasOwnProperty("exist")) {
            properties.proof = 1;
            {
              var error = $root.ics23.ExistenceProof.verify(message.exist);
              if (error)
                return "exist." + error;
            }
          }
          if (message.nonexist != null && message.hasOwnProperty("nonexist")) {
            if (properties.proof === 1)
              return "proof: multiple values";
            properties.proof = 1;
            {
              var error = $root.ics23.NonExistenceProof.verify(message.nonexist);
              if (error)
                return "nonexist." + error;
            }
          }
          return null;
        };
        BatchEntry.fromObject = function fromObject(object) {
          if (object instanceof $root.ics23.BatchEntry)
            return object;
          var message = new $root.ics23.BatchEntry();
          if (object.exist != null) {
            if (typeof object.exist !== "object")
              throw TypeError(".ics23.BatchEntry.exist: object expected");
            message.exist = $root.ics23.ExistenceProof.fromObject(object.exist);
          }
          if (object.nonexist != null) {
            if (typeof object.nonexist !== "object")
              throw TypeError(".ics23.BatchEntry.nonexist: object expected");
            message.nonexist = $root.ics23.NonExistenceProof.fromObject(object.nonexist);
          }
          return message;
        };
        BatchEntry.toObject = function toObject(message, options) {
          if (!options)
            options = {};
          var object = {};
          if (message.exist != null && message.hasOwnProperty("exist")) {
            object.exist = $root.ics23.ExistenceProof.toObject(message.exist, options);
            if (options.oneofs)
              object.proof = "exist";
          }
          if (message.nonexist != null && message.hasOwnProperty("nonexist")) {
            object.nonexist = $root.ics23.NonExistenceProof.toObject(message.nonexist, options);
            if (options.oneofs)
              object.proof = "nonexist";
          }
          return object;
        };
        BatchEntry.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return BatchEntry;
      }();
      ics23.CompressedBatchProof = function() {
        function CompressedBatchProof(properties) {
          this.entries = [];
          this.lookupInners = [];
          if (properties) {
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null)
                this[keys[i]] = properties[keys[i]];
          }
        }
        CompressedBatchProof.prototype.entries = $util.emptyArray;
        CompressedBatchProof.prototype.lookupInners = $util.emptyArray;
        CompressedBatchProof.create = function create(properties) {
          return new CompressedBatchProof(properties);
        };
        CompressedBatchProof.encode = function encode(message, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message.entries != null && message.entries.length)
            for (var i = 0; i < message.entries.length; ++i)
              $root.ics23.CompressedBatchEntry.encode(message.entries[i], writer.uint32(
                /* id 1, wireType 2 =*/
                10
              ).fork()).ldelim();
          if (message.lookupInners != null && message.lookupInners.length)
            for (var i = 0; i < message.lookupInners.length; ++i)
              $root.ics23.InnerOp.encode(message.lookupInners[i], writer.uint32(
                /* id 2, wireType 2 =*/
                18
              ).fork()).ldelim();
          return writer;
        };
        CompressedBatchProof.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };
        CompressedBatchProof.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.ics23.CompressedBatchProof();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                if (!(message.entries && message.entries.length))
                  message.entries = [];
                message.entries.push($root.ics23.CompressedBatchEntry.decode(reader, reader.uint32()));
                break;
              case 2:
                if (!(message.lookupInners && message.lookupInners.length))
                  message.lookupInners = [];
                message.lookupInners.push($root.ics23.InnerOp.decode(reader, reader.uint32()));
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };
        CompressedBatchProof.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };
        CompressedBatchProof.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
            return "object expected";
          if (message.entries != null && message.hasOwnProperty("entries")) {
            if (!Array.isArray(message.entries))
              return "entries: array expected";
            for (var i = 0; i < message.entries.length; ++i) {
              var error = $root.ics23.CompressedBatchEntry.verify(message.entries[i]);
              if (error)
                return "entries." + error;
            }
          }
          if (message.lookupInners != null && message.hasOwnProperty("lookupInners")) {
            if (!Array.isArray(message.lookupInners))
              return "lookupInners: array expected";
            for (var i = 0; i < message.lookupInners.length; ++i) {
              var error = $root.ics23.InnerOp.verify(message.lookupInners[i]);
              if (error)
                return "lookupInners." + error;
            }
          }
          return null;
        };
        CompressedBatchProof.fromObject = function fromObject(object) {
          if (object instanceof $root.ics23.CompressedBatchProof)
            return object;
          var message = new $root.ics23.CompressedBatchProof();
          if (object.entries) {
            if (!Array.isArray(object.entries))
              throw TypeError(".ics23.CompressedBatchProof.entries: array expected");
            message.entries = [];
            for (var i = 0; i < object.entries.length; ++i) {
              if (typeof object.entries[i] !== "object")
                throw TypeError(".ics23.CompressedBatchProof.entries: object expected");
              message.entries[i] = $root.ics23.CompressedBatchEntry.fromObject(object.entries[i]);
            }
          }
          if (object.lookupInners) {
            if (!Array.isArray(object.lookupInners))
              throw TypeError(".ics23.CompressedBatchProof.lookupInners: array expected");
            message.lookupInners = [];
            for (var i = 0; i < object.lookupInners.length; ++i) {
              if (typeof object.lookupInners[i] !== "object")
                throw TypeError(".ics23.CompressedBatchProof.lookupInners: object expected");
              message.lookupInners[i] = $root.ics23.InnerOp.fromObject(object.lookupInners[i]);
            }
          }
          return message;
        };
        CompressedBatchProof.toObject = function toObject(message, options) {
          if (!options)
            options = {};
          var object = {};
          if (options.arrays || options.defaults) {
            object.entries = [];
            object.lookupInners = [];
          }
          if (message.entries && message.entries.length) {
            object.entries = [];
            for (var j = 0; j < message.entries.length; ++j)
              object.entries[j] = $root.ics23.CompressedBatchEntry.toObject(message.entries[j], options);
          }
          if (message.lookupInners && message.lookupInners.length) {
            object.lookupInners = [];
            for (var j = 0; j < message.lookupInners.length; ++j)
              object.lookupInners[j] = $root.ics23.InnerOp.toObject(message.lookupInners[j], options);
          }
          return object;
        };
        CompressedBatchProof.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return CompressedBatchProof;
      }();
      ics23.CompressedBatchEntry = function() {
        function CompressedBatchEntry(properties) {
          if (properties) {
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null)
                this[keys[i]] = properties[keys[i]];
          }
        }
        CompressedBatchEntry.prototype.exist = null;
        CompressedBatchEntry.prototype.nonexist = null;
        var $oneOfFields;
        Object.defineProperty(CompressedBatchEntry.prototype, "proof", {
          get: $util.oneOfGetter($oneOfFields = ["exist", "nonexist"]),
          set: $util.oneOfSetter($oneOfFields)
        });
        CompressedBatchEntry.create = function create(properties) {
          return new CompressedBatchEntry(properties);
        };
        CompressedBatchEntry.encode = function encode(message, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message.exist != null && message.hasOwnProperty("exist"))
            $root.ics23.CompressedExistenceProof.encode(message.exist, writer.uint32(
              /* id 1, wireType 2 =*/
              10
            ).fork()).ldelim();
          if (message.nonexist != null && message.hasOwnProperty("nonexist"))
            $root.ics23.CompressedNonExistenceProof.encode(message.nonexist, writer.uint32(
              /* id 2, wireType 2 =*/
              18
            ).fork()).ldelim();
          return writer;
        };
        CompressedBatchEntry.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };
        CompressedBatchEntry.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.ics23.CompressedBatchEntry();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.exist = $root.ics23.CompressedExistenceProof.decode(reader, reader.uint32());
                break;
              case 2:
                message.nonexist = $root.ics23.CompressedNonExistenceProof.decode(reader, reader.uint32());
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };
        CompressedBatchEntry.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };
        CompressedBatchEntry.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
            return "object expected";
          var properties = {};
          if (message.exist != null && message.hasOwnProperty("exist")) {
            properties.proof = 1;
            {
              var error = $root.ics23.CompressedExistenceProof.verify(message.exist);
              if (error)
                return "exist." + error;
            }
          }
          if (message.nonexist != null && message.hasOwnProperty("nonexist")) {
            if (properties.proof === 1)
              return "proof: multiple values";
            properties.proof = 1;
            {
              var error = $root.ics23.CompressedNonExistenceProof.verify(message.nonexist);
              if (error)
                return "nonexist." + error;
            }
          }
          return null;
        };
        CompressedBatchEntry.fromObject = function fromObject(object) {
          if (object instanceof $root.ics23.CompressedBatchEntry)
            return object;
          var message = new $root.ics23.CompressedBatchEntry();
          if (object.exist != null) {
            if (typeof object.exist !== "object")
              throw TypeError(".ics23.CompressedBatchEntry.exist: object expected");
            message.exist = $root.ics23.CompressedExistenceProof.fromObject(object.exist);
          }
          if (object.nonexist != null) {
            if (typeof object.nonexist !== "object")
              throw TypeError(".ics23.CompressedBatchEntry.nonexist: object expected");
            message.nonexist = $root.ics23.CompressedNonExistenceProof.fromObject(object.nonexist);
          }
          return message;
        };
        CompressedBatchEntry.toObject = function toObject(message, options) {
          if (!options)
            options = {};
          var object = {};
          if (message.exist != null && message.hasOwnProperty("exist")) {
            object.exist = $root.ics23.CompressedExistenceProof.toObject(message.exist, options);
            if (options.oneofs)
              object.proof = "exist";
          }
          if (message.nonexist != null && message.hasOwnProperty("nonexist")) {
            object.nonexist = $root.ics23.CompressedNonExistenceProof.toObject(message.nonexist, options);
            if (options.oneofs)
              object.proof = "nonexist";
          }
          return object;
        };
        CompressedBatchEntry.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return CompressedBatchEntry;
      }();
      ics23.CompressedExistenceProof = function() {
        function CompressedExistenceProof(properties) {
          this.path = [];
          if (properties) {
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null)
                this[keys[i]] = properties[keys[i]];
          }
        }
        CompressedExistenceProof.prototype.key = $util.newBuffer([]);
        CompressedExistenceProof.prototype.value = $util.newBuffer([]);
        CompressedExistenceProof.prototype.leaf = null;
        CompressedExistenceProof.prototype.path = $util.emptyArray;
        CompressedExistenceProof.create = function create(properties) {
          return new CompressedExistenceProof(properties);
        };
        CompressedExistenceProof.encode = function encode(message, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message.key != null && message.hasOwnProperty("key"))
            writer.uint32(
              /* id 1, wireType 2 =*/
              10
            ).bytes(message.key);
          if (message.value != null && message.hasOwnProperty("value"))
            writer.uint32(
              /* id 2, wireType 2 =*/
              18
            ).bytes(message.value);
          if (message.leaf != null && message.hasOwnProperty("leaf"))
            $root.ics23.LeafOp.encode(message.leaf, writer.uint32(
              /* id 3, wireType 2 =*/
              26
            ).fork()).ldelim();
          if (message.path != null && message.path.length) {
            writer.uint32(
              /* id 4, wireType 2 =*/
              34
            ).fork();
            for (var i = 0; i < message.path.length; ++i)
              writer.int32(message.path[i]);
            writer.ldelim();
          }
          return writer;
        };
        CompressedExistenceProof.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };
        CompressedExistenceProof.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.ics23.CompressedExistenceProof();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.key = reader.bytes();
                break;
              case 2:
                message.value = reader.bytes();
                break;
              case 3:
                message.leaf = $root.ics23.LeafOp.decode(reader, reader.uint32());
                break;
              case 4:
                if (!(message.path && message.path.length))
                  message.path = [];
                if ((tag & 7) === 2) {
                  var end2 = reader.uint32() + reader.pos;
                  while (reader.pos < end2)
                    message.path.push(reader.int32());
                } else
                  message.path.push(reader.int32());
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };
        CompressedExistenceProof.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };
        CompressedExistenceProof.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
            return "object expected";
          if (message.key != null && message.hasOwnProperty("key")) {
            if (!(message.key && typeof message.key.length === "number" || $util.isString(message.key)))
              return "key: buffer expected";
          }
          if (message.value != null && message.hasOwnProperty("value")) {
            if (!(message.value && typeof message.value.length === "number" || $util.isString(message.value)))
              return "value: buffer expected";
          }
          if (message.leaf != null && message.hasOwnProperty("leaf")) {
            var error = $root.ics23.LeafOp.verify(message.leaf);
            if (error)
              return "leaf." + error;
          }
          if (message.path != null && message.hasOwnProperty("path")) {
            if (!Array.isArray(message.path))
              return "path: array expected";
            for (var i = 0; i < message.path.length; ++i)
              if (!$util.isInteger(message.path[i]))
                return "path: integer[] expected";
          }
          return null;
        };
        CompressedExistenceProof.fromObject = function fromObject(object) {
          if (object instanceof $root.ics23.CompressedExistenceProof)
            return object;
          var message = new $root.ics23.CompressedExistenceProof();
          if (object.key != null) {
            if (typeof object.key === "string")
              $util.base64.decode(object.key, message.key = $util.newBuffer($util.base64.length(object.key)), 0);
            else if (object.key.length)
              message.key = object.key;
          }
          if (object.value != null) {
            if (typeof object.value === "string")
              $util.base64.decode(object.value, message.value = $util.newBuffer($util.base64.length(object.value)), 0);
            else if (object.value.length)
              message.value = object.value;
          }
          if (object.leaf != null) {
            if (typeof object.leaf !== "object")
              throw TypeError(".ics23.CompressedExistenceProof.leaf: object expected");
            message.leaf = $root.ics23.LeafOp.fromObject(object.leaf);
          }
          if (object.path) {
            if (!Array.isArray(object.path))
              throw TypeError(".ics23.CompressedExistenceProof.path: array expected");
            message.path = [];
            for (var i = 0; i < object.path.length; ++i)
              message.path[i] = object.path[i] | 0;
          }
          return message;
        };
        CompressedExistenceProof.toObject = function toObject(message, options) {
          if (!options)
            options = {};
          var object = {};
          if (options.arrays || options.defaults)
            object.path = [];
          if (options.defaults) {
            if (options.bytes === String)
              object.key = "";
            else {
              object.key = [];
              if (options.bytes !== Array)
                object.key = $util.newBuffer(object.key);
            }
            if (options.bytes === String)
              object.value = "";
            else {
              object.value = [];
              if (options.bytes !== Array)
                object.value = $util.newBuffer(object.value);
            }
            object.leaf = null;
          }
          if (message.key != null && message.hasOwnProperty("key"))
            object.key = options.bytes === String ? $util.base64.encode(message.key, 0, message.key.length) : options.bytes === Array ? Array.prototype.slice.call(message.key) : message.key;
          if (message.value != null && message.hasOwnProperty("value"))
            object.value = options.bytes === String ? $util.base64.encode(message.value, 0, message.value.length) : options.bytes === Array ? Array.prototype.slice.call(message.value) : message.value;
          if (message.leaf != null && message.hasOwnProperty("leaf"))
            object.leaf = $root.ics23.LeafOp.toObject(message.leaf, options);
          if (message.path && message.path.length) {
            object.path = [];
            for (var j = 0; j < message.path.length; ++j)
              object.path[j] = message.path[j];
          }
          return object;
        };
        CompressedExistenceProof.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return CompressedExistenceProof;
      }();
      ics23.CompressedNonExistenceProof = function() {
        function CompressedNonExistenceProof(properties) {
          if (properties) {
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null)
                this[keys[i]] = properties[keys[i]];
          }
        }
        CompressedNonExistenceProof.prototype.key = $util.newBuffer([]);
        CompressedNonExistenceProof.prototype.left = null;
        CompressedNonExistenceProof.prototype.right = null;
        CompressedNonExistenceProof.create = function create(properties) {
          return new CompressedNonExistenceProof(properties);
        };
        CompressedNonExistenceProof.encode = function encode(message, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message.key != null && message.hasOwnProperty("key"))
            writer.uint32(
              /* id 1, wireType 2 =*/
              10
            ).bytes(message.key);
          if (message.left != null && message.hasOwnProperty("left"))
            $root.ics23.CompressedExistenceProof.encode(message.left, writer.uint32(
              /* id 2, wireType 2 =*/
              18
            ).fork()).ldelim();
          if (message.right != null && message.hasOwnProperty("right"))
            $root.ics23.CompressedExistenceProof.encode(message.right, writer.uint32(
              /* id 3, wireType 2 =*/
              26
            ).fork()).ldelim();
          return writer;
        };
        CompressedNonExistenceProof.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };
        CompressedNonExistenceProof.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.ics23.CompressedNonExistenceProof();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.key = reader.bytes();
                break;
              case 2:
                message.left = $root.ics23.CompressedExistenceProof.decode(reader, reader.uint32());
                break;
              case 3:
                message.right = $root.ics23.CompressedExistenceProof.decode(reader, reader.uint32());
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };
        CompressedNonExistenceProof.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };
        CompressedNonExistenceProof.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
            return "object expected";
          if (message.key != null && message.hasOwnProperty("key")) {
            if (!(message.key && typeof message.key.length === "number" || $util.isString(message.key)))
              return "key: buffer expected";
          }
          if (message.left != null && message.hasOwnProperty("left")) {
            var error = $root.ics23.CompressedExistenceProof.verify(message.left);
            if (error)
              return "left." + error;
          }
          if (message.right != null && message.hasOwnProperty("right")) {
            var error = $root.ics23.CompressedExistenceProof.verify(message.right);
            if (error)
              return "right." + error;
          }
          return null;
        };
        CompressedNonExistenceProof.fromObject = function fromObject(object) {
          if (object instanceof $root.ics23.CompressedNonExistenceProof)
            return object;
          var message = new $root.ics23.CompressedNonExistenceProof();
          if (object.key != null) {
            if (typeof object.key === "string")
              $util.base64.decode(object.key, message.key = $util.newBuffer($util.base64.length(object.key)), 0);
            else if (object.key.length)
              message.key = object.key;
          }
          if (object.left != null) {
            if (typeof object.left !== "object")
              throw TypeError(".ics23.CompressedNonExistenceProof.left: object expected");
            message.left = $root.ics23.CompressedExistenceProof.fromObject(object.left);
          }
          if (object.right != null) {
            if (typeof object.right !== "object")
              throw TypeError(".ics23.CompressedNonExistenceProof.right: object expected");
            message.right = $root.ics23.CompressedExistenceProof.fromObject(object.right);
          }
          return message;
        };
        CompressedNonExistenceProof.toObject = function toObject(message, options) {
          if (!options)
            options = {};
          var object = {};
          if (options.defaults) {
            if (options.bytes === String)
              object.key = "";
            else {
              object.key = [];
              if (options.bytes !== Array)
                object.key = $util.newBuffer(object.key);
            }
            object.left = null;
            object.right = null;
          }
          if (message.key != null && message.hasOwnProperty("key"))
            object.key = options.bytes === String ? $util.base64.encode(message.key, 0, message.key.length) : options.bytes === Array ? Array.prototype.slice.call(message.key) : message.key;
          if (message.left != null && message.hasOwnProperty("left"))
            object.left = $root.ics23.CompressedExistenceProof.toObject(message.left, options);
          if (message.right != null && message.hasOwnProperty("right"))
            object.right = $root.ics23.CompressedExistenceProof.toObject(message.right, options);
          return object;
        };
        CompressedNonExistenceProof.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return CompressedNonExistenceProof;
      }();
      return ics23;
    }();
    module.exports = $root;
  }
});

// ../../node_modules/.pnpm/@confio+ics23@0.6.8/node_modules/@confio/ics23/build/compress.js
var require_compress = __commonJS({
  "../../node_modules/.pnpm/@confio+ics23@0.6.8/node_modules/@confio/ics23/build/compress.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.decompress = exports.compress = void 0;
    var codecimpl_1 = require_codecimpl();
    function compress(proof) {
      if (!proof.batch) {
        return proof;
      }
      return { compressed: compressBatch(proof.batch) };
    }
    exports.compress = compress;
    function decompress(proof) {
      if (!proof.compressed) {
        return proof;
      }
      return { batch: decompressBatch(proof.compressed) };
    }
    exports.decompress = decompress;
    function compressBatch(proof) {
      const centries = [];
      const lookup = [];
      const registry = /* @__PURE__ */ new Map();
      for (const entry of proof.entries) {
        if (entry.exist) {
          const centry = { exist: compressExist(entry.exist, lookup, registry) };
          centries.push(centry);
        } else if (entry.nonexist) {
          const non = entry.nonexist;
          const centry = {
            nonexist: {
              key: non.key,
              left: compressExist(non.left, lookup, registry),
              right: compressExist(non.right, lookup, registry)
            }
          };
          centries.push(centry);
        } else {
          throw new Error("Unexpected batch entry during compress");
        }
      }
      return {
        entries: centries,
        lookupInners: lookup
      };
    }
    function compressExist(exist, lookup, registry) {
      if (!exist) {
        return void 0;
      }
      const path = exist.path.map((inner) => {
        const sig = codecimpl_1.ics23.InnerOp.encode(inner).finish();
        let idx = registry.get(sig);
        if (idx === void 0) {
          idx = lookup.length;
          lookup.push(inner);
          registry.set(sig, idx);
        }
        return idx;
      });
      return {
        key: exist.key,
        value: exist.value,
        leaf: exist.leaf,
        path
      };
    }
    function decompressBatch(proof) {
      const lookup = proof.lookupInners;
      const entries = proof.entries.map((comp) => {
        if (comp.exist) {
          return { exist: decompressExist(comp.exist, lookup) };
        } else if (comp.nonexist) {
          const non = comp.nonexist;
          return {
            nonexist: {
              key: non.key,
              left: decompressExist(non.left, lookup),
              right: decompressExist(non.right, lookup)
            }
          };
        } else {
          throw new Error("Unexpected batch entry during compress");
        }
      });
      return {
        entries
      };
    }
    function decompressExist(exist, lookup) {
      if (!exist) {
        return void 0;
      }
      const { key, value, leaf, path } = exist;
      const newPath = (path || []).map((idx) => lookup[idx]);
      return { key, value, leaf, path: newPath };
    }
  }
});

// ../../node_modules/.pnpm/@confio+ics23@0.6.8/node_modules/@confio/ics23/build/ops.js
var require_ops = __commonJS({
  "../../node_modules/.pnpm/@confio+ics23@0.6.8/node_modules/@confio/ics23/build/ops.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.doHash = exports.applyInner = exports.applyLeaf = void 0;
    var ripemd160_1 = require_ripemd160();
    var sha256_1 = require_sha256();
    var sha512_1 = require_sha512();
    var codecimpl_1 = require_codecimpl();
    function applyLeaf(leaf, key, value) {
      if (key.length === 0) {
        throw new Error("Missing key");
      }
      if (value.length === 0) {
        throw new Error("Missing value");
      }
      const pkey = prepareLeafData(ensureHash(leaf.prehashKey), ensureLength(leaf.length), key);
      const pvalue = prepareLeafData(ensureHash(leaf.prehashValue), ensureLength(leaf.length), value);
      const data = new Uint8Array([
        ...ensureBytes(leaf.prefix),
        ...pkey,
        ...pvalue
      ]);
      return doHash(ensureHash(leaf.hash), data);
    }
    exports.applyLeaf = applyLeaf;
    function applyInner(inner, child) {
      if (child.length === 0) {
        throw new Error("Inner op needs child value");
      }
      const preimage = new Uint8Array([
        ...ensureBytes(inner.prefix),
        ...child,
        ...ensureBytes(inner.suffix)
      ]);
      return doHash(ensureHash(inner.hash), preimage);
    }
    exports.applyInner = applyInner;
    function ensure(maybe, value) {
      return maybe === void 0 || maybe === null ? value : maybe;
    }
    var ensureHash = (h) => ensure(h, codecimpl_1.ics23.HashOp.NO_HASH);
    var ensureLength = (l) => ensure(l, codecimpl_1.ics23.LengthOp.NO_PREFIX);
    var ensureBytes = (b) => ensure(b, new Uint8Array([]));
    function prepareLeafData(hashOp, lengthOp, data) {
      const h = doHashOrNoop(hashOp, data);
      return doLengthOp(lengthOp, h);
    }
    function doHashOrNoop(hashOp, preimage) {
      if (hashOp === codecimpl_1.ics23.HashOp.NO_HASH) {
        return preimage;
      }
      return doHash(hashOp, preimage);
    }
    function doHash(hashOp, preimage) {
      switch (hashOp) {
        case codecimpl_1.ics23.HashOp.SHA256:
          return (0, sha256_1.sha256)(preimage);
        case codecimpl_1.ics23.HashOp.SHA512:
          return (0, sha512_1.sha512)(preimage);
        case codecimpl_1.ics23.HashOp.RIPEMD160:
          return (0, ripemd160_1.ripemd160)(preimage);
        case codecimpl_1.ics23.HashOp.BITCOIN:
          return (0, ripemd160_1.ripemd160)((0, sha256_1.sha256)(preimage));
        case codecimpl_1.ics23.HashOp.SHA512_256:
          return (0, sha512_1.sha512_256)(preimage);
      }
      throw new Error(`Unsupported hashop: ${hashOp}`);
    }
    exports.doHash = doHash;
    function doLengthOp(lengthOp, data) {
      switch (lengthOp) {
        case codecimpl_1.ics23.LengthOp.NO_PREFIX:
          return data;
        case codecimpl_1.ics23.LengthOp.VAR_PROTO:
          return new Uint8Array([...encodeVarintProto(data.length), ...data]);
        case codecimpl_1.ics23.LengthOp.REQUIRE_32_BYTES:
          if (data.length !== 32) {
            throw new Error(`Length is ${data.length}, not 32 bytes`);
          }
          return data;
        case codecimpl_1.ics23.LengthOp.REQUIRE_64_BYTES:
          if (data.length !== 64) {
            throw new Error(`Length is ${data.length}, not 64 bytes`);
          }
          return data;
        case codecimpl_1.ics23.LengthOp.FIXED32_LITTLE:
          return new Uint8Array([...encodeFixed32Le(data.length), ...data]);
      }
      throw new Error(`Unsupported lengthop: ${lengthOp}`);
    }
    function encodeVarintProto(n) {
      let enc = [];
      let l = n;
      while (l >= 128) {
        const b = l % 128 + 128;
        enc = [...enc, b];
        l = l / 128;
      }
      enc = [...enc, l];
      return new Uint8Array(enc);
    }
    function encodeFixed32Le(n) {
      const enc = new Uint8Array(4);
      let l = n;
      for (let i = enc.length; i > 0; i--) {
        enc[Math.abs(i - enc.length)] = l % 256;
        l = Math.floor(l / 256);
      }
      return enc;
    }
  }
});

// ../../node_modules/.pnpm/@confio+ics23@0.6.8/node_modules/@confio/ics23/build/specs.js
var require_specs = __commonJS({
  "../../node_modules/.pnpm/@confio+ics23@0.6.8/node_modules/@confio/ics23/build/specs.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.bytesBefore = exports.ensureBytesBefore = exports.bytesEqual = exports.ensureBytesEqual = exports.ensureInner = exports.ensureLeaf = void 0;
    function ensureLeaf(leaf, spec) {
      if (leaf.hash !== spec.hash) {
        throw new Error(`Unexpected hashOp: ${leaf.hash}`);
      }
      if (leaf.prehashKey !== spec.prehashKey) {
        throw new Error(`Unexpected prehashKey: ${leaf.prehashKey}`);
      }
      if (leaf.prehashValue !== spec.prehashValue) {
        throw new Error(`Unexpected prehashValue: ${leaf.prehashValue}`);
      }
      if (leaf.length !== spec.length) {
        throw new Error(`Unexpected length op: ${leaf.length}`);
      }
      ensurePrefix(leaf.prefix, spec.prefix);
    }
    exports.ensureLeaf = ensureLeaf;
    function ensureInner(inner, prefix, spec) {
      if (inner.hash !== spec.hash) {
        throw new Error(`Unexpected hashOp: ${inner.hash}`);
      }
      if (!inner.prefix) {
        throw new Error("No prefix set for inner node");
      }
      if (hasPrefix(inner.prefix, prefix)) {
        throw new Error(`Inner node has leaf prefix`);
      }
      if (inner.prefix.length < (spec.minPrefixLength || 0)) {
        throw new Error(`Prefix too short: ${inner.prefix.length} bytes`);
      }
      const maxLeftChildBytes = (spec.childOrder.length - 1) * spec.childSize;
      if (inner.prefix.length > (spec.maxPrefixLength || 0) + maxLeftChildBytes) {
        throw new Error(`Prefix too long: ${inner.prefix.length} bytes`);
      }
    }
    exports.ensureInner = ensureInner;
    function ensurePrefix(check, prefix) {
      if (!prefix || prefix.length === 0) {
        return;
      }
      if (!check) {
        throw new Error(`Target bytes missing`);
      }
      ensureBytesEqual(prefix, check.slice(0, prefix.length));
    }
    function ensureBytesEqual(a, b) {
      if (a.length !== b.length) {
        throw new Error(`Different lengths ${a.length} vs ${b.length}`);
      }
      for (let i = 0; i < a.length; i++) {
        if (a[i] !== b[i]) {
          throw new Error(`Arrays differ at index ${i}: ${a[i]} vs ${b[i]}`);
        }
      }
    }
    exports.ensureBytesEqual = ensureBytesEqual;
    function bytesEqual(a, b) {
      if (a.length !== b.length) {
        return false;
      }
      for (let i = 0; i < a.length; i++) {
        if (a[i] !== b[i]) {
          return false;
        }
      }
      return true;
    }
    exports.bytesEqual = bytesEqual;
    function hasPrefix(check, prefix) {
      if (!prefix || prefix.length === 0) {
        return false;
      }
      if (!check) {
        return false;
      }
      if (check.length <= prefix.length) {
        return false;
      }
      for (let i = 0; i < prefix.length; i++) {
        if (check[i] !== prefix[i]) {
          return false;
        }
      }
      throw true;
    }
    function ensureBytesBefore(first, last) {
      if (!bytesBefore(first, last)) {
        throw new Error("first is after last");
      }
    }
    exports.ensureBytesBefore = ensureBytesBefore;
    function bytesBefore(first, last) {
      const min = first.length < last.length ? first.length : last.length;
      for (let i = 0; i < min; i++) {
        if (first[i] < last[i]) {
          return true;
        }
        if (first[i] > last[i]) {
          return false;
        }
      }
      return first.length < last.length;
    }
    exports.bytesBefore = bytesBefore;
  }
});

// ../../node_modules/.pnpm/@confio+ics23@0.6.8/node_modules/@confio/ics23/build/proofs.js
var require_proofs = __commonJS({
  "../../node_modules/.pnpm/@confio+ics23@0.6.8/node_modules/@confio/ics23/build/proofs.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ensureLeftNeighbor = exports.ensureSpec = exports.calculateExistenceRoot = exports.verifyNonExistence = exports.verifyExistence = exports.smtSpec = exports.tendermintSpec = exports.iavlSpec = void 0;
    var codecimpl_1 = require_codecimpl();
    var ops_1 = require_ops();
    var specs_1 = require_specs();
    exports.iavlSpec = {
      leafSpec: {
        prefix: Uint8Array.from([0]),
        hash: codecimpl_1.ics23.HashOp.SHA256,
        prehashValue: codecimpl_1.ics23.HashOp.SHA256,
        prehashKey: codecimpl_1.ics23.HashOp.NO_HASH,
        length: codecimpl_1.ics23.LengthOp.VAR_PROTO
      },
      innerSpec: {
        childOrder: [0, 1],
        minPrefixLength: 4,
        maxPrefixLength: 12,
        childSize: 33,
        hash: codecimpl_1.ics23.HashOp.SHA256
      }
    };
    exports.tendermintSpec = {
      leafSpec: {
        prefix: Uint8Array.from([0]),
        hash: codecimpl_1.ics23.HashOp.SHA256,
        prehashValue: codecimpl_1.ics23.HashOp.SHA256,
        prehashKey: codecimpl_1.ics23.HashOp.NO_HASH,
        length: codecimpl_1.ics23.LengthOp.VAR_PROTO
      },
      innerSpec: {
        childOrder: [0, 1],
        minPrefixLength: 1,
        maxPrefixLength: 1,
        childSize: 32,
        hash: codecimpl_1.ics23.HashOp.SHA256
      }
    };
    exports.smtSpec = {
      leafSpec: {
        hash: codecimpl_1.ics23.HashOp.SHA256,
        prehashKey: codecimpl_1.ics23.HashOp.NO_HASH,
        prehashValue: codecimpl_1.ics23.HashOp.SHA256,
        length: codecimpl_1.ics23.LengthOp.NO_PREFIX,
        prefix: Uint8Array.from([0])
      },
      innerSpec: {
        childOrder: [0, 1],
        childSize: 32,
        minPrefixLength: 1,
        maxPrefixLength: 1,
        emptyChild: new Uint8Array(32),
        hash: codecimpl_1.ics23.HashOp.SHA256
      },
      maxDepth: 256
    };
    function verifyExistence(proof, spec, root, key, value) {
      ensureSpec(proof, spec);
      const calc = calculateExistenceRoot(proof);
      (0, specs_1.ensureBytesEqual)(calc, root);
      (0, specs_1.ensureBytesEqual)(key, proof.key);
      (0, specs_1.ensureBytesEqual)(value, proof.value);
    }
    exports.verifyExistence = verifyExistence;
    function verifyNonExistence(proof, spec, root, key) {
      let leftKey;
      let rightKey;
      if (proof.left) {
        verifyExistence(proof.left, spec, root, proof.left.key, proof.left.value);
        leftKey = proof.left.key;
      }
      if (proof.right) {
        verifyExistence(proof.right, spec, root, proof.right.key, proof.right.value);
        rightKey = proof.right.key;
      }
      if (!leftKey && !rightKey) {
        throw new Error("neither left nor right proof defined");
      }
      if (leftKey) {
        (0, specs_1.ensureBytesBefore)(leftKey, key);
      }
      if (rightKey) {
        (0, specs_1.ensureBytesBefore)(key, rightKey);
      }
      if (!spec.innerSpec) {
        throw new Error("no inner spec");
      }
      if (!leftKey) {
        ensureLeftMost(spec.innerSpec, proof.right.path);
      } else if (!rightKey) {
        ensureRightMost(spec.innerSpec, proof.left.path);
      } else {
        ensureLeftNeighbor(spec.innerSpec, proof.left.path, proof.right.path);
      }
      return;
    }
    exports.verifyNonExistence = verifyNonExistence;
    function calculateExistenceRoot(proof) {
      if (!proof.key || !proof.value) {
        throw new Error("Existence proof needs key and value set");
      }
      if (!proof.leaf) {
        throw new Error("Existence proof must start with a leaf operation");
      }
      const path = proof.path || [];
      let res = (0, ops_1.applyLeaf)(proof.leaf, proof.key, proof.value);
      for (const inner of path) {
        res = (0, ops_1.applyInner)(inner, res);
      }
      return res;
    }
    exports.calculateExistenceRoot = calculateExistenceRoot;
    function ensureSpec(proof, spec) {
      if (!proof.leaf) {
        throw new Error("Existence proof must start with a leaf operation");
      }
      if (!spec.leafSpec) {
        throw new Error("Spec must include leafSpec");
      }
      if (!spec.innerSpec) {
        throw new Error("Spec must include innerSpec");
      }
      (0, specs_1.ensureLeaf)(proof.leaf, spec.leafSpec);
      const path = proof.path || [];
      if (spec.minDepth && path.length < spec.minDepth) {
        throw new Error(`Too few inner nodes ${path.length}`);
      }
      if (spec.maxDepth && path.length > spec.maxDepth) {
        throw new Error(`Too many inner nodes ${path.length}`);
      }
      for (const inner of path) {
        (0, specs_1.ensureInner)(inner, spec.leafSpec.prefix, spec.innerSpec);
      }
    }
    exports.ensureSpec = ensureSpec;
    function ensureLeftMost(spec, path) {
      const { minPrefix, maxPrefix, suffix } = getPadding(spec, 0);
      for (const step of path) {
        if (!hasPadding(step, minPrefix, maxPrefix, suffix)) {
          throw new Error("Step not leftmost");
        }
      }
    }
    function ensureRightMost(spec, path) {
      const len = spec.childOrder.length - 1;
      const { minPrefix, maxPrefix, suffix } = getPadding(spec, len);
      for (const step of path) {
        if (!hasPadding(step, minPrefix, maxPrefix, suffix)) {
          throw new Error("Step not leftmost");
        }
      }
    }
    function ensureLeftNeighbor(spec, left, right) {
      const mutleft = [...left];
      const mutright = [...right];
      let topleft = mutleft.pop();
      let topright = mutright.pop();
      while ((0, specs_1.bytesEqual)(topleft.prefix, topright.prefix) && (0, specs_1.bytesEqual)(topleft.suffix, topright.suffix)) {
        topleft = mutleft.pop();
        topright = mutright.pop();
      }
      if (!isLeftStep(spec, topleft, topright)) {
        throw new Error(`Not left neightbor at first divergent step`);
      }
      ensureRightMost(spec, mutleft);
      ensureLeftMost(spec, mutright);
    }
    exports.ensureLeftNeighbor = ensureLeftNeighbor;
    function isLeftStep(spec, left, right) {
      const leftidx = orderFromPadding(spec, left);
      const rightidx = orderFromPadding(spec, right);
      return rightidx === leftidx + 1;
    }
    function orderFromPadding(spec, inner) {
      for (let branch = 0; branch < spec.childOrder.length; branch++) {
        const { minPrefix, maxPrefix, suffix } = getPadding(spec, branch);
        if (hasPadding(inner, minPrefix, maxPrefix, suffix)) {
          return branch;
        }
      }
      throw new Error(`Cannot find any valid spacing for this node`);
    }
    function hasPadding(op, minPrefix, maxPrefix, suffix) {
      if ((op.prefix || []).length < minPrefix) {
        return false;
      }
      if ((op.prefix || []).length > maxPrefix) {
        return false;
      }
      return (op.suffix || []).length === suffix;
    }
    function getPadding(spec, branch) {
      const idx = getPosition(spec.childOrder, branch);
      const prefix = idx * spec.childSize;
      const minPrefix = prefix + spec.minPrefixLength;
      const maxPrefix = prefix + spec.maxPrefixLength;
      const suffix = (spec.childOrder.length - 1 - idx) * spec.childSize;
      return { minPrefix, maxPrefix, suffix };
    }
    function getPosition(order, branch) {
      if (branch < 0 || branch >= order.length) {
        throw new Error(`Invalid branch: ${branch}`);
      }
      return order.findIndex((val) => val === branch);
    }
  }
});

// ../../node_modules/.pnpm/@confio+ics23@0.6.8/node_modules/@confio/ics23/build/ics23.js
var require_ics23 = __commonJS({
  "../../node_modules/.pnpm/@confio+ics23@0.6.8/node_modules/@confio/ics23/build/ics23.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.batchVerifyNonMembership = exports.batchVerifyMembership = exports.verifyNonMembership = exports.verifyMembership = void 0;
    var compress_1 = require_compress();
    var proofs_1 = require_proofs();
    var specs_1 = require_specs();
    function verifyMembership(proof, spec, root, key, value) {
      const norm = (0, compress_1.decompress)(proof);
      const exist = getExistForKey(norm, key);
      if (!exist) {
        return false;
      }
      try {
        (0, proofs_1.verifyExistence)(exist, spec, root, key, value);
        return true;
      } catch (_a) {
        return false;
      }
    }
    exports.verifyMembership = verifyMembership;
    function verifyNonMembership(proof, spec, root, key) {
      const norm = (0, compress_1.decompress)(proof);
      const nonexist = getNonExistForKey(norm, key);
      if (!nonexist) {
        return false;
      }
      try {
        (0, proofs_1.verifyNonExistence)(nonexist, spec, root, key);
        return true;
      } catch (_a) {
        return false;
      }
    }
    exports.verifyNonMembership = verifyNonMembership;
    function batchVerifyMembership(proof, spec, root, items) {
      const norm = (0, compress_1.decompress)(proof);
      for (const [key, value] of items.entries()) {
        if (!verifyMembership(norm, spec, root, key, value)) {
          return false;
        }
      }
      return true;
    }
    exports.batchVerifyMembership = batchVerifyMembership;
    function batchVerifyNonMembership(proof, spec, root, keys) {
      const norm = (0, compress_1.decompress)(proof);
      for (const key of keys) {
        if (!verifyNonMembership(norm, spec, root, key)) {
          return false;
        }
      }
      return true;
    }
    exports.batchVerifyNonMembership = batchVerifyNonMembership;
    function getExistForKey(proof, key) {
      const match = (p) => !!p && (0, specs_1.bytesEqual)(key, p.key);
      if (match(proof.exist)) {
        return proof.exist;
      } else if (proof.batch) {
        return proof.batch.entries.map((x) => x.exist || null).find(match);
      }
      return void 0;
    }
    function getNonExistForKey(proof, key) {
      const match = (p) => {
        return !!p && (!p.left || (0, specs_1.bytesBefore)(p.left.key, key)) && (!p.right || (0, specs_1.bytesBefore)(key, p.right.key));
      };
      if (match(proof.nonexist)) {
        return proof.nonexist;
      } else if (proof.batch) {
        return proof.batch.entries.map((x) => x.nonexist || null).find(match);
      }
      return void 0;
    }
  }
});

// ../../node_modules/.pnpm/@confio+ics23@0.6.8/node_modules/@confio/ics23/build/index.js
var require_build7 = __commonJS({
  "../../node_modules/.pnpm/@confio+ics23@0.6.8/node_modules/@confio/ics23/build/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.verifyNonExistence = exports.verifyExistence = exports.tendermintSpec = exports.iavlSpec = exports.calculateExistenceRoot = exports.verifyNonMembership = exports.verifyMembership = exports.ics23 = void 0;
    var codecimpl_1 = require_codecimpl();
    Object.defineProperty(exports, "ics23", { enumerable: true, get: function() {
      return codecimpl_1.ics23;
    } });
    var ics23_1 = require_ics23();
    Object.defineProperty(exports, "verifyMembership", { enumerable: true, get: function() {
      return ics23_1.verifyMembership;
    } });
    Object.defineProperty(exports, "verifyNonMembership", { enumerable: true, get: function() {
      return ics23_1.verifyNonMembership;
    } });
    var proofs_1 = require_proofs();
    Object.defineProperty(exports, "calculateExistenceRoot", { enumerable: true, get: function() {
      return proofs_1.calculateExistenceRoot;
    } });
    Object.defineProperty(exports, "iavlSpec", { enumerable: true, get: function() {
      return proofs_1.iavlSpec;
    } });
    Object.defineProperty(exports, "tendermintSpec", { enumerable: true, get: function() {
      return proofs_1.tendermintSpec;
    } });
    Object.defineProperty(exports, "verifyExistence", { enumerable: true, get: function() {
      return proofs_1.verifyExistence;
    } });
    Object.defineProperty(exports, "verifyNonExistence", { enumerable: true, get: function() {
      return proofs_1.verifyNonExistence;
    } });
  }
});

// ../../node_modules/.pnpm/@cosmjs+stream@0.32.4/node_modules/@cosmjs/stream/build/concat.js
var require_concat = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+stream@0.32.4/node_modules/@cosmjs/stream/build/concat.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.concat = void 0;
    var xstream_1 = require_xstream();
    function concat(...streams) {
      const subscriptions = new Array();
      const queues = new Array();
      const completedStreams = /* @__PURE__ */ new Set();
      let activeStreamIndex = 0;
      function reset() {
        while (subscriptions.length > 0) {
          const subscription = subscriptions.shift();
          subscription.unsubscribe();
        }
        queues.length = 0;
        completedStreams.clear();
        activeStreamIndex = 0;
      }
      const producer = {
        start: (listener) => {
          streams.forEach((_) => queues.push([]));
          function emitAllQueuesEvents(streamIndex) {
            while (true) {
              const element = queues[streamIndex].shift();
              if (element === void 0) {
                return;
              }
              listener.next(element);
            }
          }
          function isDone() {
            return activeStreamIndex >= streams.length;
          }
          if (isDone()) {
            listener.complete();
            return;
          }
          streams.forEach((stream, index) => {
            subscriptions.push(stream.subscribe({
              next: (value) => {
                if (index === activeStreamIndex) {
                  listener.next(value);
                } else {
                  queues[index].push(value);
                }
              },
              complete: () => {
                completedStreams.add(index);
                while (completedStreams.has(activeStreamIndex)) {
                  emitAllQueuesEvents(activeStreamIndex);
                  activeStreamIndex++;
                }
                if (isDone()) {
                  listener.complete();
                } else {
                  emitAllQueuesEvents(activeStreamIndex);
                }
              },
              error: (error) => {
                listener.error(error);
                reset();
              }
            }));
          });
        },
        stop: () => {
          reset();
        }
      };
      return xstream_1.Stream.create(producer);
    }
    exports.concat = concat;
  }
});

// ../../node_modules/.pnpm/@cosmjs+stream@0.32.4/node_modules/@cosmjs/stream/build/defaultvalueproducer.js
var require_defaultvalueproducer = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+stream@0.32.4/node_modules/@cosmjs/stream/build/defaultvalueproducer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DefaultValueProducer = void 0;
    var DefaultValueProducer = class {
      get value() {
        return this.internalValue;
      }
      constructor(value, callbacks) {
        this.callbacks = callbacks;
        this.internalValue = value;
      }
      /**
       * Update the current value.
       *
       * If producer is active (i.e. someone is listening), this emits an event.
       * If not, just the current value is updated.
       */
      update(value) {
        this.internalValue = value;
        if (this.listener) {
          this.listener.next(value);
        }
      }
      /**
       * Produce an error
       */
      // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
      error(error) {
        if (this.listener) {
          this.listener.error(error);
        }
      }
      /**
       * Called by the stream. Do not call this directly.
       */
      start(listener) {
        this.listener = listener;
        listener.next(this.internalValue);
        if (this.callbacks) {
          this.callbacks.onStarted();
        }
      }
      /**
       * Called by the stream. Do not call this directly.
       */
      stop() {
        if (this.callbacks) {
          this.callbacks.onStop();
        }
        this.listener = void 0;
      }
    };
    exports.DefaultValueProducer = DefaultValueProducer;
  }
});

// ../../node_modules/.pnpm/@cosmjs+stream@0.32.4/node_modules/@cosmjs/stream/build/dropduplicates.js
var require_dropduplicates = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+stream@0.32.4/node_modules/@cosmjs/stream/build/dropduplicates.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.dropDuplicates = void 0;
    function dropDuplicates(valueToKey) {
      const operand = (instream) => {
        const emittedKeys = /* @__PURE__ */ new Set();
        const deduplicatedStream = instream.filter((value) => !emittedKeys.has(valueToKey(value))).debug((value) => emittedKeys.add(valueToKey(value)));
        return deduplicatedStream;
      };
      return operand;
    }
    exports.dropDuplicates = dropDuplicates;
  }
});

// ../../node_modules/.pnpm/@cosmjs+stream@0.32.4/node_modules/@cosmjs/stream/build/promise.js
var require_promise = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+stream@0.32.4/node_modules/@cosmjs/stream/build/promise.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.firstEvent = exports.toListPromise = exports.fromListPromise = void 0;
    var xstream_1 = require_xstream();
    function fromListPromise(promise) {
      const producer = {
        start: (listener) => {
          promise.then((iterable) => {
            for (const element of iterable) {
              listener.next(element);
            }
            listener.complete();
          }).catch((error) => listener.error(error));
        },
        // eslint-disable-next-line @typescript-eslint/no-empty-function
        stop: () => {
        }
      };
      return xstream_1.Stream.create(producer);
    }
    exports.fromListPromise = fromListPromise;
    async function toListPromise(stream, count) {
      return new Promise((resolve, reject) => {
        if (count === 0) {
          resolve([]);
          return;
        }
        const events = new Array();
        stream.take(count).subscribe({
          next: (event) => {
            events.push(event);
            if (events.length === count) {
              resolve(events);
            }
          },
          complete: () => {
            reject(`Stream completed before all events could be collected. Collected ${events.length}, expected ${count}`);
          },
          error: (error) => reject(error)
        });
      });
    }
    exports.toListPromise = toListPromise;
    async function firstEvent(stream) {
      return (await toListPromise(stream, 1))[0];
    }
    exports.firstEvent = firstEvent;
  }
});

// ../../node_modules/.pnpm/@cosmjs+stream@0.32.4/node_modules/@cosmjs/stream/build/reducer.js
var require_reducer = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+stream@0.32.4/node_modules/@cosmjs/stream/build/reducer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.lastValue = exports.asArray = exports.countStream = exports.Reducer = void 0;
    var Reducer = class {
      constructor(stream, reducer, initState) {
        this.stream = stream;
        this.reducer = reducer;
        this.state = initState;
        this.completed = new Promise((resolve, reject) => {
          const subscription = this.stream.subscribe({
            next: (evt) => {
              this.state = this.reducer(this.state, evt);
            },
            complete: () => {
              resolve();
              subscription.unsubscribe();
            },
            error: (err) => {
              reject(err);
              subscription.unsubscribe();
            }
          });
        });
      }
      // value returns current materialized state
      value() {
        return this.state;
      }
      // finished resolves on completed stream, rejects on stream error
      async finished() {
        return this.completed;
      }
    };
    exports.Reducer = Reducer;
    function increment(sum, _) {
      return sum + 1;
    }
    function countStream(stream) {
      return new Reducer(stream, increment, 0);
    }
    exports.countStream = countStream;
    function append(list, evt) {
      return [...list, evt];
    }
    function asArray(stream) {
      return new Reducer(stream, append, []);
    }
    exports.asArray = asArray;
    function last(_, event) {
      return event;
    }
    function lastValue(stream) {
      return new Reducer(stream, last, void 0);
    }
    exports.lastValue = lastValue;
  }
});

// ../../node_modules/.pnpm/@cosmjs+stream@0.32.4/node_modules/@cosmjs/stream/build/valueandupdates.js
var require_valueandupdates = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+stream@0.32.4/node_modules/@cosmjs/stream/build/valueandupdates.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ValueAndUpdates = void 0;
    var xstream_1 = require_xstream();
    var ValueAndUpdates = class {
      get value() {
        return this.producer.value;
      }
      constructor(producer) {
        this.producer = producer;
        this.updates = xstream_1.MemoryStream.createWithMemory(this.producer);
      }
      /**
       * Resolves as soon as search value is found.
       *
       * @param search either a value or a function that must return true when found
       * @returns the value of the update that caused the search match
       */
      async waitFor(search) {
        const searchImplementation = typeof search === "function" ? search : (value) => value === search;
        return new Promise((resolve, reject) => {
          const subscription = this.updates.subscribe({
            next: (newValue) => {
              if (searchImplementation(newValue)) {
                resolve(newValue);
                setTimeout(() => subscription.unsubscribe(), 0);
              }
            },
            complete: () => {
              subscription.unsubscribe();
              reject("Update stream completed without expected value");
            },
            error: (error) => {
              reject(error);
            }
          });
        });
      }
    };
    exports.ValueAndUpdates = ValueAndUpdates;
  }
});

// ../../node_modules/.pnpm/@cosmjs+stream@0.32.4/node_modules/@cosmjs/stream/build/index.js
var require_build8 = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+stream@0.32.4/node_modules/@cosmjs/stream/build/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ValueAndUpdates = exports.toListPromise = exports.fromListPromise = exports.firstEvent = exports.dropDuplicates = exports.DefaultValueProducer = exports.concat = void 0;
    var concat_1 = require_concat();
    Object.defineProperty(exports, "concat", { enumerable: true, get: function() {
      return concat_1.concat;
    } });
    var defaultvalueproducer_1 = require_defaultvalueproducer();
    Object.defineProperty(exports, "DefaultValueProducer", { enumerable: true, get: function() {
      return defaultvalueproducer_1.DefaultValueProducer;
    } });
    var dropduplicates_1 = require_dropduplicates();
    Object.defineProperty(exports, "dropDuplicates", { enumerable: true, get: function() {
      return dropduplicates_1.dropDuplicates;
    } });
    var promise_1 = require_promise();
    Object.defineProperty(exports, "firstEvent", { enumerable: true, get: function() {
      return promise_1.firstEvent;
    } });
    Object.defineProperty(exports, "fromListPromise", { enumerable: true, get: function() {
      return promise_1.fromListPromise;
    } });
    Object.defineProperty(exports, "toListPromise", { enumerable: true, get: function() {
      return promise_1.toListPromise;
    } });
    __exportStar(require_reducer(), exports);
    var valueandupdates_1 = require_valueandupdates();
    Object.defineProperty(exports, "ValueAndUpdates", { enumerable: true, get: function() {
      return valueandupdates_1.ValueAndUpdates;
    } });
  }
});

// ../../node_modules/.pnpm/@cosmjs+stargate@0.32.4/node_modules/@cosmjs/stargate/build/queryclient/queryclient.js
var require_queryclient = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+stargate@0.32.4/node_modules/@cosmjs/stargate/build/queryclient/queryclient.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.QueryClient = void 0;
    var ics23_1 = require_build7();
    var encoding_1 = require_build2();
    var stream_1 = require_build8();
    var utils_1 = require_build3();
    function checkAndParseOp(op, kind, key) {
      if (op.type !== kind) {
        throw new Error(`Op expected to be ${kind}, got "${op.type}`);
      }
      if (!(0, utils_1.arrayContentEquals)(key, op.key)) {
        throw new Error(`Proven key different than queried key.
Query: ${(0, encoding_1.toHex)(key)}
Proven: ${(0, encoding_1.toHex)(op.key)}`);
      }
      return ics23_1.ics23.CommitmentProof.decode(op.data);
    }
    var QueryClient = class _QueryClient {
      static withExtensions(cometClient, ...extensionSetups) {
        const client = new _QueryClient(cometClient);
        const extensions = extensionSetups.map((setupExtension) => setupExtension(client));
        for (const extension of extensions) {
          (0, utils_1.assert)((0, utils_1.isNonNullObject)(extension), `Extension must be a non-null object`);
          for (const [moduleKey, moduleValue] of Object.entries(extension)) {
            (0, utils_1.assert)((0, utils_1.isNonNullObject)(moduleValue), `Module must be a non-null object. Found type ${typeof moduleValue} for module "${moduleKey}".`);
            const current = client[moduleKey] || {};
            client[moduleKey] = {
              ...current,
              ...moduleValue
            };
          }
        }
        return client;
      }
      constructor(cometClient) {
        this.cometClient = cometClient;
      }
      /**
       * Queries the database store with a proof, which is then verified.
       *
       * Please note: the current implementation trusts block headers it gets from the PRC endpoint.
       */
      async queryStoreVerified(store, queryKey, desiredHeight) {
        const { height, proof, key, value } = await this.queryRawProof(store, queryKey, desiredHeight);
        const subProof = checkAndParseOp(proof.ops[0], "ics23:iavl", queryKey);
        const storeProof = checkAndParseOp(proof.ops[1], "ics23:simple", (0, encoding_1.toAscii)(store));
        (0, utils_1.assert)(storeProof.exist);
        (0, utils_1.assert)(storeProof.exist.value);
        if (!value || value.length === 0) {
          (0, utils_1.assert)(subProof.nonexist);
          (0, ics23_1.verifyNonExistence)(subProof.nonexist, ics23_1.iavlSpec, storeProof.exist.value, queryKey);
        } else {
          (0, utils_1.assert)(subProof.exist);
          (0, utils_1.assert)(subProof.exist.value);
          (0, ics23_1.verifyExistence)(subProof.exist, ics23_1.iavlSpec, storeProof.exist.value, queryKey, value);
        }
        const header = await this.getNextHeader(height);
        (0, ics23_1.verifyExistence)(storeProof.exist, ics23_1.tendermintSpec, header.appHash, (0, encoding_1.toAscii)(store), storeProof.exist.value);
        return { key, value, height };
      }
      async queryRawProof(store, queryKey, desiredHeight) {
        const { key, value, height, proof, code, log } = await this.cometClient.abciQuery({
          // we need the StoreKey for the module, not the module name
          // https://github.com/cosmos/cosmos-sdk/blob/8cab43c8120fec5200c3459cbf4a92017bb6f287/x/auth/types/keys.go#L12
          path: `/store/${store}/key`,
          data: queryKey,
          prove: true,
          height: desiredHeight
        });
        if (code) {
          throw new Error(`Query failed with (${code}): ${log}`);
        }
        if (!(0, utils_1.arrayContentEquals)(queryKey, key)) {
          throw new Error(`Response key ${(0, encoding_1.toHex)(key)} doesn't match query key ${(0, encoding_1.toHex)(queryKey)}`);
        }
        if (!height) {
          throw new Error("No query height returned");
        }
        if (!proof || proof.ops.length !== 2) {
          throw new Error(`Expected 2 proof ops, got ${(proof == null ? void 0 : proof.ops.length) ?? 0}. Are you using stargate?`);
        }
        checkAndParseOp(proof.ops[0], "ics23:iavl", key);
        checkAndParseOp(proof.ops[1], "ics23:simple", (0, encoding_1.toAscii)(store));
        return {
          key,
          value,
          height,
          // need to clone this: readonly input / writeable output
          proof: {
            ops: [...proof.ops]
          }
        };
      }
      /**
       * Performs an ABCI query to Tendermint without requesting a proof.
       *
       * If the `desiredHeight` is set, a particular height is requested. Otherwise
       * the latest height is requested. The response contains the actual height of
       * the query.
       */
      async queryAbci(path, request, desiredHeight) {
        const response = await this.cometClient.abciQuery({
          path,
          data: request,
          prove: false,
          height: desiredHeight
        });
        if (response.code) {
          throw new Error(`Query failed with (${response.code}): ${response.log}`);
        }
        if (!response.height) {
          throw new Error("No query height returned");
        }
        return {
          value: response.value,
          height: response.height
        };
      }
      // this must return the header for height+1
      // throws an error if height is 0 or undefined
      async getNextHeader(height) {
        (0, utils_1.assertDefined)(height);
        if (height === 0) {
          throw new Error("Query returned height 0, cannot prove it");
        }
        const searchHeight = height + 1;
        let nextHeader;
        let headersSubscription;
        try {
          headersSubscription = this.cometClient.subscribeNewBlockHeader();
        } catch {
        }
        if (headersSubscription) {
          const firstHeader = await (0, stream_1.firstEvent)(headersSubscription);
          if (firstHeader.height === searchHeight) {
            nextHeader = firstHeader;
          }
        }
        while (!nextHeader) {
          const correctHeader = (await this.cometClient.blockchain(height, searchHeight)).blockMetas.map((meta) => meta.header).find((h) => h.height === searchHeight);
          if (correctHeader) {
            nextHeader = correctHeader;
          } else {
            await (0, utils_1.sleep)(1e3);
          }
        }
        (0, utils_1.assert)(nextHeader.height === searchHeight, "Got wrong header. This is a bug in the logic above.");
        return nextHeader;
      }
    };
    exports.QueryClient = QueryClient;
  }
});

// ../../node_modules/.pnpm/@cosmjs+stargate@0.32.4/node_modules/@cosmjs/stargate/build/queryclient/utils.js
var require_utils2 = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+stargate@0.32.4/node_modules/@cosmjs/stargate/build/queryclient/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.decodeCosmosSdkDecFromProto = exports.longify = exports.createProtobufRpcClient = exports.createPagination = exports.toAccAddress = void 0;
    var encoding_1 = require_build2();
    var math_1 = require_build();
    var pagination_1 = require_pagination();
    function toAccAddress(address) {
      return (0, encoding_1.fromBech32)(address).data;
    }
    exports.toAccAddress = toAccAddress;
    function createPagination(paginationKey) {
      return paginationKey ? pagination_1.PageRequest.fromPartial({ key: paginationKey }) : pagination_1.PageRequest.fromPartial({});
    }
    exports.createPagination = createPagination;
    function createProtobufRpcClient(base) {
      return {
        request: async (service, method, data) => {
          const path = `/${service}/${method}`;
          const response = await base.queryAbci(path, data, void 0);
          return response.value;
        }
      };
    }
    exports.createProtobufRpcClient = createProtobufRpcClient;
    function longify(value) {
      const checkedValue = math_1.Uint64.fromString(value.toString());
      return BigInt(checkedValue.toString());
    }
    exports.longify = longify;
    function decodeCosmosSdkDecFromProto(input) {
      const asString = typeof input === "string" ? input : (0, encoding_1.fromAscii)(input);
      return math_1.Decimal.fromAtomics(asString, 18);
    }
    exports.decodeCosmosSdkDecFromProto = decodeCosmosSdkDecFromProto;
  }
});

// ../../node_modules/.pnpm/@cosmjs+stargate@0.32.4/node_modules/@cosmjs/stargate/build/queryclient/index.js
var require_queryclient2 = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+stargate@0.32.4/node_modules/@cosmjs/stargate/build/queryclient/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.longify = exports.decodeCosmosSdkDecFromProto = exports.createProtobufRpcClient = exports.createPagination = exports.QueryClient = void 0;
    var queryclient_1 = require_queryclient();
    Object.defineProperty(exports, "QueryClient", { enumerable: true, get: function() {
      return queryclient_1.QueryClient;
    } });
    var utils_1 = require_utils2();
    Object.defineProperty(exports, "createPagination", { enumerable: true, get: function() {
      return utils_1.createPagination;
    } });
    Object.defineProperty(exports, "createProtobufRpcClient", { enumerable: true, get: function() {
      return utils_1.createProtobufRpcClient;
    } });
    Object.defineProperty(exports, "decodeCosmosSdkDecFromProto", { enumerable: true, get: function() {
      return utils_1.decodeCosmosSdkDecFromProto;
    } });
    Object.defineProperty(exports, "longify", { enumerable: true, get: function() {
      return utils_1.longify;
    } });
  }
});

// ../../node_modules/.pnpm/@cosmjs+stargate@0.32.4/node_modules/@cosmjs/stargate/build/modules/auth/queries.js
var require_queries = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+stargate@0.32.4/node_modules/@cosmjs/stargate/build/modules/auth/queries.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.setupAuthExtension = void 0;
    var query_1 = require_query();
    var queryclient_1 = require_queryclient2();
    function setupAuthExtension(base) {
      const rpc = (0, queryclient_1.createProtobufRpcClient)(base);
      const queryService = new query_1.QueryClientImpl(rpc);
      return {
        auth: {
          account: async (address) => {
            const { account } = await queryService.Account({ address });
            return account ?? null;
          }
        }
      };
    }
    exports.setupAuthExtension = setupAuthExtension;
  }
});

// ../../node_modules/.pnpm/@cosmjs+stargate@0.32.4/node_modules/@cosmjs/stargate/build/modules/authz/aminomessages.js
var require_aminomessages = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+stargate@0.32.4/node_modules/@cosmjs/stargate/build/modules/authz/aminomessages.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createAuthzAminoConverters = void 0;
    function createAuthzAminoConverters() {
      return {
        // For Cosmos SDK < 0.46 the Amino JSON codec was broken on chain and thus inaccessible.
        // Now this can be implemented for 0.46+ chains, see
        // https://github.com/cosmos/cosmjs/issues/1092
        //
        // "/cosmos.authz.v1beta1.MsgGrant": IMPLEMENT ME,
        // "/cosmos.authz.v1beta1.MsgExec": IMPLEMENT ME,
        // "/cosmos.authz.v1beta1.MsgRevoke": IMPLEMENT ME,
      };
    }
    exports.createAuthzAminoConverters = createAuthzAminoConverters;
  }
});

// ../../node_modules/.pnpm/@cosmjs+stargate@0.32.4/node_modules/@cosmjs/stargate/build/modules/authz/messages.js
var require_messages = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+stargate@0.32.4/node_modules/@cosmjs/stargate/build/modules/authz/messages.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.authzTypes = void 0;
    var tx_1 = require_tx3();
    exports.authzTypes = [
      ["/cosmos.authz.v1beta1.MsgExec", tx_1.MsgExec],
      ["/cosmos.authz.v1beta1.MsgGrant", tx_1.MsgGrant],
      ["/cosmos.authz.v1beta1.MsgRevoke", tx_1.MsgRevoke]
    ];
  }
});

// ../../node_modules/.pnpm/@cosmjs+stargate@0.32.4/node_modules/@cosmjs/stargate/build/modules/authz/queries.js
var require_queries2 = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+stargate@0.32.4/node_modules/@cosmjs/stargate/build/modules/authz/queries.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.setupAuthzExtension = void 0;
    var query_1 = require_query2();
    var queryclient_1 = require_queryclient2();
    function setupAuthzExtension(base) {
      const rpc = (0, queryclient_1.createProtobufRpcClient)(base);
      const queryService = new query_1.QueryClientImpl(rpc);
      return {
        authz: {
          grants: async (granter, grantee, msgTypeUrl, paginationKey) => {
            return await queryService.Grants({
              granter,
              grantee,
              msgTypeUrl,
              pagination: (0, queryclient_1.createPagination)(paginationKey)
            });
          },
          granteeGrants: async (grantee, paginationKey) => {
            return await queryService.GranteeGrants({
              grantee,
              pagination: (0, queryclient_1.createPagination)(paginationKey)
            });
          },
          granterGrants: async (granter, paginationKey) => {
            return await queryService.GranterGrants({
              granter,
              pagination: (0, queryclient_1.createPagination)(paginationKey)
            });
          }
        }
      };
    }
    exports.setupAuthzExtension = setupAuthzExtension;
  }
});

// ../../node_modules/.pnpm/@cosmjs+stargate@0.32.4/node_modules/@cosmjs/stargate/build/modules/bank/aminomessages.js
var require_aminomessages2 = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+stargate@0.32.4/node_modules/@cosmjs/stargate/build/modules/bank/aminomessages.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createBankAminoConverters = exports.isAminoMsgMultiSend = exports.isAminoMsgSend = void 0;
    function isAminoMsgSend(msg) {
      return msg.type === "cosmos-sdk/MsgSend";
    }
    exports.isAminoMsgSend = isAminoMsgSend;
    function isAminoMsgMultiSend(msg) {
      return msg.type === "cosmos-sdk/MsgMultiSend";
    }
    exports.isAminoMsgMultiSend = isAminoMsgMultiSend;
    function createBankAminoConverters() {
      return {
        "/cosmos.bank.v1beta1.MsgSend": {
          aminoType: "cosmos-sdk/MsgSend",
          toAmino: ({ fromAddress, toAddress, amount }) => ({
            from_address: fromAddress,
            to_address: toAddress,
            amount: [...amount]
          }),
          fromAmino: ({ from_address, to_address, amount }) => ({
            fromAddress: from_address,
            toAddress: to_address,
            amount: [...amount]
          })
        },
        "/cosmos.bank.v1beta1.MsgMultiSend": {
          aminoType: "cosmos-sdk/MsgMultiSend",
          toAmino: ({ inputs, outputs }) => ({
            inputs: inputs.map((input) => ({
              address: input.address,
              coins: [...input.coins]
            })),
            outputs: outputs.map((output) => ({
              address: output.address,
              coins: [...output.coins]
            }))
          }),
          fromAmino: ({ inputs, outputs }) => ({
            inputs: inputs.map((input) => ({
              address: input.address,
              coins: [...input.coins]
            })),
            outputs: outputs.map((output) => ({
              address: output.address,
              coins: [...output.coins]
            }))
          })
        }
      };
    }
    exports.createBankAminoConverters = createBankAminoConverters;
  }
});

// ../../node_modules/.pnpm/@cosmjs+stargate@0.32.4/node_modules/@cosmjs/stargate/build/modules/bank/messages.js
var require_messages2 = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+stargate@0.32.4/node_modules/@cosmjs/stargate/build/modules/bank/messages.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isMsgSendEncodeObject = exports.bankTypes = void 0;
    var tx_1 = require_tx2();
    exports.bankTypes = [
      ["/cosmos.bank.v1beta1.MsgMultiSend", tx_1.MsgMultiSend],
      ["/cosmos.bank.v1beta1.MsgSend", tx_1.MsgSend]
    ];
    function isMsgSendEncodeObject(encodeObject) {
      return encodeObject.typeUrl === "/cosmos.bank.v1beta1.MsgSend";
    }
    exports.isMsgSendEncodeObject = isMsgSendEncodeObject;
  }
});

// ../../node_modules/.pnpm/@cosmjs+stargate@0.32.4/node_modules/@cosmjs/stargate/build/modules/bank/queries.js
var require_queries3 = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+stargate@0.32.4/node_modules/@cosmjs/stargate/build/modules/bank/queries.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.setupBankExtension = void 0;
    var utils_1 = require_build3();
    var query_1 = require_query3();
    var queryclient_1 = require_queryclient2();
    function setupBankExtension(base) {
      const rpc = (0, queryclient_1.createProtobufRpcClient)(base);
      const queryService = new query_1.QueryClientImpl(rpc);
      return {
        bank: {
          balance: async (address, denom) => {
            const { balance } = await queryService.Balance({ address, denom });
            (0, utils_1.assert)(balance);
            return balance;
          },
          allBalances: async (address) => {
            const { balances } = await queryService.AllBalances(query_1.QueryAllBalancesRequest.fromPartial({ address }));
            return balances;
          },
          totalSupply: async (paginationKey) => {
            const response = await queryService.TotalSupply({
              pagination: (0, queryclient_1.createPagination)(paginationKey)
            });
            return response;
          },
          supplyOf: async (denom) => {
            const { amount } = await queryService.SupplyOf({ denom });
            (0, utils_1.assert)(amount);
            return amount;
          },
          denomMetadata: async (denom) => {
            const { metadata } = await queryService.DenomMetadata({ denom });
            (0, utils_1.assert)(metadata);
            return metadata;
          },
          denomsMetadata: async () => {
            const { metadatas } = await queryService.DenomsMetadata(query_1.QueryDenomsMetadataRequest.fromPartial({
              pagination: void 0
              // Not implemented
            }));
            return metadatas;
          }
        }
      };
    }
    exports.setupBankExtension = setupBankExtension;
  }
});

// ../../node_modules/.pnpm/@cosmjs+stargate@0.32.4/node_modules/@cosmjs/stargate/build/modules/crisis/aminomessages.js
var require_aminomessages3 = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+stargate@0.32.4/node_modules/@cosmjs/stargate/build/modules/crisis/aminomessages.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createCrysisAminoConverters = exports.isAminoMsgVerifyInvariant = void 0;
    function isAminoMsgVerifyInvariant(msg) {
      return msg.type === "cosmos-sdk/MsgVerifyInvariant";
    }
    exports.isAminoMsgVerifyInvariant = isAminoMsgVerifyInvariant;
    function createCrysisAminoConverters() {
      throw new Error("Not implemented");
    }
    exports.createCrysisAminoConverters = createCrysisAminoConverters;
  }
});

// ../../node_modules/.pnpm/@cosmjs+stargate@0.32.4/node_modules/@cosmjs/stargate/build/modules/distribution/aminomessages.js
var require_aminomessages4 = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+stargate@0.32.4/node_modules/@cosmjs/stargate/build/modules/distribution/aminomessages.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createDistributionAminoConverters = exports.isAminoMsgFundCommunityPool = exports.isAminoMsgWithdrawValidatorCommission = exports.isAminoMsgWithdrawDelegatorReward = exports.isAminoMsgSetWithdrawAddress = void 0;
    function isAminoMsgSetWithdrawAddress(msg) {
      return msg.type === "cosmos-sdk/MsgModifyWithdrawAddress";
    }
    exports.isAminoMsgSetWithdrawAddress = isAminoMsgSetWithdrawAddress;
    function isAminoMsgWithdrawDelegatorReward(msg) {
      return msg.type === "cosmos-sdk/MsgWithdrawDelegationReward";
    }
    exports.isAminoMsgWithdrawDelegatorReward = isAminoMsgWithdrawDelegatorReward;
    function isAminoMsgWithdrawValidatorCommission(msg) {
      return msg.type === "cosmos-sdk/MsgWithdrawValidatorCommission";
    }
    exports.isAminoMsgWithdrawValidatorCommission = isAminoMsgWithdrawValidatorCommission;
    function isAminoMsgFundCommunityPool(msg) {
      return msg.type === "cosmos-sdk/MsgFundCommunityPool";
    }
    exports.isAminoMsgFundCommunityPool = isAminoMsgFundCommunityPool;
    function createDistributionAminoConverters() {
      return {
        "/cosmos.distribution.v1beta1.MsgFundCommunityPool": {
          aminoType: "cosmos-sdk/MsgFundCommunityPool",
          toAmino: ({ amount, depositor }) => ({
            amount: [...amount],
            depositor
          }),
          fromAmino: ({ amount, depositor }) => ({
            amount: [...amount],
            depositor
          })
        },
        "/cosmos.distribution.v1beta1.MsgSetWithdrawAddress": {
          aminoType: "cosmos-sdk/MsgModifyWithdrawAddress",
          toAmino: ({ delegatorAddress, withdrawAddress }) => ({
            delegator_address: delegatorAddress,
            withdraw_address: withdrawAddress
          }),
          fromAmino: ({ delegator_address, withdraw_address }) => ({
            delegatorAddress: delegator_address,
            withdrawAddress: withdraw_address
          })
        },
        "/cosmos.distribution.v1beta1.MsgWithdrawDelegatorReward": {
          aminoType: "cosmos-sdk/MsgWithdrawDelegationReward",
          toAmino: ({ delegatorAddress, validatorAddress }) => ({
            delegator_address: delegatorAddress,
            validator_address: validatorAddress
          }),
          fromAmino: ({ delegator_address, validator_address }) => ({
            delegatorAddress: delegator_address,
            validatorAddress: validator_address
          })
        },
        "/cosmos.distribution.v1beta1.MsgWithdrawValidatorCommission": {
          aminoType: "cosmos-sdk/MsgWithdrawValidatorCommission",
          toAmino: ({ validatorAddress }) => ({
            validator_address: validatorAddress
          }),
          fromAmino: ({ validator_address }) => ({
            validatorAddress: validator_address
          })
        }
      };
    }
    exports.createDistributionAminoConverters = createDistributionAminoConverters;
  }
});

// ../../node_modules/.pnpm/@cosmjs+stargate@0.32.4/node_modules/@cosmjs/stargate/build/modules/distribution/messages.js
var require_messages3 = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+stargate@0.32.4/node_modules/@cosmjs/stargate/build/modules/distribution/messages.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isMsgWithdrawDelegatorRewardEncodeObject = exports.distributionTypes = void 0;
    var tx_1 = require_tx4();
    exports.distributionTypes = [
      ["/cosmos.distribution.v1beta1.MsgFundCommunityPool", tx_1.MsgFundCommunityPool],
      ["/cosmos.distribution.v1beta1.MsgSetWithdrawAddress", tx_1.MsgSetWithdrawAddress],
      ["/cosmos.distribution.v1beta1.MsgWithdrawDelegatorReward", tx_1.MsgWithdrawDelegatorReward],
      ["/cosmos.distribution.v1beta1.MsgWithdrawValidatorCommission", tx_1.MsgWithdrawValidatorCommission]
    ];
    function isMsgWithdrawDelegatorRewardEncodeObject(object) {
      return object.typeUrl === "/cosmos.distribution.v1beta1.MsgWithdrawDelegatorReward";
    }
    exports.isMsgWithdrawDelegatorRewardEncodeObject = isMsgWithdrawDelegatorRewardEncodeObject;
  }
});

// ../../node_modules/.pnpm/@cosmjs+stargate@0.32.4/node_modules/@cosmjs/stargate/build/modules/distribution/queries.js
var require_queries4 = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+stargate@0.32.4/node_modules/@cosmjs/stargate/build/modules/distribution/queries.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.setupDistributionExtension = void 0;
    var query_1 = require_query4();
    var queryclient_1 = require_queryclient2();
    function setupDistributionExtension(base) {
      const rpc = (0, queryclient_1.createProtobufRpcClient)(base);
      const queryService = new query_1.QueryClientImpl(rpc);
      return {
        distribution: {
          communityPool: async () => {
            const response = await queryService.CommunityPool({});
            return response;
          },
          delegationRewards: async (delegatorAddress, validatorAddress) => {
            const response = await queryService.DelegationRewards({
              delegatorAddress,
              validatorAddress
            });
            return response;
          },
          delegationTotalRewards: async (delegatorAddress) => {
            const response = await queryService.DelegationTotalRewards({
              delegatorAddress
            });
            return response;
          },
          delegatorValidators: async (delegatorAddress) => {
            const response = await queryService.DelegatorValidators({
              delegatorAddress
            });
            return response;
          },
          delegatorWithdrawAddress: async (delegatorAddress) => {
            const response = await queryService.DelegatorWithdrawAddress({
              delegatorAddress
            });
            return response;
          },
          params: async () => {
            const response = await queryService.Params({});
            return response;
          },
          validatorCommission: async (validatorAddress) => {
            const response = await queryService.ValidatorCommission({
              validatorAddress
            });
            return response;
          },
          validatorOutstandingRewards: async (validatorAddress) => {
            const response = await queryService.ValidatorOutstandingRewards({
              validatorAddress
            });
            return response;
          },
          validatorSlashes: async (validatorAddress, startingHeight, endingHeight, paginationKey) => {
            const response = await queryService.ValidatorSlashes({
              validatorAddress,
              startingHeight: BigInt(startingHeight),
              endingHeight: BigInt(endingHeight),
              pagination: (0, queryclient_1.createPagination)(paginationKey)
            });
            return response;
          }
        }
      };
    }
    exports.setupDistributionExtension = setupDistributionExtension;
  }
});

// ../../node_modules/.pnpm/@cosmjs+stargate@0.32.4/node_modules/@cosmjs/stargate/build/modules/evidence/aminomessages.js
var require_aminomessages5 = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+stargate@0.32.4/node_modules/@cosmjs/stargate/build/modules/evidence/aminomessages.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createEvidenceAminoConverters = exports.isAminoMsgSubmitEvidence = void 0;
    function isAminoMsgSubmitEvidence(msg) {
      return msg.type === "cosmos-sdk/MsgSubmitEvidence";
    }
    exports.isAminoMsgSubmitEvidence = isAminoMsgSubmitEvidence;
    function createEvidenceAminoConverters() {
      throw new Error("Not implemented");
    }
    exports.createEvidenceAminoConverters = createEvidenceAminoConverters;
  }
});

// ../../node_modules/.pnpm/@cosmjs+stargate@0.32.4/node_modules/@cosmjs/stargate/build/modules/feegrant/aminomessages.js
var require_aminomessages6 = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+stargate@0.32.4/node_modules/@cosmjs/stargate/build/modules/feegrant/aminomessages.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createFeegrantAminoConverters = void 0;
    function createFeegrantAminoConverters() {
      return {
        // For Cosmos SDK < 0.46 the Amino JSON codec was broken on chain and thus inaccessible.
        // Now this can be implemented for 0.46+ chains, see
        // https://github.com/cosmos/cosmjs/issues/1092
        //
        // "/cosmos.feegrant.v1beta1.MsgGrantAllowance": IMPLEMENT_ME,
        // "/cosmos.feegrant.v1beta1.MsgRevokeAllowance": IMPLEMENT_ME,
      };
    }
    exports.createFeegrantAminoConverters = createFeegrantAminoConverters;
  }
});

// ../../node_modules/.pnpm/@cosmjs+stargate@0.32.4/node_modules/@cosmjs/stargate/build/modules/feegrant/messages.js
var require_messages4 = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+stargate@0.32.4/node_modules/@cosmjs/stargate/build/modules/feegrant/messages.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.feegrantTypes = void 0;
    var tx_1 = require_tx5();
    exports.feegrantTypes = [
      ["/cosmos.feegrant.v1beta1.MsgGrantAllowance", tx_1.MsgGrantAllowance],
      ["/cosmos.feegrant.v1beta1.MsgRevokeAllowance", tx_1.MsgRevokeAllowance]
    ];
  }
});

// ../../node_modules/.pnpm/@cosmjs+stargate@0.32.4/node_modules/@cosmjs/stargate/build/modules/feegrant/queries.js
var require_queries5 = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+stargate@0.32.4/node_modules/@cosmjs/stargate/build/modules/feegrant/queries.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.setupFeegrantExtension = void 0;
    var query_1 = require_query5();
    var queryclient_1 = require_queryclient2();
    function setupFeegrantExtension(base) {
      const rpc = (0, queryclient_1.createProtobufRpcClient)(base);
      const queryService = new query_1.QueryClientImpl(rpc);
      return {
        feegrant: {
          allowance: async (granter, grantee) => {
            const response = await queryService.Allowance({
              granter,
              grantee
            });
            return response;
          },
          allowances: async (grantee, paginationKey) => {
            const response = await queryService.Allowances({
              grantee,
              pagination: (0, queryclient_1.createPagination)(paginationKey)
            });
            return response;
          }
        }
      };
    }
    exports.setupFeegrantExtension = setupFeegrantExtension;
  }
});

// ../../node_modules/.pnpm/@cosmjs+stargate@0.32.4/node_modules/@cosmjs/stargate/build/modules/gov/aminomessages.js
var require_aminomessages7 = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+stargate@0.32.4/node_modules/@cosmjs/stargate/build/modules/gov/aminomessages.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createGovAminoConverters = exports.isAminoMsgDeposit = exports.isAminoMsgVoteWeighted = exports.isAminoMsgVote = exports.isAminoMsgSubmitProposal = void 0;
    var math_1 = require_build();
    var utils_1 = require_build3();
    var gov_1 = require_gov();
    var any_1 = require_any();
    var queryclient_1 = require_queryclient2();
    function isAminoMsgSubmitProposal(msg) {
      return msg.type === "cosmos-sdk/MsgSubmitProposal";
    }
    exports.isAminoMsgSubmitProposal = isAminoMsgSubmitProposal;
    function isAminoMsgVote(msg) {
      return msg.type === "cosmos-sdk/MsgVote";
    }
    exports.isAminoMsgVote = isAminoMsgVote;
    function isAminoMsgVoteWeighted(msg) {
      return msg.type === "cosmos-sdk/MsgVoteWeighted";
    }
    exports.isAminoMsgVoteWeighted = isAminoMsgVoteWeighted;
    function isAminoMsgDeposit(msg) {
      return msg.type === "cosmos-sdk/MsgDeposit";
    }
    exports.isAminoMsgDeposit = isAminoMsgDeposit;
    function createGovAminoConverters() {
      return {
        "/cosmos.gov.v1beta1.MsgDeposit": {
          aminoType: "cosmos-sdk/MsgDeposit",
          toAmino: ({ amount, depositor, proposalId }) => {
            return {
              amount,
              depositor,
              proposal_id: proposalId.toString()
            };
          },
          fromAmino: ({ amount, depositor, proposal_id }) => {
            return {
              amount: Array.from(amount),
              depositor,
              proposalId: BigInt(proposal_id)
            };
          }
        },
        "/cosmos.gov.v1beta1.MsgVote": {
          aminoType: "cosmos-sdk/MsgVote",
          toAmino: ({ option, proposalId, voter }) => {
            return {
              option,
              proposal_id: proposalId.toString(),
              voter
            };
          },
          fromAmino: ({ option, proposal_id, voter }) => {
            return {
              option: (0, gov_1.voteOptionFromJSON)(option),
              proposalId: BigInt(proposal_id),
              voter
            };
          }
        },
        "/cosmos.gov.v1beta1.MsgVoteWeighted": {
          aminoType: "cosmos-sdk/MsgVoteWeighted",
          toAmino: ({ options, proposalId, voter }) => {
            return {
              options: options.map((o) => ({
                option: o.option,
                // Weight is between 0 and 1, so we always have 20 characters when printing all trailing
                // zeros (e.g. "0.700000000000000000" or "1.000000000000000000")
                weight: (0, queryclient_1.decodeCosmosSdkDecFromProto)(o.weight).toString().padEnd(20, "0")
              })),
              proposal_id: proposalId.toString(),
              voter
            };
          },
          fromAmino: ({ options, proposal_id, voter }) => {
            return {
              proposalId: BigInt(proposal_id),
              voter,
              options: options.map((o) => ({
                option: (0, gov_1.voteOptionFromJSON)(o.option),
                weight: math_1.Decimal.fromUserInput(o.weight, 18).atomics
              }))
            };
          }
        },
        "/cosmos.gov.v1beta1.MsgSubmitProposal": {
          aminoType: "cosmos-sdk/MsgSubmitProposal",
          toAmino: ({ initialDeposit, proposer, content }) => {
            (0, utils_1.assertDefinedAndNotNull)(content);
            let proposal;
            switch (content.typeUrl) {
              case "/cosmos.gov.v1beta1.TextProposal": {
                const textProposal = gov_1.TextProposal.decode(content.value);
                proposal = {
                  type: "cosmos-sdk/TextProposal",
                  value: {
                    description: textProposal.description,
                    title: textProposal.title
                  }
                };
                break;
              }
              default:
                throw new Error(`Unsupported proposal type: '${content.typeUrl}'`);
            }
            return {
              initial_deposit: initialDeposit,
              proposer,
              content: proposal
            };
          },
          fromAmino: ({ initial_deposit, proposer, content }) => {
            let any_content;
            switch (content.type) {
              case "cosmos-sdk/TextProposal": {
                const { value } = content;
                (0, utils_1.assert)((0, utils_1.isNonNullObject)(value));
                const { title, description } = value;
                (0, utils_1.assert)(typeof title === "string");
                (0, utils_1.assert)(typeof description === "string");
                any_content = any_1.Any.fromPartial({
                  typeUrl: "/cosmos.gov.v1beta1.TextProposal",
                  value: gov_1.TextProposal.encode(gov_1.TextProposal.fromPartial({
                    title,
                    description
                  })).finish()
                });
                break;
              }
              default:
                throw new Error(`Unsupported proposal type: '${content.type}'`);
            }
            return {
              initialDeposit: Array.from(initial_deposit),
              proposer,
              content: any_content
            };
          }
        }
      };
    }
    exports.createGovAminoConverters = createGovAminoConverters;
  }
});

// ../../node_modules/.pnpm/@cosmjs+stargate@0.32.4/node_modules/@cosmjs/stargate/build/modules/gov/messages.js
var require_messages5 = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+stargate@0.32.4/node_modules/@cosmjs/stargate/build/modules/gov/messages.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isMsgVoteWeightedEncodeObject = exports.isMsgVoteEncodeObject = exports.isMsgSubmitProposalEncodeObject = exports.isMsgDepositEncodeObject = exports.govTypes = void 0;
    var tx_1 = require_tx6();
    var tx_2 = require_tx7();
    exports.govTypes = [
      ["/cosmos.gov.v1.MsgDeposit", tx_1.MsgDeposit],
      ["/cosmos.gov.v1.MsgSubmitProposal", tx_1.MsgSubmitProposal],
      ["/cosmos.gov.v1.MsgUpdateParams", tx_1.MsgUpdateParams],
      ["/cosmos.gov.v1.MsgVote", tx_1.MsgVote],
      ["/cosmos.gov.v1.MsgVoteWeighted", tx_1.MsgVoteWeighted],
      ["/cosmos.gov.v1beta1.MsgDeposit", tx_2.MsgDeposit],
      ["/cosmos.gov.v1beta1.MsgSubmitProposal", tx_2.MsgSubmitProposal],
      ["/cosmos.gov.v1beta1.MsgVote", tx_2.MsgVote],
      ["/cosmos.gov.v1beta1.MsgVoteWeighted", tx_2.MsgVoteWeighted]
    ];
    function isMsgDepositEncodeObject(object) {
      return object.typeUrl === "/cosmos.gov.v1beta1.MsgDeposit";
    }
    exports.isMsgDepositEncodeObject = isMsgDepositEncodeObject;
    function isMsgSubmitProposalEncodeObject(object) {
      return object.typeUrl === "/cosmos.gov.v1beta1.MsgSubmitProposal";
    }
    exports.isMsgSubmitProposalEncodeObject = isMsgSubmitProposalEncodeObject;
    function isMsgVoteEncodeObject(object) {
      return object.typeUrl === "/cosmos.gov.v1beta1.MsgVote";
    }
    exports.isMsgVoteEncodeObject = isMsgVoteEncodeObject;
    function isMsgVoteWeightedEncodeObject(object) {
      return object.typeUrl === "/cosmos.gov.v1beta1.MsgVoteWeighted";
    }
    exports.isMsgVoteWeightedEncodeObject = isMsgVoteWeightedEncodeObject;
  }
});

// ../../node_modules/.pnpm/@cosmjs+stargate@0.32.4/node_modules/@cosmjs/stargate/build/modules/gov/queries.js
var require_queries6 = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+stargate@0.32.4/node_modules/@cosmjs/stargate/build/modules/gov/queries.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.setupGovExtension = void 0;
    var query_1 = require_query6();
    var queryclient_1 = require_queryclient2();
    function setupGovExtension(base) {
      const rpc = (0, queryclient_1.createProtobufRpcClient)(base);
      const queryService = new query_1.QueryClientImpl(rpc);
      return {
        gov: {
          params: async (parametersType) => {
            const response = await queryService.Params({ paramsType: parametersType });
            return response;
          },
          proposals: async (proposalStatus, depositorAddress, voterAddress, paginationKey) => {
            const response = await queryService.Proposals({
              proposalStatus,
              depositor: depositorAddress,
              voter: voterAddress,
              pagination: (0, queryclient_1.createPagination)(paginationKey)
            });
            return response;
          },
          proposal: async (proposalId) => {
            const response = await queryService.Proposal({ proposalId: (0, queryclient_1.longify)(proposalId) });
            return response;
          },
          deposits: async (proposalId, paginationKey) => {
            const response = await queryService.Deposits({
              proposalId: (0, queryclient_1.longify)(proposalId),
              pagination: (0, queryclient_1.createPagination)(paginationKey)
            });
            return response;
          },
          deposit: async (proposalId, depositorAddress) => {
            const response = await queryService.Deposit({
              proposalId: (0, queryclient_1.longify)(proposalId),
              depositor: depositorAddress
            });
            return response;
          },
          tally: async (proposalId) => {
            const response = await queryService.TallyResult({
              proposalId: (0, queryclient_1.longify)(proposalId)
            });
            return response;
          },
          votes: async (proposalId, paginationKey) => {
            const response = await queryService.Votes({
              proposalId: (0, queryclient_1.longify)(proposalId),
              pagination: (0, queryclient_1.createPagination)(paginationKey)
            });
            return response;
          },
          vote: async (proposalId, voterAddress) => {
            const response = await queryService.Vote({
              proposalId: (0, queryclient_1.longify)(proposalId),
              voter: voterAddress
            });
            return response;
          }
        }
      };
    }
    exports.setupGovExtension = setupGovExtension;
  }
});

// ../../node_modules/.pnpm/@cosmjs+stargate@0.32.4/node_modules/@cosmjs/stargate/build/modules/group/aminomessages.js
var require_aminomessages8 = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+stargate@0.32.4/node_modules/@cosmjs/stargate/build/modules/group/aminomessages.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createGroupAminoConverters = void 0;
    function createGroupAminoConverters() {
      return {};
    }
    exports.createGroupAminoConverters = createGroupAminoConverters;
  }
});

// ../../node_modules/.pnpm/@cosmjs+stargate@0.32.4/node_modules/@cosmjs/stargate/build/modules/group/messages.js
var require_messages6 = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+stargate@0.32.4/node_modules/@cosmjs/stargate/build/modules/group/messages.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.groupTypes = void 0;
    var tx_1 = require_tx8();
    exports.groupTypes = [
      ["/cosmos.group.v1.MsgCreateGroup", tx_1.MsgCreateGroup],
      ["/cosmos.group.v1.MsgCreateGroupPolicy", tx_1.MsgCreateGroupPolicy],
      ["/cosmos.group.v1.MsgCreateGroupWithPolicy", tx_1.MsgCreateGroupWithPolicy],
      ["/cosmos.group.v1.MsgExec", tx_1.MsgExec],
      ["/cosmos.group.v1.MsgLeaveGroup", tx_1.MsgLeaveGroup],
      ["/cosmos.group.v1.MsgSubmitProposal", tx_1.MsgSubmitProposal],
      ["/cosmos.group.v1.MsgUpdateGroupAdmin", tx_1.MsgUpdateGroupAdmin],
      ["/cosmos.group.v1.MsgUpdateGroupMembers", tx_1.MsgUpdateGroupMembers],
      ["/cosmos.group.v1.MsgUpdateGroupMetadata", tx_1.MsgUpdateGroupMetadata],
      ["/cosmos.group.v1.MsgUpdateGroupPolicyAdmin", tx_1.MsgUpdateGroupPolicyAdmin],
      ["/cosmos.group.v1.MsgUpdateGroupPolicyDecisionPolicy", tx_1.MsgUpdateGroupPolicyDecisionPolicy],
      ["/cosmos.group.v1.MsgUpdateGroupPolicyMetadata", tx_1.MsgUpdateGroupPolicyMetadata],
      ["/cosmos.group.v1.MsgVote", tx_1.MsgVote],
      ["/cosmos.group.v1.MsgWithdrawProposal", tx_1.MsgWithdrawProposal]
    ];
  }
});

// ../../node_modules/.pnpm/@cosmjs+stargate@0.32.4/node_modules/@cosmjs/stargate/build/modules/ibc/aminomessages.js
var require_aminomessages9 = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+stargate@0.32.4/node_modules/@cosmjs/stargate/build/modules/ibc/aminomessages.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createIbcAminoConverters = exports.isAminoMsgTransfer = void 0;
    var amino_1 = require_build5();
    var tx_1 = require_tx9();
    function isAminoMsgTransfer(msg) {
      return msg.type === "cosmos-sdk/MsgTransfer";
    }
    exports.isAminoMsgTransfer = isAminoMsgTransfer;
    function createIbcAminoConverters() {
      return {
        "/ibc.applications.transfer.v1.MsgTransfer": {
          aminoType: "cosmos-sdk/MsgTransfer",
          toAmino: ({ sourcePort, sourceChannel, token, sender, receiver, timeoutHeight, timeoutTimestamp, memo }) => {
            var _a, _b, _c;
            return {
              source_port: sourcePort,
              source_channel: sourceChannel,
              token,
              sender,
              receiver,
              timeout_height: timeoutHeight ? {
                revision_height: (_a = (0, amino_1.omitDefault)(timeoutHeight.revisionHeight)) == null ? void 0 : _a.toString(),
                revision_number: (_b = (0, amino_1.omitDefault)(timeoutHeight.revisionNumber)) == null ? void 0 : _b.toString()
              } : {},
              timeout_timestamp: (_c = (0, amino_1.omitDefault)(timeoutTimestamp)) == null ? void 0 : _c.toString(),
              memo: (0, amino_1.omitDefault)(memo)
            };
          },
          fromAmino: ({ source_port, source_channel, token, sender, receiver, timeout_height, timeout_timestamp, memo }) => tx_1.MsgTransfer.fromPartial({
            sourcePort: source_port,
            sourceChannel: source_channel,
            token,
            sender,
            receiver,
            timeoutHeight: timeout_height ? {
              revisionHeight: BigInt(timeout_height.revision_height || "0"),
              revisionNumber: BigInt(timeout_height.revision_number || "0")
            } : void 0,
            timeoutTimestamp: BigInt(timeout_timestamp || "0"),
            memo: memo ?? ""
          })
        }
      };
    }
    exports.createIbcAminoConverters = createIbcAminoConverters;
  }
});

// ../../node_modules/.pnpm/@cosmjs+stargate@0.32.4/node_modules/@cosmjs/stargate/build/modules/ibc/messages.js
var require_messages7 = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+stargate@0.32.4/node_modules/@cosmjs/stargate/build/modules/ibc/messages.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isMsgTransferEncodeObject = exports.ibcTypes = void 0;
    var tx_1 = require_tx9();
    var tx_2 = require_tx10();
    var tx_3 = require_tx11();
    var tx_4 = require_tx12();
    exports.ibcTypes = [
      ["/ibc.applications.transfer.v1.MsgTransfer", tx_1.MsgTransfer],
      ["/ibc.core.channel.v1.MsgAcknowledgement", tx_2.MsgAcknowledgement],
      ["/ibc.core.channel.v1.MsgChannelCloseConfirm", tx_2.MsgChannelCloseConfirm],
      ["/ibc.core.channel.v1.MsgChannelCloseInit", tx_2.MsgChannelCloseInit],
      ["/ibc.core.channel.v1.MsgChannelOpenAck", tx_2.MsgChannelOpenAck],
      ["/ibc.core.channel.v1.MsgChannelOpenConfirm", tx_2.MsgChannelOpenConfirm],
      ["/ibc.core.channel.v1.MsgChannelOpenInit", tx_2.MsgChannelOpenInit],
      ["/ibc.core.channel.v1.MsgChannelOpenTry", tx_2.MsgChannelOpenTry],
      ["/ibc.core.channel.v1.MsgRecvPacket", tx_2.MsgRecvPacket],
      ["/ibc.core.channel.v1.MsgTimeout", tx_2.MsgTimeout],
      ["/ibc.core.channel.v1.MsgTimeoutOnClose", tx_2.MsgTimeoutOnClose],
      ["/ibc.core.client.v1.MsgCreateClient", tx_3.MsgCreateClient],
      ["/ibc.core.client.v1.MsgSubmitMisbehaviour", tx_3.MsgSubmitMisbehaviour],
      ["/ibc.core.client.v1.MsgUpdateClient", tx_3.MsgUpdateClient],
      ["/ibc.core.client.v1.MsgUpgradeClient", tx_3.MsgUpgradeClient],
      ["/ibc.core.connection.v1.MsgConnectionOpenAck", tx_4.MsgConnectionOpenAck],
      ["/ibc.core.connection.v1.MsgConnectionOpenConfirm", tx_4.MsgConnectionOpenConfirm],
      ["/ibc.core.connection.v1.MsgConnectionOpenInit", tx_4.MsgConnectionOpenInit],
      ["/ibc.core.connection.v1.MsgConnectionOpenTry", tx_4.MsgConnectionOpenTry]
    ];
    function isMsgTransferEncodeObject(object) {
      return object.typeUrl === "/ibc.applications.transfer.v1.MsgTransfer";
    }
    exports.isMsgTransferEncodeObject = isMsgTransferEncodeObject;
  }
});

// ../../node_modules/.pnpm/@cosmjs+stargate@0.32.4/node_modules/@cosmjs/stargate/build/modules/ibc/queries.js
var require_queries7 = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+stargate@0.32.4/node_modules/@cosmjs/stargate/build/modules/ibc/queries.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.setupIbcExtension = void 0;
    var encoding_1 = require_build2();
    var math_1 = require_build();
    var query_1 = require_query7();
    var channel_1 = require_channel();
    var query_2 = require_query8();
    var query_3 = require_query9();
    var query_4 = require_query10();
    var tendermint_1 = require_tendermint();
    var queryclient_1 = require_queryclient2();
    function decodeTendermintClientStateAny(clientState) {
      if ((clientState == null ? void 0 : clientState.typeUrl) !== "/ibc.lightclients.tendermint.v1.ClientState") {
        throw new Error(`Unexpected client state type: ${clientState == null ? void 0 : clientState.typeUrl}`);
      }
      return tendermint_1.ClientState.decode(clientState.value);
    }
    function decodeTendermintConsensusStateAny(clientState) {
      if ((clientState == null ? void 0 : clientState.typeUrl) !== "/ibc.lightclients.tendermint.v1.ConsensusState") {
        throw new Error(`Unexpected client state type: ${clientState == null ? void 0 : clientState.typeUrl}`);
      }
      return tendermint_1.ConsensusState.decode(clientState.value);
    }
    function setupIbcExtension(base) {
      const rpc = (0, queryclient_1.createProtobufRpcClient)(base);
      const channelQueryService = new query_2.QueryClientImpl(rpc);
      const clientQueryService = new query_3.QueryClientImpl(rpc);
      const connectionQueryService = new query_4.QueryClientImpl(rpc);
      const transferQueryService = new query_1.QueryClientImpl(rpc);
      return {
        ibc: {
          channel: {
            channel: async (portId, channelId) => channelQueryService.Channel({
              portId,
              channelId
            }),
            channels: async (paginationKey) => channelQueryService.Channels({
              pagination: (0, queryclient_1.createPagination)(paginationKey)
            }),
            allChannels: async () => {
              var _a;
              const channels = [];
              let response;
              let key;
              do {
                response = await channelQueryService.Channels({
                  pagination: (0, queryclient_1.createPagination)(key)
                });
                channels.push(...response.channels);
                key = (_a = response.pagination) == null ? void 0 : _a.nextKey;
              } while (key && key.length);
              return query_2.QueryChannelsResponse.fromPartial({
                channels,
                height: response.height
              });
            },
            connectionChannels: async (connection, paginationKey) => channelQueryService.ConnectionChannels({
              connection,
              pagination: (0, queryclient_1.createPagination)(paginationKey)
            }),
            allConnectionChannels: async (connection) => {
              var _a;
              const channels = [];
              let response;
              let key;
              do {
                response = await channelQueryService.ConnectionChannels({
                  connection,
                  pagination: (0, queryclient_1.createPagination)(key)
                });
                channels.push(...response.channels);
                key = (_a = response.pagination) == null ? void 0 : _a.nextKey;
              } while (key && key.length);
              return query_2.QueryConnectionChannelsResponse.fromPartial({
                channels,
                height: response.height
              });
            },
            clientState: async (portId, channelId) => channelQueryService.ChannelClientState({
              portId,
              channelId
            }),
            consensusState: async (portId, channelId, revisionNumber, revisionHeight) => channelQueryService.ChannelConsensusState({
              portId,
              channelId,
              revisionNumber: BigInt(revisionNumber),
              revisionHeight: BigInt(revisionHeight)
            }),
            packetCommitment: async (portId, channelId, sequence) => channelQueryService.PacketCommitment({
              portId,
              channelId,
              sequence: (0, queryclient_1.longify)(sequence)
            }),
            packetCommitments: async (portId, channelId, paginationKey) => channelQueryService.PacketCommitments({
              channelId,
              portId,
              pagination: (0, queryclient_1.createPagination)(paginationKey)
            }),
            allPacketCommitments: async (portId, channelId) => {
              var _a;
              const commitments = [];
              let response;
              let key;
              do {
                response = await channelQueryService.PacketCommitments({
                  channelId,
                  portId,
                  pagination: (0, queryclient_1.createPagination)(key)
                });
                commitments.push(...response.commitments);
                key = (_a = response.pagination) == null ? void 0 : _a.nextKey;
              } while (key && key.length);
              return query_2.QueryPacketCommitmentsResponse.fromPartial({
                commitments,
                height: response.height
              });
            },
            packetReceipt: async (portId, channelId, sequence) => channelQueryService.PacketReceipt({
              portId,
              channelId,
              sequence: (0, queryclient_1.longify)(sequence)
            }),
            packetAcknowledgement: async (portId, channelId, sequence) => channelQueryService.PacketAcknowledgement({
              portId,
              channelId,
              sequence: (0, queryclient_1.longify)(sequence)
            }),
            packetAcknowledgements: async (portId, channelId, paginationKey) => {
              const request = query_2.QueryPacketAcknowledgementsRequest.fromPartial({
                portId,
                channelId,
                pagination: (0, queryclient_1.createPagination)(paginationKey)
              });
              return channelQueryService.PacketAcknowledgements(request);
            },
            allPacketAcknowledgements: async (portId, channelId) => {
              var _a;
              const acknowledgements = [];
              let response;
              let key;
              do {
                const request = query_2.QueryPacketAcknowledgementsRequest.fromPartial({
                  channelId,
                  portId,
                  pagination: (0, queryclient_1.createPagination)(key)
                });
                response = await channelQueryService.PacketAcknowledgements(request);
                acknowledgements.push(...response.acknowledgements);
                key = (_a = response.pagination) == null ? void 0 : _a.nextKey;
              } while (key && key.length);
              return query_2.QueryPacketAcknowledgementsResponse.fromPartial({
                acknowledgements,
                height: response.height
              });
            },
            unreceivedPackets: async (portId, channelId, packetCommitmentSequences) => channelQueryService.UnreceivedPackets({
              portId,
              channelId,
              packetCommitmentSequences: packetCommitmentSequences.map((s) => BigInt(s))
            }),
            unreceivedAcks: async (portId, channelId, packetAckSequences) => channelQueryService.UnreceivedAcks({
              portId,
              channelId,
              packetAckSequences: packetAckSequences.map((s) => BigInt(s))
            }),
            nextSequenceReceive: async (portId, channelId) => channelQueryService.NextSequenceReceive({
              portId,
              channelId
            })
          },
          client: {
            state: async (clientId) => clientQueryService.ClientState({ clientId }),
            states: async (paginationKey) => clientQueryService.ClientStates({
              pagination: (0, queryclient_1.createPagination)(paginationKey)
            }),
            allStates: async () => {
              var _a;
              const clientStates = [];
              let response;
              let key;
              do {
                response = await clientQueryService.ClientStates({
                  pagination: (0, queryclient_1.createPagination)(key)
                });
                clientStates.push(...response.clientStates);
                key = (_a = response.pagination) == null ? void 0 : _a.nextKey;
              } while (key && key.length);
              return query_3.QueryClientStatesResponse.fromPartial({
                clientStates
              });
            },
            consensusState: async (clientId, consensusHeight) => clientQueryService.ConsensusState(query_3.QueryConsensusStateRequest.fromPartial({
              clientId,
              revisionHeight: consensusHeight !== void 0 ? BigInt(consensusHeight) : void 0,
              latestHeight: consensusHeight === void 0
            })),
            consensusStates: async (clientId, paginationKey) => clientQueryService.ConsensusStates({
              clientId,
              pagination: (0, queryclient_1.createPagination)(paginationKey)
            }),
            allConsensusStates: async (clientId) => {
              var _a;
              const consensusStates = [];
              let response;
              let key;
              do {
                response = await clientQueryService.ConsensusStates({
                  clientId,
                  pagination: (0, queryclient_1.createPagination)(key)
                });
                consensusStates.push(...response.consensusStates);
                key = (_a = response.pagination) == null ? void 0 : _a.nextKey;
              } while (key && key.length);
              return query_3.QueryConsensusStatesResponse.fromPartial({
                consensusStates
              });
            },
            params: async () => clientQueryService.ClientParams({}),
            stateTm: async (clientId) => {
              const response = await clientQueryService.ClientState({ clientId });
              return decodeTendermintClientStateAny(response.clientState);
            },
            statesTm: async (paginationKey) => {
              const { clientStates } = await clientQueryService.ClientStates({
                pagination: (0, queryclient_1.createPagination)(paginationKey)
              });
              return clientStates.map(({ clientState }) => decodeTendermintClientStateAny(clientState));
            },
            allStatesTm: async () => {
              var _a;
              const clientStates = [];
              let response;
              let key;
              do {
                response = await clientQueryService.ClientStates({
                  pagination: (0, queryclient_1.createPagination)(key)
                });
                clientStates.push(...response.clientStates);
                key = (_a = response.pagination) == null ? void 0 : _a.nextKey;
              } while (key && key.length);
              return clientStates.map(({ clientState }) => decodeTendermintClientStateAny(clientState));
            },
            consensusStateTm: async (clientId, consensusHeight) => {
              const response = await clientQueryService.ConsensusState(query_3.QueryConsensusStateRequest.fromPartial({
                clientId,
                revisionHeight: consensusHeight == null ? void 0 : consensusHeight.revisionHeight,
                revisionNumber: consensusHeight == null ? void 0 : consensusHeight.revisionNumber,
                latestHeight: consensusHeight === void 0
              }));
              return decodeTendermintConsensusStateAny(response.consensusState);
            }
          },
          connection: {
            connection: async (connectionId) => connectionQueryService.Connection({
              connectionId
            }),
            connections: async (paginationKey) => connectionQueryService.Connections({
              pagination: (0, queryclient_1.createPagination)(paginationKey)
            }),
            allConnections: async () => {
              var _a;
              const connections = [];
              let response;
              let key;
              do {
                response = await connectionQueryService.Connections({
                  pagination: (0, queryclient_1.createPagination)(key)
                });
                connections.push(...response.connections);
                key = (_a = response.pagination) == null ? void 0 : _a.nextKey;
              } while (key && key.length);
              return query_4.QueryConnectionsResponse.fromPartial({
                connections,
                height: response.height
              });
            },
            clientConnections: async (clientId) => connectionQueryService.ClientConnections({
              clientId
            }),
            clientState: async (connectionId) => connectionQueryService.ConnectionClientState({
              connectionId
            }),
            consensusState: async (connectionId, revisionHeight) => connectionQueryService.ConnectionConsensusState(query_4.QueryConnectionConsensusStateRequest.fromPartial({
              connectionId,
              revisionHeight: BigInt(revisionHeight)
            }))
          },
          transfer: {
            denomTrace: async (hash) => transferQueryService.DenomTrace({ hash }),
            denomTraces: async (paginationKey) => transferQueryService.DenomTraces({
              pagination: (0, queryclient_1.createPagination)(paginationKey)
            }),
            allDenomTraces: async () => {
              var _a;
              const denomTraces = [];
              let response;
              let key;
              do {
                response = await transferQueryService.DenomTraces({
                  pagination: (0, queryclient_1.createPagination)(key)
                });
                denomTraces.push(...response.denomTraces);
                key = (_a = response.pagination) == null ? void 0 : _a.nextKey;
              } while (key && key.length);
              return query_1.QueryDenomTracesResponse.fromPartial({
                denomTraces
              });
            },
            params: async () => transferQueryService.Params({})
          },
          verified: {
            channel: {
              channel: async (portId, channelId) => {
                const key = (0, encoding_1.toAscii)(`channelEnds/ports/${portId}/channels/${channelId}`);
                const { value } = await base.queryStoreVerified("ibc", key);
                return value.length ? channel_1.Channel.decode(value) : null;
              },
              packetCommitment: async (portId, channelId, sequence) => {
                const key = (0, encoding_1.toAscii)(`commitments/ports/${portId}/channels/${channelId}/packets/${sequence}`);
                const { value } = await base.queryStoreVerified("ibc", key);
                return value;
              },
              packetAcknowledgement: async (portId, channelId, sequence) => {
                const key = (0, encoding_1.toAscii)(`acks/ports/${portId}/channels/${channelId}/acknowledgements/${sequence}`);
                const { value } = await base.queryStoreVerified("ibc", key);
                return value;
              },
              nextSequenceReceive: async (portId, channelId) => {
                const key = (0, encoding_1.toAscii)(`seqAcks/ports/${portId}/channels/${channelId}/nextSequenceAck`);
                const { value } = await base.queryStoreVerified("ibc", key);
                return value.length ? math_1.Uint64.fromBytes(value).toNumber() : null;
              }
            }
          }
        }
      };
    }
    exports.setupIbcExtension = setupIbcExtension;
  }
});

// ../../node_modules/.pnpm/@cosmjs+stargate@0.32.4/node_modules/@cosmjs/stargate/build/modules/mint/queries.js
var require_queries8 = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+stargate@0.32.4/node_modules/@cosmjs/stargate/build/modules/mint/queries.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.setupMintExtension = void 0;
    var utils_1 = require_build3();
    var query_1 = require_query11();
    var queryclient_1 = require_queryclient2();
    function setupMintExtension(base) {
      const rpc = (0, queryclient_1.createProtobufRpcClient)(base);
      const queryService = new query_1.QueryClientImpl(rpc);
      return {
        mint: {
          params: async () => {
            const { params } = await queryService.Params({});
            (0, utils_1.assert)(params);
            return {
              blocksPerYear: params.blocksPerYear,
              goalBonded: (0, queryclient_1.decodeCosmosSdkDecFromProto)(params.goalBonded),
              inflationMin: (0, queryclient_1.decodeCosmosSdkDecFromProto)(params.inflationMin),
              inflationMax: (0, queryclient_1.decodeCosmosSdkDecFromProto)(params.inflationMax),
              inflationRateChange: (0, queryclient_1.decodeCosmosSdkDecFromProto)(params.inflationRateChange),
              mintDenom: params.mintDenom
            };
          },
          inflation: async () => {
            const { inflation } = await queryService.Inflation({});
            return (0, queryclient_1.decodeCosmosSdkDecFromProto)(inflation);
          },
          annualProvisions: async () => {
            const { annualProvisions } = await queryService.AnnualProvisions({});
            return (0, queryclient_1.decodeCosmosSdkDecFromProto)(annualProvisions);
          }
        }
      };
    }
    exports.setupMintExtension = setupMintExtension;
  }
});

// ../../node_modules/.pnpm/@cosmjs+stargate@0.32.4/node_modules/@cosmjs/stargate/build/modules/slashing/aminomessages.js
var require_aminomessages10 = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+stargate@0.32.4/node_modules/@cosmjs/stargate/build/modules/slashing/aminomessages.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createSlashingAminoConverters = exports.isAminoMsgUnjail = void 0;
    function isAminoMsgUnjail(msg) {
      return msg.type === "cosmos-sdk/MsgUnjail";
    }
    exports.isAminoMsgUnjail = isAminoMsgUnjail;
    function createSlashingAminoConverters() {
      throw new Error("Not implemented");
    }
    exports.createSlashingAminoConverters = createSlashingAminoConverters;
  }
});

// ../../node_modules/.pnpm/@cosmjs+stargate@0.32.4/node_modules/@cosmjs/stargate/build/modules/slashing/queries.js
var require_queries9 = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+stargate@0.32.4/node_modules/@cosmjs/stargate/build/modules/slashing/queries.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.setupSlashingExtension = void 0;
    var query_1 = require_query12();
    var queryclient_1 = require_queryclient2();
    function setupSlashingExtension(base) {
      const rpc = (0, queryclient_1.createProtobufRpcClient)(base);
      const queryService = new query_1.QueryClientImpl(rpc);
      return {
        slashing: {
          signingInfo: async (consAddress) => {
            const response = await queryService.SigningInfo({
              consAddress
            });
            return response;
          },
          signingInfos: async (paginationKey) => {
            const response = await queryService.SigningInfos({
              pagination: (0, queryclient_1.createPagination)(paginationKey)
            });
            return response;
          },
          params: async () => {
            const response = await queryService.Params({});
            return response;
          }
        }
      };
    }
    exports.setupSlashingExtension = setupSlashingExtension;
  }
});

// ../../node_modules/.pnpm/@cosmjs+stargate@0.32.4/node_modules/@cosmjs/stargate/build/modules/staking/aminomessages.js
var require_aminomessages11 = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+stargate@0.32.4/node_modules/@cosmjs/stargate/build/modules/staking/aminomessages.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createStakingAminoConverters = exports.isAminoMsgCancelUnbondingDelegation = exports.isAminoMsgUndelegate = exports.isAminoMsgBeginRedelegate = exports.isAminoMsgDelegate = exports.isAminoMsgEditValidator = exports.isAminoMsgCreateValidator = exports.protoDecimalToJson = void 0;
    var math_1 = require_build();
    var proto_signing_1 = require_build6();
    var utils_1 = require_build3();
    function protoDecimalToJson(decimal) {
      const parsed = math_1.Decimal.fromAtomics(decimal, 18);
      const [whole, fractional] = parsed.toString().split(".");
      return `${whole}.${(fractional ?? "").padEnd(18, "0")}`;
    }
    exports.protoDecimalToJson = protoDecimalToJson;
    function jsonDecimalToProto(decimal) {
      const parsed = math_1.Decimal.fromUserInput(decimal, 18);
      return parsed.atomics;
    }
    function isAminoMsgCreateValidator(msg) {
      return msg.type === "cosmos-sdk/MsgCreateValidator";
    }
    exports.isAminoMsgCreateValidator = isAminoMsgCreateValidator;
    function isAminoMsgEditValidator(msg) {
      return msg.type === "cosmos-sdk/MsgEditValidator";
    }
    exports.isAminoMsgEditValidator = isAminoMsgEditValidator;
    function isAminoMsgDelegate(msg) {
      return msg.type === "cosmos-sdk/MsgDelegate";
    }
    exports.isAminoMsgDelegate = isAminoMsgDelegate;
    function isAminoMsgBeginRedelegate(msg) {
      return msg.type === "cosmos-sdk/MsgBeginRedelegate";
    }
    exports.isAminoMsgBeginRedelegate = isAminoMsgBeginRedelegate;
    function isAminoMsgUndelegate(msg) {
      return msg.type === "cosmos-sdk/MsgUndelegate";
    }
    exports.isAminoMsgUndelegate = isAminoMsgUndelegate;
    function isAminoMsgCancelUnbondingDelegation(msg) {
      return msg.type === "cosmos-sdk/MsgCancelUnbondingDelegation";
    }
    exports.isAminoMsgCancelUnbondingDelegation = isAminoMsgCancelUnbondingDelegation;
    function createStakingAminoConverters() {
      return {
        "/cosmos.staking.v1beta1.MsgBeginRedelegate": {
          aminoType: "cosmos-sdk/MsgBeginRedelegate",
          toAmino: ({ delegatorAddress, validatorSrcAddress, validatorDstAddress, amount }) => {
            (0, utils_1.assertDefinedAndNotNull)(amount, "missing amount");
            return {
              delegator_address: delegatorAddress,
              validator_src_address: validatorSrcAddress,
              validator_dst_address: validatorDstAddress,
              amount
            };
          },
          fromAmino: ({ delegator_address, validator_src_address, validator_dst_address, amount }) => ({
            delegatorAddress: delegator_address,
            validatorSrcAddress: validator_src_address,
            validatorDstAddress: validator_dst_address,
            amount
          })
        },
        "/cosmos.staking.v1beta1.MsgCreateValidator": {
          aminoType: "cosmos-sdk/MsgCreateValidator",
          toAmino: ({ description, commission, minSelfDelegation, delegatorAddress, validatorAddress, pubkey, value }) => {
            (0, utils_1.assertDefinedAndNotNull)(description, "missing description");
            (0, utils_1.assertDefinedAndNotNull)(commission, "missing commission");
            (0, utils_1.assertDefinedAndNotNull)(pubkey, "missing pubkey");
            (0, utils_1.assertDefinedAndNotNull)(value, "missing value");
            return {
              description: {
                moniker: description.moniker,
                identity: description.identity,
                website: description.website,
                security_contact: description.securityContact,
                details: description.details
              },
              commission: {
                rate: protoDecimalToJson(commission.rate),
                max_rate: protoDecimalToJson(commission.maxRate),
                max_change_rate: protoDecimalToJson(commission.maxChangeRate)
              },
              min_self_delegation: minSelfDelegation,
              delegator_address: delegatorAddress,
              validator_address: validatorAddress,
              pubkey: (0, proto_signing_1.decodePubkey)(pubkey),
              value
            };
          },
          fromAmino: ({ description, commission, min_self_delegation, delegator_address, validator_address, pubkey, value }) => {
            return {
              description: {
                moniker: description.moniker,
                identity: description.identity,
                website: description.website,
                securityContact: description.security_contact,
                details: description.details
              },
              commission: {
                rate: jsonDecimalToProto(commission.rate),
                maxRate: jsonDecimalToProto(commission.max_rate),
                maxChangeRate: jsonDecimalToProto(commission.max_change_rate)
              },
              minSelfDelegation: min_self_delegation,
              delegatorAddress: delegator_address,
              validatorAddress: validator_address,
              pubkey: (0, proto_signing_1.encodePubkey)(pubkey),
              value
            };
          }
        },
        "/cosmos.staking.v1beta1.MsgDelegate": {
          aminoType: "cosmos-sdk/MsgDelegate",
          toAmino: ({ delegatorAddress, validatorAddress, amount }) => {
            (0, utils_1.assertDefinedAndNotNull)(amount, "missing amount");
            return {
              delegator_address: delegatorAddress,
              validator_address: validatorAddress,
              amount
            };
          },
          fromAmino: ({ delegator_address, validator_address, amount }) => ({
            delegatorAddress: delegator_address,
            validatorAddress: validator_address,
            amount
          })
        },
        "/cosmos.staking.v1beta1.MsgEditValidator": {
          aminoType: "cosmos-sdk/MsgEditValidator",
          toAmino: ({ description, commissionRate, minSelfDelegation, validatorAddress }) => {
            (0, utils_1.assertDefinedAndNotNull)(description, "missing description");
            return {
              description: {
                moniker: description.moniker,
                identity: description.identity,
                website: description.website,
                security_contact: description.securityContact,
                details: description.details
              },
              // empty string in the protobuf document means "do not change"
              commission_rate: commissionRate ? protoDecimalToJson(commissionRate) : void 0,
              // empty string in the protobuf document means "do not change"
              min_self_delegation: minSelfDelegation ? minSelfDelegation : void 0,
              validator_address: validatorAddress
            };
          },
          fromAmino: ({ description, commission_rate, min_self_delegation, validator_address }) => ({
            description: {
              moniker: description.moniker,
              identity: description.identity,
              website: description.website,
              securityContact: description.security_contact,
              details: description.details
            },
            // empty string in the protobuf document means "do not change"
            commissionRate: commission_rate ? jsonDecimalToProto(commission_rate) : "",
            // empty string in the protobuf document means "do not change"
            minSelfDelegation: min_self_delegation ?? "",
            validatorAddress: validator_address
          })
        },
        "/cosmos.staking.v1beta1.MsgUndelegate": {
          aminoType: "cosmos-sdk/MsgUndelegate",
          toAmino: ({ delegatorAddress, validatorAddress, amount }) => {
            (0, utils_1.assertDefinedAndNotNull)(amount, "missing amount");
            return {
              delegator_address: delegatorAddress,
              validator_address: validatorAddress,
              amount
            };
          },
          fromAmino: ({ delegator_address, validator_address, amount }) => ({
            delegatorAddress: delegator_address,
            validatorAddress: validator_address,
            amount
          })
        },
        "/cosmos.staking.v1beta1.MsgCancelUnbondingDelegation": {
          aminoType: "cosmos-sdk/MsgCancelUnbondingDelegation",
          toAmino: ({ delegatorAddress, validatorAddress, amount, creationHeight }) => {
            (0, utils_1.assertDefinedAndNotNull)(amount, "missing amount");
            return {
              delegator_address: delegatorAddress,
              validator_address: validatorAddress,
              amount,
              creation_height: creationHeight.toString()
            };
          },
          fromAmino: ({ delegator_address, validator_address, amount, creation_height }) => ({
            delegatorAddress: delegator_address,
            validatorAddress: validator_address,
            amount,
            creationHeight: BigInt(creation_height)
          })
        }
      };
    }
    exports.createStakingAminoConverters = createStakingAminoConverters;
  }
});

// ../../node_modules/.pnpm/@cosmjs+stargate@0.32.4/node_modules/@cosmjs/stargate/build/modules/staking/messages.js
var require_messages8 = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+stargate@0.32.4/node_modules/@cosmjs/stargate/build/modules/staking/messages.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isMsgCancelUnbondingDelegationEncodeObject = exports.isMsgUndelegateEncodeObject = exports.isMsgEditValidatorEncodeObject = exports.isMsgDelegateEncodeObject = exports.isMsgCreateValidatorEncodeObject = exports.isMsgBeginRedelegateEncodeObject = exports.stakingTypes = void 0;
    var tx_1 = require_tx13();
    exports.stakingTypes = [
      ["/cosmos.staking.v1beta1.MsgBeginRedelegate", tx_1.MsgBeginRedelegate],
      ["/cosmos.staking.v1beta1.MsgCreateValidator", tx_1.MsgCreateValidator],
      ["/cosmos.staking.v1beta1.MsgDelegate", tx_1.MsgDelegate],
      ["/cosmos.staking.v1beta1.MsgEditValidator", tx_1.MsgEditValidator],
      ["/cosmos.staking.v1beta1.MsgUndelegate", tx_1.MsgUndelegate],
      ["/cosmos.staking.v1beta1.MsgCancelUnbondingDelegation", tx_1.MsgCancelUnbondingDelegation]
    ];
    function isMsgBeginRedelegateEncodeObject(o) {
      return o.typeUrl === "/cosmos.staking.v1beta1.MsgBeginRedelegate";
    }
    exports.isMsgBeginRedelegateEncodeObject = isMsgBeginRedelegateEncodeObject;
    function isMsgCreateValidatorEncodeObject(o) {
      return o.typeUrl === "/cosmos.staking.v1beta1.MsgCreateValidator";
    }
    exports.isMsgCreateValidatorEncodeObject = isMsgCreateValidatorEncodeObject;
    function isMsgDelegateEncodeObject(object) {
      return object.typeUrl === "/cosmos.staking.v1beta1.MsgDelegate";
    }
    exports.isMsgDelegateEncodeObject = isMsgDelegateEncodeObject;
    function isMsgEditValidatorEncodeObject(o) {
      return o.typeUrl === "/cosmos.staking.v1beta1.MsgEditValidator";
    }
    exports.isMsgEditValidatorEncodeObject = isMsgEditValidatorEncodeObject;
    function isMsgUndelegateEncodeObject(object) {
      return object.typeUrl === "/cosmos.staking.v1beta1.MsgUndelegate";
    }
    exports.isMsgUndelegateEncodeObject = isMsgUndelegateEncodeObject;
    function isMsgCancelUnbondingDelegationEncodeObject(object) {
      return object.typeUrl === "/cosmos.staking.v1beta1.MsgCancelUnbondingDelegation";
    }
    exports.isMsgCancelUnbondingDelegationEncodeObject = isMsgCancelUnbondingDelegationEncodeObject;
  }
});

// ../../node_modules/.pnpm/@cosmjs+stargate@0.32.4/node_modules/@cosmjs/stargate/build/modules/staking/queries.js
var require_queries10 = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+stargate@0.32.4/node_modules/@cosmjs/stargate/build/modules/staking/queries.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.setupStakingExtension = void 0;
    var query_1 = require_query13();
    var queryclient_1 = require_queryclient2();
    function setupStakingExtension(base) {
      const rpc = (0, queryclient_1.createProtobufRpcClient)(base);
      const queryService = new query_1.QueryClientImpl(rpc);
      return {
        staking: {
          delegation: async (delegatorAddress, validatorAddress) => {
            const response = await queryService.Delegation({
              delegatorAddr: delegatorAddress,
              validatorAddr: validatorAddress
            });
            return response;
          },
          delegatorDelegations: async (delegatorAddress, paginationKey) => {
            const response = await queryService.DelegatorDelegations({
              delegatorAddr: delegatorAddress,
              pagination: (0, queryclient_1.createPagination)(paginationKey)
            });
            return response;
          },
          delegatorUnbondingDelegations: async (delegatorAddress, paginationKey) => {
            const response = await queryService.DelegatorUnbondingDelegations({
              delegatorAddr: delegatorAddress,
              pagination: (0, queryclient_1.createPagination)(paginationKey)
            });
            return response;
          },
          delegatorValidator: async (delegatorAddress, validatorAddress) => {
            const response = await queryService.DelegatorValidator({
              delegatorAddr: delegatorAddress,
              validatorAddr: validatorAddress
            });
            return response;
          },
          delegatorValidators: async (delegatorAddress, paginationKey) => {
            const response = await queryService.DelegatorValidators({
              delegatorAddr: delegatorAddress,
              pagination: (0, queryclient_1.createPagination)(paginationKey)
            });
            return response;
          },
          historicalInfo: async (height) => {
            const response = await queryService.HistoricalInfo({
              height: BigInt(height)
            });
            return response;
          },
          params: async () => {
            const response = await queryService.Params({});
            return response;
          },
          pool: async () => {
            const response = await queryService.Pool({});
            return response;
          },
          redelegations: async (delegatorAddress, sourceValidatorAddress, destinationValidatorAddress, paginationKey) => {
            const response = await queryService.Redelegations({
              delegatorAddr: delegatorAddress,
              srcValidatorAddr: sourceValidatorAddress,
              dstValidatorAddr: destinationValidatorAddress,
              pagination: (0, queryclient_1.createPagination)(paginationKey)
            });
            return response;
          },
          unbondingDelegation: async (delegatorAddress, validatorAddress) => {
            const response = await queryService.UnbondingDelegation({
              delegatorAddr: delegatorAddress,
              validatorAddr: validatorAddress
            });
            return response;
          },
          validator: async (validatorAddress) => {
            const response = await queryService.Validator({ validatorAddr: validatorAddress });
            return response;
          },
          validatorDelegations: async (validatorAddress, paginationKey) => {
            const response = await queryService.ValidatorDelegations({
              validatorAddr: validatorAddress,
              pagination: (0, queryclient_1.createPagination)(paginationKey)
            });
            return response;
          },
          validators: async (status, paginationKey) => {
            const response = await queryService.Validators({
              status,
              pagination: (0, queryclient_1.createPagination)(paginationKey)
            });
            return response;
          },
          validatorUnbondingDelegations: async (validatorAddress, paginationKey) => {
            const response = await queryService.ValidatorUnbondingDelegations({
              validatorAddr: validatorAddress,
              pagination: (0, queryclient_1.createPagination)(paginationKey)
            });
            return response;
          }
        }
      };
    }
    exports.setupStakingExtension = setupStakingExtension;
  }
});

// ../../node_modules/.pnpm/@cosmjs+stargate@0.32.4/node_modules/@cosmjs/stargate/build/modules/tx/queries.js
var require_queries11 = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+stargate@0.32.4/node_modules/@cosmjs/stargate/build/modules/tx/queries.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.setupTxExtension = void 0;
    var proto_signing_1 = require_build6();
    var signing_1 = require_signing();
    var service_1 = require_service();
    var tx_1 = require_tx();
    var queryclient_1 = require_queryclient2();
    function setupTxExtension(base) {
      const rpc = (0, queryclient_1.createProtobufRpcClient)(base);
      const queryService = new service_1.ServiceClientImpl(rpc);
      return {
        tx: {
          getTx: async (txId) => {
            const request = {
              hash: txId
            };
            const response = await queryService.GetTx(request);
            return response;
          },
          simulate: async (messages, memo, signer, sequence) => {
            const tx = tx_1.Tx.fromPartial({
              authInfo: tx_1.AuthInfo.fromPartial({
                fee: tx_1.Fee.fromPartial({}),
                signerInfos: [
                  {
                    publicKey: (0, proto_signing_1.encodePubkey)(signer),
                    sequence: BigInt(sequence),
                    modeInfo: { single: { mode: signing_1.SignMode.SIGN_MODE_UNSPECIFIED } }
                  }
                ]
              }),
              body: tx_1.TxBody.fromPartial({
                messages: Array.from(messages),
                memo
              }),
              signatures: [new Uint8Array()]
            });
            const request = service_1.SimulateRequest.fromPartial({
              txBytes: tx_1.Tx.encode(tx).finish()
            });
            const response = await queryService.Simulate(request);
            return response;
          }
        }
      };
    }
    exports.setupTxExtension = setupTxExtension;
  }
});

// ../../node_modules/.pnpm/@cosmjs+stargate@0.32.4/node_modules/@cosmjs/stargate/build/modules/vesting/aminomessages.js
var require_aminomessages12 = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+stargate@0.32.4/node_modules/@cosmjs/stargate/build/modules/vesting/aminomessages.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createVestingAminoConverters = exports.isAminoMsgCreateVestingAccount = void 0;
    function isAminoMsgCreateVestingAccount(msg) {
      return msg.type === "cosmos-sdk/MsgCreateVestingAccount";
    }
    exports.isAminoMsgCreateVestingAccount = isAminoMsgCreateVestingAccount;
    function createVestingAminoConverters() {
      return {
        "/cosmos.vesting.v1beta1.MsgCreateVestingAccount": {
          aminoType: "cosmos-sdk/MsgCreateVestingAccount",
          toAmino: ({ fromAddress, toAddress, amount, endTime, delayed }) => ({
            from_address: fromAddress,
            to_address: toAddress,
            amount: [...amount],
            end_time: endTime.toString(),
            delayed
          }),
          fromAmino: ({ from_address, to_address, amount, end_time, delayed }) => ({
            fromAddress: from_address,
            toAddress: to_address,
            amount: [...amount],
            endTime: BigInt(end_time),
            delayed
          })
        }
      };
    }
    exports.createVestingAminoConverters = createVestingAminoConverters;
  }
});

// ../../node_modules/.pnpm/@cosmjs+stargate@0.32.4/node_modules/@cosmjs/stargate/build/modules/vesting/messages.js
var require_messages9 = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+stargate@0.32.4/node_modules/@cosmjs/stargate/build/modules/vesting/messages.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.vestingTypes = void 0;
    var tx_1 = require_tx14();
    exports.vestingTypes = [
      ["/cosmos.vesting.v1beta1.MsgCreateVestingAccount", tx_1.MsgCreateVestingAccount]
    ];
  }
});

// ../../node_modules/.pnpm/@cosmjs+stargate@0.32.4/node_modules/@cosmjs/stargate/build/modules/index.js
var require_modules = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+stargate@0.32.4/node_modules/@cosmjs/stargate/build/modules/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isAminoMsgCreateValidator = exports.isAminoMsgBeginRedelegate = exports.createStakingAminoConverters = exports.setupSlashingExtension = exports.isAminoMsgUnjail = exports.createSlashingAminoConverters = exports.setupMintExtension = exports.setupIbcExtension = exports.isMsgTransferEncodeObject = exports.ibcTypes = exports.isAminoMsgTransfer = exports.createIbcAminoConverters = exports.groupTypes = exports.createGroupAminoConverters = exports.setupGovExtension = exports.isMsgVoteWeightedEncodeObject = exports.isMsgVoteEncodeObject = exports.isMsgSubmitProposalEncodeObject = exports.isMsgDepositEncodeObject = exports.govTypes = exports.isAminoMsgVoteWeighted = exports.isAminoMsgVote = exports.isAminoMsgSubmitProposal = exports.isAminoMsgDeposit = exports.createGovAminoConverters = exports.setupFeegrantExtension = exports.feegrantTypes = exports.createFeegrantAminoConverters = exports.isAminoMsgSubmitEvidence = exports.createEvidenceAminoConverters = exports.setupDistributionExtension = exports.isMsgWithdrawDelegatorRewardEncodeObject = exports.distributionTypes = exports.isAminoMsgWithdrawValidatorCommission = exports.isAminoMsgWithdrawDelegatorReward = exports.isAminoMsgSetWithdrawAddress = exports.isAminoMsgFundCommunityPool = exports.createDistributionAminoConverters = exports.isAminoMsgVerifyInvariant = exports.createCrysisAminoConverters = exports.setupBankExtension = exports.isMsgSendEncodeObject = exports.bankTypes = exports.isAminoMsgSend = exports.isAminoMsgMultiSend = exports.createBankAminoConverters = exports.setupAuthzExtension = exports.authzTypes = exports.createAuthzAminoConverters = exports.setupAuthExtension = void 0;
    exports.vestingTypes = exports.isAminoMsgCreateVestingAccount = exports.createVestingAminoConverters = exports.setupTxExtension = exports.setupStakingExtension = exports.stakingTypes = exports.isMsgUndelegateEncodeObject = exports.isMsgEditValidatorEncodeObject = exports.isMsgDelegateEncodeObject = exports.isMsgCreateValidatorEncodeObject = exports.isMsgCancelUnbondingDelegationEncodeObject = exports.isMsgBeginRedelegateEncodeObject = exports.isAminoMsgUndelegate = exports.isAminoMsgEditValidator = exports.isAminoMsgDelegate = void 0;
    var queries_1 = require_queries();
    Object.defineProperty(exports, "setupAuthExtension", { enumerable: true, get: function() {
      return queries_1.setupAuthExtension;
    } });
    var aminomessages_1 = require_aminomessages();
    Object.defineProperty(exports, "createAuthzAminoConverters", { enumerable: true, get: function() {
      return aminomessages_1.createAuthzAminoConverters;
    } });
    var messages_1 = require_messages();
    Object.defineProperty(exports, "authzTypes", { enumerable: true, get: function() {
      return messages_1.authzTypes;
    } });
    var queries_2 = require_queries2();
    Object.defineProperty(exports, "setupAuthzExtension", { enumerable: true, get: function() {
      return queries_2.setupAuthzExtension;
    } });
    var aminomessages_2 = require_aminomessages2();
    Object.defineProperty(exports, "createBankAminoConverters", { enumerable: true, get: function() {
      return aminomessages_2.createBankAminoConverters;
    } });
    Object.defineProperty(exports, "isAminoMsgMultiSend", { enumerable: true, get: function() {
      return aminomessages_2.isAminoMsgMultiSend;
    } });
    Object.defineProperty(exports, "isAminoMsgSend", { enumerable: true, get: function() {
      return aminomessages_2.isAminoMsgSend;
    } });
    var messages_2 = require_messages2();
    Object.defineProperty(exports, "bankTypes", { enumerable: true, get: function() {
      return messages_2.bankTypes;
    } });
    Object.defineProperty(exports, "isMsgSendEncodeObject", { enumerable: true, get: function() {
      return messages_2.isMsgSendEncodeObject;
    } });
    var queries_3 = require_queries3();
    Object.defineProperty(exports, "setupBankExtension", { enumerable: true, get: function() {
      return queries_3.setupBankExtension;
    } });
    var aminomessages_3 = require_aminomessages3();
    Object.defineProperty(exports, "createCrysisAminoConverters", { enumerable: true, get: function() {
      return aminomessages_3.createCrysisAminoConverters;
    } });
    Object.defineProperty(exports, "isAminoMsgVerifyInvariant", { enumerable: true, get: function() {
      return aminomessages_3.isAminoMsgVerifyInvariant;
    } });
    var aminomessages_4 = require_aminomessages4();
    Object.defineProperty(exports, "createDistributionAminoConverters", { enumerable: true, get: function() {
      return aminomessages_4.createDistributionAminoConverters;
    } });
    Object.defineProperty(exports, "isAminoMsgFundCommunityPool", { enumerable: true, get: function() {
      return aminomessages_4.isAminoMsgFundCommunityPool;
    } });
    Object.defineProperty(exports, "isAminoMsgSetWithdrawAddress", { enumerable: true, get: function() {
      return aminomessages_4.isAminoMsgSetWithdrawAddress;
    } });
    Object.defineProperty(exports, "isAminoMsgWithdrawDelegatorReward", { enumerable: true, get: function() {
      return aminomessages_4.isAminoMsgWithdrawDelegatorReward;
    } });
    Object.defineProperty(exports, "isAminoMsgWithdrawValidatorCommission", { enumerable: true, get: function() {
      return aminomessages_4.isAminoMsgWithdrawValidatorCommission;
    } });
    var messages_3 = require_messages3();
    Object.defineProperty(exports, "distributionTypes", { enumerable: true, get: function() {
      return messages_3.distributionTypes;
    } });
    Object.defineProperty(exports, "isMsgWithdrawDelegatorRewardEncodeObject", { enumerable: true, get: function() {
      return messages_3.isMsgWithdrawDelegatorRewardEncodeObject;
    } });
    var queries_4 = require_queries4();
    Object.defineProperty(exports, "setupDistributionExtension", { enumerable: true, get: function() {
      return queries_4.setupDistributionExtension;
    } });
    var aminomessages_5 = require_aminomessages5();
    Object.defineProperty(exports, "createEvidenceAminoConverters", { enumerable: true, get: function() {
      return aminomessages_5.createEvidenceAminoConverters;
    } });
    Object.defineProperty(exports, "isAminoMsgSubmitEvidence", { enumerable: true, get: function() {
      return aminomessages_5.isAminoMsgSubmitEvidence;
    } });
    var aminomessages_6 = require_aminomessages6();
    Object.defineProperty(exports, "createFeegrantAminoConverters", { enumerable: true, get: function() {
      return aminomessages_6.createFeegrantAminoConverters;
    } });
    var messages_4 = require_messages4();
    Object.defineProperty(exports, "feegrantTypes", { enumerable: true, get: function() {
      return messages_4.feegrantTypes;
    } });
    var queries_5 = require_queries5();
    Object.defineProperty(exports, "setupFeegrantExtension", { enumerable: true, get: function() {
      return queries_5.setupFeegrantExtension;
    } });
    var aminomessages_7 = require_aminomessages7();
    Object.defineProperty(exports, "createGovAminoConverters", { enumerable: true, get: function() {
      return aminomessages_7.createGovAminoConverters;
    } });
    Object.defineProperty(exports, "isAminoMsgDeposit", { enumerable: true, get: function() {
      return aminomessages_7.isAminoMsgDeposit;
    } });
    Object.defineProperty(exports, "isAminoMsgSubmitProposal", { enumerable: true, get: function() {
      return aminomessages_7.isAminoMsgSubmitProposal;
    } });
    Object.defineProperty(exports, "isAminoMsgVote", { enumerable: true, get: function() {
      return aminomessages_7.isAminoMsgVote;
    } });
    Object.defineProperty(exports, "isAminoMsgVoteWeighted", { enumerable: true, get: function() {
      return aminomessages_7.isAminoMsgVoteWeighted;
    } });
    var messages_5 = require_messages5();
    Object.defineProperty(exports, "govTypes", { enumerable: true, get: function() {
      return messages_5.govTypes;
    } });
    Object.defineProperty(exports, "isMsgDepositEncodeObject", { enumerable: true, get: function() {
      return messages_5.isMsgDepositEncodeObject;
    } });
    Object.defineProperty(exports, "isMsgSubmitProposalEncodeObject", { enumerable: true, get: function() {
      return messages_5.isMsgSubmitProposalEncodeObject;
    } });
    Object.defineProperty(exports, "isMsgVoteEncodeObject", { enumerable: true, get: function() {
      return messages_5.isMsgVoteEncodeObject;
    } });
    Object.defineProperty(exports, "isMsgVoteWeightedEncodeObject", { enumerable: true, get: function() {
      return messages_5.isMsgVoteWeightedEncodeObject;
    } });
    var queries_6 = require_queries6();
    Object.defineProperty(exports, "setupGovExtension", { enumerable: true, get: function() {
      return queries_6.setupGovExtension;
    } });
    var aminomessages_8 = require_aminomessages8();
    Object.defineProperty(exports, "createGroupAminoConverters", { enumerable: true, get: function() {
      return aminomessages_8.createGroupAminoConverters;
    } });
    var messages_6 = require_messages6();
    Object.defineProperty(exports, "groupTypes", { enumerable: true, get: function() {
      return messages_6.groupTypes;
    } });
    var aminomessages_9 = require_aminomessages9();
    Object.defineProperty(exports, "createIbcAminoConverters", { enumerable: true, get: function() {
      return aminomessages_9.createIbcAminoConverters;
    } });
    Object.defineProperty(exports, "isAminoMsgTransfer", { enumerable: true, get: function() {
      return aminomessages_9.isAminoMsgTransfer;
    } });
    var messages_7 = require_messages7();
    Object.defineProperty(exports, "ibcTypes", { enumerable: true, get: function() {
      return messages_7.ibcTypes;
    } });
    Object.defineProperty(exports, "isMsgTransferEncodeObject", { enumerable: true, get: function() {
      return messages_7.isMsgTransferEncodeObject;
    } });
    var queries_7 = require_queries7();
    Object.defineProperty(exports, "setupIbcExtension", { enumerable: true, get: function() {
      return queries_7.setupIbcExtension;
    } });
    var queries_8 = require_queries8();
    Object.defineProperty(exports, "setupMintExtension", { enumerable: true, get: function() {
      return queries_8.setupMintExtension;
    } });
    var aminomessages_10 = require_aminomessages10();
    Object.defineProperty(exports, "createSlashingAminoConverters", { enumerable: true, get: function() {
      return aminomessages_10.createSlashingAminoConverters;
    } });
    Object.defineProperty(exports, "isAminoMsgUnjail", { enumerable: true, get: function() {
      return aminomessages_10.isAminoMsgUnjail;
    } });
    var queries_9 = require_queries9();
    Object.defineProperty(exports, "setupSlashingExtension", { enumerable: true, get: function() {
      return queries_9.setupSlashingExtension;
    } });
    var aminomessages_11 = require_aminomessages11();
    Object.defineProperty(exports, "createStakingAminoConverters", { enumerable: true, get: function() {
      return aminomessages_11.createStakingAminoConverters;
    } });
    Object.defineProperty(exports, "isAminoMsgBeginRedelegate", { enumerable: true, get: function() {
      return aminomessages_11.isAminoMsgBeginRedelegate;
    } });
    Object.defineProperty(exports, "isAminoMsgCreateValidator", { enumerable: true, get: function() {
      return aminomessages_11.isAminoMsgCreateValidator;
    } });
    Object.defineProperty(exports, "isAminoMsgDelegate", { enumerable: true, get: function() {
      return aminomessages_11.isAminoMsgDelegate;
    } });
    Object.defineProperty(exports, "isAminoMsgEditValidator", { enumerable: true, get: function() {
      return aminomessages_11.isAminoMsgEditValidator;
    } });
    Object.defineProperty(exports, "isAminoMsgUndelegate", { enumerable: true, get: function() {
      return aminomessages_11.isAminoMsgUndelegate;
    } });
    var messages_8 = require_messages8();
    Object.defineProperty(exports, "isMsgBeginRedelegateEncodeObject", { enumerable: true, get: function() {
      return messages_8.isMsgBeginRedelegateEncodeObject;
    } });
    Object.defineProperty(exports, "isMsgCancelUnbondingDelegationEncodeObject", { enumerable: true, get: function() {
      return messages_8.isMsgCancelUnbondingDelegationEncodeObject;
    } });
    Object.defineProperty(exports, "isMsgCreateValidatorEncodeObject", { enumerable: true, get: function() {
      return messages_8.isMsgCreateValidatorEncodeObject;
    } });
    Object.defineProperty(exports, "isMsgDelegateEncodeObject", { enumerable: true, get: function() {
      return messages_8.isMsgDelegateEncodeObject;
    } });
    Object.defineProperty(exports, "isMsgEditValidatorEncodeObject", { enumerable: true, get: function() {
      return messages_8.isMsgEditValidatorEncodeObject;
    } });
    Object.defineProperty(exports, "isMsgUndelegateEncodeObject", { enumerable: true, get: function() {
      return messages_8.isMsgUndelegateEncodeObject;
    } });
    Object.defineProperty(exports, "stakingTypes", { enumerable: true, get: function() {
      return messages_8.stakingTypes;
    } });
    var queries_10 = require_queries10();
    Object.defineProperty(exports, "setupStakingExtension", { enumerable: true, get: function() {
      return queries_10.setupStakingExtension;
    } });
    var queries_11 = require_queries11();
    Object.defineProperty(exports, "setupTxExtension", { enumerable: true, get: function() {
      return queries_11.setupTxExtension;
    } });
    var aminomessages_12 = require_aminomessages12();
    Object.defineProperty(exports, "createVestingAminoConverters", { enumerable: true, get: function() {
      return aminomessages_12.createVestingAminoConverters;
    } });
    Object.defineProperty(exports, "isAminoMsgCreateVestingAccount", { enumerable: true, get: function() {
      return aminomessages_12.isAminoMsgCreateVestingAccount;
    } });
    var messages_9 = require_messages9();
    Object.defineProperty(exports, "vestingTypes", { enumerable: true, get: function() {
      return messages_9.vestingTypes;
    } });
  }
});

// ../../node_modules/.pnpm/@cosmjs+stargate@0.32.4/node_modules/@cosmjs/stargate/build/multisignature.js
var require_multisignature = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+stargate@0.32.4/node_modules/@cosmjs/stargate/build/multisignature.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.makeMultisignedTxBytes = exports.makeMultisignedTx = exports.makeCompactBitArray = void 0;
    var amino_1 = require_build5();
    var encoding_1 = require_build2();
    var proto_signing_1 = require_build6();
    var multisig_1 = require_multisig();
    var signing_1 = require_signing();
    var tx_1 = require_tx();
    var tx_2 = require_tx();
    function makeCompactBitArray(bits) {
      const byteCount = Math.ceil(bits.length / 8);
      const extraBits = bits.length - Math.floor(bits.length / 8) * 8;
      const bytes = new Uint8Array(byteCount);
      bits.forEach((value, index) => {
        const bytePos = Math.floor(index / 8);
        const bitPos = index % 8;
        if (value)
          bytes[bytePos] |= 1 << 8 - 1 - bitPos;
      });
      return multisig_1.CompactBitArray.fromPartial({ elems: bytes, extraBitsStored: extraBits });
    }
    exports.makeCompactBitArray = makeCompactBitArray;
    function makeMultisignedTx(multisigPubkey, sequence, fee, bodyBytes, signatures) {
      const addresses = Array.from(signatures.keys());
      const prefix = (0, encoding_1.fromBech32)(addresses[0]).prefix;
      const signers = Array(multisigPubkey.value.pubkeys.length).fill(false);
      const signaturesList = new Array();
      for (let i = 0; i < multisigPubkey.value.pubkeys.length; i++) {
        const signerAddress = (0, amino_1.pubkeyToAddress)(multisigPubkey.value.pubkeys[i], prefix);
        const signature = signatures.get(signerAddress);
        if (signature) {
          signers[i] = true;
          signaturesList.push(signature);
        }
      }
      const signerInfo = {
        publicKey: (0, proto_signing_1.encodePubkey)(multisigPubkey),
        modeInfo: {
          multi: {
            bitarray: makeCompactBitArray(signers),
            modeInfos: signaturesList.map((_) => ({ single: { mode: signing_1.SignMode.SIGN_MODE_LEGACY_AMINO_JSON } }))
          }
        },
        sequence: BigInt(sequence)
      };
      const authInfo = tx_1.AuthInfo.fromPartial({
        signerInfos: [signerInfo],
        fee: {
          amount: [...fee.amount],
          gasLimit: BigInt(fee.gas)
        }
      });
      const authInfoBytes = tx_1.AuthInfo.encode(authInfo).finish();
      const signedTx = tx_2.TxRaw.fromPartial({
        bodyBytes,
        authInfoBytes,
        signatures: [multisig_1.MultiSignature.encode(multisig_1.MultiSignature.fromPartial({ signatures: signaturesList })).finish()]
      });
      return signedTx;
    }
    exports.makeMultisignedTx = makeMultisignedTx;
    function makeMultisignedTxBytes(multisigPubkey, sequence, fee, bodyBytes, signatures) {
      const signedTx = makeMultisignedTx(multisigPubkey, sequence, fee, bodyBytes, signatures);
      return Uint8Array.from(tx_2.TxRaw.encode(signedTx).finish());
    }
    exports.makeMultisignedTxBytes = makeMultisignedTxBytes;
  }
});

// ../../node_modules/.pnpm/@cosmjs+stargate@0.32.4/node_modules/@cosmjs/stargate/build/search.js
var require_search = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+stargate@0.32.4/node_modules/@cosmjs/stargate/build/search.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isSearchTxQueryArray = void 0;
    function isSearchTxQueryArray(query) {
      return Array.isArray(query);
    }
    exports.isSearchTxQueryArray = isSearchTxQueryArray;
  }
});

// ../../node_modules/.pnpm/@cosmjs+tendermint-rpc@0.32.4/node_modules/@cosmjs/tendermint-rpc/build/addresses.js
var require_addresses2 = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+tendermint-rpc@0.32.4/node_modules/@cosmjs/tendermint-rpc/build/addresses.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.pubkeyToAddress = exports.pubkeyToRawAddress = exports.rawSecp256k1PubkeyToRawAddress = exports.rawEd25519PubkeyToRawAddress = void 0;
    var crypto_1 = require_build4();
    var encoding_1 = require_build2();
    function rawEd25519PubkeyToRawAddress(pubkeyData) {
      if (pubkeyData.length !== 32) {
        throw new Error(`Invalid Ed25519 pubkey length: ${pubkeyData.length}`);
      }
      return (0, crypto_1.sha256)(pubkeyData).slice(0, 20);
    }
    exports.rawEd25519PubkeyToRawAddress = rawEd25519PubkeyToRawAddress;
    function rawSecp256k1PubkeyToRawAddress(pubkeyData) {
      if (pubkeyData.length !== 33) {
        throw new Error(`Invalid Secp256k1 pubkey length (compressed): ${pubkeyData.length}`);
      }
      return (0, crypto_1.ripemd160)((0, crypto_1.sha256)(pubkeyData));
    }
    exports.rawSecp256k1PubkeyToRawAddress = rawSecp256k1PubkeyToRawAddress;
    function pubkeyToRawAddress(type, data) {
      switch (type) {
        case "ed25519":
          return rawEd25519PubkeyToRawAddress(data);
        case "secp256k1":
          return rawSecp256k1PubkeyToRawAddress(data);
        default:
          throw new Error(`Pubkey type ${type} not supported`);
      }
    }
    exports.pubkeyToRawAddress = pubkeyToRawAddress;
    function pubkeyToAddress(type, data) {
      return (0, encoding_1.toHex)(pubkeyToRawAddress(type, data)).toUpperCase();
    }
    exports.pubkeyToAddress = pubkeyToAddress;
  }
});

// ../../node_modules/.pnpm/@cosmjs+tendermint-rpc@0.32.4/node_modules/@cosmjs/tendermint-rpc/build/dates.js
var require_dates = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+tendermint-rpc@0.32.4/node_modules/@cosmjs/tendermint-rpc/build/dates.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DateTime = exports.toSeconds = exports.fromSeconds = exports.toRfc3339WithNanoseconds = exports.fromRfc3339WithNanoseconds = void 0;
    var encoding_1 = require_build2();
    var math_1 = require_build();
    function fromRfc3339WithNanoseconds(dateTimeString) {
      const out = (0, encoding_1.fromRfc3339)(dateTimeString);
      const nanosecondsMatch = dateTimeString.match(/\.(\d+)Z$/);
      const nanoseconds = nanosecondsMatch ? nanosecondsMatch[1].slice(3) : "";
      out.nanoseconds = parseInt(nanoseconds.padEnd(6, "0"), 10);
      return out;
    }
    exports.fromRfc3339WithNanoseconds = fromRfc3339WithNanoseconds;
    function toRfc3339WithNanoseconds(dateTime) {
      var _a;
      const millisecondIso = dateTime.toISOString();
      const nanoseconds = ((_a = dateTime.nanoseconds) == null ? void 0 : _a.toString()) ?? "";
      return `${millisecondIso.slice(0, -1)}${nanoseconds.padStart(6, "0")}Z`;
    }
    exports.toRfc3339WithNanoseconds = toRfc3339WithNanoseconds;
    function fromSeconds(seconds, nanos = 0) {
      const checkedNanos = new math_1.Uint32(nanos).toNumber();
      if (checkedNanos > 999999999) {
        throw new Error("Nano seconds must not exceed 999999999");
      }
      const out = new Date(seconds * 1e3 + Math.floor(checkedNanos / 1e6));
      out.nanoseconds = checkedNanos % 1e6;
      return out;
    }
    exports.fromSeconds = fromSeconds;
    function toSeconds(date) {
      return {
        seconds: Math.floor(date.getTime() / 1e3),
        nanos: date.getTime() % 1e3 * 1e6 + (date.nanoseconds ?? 0)
      };
    }
    exports.toSeconds = toSeconds;
    var DateTime = class {
      /** @deprecated Use fromRfc3339WithNanoseconds instead */
      static decode(dateTimeString) {
        return fromRfc3339WithNanoseconds(dateTimeString);
      }
      /** @deprecated Use toRfc3339WithNanoseconds instead */
      static encode(dateTime) {
        return toRfc3339WithNanoseconds(dateTime);
      }
    };
    exports.DateTime = DateTime;
  }
});

// ../../node_modules/.pnpm/@cosmjs+tendermint-rpc@0.32.4/node_modules/@cosmjs/tendermint-rpc/build/jsonrpc.js
var require_jsonrpc = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+tendermint-rpc@0.32.4/node_modules/@cosmjs/tendermint-rpc/build/jsonrpc.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createJsonRpcRequest = void 0;
    var numbersWithoutZero = "123456789";
    function randomNumericChar() {
      return numbersWithoutZero[Math.floor(Math.random() * numbersWithoutZero.length)];
    }
    function randomId() {
      return parseInt(Array.from({ length: 12 }).map(() => randomNumericChar()).join(""), 10);
    }
    function createJsonRpcRequest(method, params) {
      const paramsCopy = params ? { ...params } : {};
      return {
        jsonrpc: "2.0",
        id: randomId(),
        method,
        params: paramsCopy
      };
    }
    exports.createJsonRpcRequest = createJsonRpcRequest;
  }
});

// ../../node_modules/.pnpm/@cosmjs+json-rpc@0.32.4/node_modules/@cosmjs/json-rpc/build/id.js
var require_id = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+json-rpc@0.32.4/node_modules/@cosmjs/json-rpc/build/id.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.makeJsonRpcId = void 0;
    var counter = 1e4;
    function makeJsonRpcId() {
      return counter += 1;
    }
    exports.makeJsonRpcId = makeJsonRpcId;
  }
});

// ../../node_modules/.pnpm/@cosmjs+json-rpc@0.32.4/node_modules/@cosmjs/json-rpc/build/types.js
var require_types = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+json-rpc@0.32.4/node_modules/@cosmjs/json-rpc/build/types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.jsonRpcCode = exports.isJsonRpcSuccessResponse = exports.isJsonRpcErrorResponse = void 0;
    function isJsonRpcErrorResponse(response) {
      return typeof response.error === "object";
    }
    exports.isJsonRpcErrorResponse = isJsonRpcErrorResponse;
    function isJsonRpcSuccessResponse(response) {
      return !isJsonRpcErrorResponse(response);
    }
    exports.isJsonRpcSuccessResponse = isJsonRpcSuccessResponse;
    exports.jsonRpcCode = {
      parseError: -32700,
      invalidRequest: -32600,
      methodNotFound: -32601,
      invalidParams: -32602,
      internalError: -32603,
      // server error (Reserved for implementation-defined server-errors.):
      // -32000 to -32099
      serverError: {
        default: -32e3
      }
    };
  }
});

// ../../node_modules/.pnpm/@cosmjs+json-rpc@0.32.4/node_modules/@cosmjs/json-rpc/build/jsonrpcclient.js
var require_jsonrpcclient = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+json-rpc@0.32.4/node_modules/@cosmjs/json-rpc/build/jsonrpcclient.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.JsonRpcClient = void 0;
    var stream_1 = require_build8();
    var types_1 = require_types();
    var JsonRpcClient = class {
      constructor(connection) {
        this.connection = connection;
      }
      async run(request) {
        const filteredStream = this.connection.responseStream.filter((r) => r.id === request.id);
        const pendingResponses = (0, stream_1.firstEvent)(filteredStream);
        this.connection.sendRequest(request);
        const response = await pendingResponses;
        if ((0, types_1.isJsonRpcErrorResponse)(response)) {
          const error = response.error;
          throw new Error(`JSON RPC error: code=${error.code}; message='${error.message}'`);
        }
        return response;
      }
    };
    exports.JsonRpcClient = JsonRpcClient;
  }
});

// ../../node_modules/.pnpm/@cosmjs+json-rpc@0.32.4/node_modules/@cosmjs/json-rpc/build/compatibility.js
var require_compatibility = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+json-rpc@0.32.4/node_modules/@cosmjs/json-rpc/build/compatibility.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isJsonCompatibleDictionary = exports.isJsonCompatibleArray = exports.isJsonCompatibleValue = void 0;
    function isJsonCompatibleValue(value) {
      if (typeof value === "string" || typeof value === "number" || typeof value === "boolean" || value === null || // eslint-disable-next-line @typescript-eslint/no-use-before-define
      isJsonCompatibleArray(value) || // eslint-disable-next-line @typescript-eslint/no-use-before-define
      isJsonCompatibleDictionary(value)) {
        return true;
      } else {
        return false;
      }
    }
    exports.isJsonCompatibleValue = isJsonCompatibleValue;
    function isJsonCompatibleArray(value) {
      if (!Array.isArray(value)) {
        return false;
      }
      for (const item of value) {
        if (!isJsonCompatibleValue(item)) {
          return false;
        }
      }
      return true;
    }
    exports.isJsonCompatibleArray = isJsonCompatibleArray;
    function isJsonCompatibleDictionary(data) {
      if (typeof data !== "object" || data === null) {
        return false;
      }
      if (Object.prototype.toString.call(data) !== "[object Object]") {
        return false;
      }
      return Object.values(data).every(isJsonCompatibleValue);
    }
    exports.isJsonCompatibleDictionary = isJsonCompatibleDictionary;
  }
});

// ../../node_modules/.pnpm/@cosmjs+json-rpc@0.32.4/node_modules/@cosmjs/json-rpc/build/parse.js
var require_parse = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+json-rpc@0.32.4/node_modules/@cosmjs/json-rpc/build/parse.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseJsonRpcResponse = exports.parseJsonRpcSuccessResponse = exports.parseJsonRpcErrorResponse = exports.parseJsonRpcRequest = exports.parseJsonRpcId = void 0;
    var compatibility_1 = require_compatibility();
    function parseJsonRpcId(data) {
      if (!(0, compatibility_1.isJsonCompatibleDictionary)(data)) {
        throw new Error("Data must be JSON compatible dictionary");
      }
      const id = data.id;
      if (typeof id !== "number" && typeof id !== "string") {
        return null;
      }
      return id;
    }
    exports.parseJsonRpcId = parseJsonRpcId;
    function parseJsonRpcRequest(data) {
      if (!(0, compatibility_1.isJsonCompatibleDictionary)(data)) {
        throw new Error("Data must be JSON compatible dictionary");
      }
      if (data.jsonrpc !== "2.0") {
        throw new Error(`Got unexpected jsonrpc version: ${data.jsonrpc}`);
      }
      const id = parseJsonRpcId(data);
      if (id === null) {
        throw new Error("Invalid id field");
      }
      const method = data.method;
      if (typeof method !== "string") {
        throw new Error("Invalid method field");
      }
      if (!(0, compatibility_1.isJsonCompatibleArray)(data.params) && !(0, compatibility_1.isJsonCompatibleDictionary)(data.params)) {
        throw new Error("Invalid params field");
      }
      return {
        jsonrpc: "2.0",
        id,
        method,
        params: data.params
      };
    }
    exports.parseJsonRpcRequest = parseJsonRpcRequest;
    function parseError(error) {
      if (typeof error.code !== "number") {
        throw new Error("Error property 'code' is not a number");
      }
      if (typeof error.message !== "string") {
        throw new Error("Error property 'message' is not a string");
      }
      let maybeUndefinedData;
      if (error.data === void 0) {
        maybeUndefinedData = void 0;
      } else if ((0, compatibility_1.isJsonCompatibleValue)(error.data)) {
        maybeUndefinedData = error.data;
      } else {
        throw new Error("Error property 'data' is defined but not a JSON compatible value.");
      }
      return {
        code: error.code,
        message: error.message,
        ...maybeUndefinedData !== void 0 ? { data: maybeUndefinedData } : {}
      };
    }
    function parseJsonRpcErrorResponse(data) {
      if (!(0, compatibility_1.isJsonCompatibleDictionary)(data)) {
        throw new Error("Data must be JSON compatible dictionary");
      }
      if (data.jsonrpc !== "2.0") {
        throw new Error(`Got unexpected jsonrpc version: ${JSON.stringify(data)}`);
      }
      const id = data.id;
      if (typeof id !== "number" && typeof id !== "string" && id !== null) {
        throw new Error("Invalid id field");
      }
      if (typeof data.error === "undefined" || !(0, compatibility_1.isJsonCompatibleDictionary)(data.error)) {
        throw new Error("Invalid error field");
      }
      return {
        jsonrpc: "2.0",
        id,
        error: parseError(data.error)
      };
    }
    exports.parseJsonRpcErrorResponse = parseJsonRpcErrorResponse;
    function parseJsonRpcSuccessResponse(data) {
      if (!(0, compatibility_1.isJsonCompatibleDictionary)(data)) {
        throw new Error("Data must be JSON compatible dictionary");
      }
      if (data.jsonrpc !== "2.0") {
        throw new Error(`Got unexpected jsonrpc version: ${JSON.stringify(data)}`);
      }
      const id = data.id;
      if (typeof id !== "number" && typeof id !== "string") {
        throw new Error("Invalid id field");
      }
      if (typeof data.result === "undefined") {
        throw new Error("Invalid result field");
      }
      const result = data.result;
      return {
        jsonrpc: "2.0",
        id,
        result
      };
    }
    exports.parseJsonRpcSuccessResponse = parseJsonRpcSuccessResponse;
    function parseJsonRpcResponse(data) {
      let response;
      try {
        response = parseJsonRpcErrorResponse(data);
      } catch (_) {
        response = parseJsonRpcSuccessResponse(data);
      }
      return response;
    }
    exports.parseJsonRpcResponse = parseJsonRpcResponse;
  }
});

// ../../node_modules/.pnpm/@cosmjs+json-rpc@0.32.4/node_modules/@cosmjs/json-rpc/build/index.js
var require_build9 = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+json-rpc@0.32.4/node_modules/@cosmjs/json-rpc/build/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.jsonRpcCode = exports.isJsonRpcSuccessResponse = exports.isJsonRpcErrorResponse = exports.parseJsonRpcSuccessResponse = exports.parseJsonRpcResponse = exports.parseJsonRpcRequest = exports.parseJsonRpcId = exports.parseJsonRpcErrorResponse = exports.JsonRpcClient = exports.makeJsonRpcId = void 0;
    var id_1 = require_id();
    Object.defineProperty(exports, "makeJsonRpcId", { enumerable: true, get: function() {
      return id_1.makeJsonRpcId;
    } });
    var jsonrpcclient_1 = require_jsonrpcclient();
    Object.defineProperty(exports, "JsonRpcClient", { enumerable: true, get: function() {
      return jsonrpcclient_1.JsonRpcClient;
    } });
    var parse_1 = require_parse();
    Object.defineProperty(exports, "parseJsonRpcErrorResponse", { enumerable: true, get: function() {
      return parse_1.parseJsonRpcErrorResponse;
    } });
    Object.defineProperty(exports, "parseJsonRpcId", { enumerable: true, get: function() {
      return parse_1.parseJsonRpcId;
    } });
    Object.defineProperty(exports, "parseJsonRpcRequest", { enumerable: true, get: function() {
      return parse_1.parseJsonRpcRequest;
    } });
    Object.defineProperty(exports, "parseJsonRpcResponse", { enumerable: true, get: function() {
      return parse_1.parseJsonRpcResponse;
    } });
    Object.defineProperty(exports, "parseJsonRpcSuccessResponse", { enumerable: true, get: function() {
      return parse_1.parseJsonRpcSuccessResponse;
    } });
    var types_1 = require_types();
    Object.defineProperty(exports, "isJsonRpcErrorResponse", { enumerable: true, get: function() {
      return types_1.isJsonRpcErrorResponse;
    } });
    Object.defineProperty(exports, "isJsonRpcSuccessResponse", { enumerable: true, get: function() {
      return types_1.isJsonRpcSuccessResponse;
    } });
    Object.defineProperty(exports, "jsonRpcCode", { enumerable: true, get: function() {
      return types_1.jsonRpcCode;
    } });
  }
});

// ../../node_modules/.pnpm/axios@1.10.0/node_modules/axios/dist/browser/axios.cjs
var require_axios = __commonJS({
  "../../node_modules/.pnpm/axios@1.10.0/node_modules/axios/dist/browser/axios.cjs"(exports, module) {
    "use strict";
    function bind(fn, thisArg) {
      return function wrap() {
        return fn.apply(thisArg, arguments);
      };
    }
    var { toString } = Object.prototype;
    var { getPrototypeOf } = Object;
    var { iterator, toStringTag } = Symbol;
    var kindOf = ((cache) => (thing) => {
      const str = toString.call(thing);
      return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());
    })(/* @__PURE__ */ Object.create(null));
    var kindOfTest = (type) => {
      type = type.toLowerCase();
      return (thing) => kindOf(thing) === type;
    };
    var typeOfTest = (type) => (thing) => typeof thing === type;
    var { isArray } = Array;
    var isUndefined = typeOfTest("undefined");
    function isBuffer(val) {
      return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && isFunction(val.constructor.isBuffer) && val.constructor.isBuffer(val);
    }
    var isArrayBuffer = kindOfTest("ArrayBuffer");
    function isArrayBufferView(val) {
      let result;
      if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
        result = ArrayBuffer.isView(val);
      } else {
        result = val && val.buffer && isArrayBuffer(val.buffer);
      }
      return result;
    }
    var isString = typeOfTest("string");
    var isFunction = typeOfTest("function");
    var isNumber = typeOfTest("number");
    var isObject = (thing) => thing !== null && typeof thing === "object";
    var isBoolean = (thing) => thing === true || thing === false;
    var isPlainObject = (val) => {
      if (kindOf(val) !== "object") {
        return false;
      }
      const prototype2 = getPrototypeOf(val);
      return (prototype2 === null || prototype2 === Object.prototype || Object.getPrototypeOf(prototype2) === null) && !(toStringTag in val) && !(iterator in val);
    };
    var isDate = kindOfTest("Date");
    var isFile = kindOfTest("File");
    var isBlob = kindOfTest("Blob");
    var isFileList = kindOfTest("FileList");
    var isStream = (val) => isObject(val) && isFunction(val.pipe);
    var isFormData = (thing) => {
      let kind;
      return thing && (typeof FormData === "function" && thing instanceof FormData || isFunction(thing.append) && ((kind = kindOf(thing)) === "formdata" || // detect form-data instance
      kind === "object" && isFunction(thing.toString) && thing.toString() === "[object FormData]"));
    };
    var isURLSearchParams = kindOfTest("URLSearchParams");
    var [isReadableStream, isRequest, isResponse, isHeaders] = ["ReadableStream", "Request", "Response", "Headers"].map(kindOfTest);
    var trim = (str) => str.trim ? str.trim() : str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
    function forEach(obj, fn, { allOwnKeys = false } = {}) {
      if (obj === null || typeof obj === "undefined") {
        return;
      }
      let i;
      let l;
      if (typeof obj !== "object") {
        obj = [obj];
      }
      if (isArray(obj)) {
        for (i = 0, l = obj.length; i < l; i++) {
          fn.call(null, obj[i], i, obj);
        }
      } else {
        const keys = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);
        const len = keys.length;
        let key;
        for (i = 0; i < len; i++) {
          key = keys[i];
          fn.call(null, obj[key], key, obj);
        }
      }
    }
    function findKey(obj, key) {
      key = key.toLowerCase();
      const keys = Object.keys(obj);
      let i = keys.length;
      let _key;
      while (i-- > 0) {
        _key = keys[i];
        if (key === _key.toLowerCase()) {
          return _key;
        }
      }
      return null;
    }
    var _global = (() => {
      if (typeof globalThis !== "undefined")
        return globalThis;
      return typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : global;
    })();
    var isContextDefined = (context) => !isUndefined(context) && context !== _global;
    function merge() {
      const { caseless } = isContextDefined(this) && this || {};
      const result = {};
      const assignValue = (val, key) => {
        const targetKey = caseless && findKey(result, key) || key;
        if (isPlainObject(result[targetKey]) && isPlainObject(val)) {
          result[targetKey] = merge(result[targetKey], val);
        } else if (isPlainObject(val)) {
          result[targetKey] = merge({}, val);
        } else if (isArray(val)) {
          result[targetKey] = val.slice();
        } else {
          result[targetKey] = val;
        }
      };
      for (let i = 0, l = arguments.length; i < l; i++) {
        arguments[i] && forEach(arguments[i], assignValue);
      }
      return result;
    }
    var extend = (a, b, thisArg, { allOwnKeys } = {}) => {
      forEach(b, (val, key) => {
        if (thisArg && isFunction(val)) {
          a[key] = bind(val, thisArg);
        } else {
          a[key] = val;
        }
      }, { allOwnKeys });
      return a;
    };
    var stripBOM = (content) => {
      if (content.charCodeAt(0) === 65279) {
        content = content.slice(1);
      }
      return content;
    };
    var inherits = (constructor, superConstructor, props, descriptors2) => {
      constructor.prototype = Object.create(superConstructor.prototype, descriptors2);
      constructor.prototype.constructor = constructor;
      Object.defineProperty(constructor, "super", {
        value: superConstructor.prototype
      });
      props && Object.assign(constructor.prototype, props);
    };
    var toFlatObject = (sourceObj, destObj, filter, propFilter) => {
      let props;
      let i;
      let prop;
      const merged = {};
      destObj = destObj || {};
      if (sourceObj == null)
        return destObj;
      do {
        props = Object.getOwnPropertyNames(sourceObj);
        i = props.length;
        while (i-- > 0) {
          prop = props[i];
          if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {
            destObj[prop] = sourceObj[prop];
            merged[prop] = true;
          }
        }
        sourceObj = filter !== false && getPrototypeOf(sourceObj);
      } while (sourceObj && (!filter || filter(sourceObj, destObj)) && sourceObj !== Object.prototype);
      return destObj;
    };
    var endsWith = (str, searchString, position) => {
      str = String(str);
      if (position === void 0 || position > str.length) {
        position = str.length;
      }
      position -= searchString.length;
      const lastIndex = str.indexOf(searchString, position);
      return lastIndex !== -1 && lastIndex === position;
    };
    var toArray = (thing) => {
      if (!thing)
        return null;
      if (isArray(thing))
        return thing;
      let i = thing.length;
      if (!isNumber(i))
        return null;
      const arr = new Array(i);
      while (i-- > 0) {
        arr[i] = thing[i];
      }
      return arr;
    };
    var isTypedArray = ((TypedArray) => {
      return (thing) => {
        return TypedArray && thing instanceof TypedArray;
      };
    })(typeof Uint8Array !== "undefined" && getPrototypeOf(Uint8Array));
    var forEachEntry = (obj, fn) => {
      const generator = obj && obj[iterator];
      const _iterator = generator.call(obj);
      let result;
      while ((result = _iterator.next()) && !result.done) {
        const pair = result.value;
        fn.call(obj, pair[0], pair[1]);
      }
    };
    var matchAll = (regExp, str) => {
      let matches;
      const arr = [];
      while ((matches = regExp.exec(str)) !== null) {
        arr.push(matches);
      }
      return arr;
    };
    var isHTMLForm = kindOfTest("HTMLFormElement");
    var toCamelCase = (str) => {
      return str.toLowerCase().replace(
        /[-_\s]([a-z\d])(\w*)/g,
        function replacer(m, p1, p2) {
          return p1.toUpperCase() + p2;
        }
      );
    };
    var hasOwnProperty = (({ hasOwnProperty: hasOwnProperty2 }) => (obj, prop) => hasOwnProperty2.call(obj, prop))(Object.prototype);
    var isRegExp = kindOfTest("RegExp");
    var reduceDescriptors = (obj, reducer) => {
      const descriptors2 = Object.getOwnPropertyDescriptors(obj);
      const reducedDescriptors = {};
      forEach(descriptors2, (descriptor, name) => {
        let ret;
        if ((ret = reducer(descriptor, name, obj)) !== false) {
          reducedDescriptors[name] = ret || descriptor;
        }
      });
      Object.defineProperties(obj, reducedDescriptors);
    };
    var freezeMethods = (obj) => {
      reduceDescriptors(obj, (descriptor, name) => {
        if (isFunction(obj) && ["arguments", "caller", "callee"].indexOf(name) !== -1) {
          return false;
        }
        const value = obj[name];
        if (!isFunction(value))
          return;
        descriptor.enumerable = false;
        if ("writable" in descriptor) {
          descriptor.writable = false;
          return;
        }
        if (!descriptor.set) {
          descriptor.set = () => {
            throw Error("Can not rewrite read-only method '" + name + "'");
          };
        }
      });
    };
    var toObjectSet = (arrayOrString, delimiter) => {
      const obj = {};
      const define = (arr) => {
        arr.forEach((value) => {
          obj[value] = true;
        });
      };
      isArray(arrayOrString) ? define(arrayOrString) : define(String(arrayOrString).split(delimiter));
      return obj;
    };
    var noop = () => {
    };
    var toFiniteNumber = (value, defaultValue) => {
      return value != null && Number.isFinite(value = +value) ? value : defaultValue;
    };
    function isSpecCompliantForm(thing) {
      return !!(thing && isFunction(thing.append) && thing[toStringTag] === "FormData" && thing[iterator]);
    }
    var toJSONObject = (obj) => {
      const stack = new Array(10);
      const visit = (source, i) => {
        if (isObject(source)) {
          if (stack.indexOf(source) >= 0) {
            return;
          }
          if (!("toJSON" in source)) {
            stack[i] = source;
            const target = isArray(source) ? [] : {};
            forEach(source, (value, key) => {
              const reducedValue = visit(value, i + 1);
              !isUndefined(reducedValue) && (target[key] = reducedValue);
            });
            stack[i] = void 0;
            return target;
          }
        }
        return source;
      };
      return visit(obj, 0);
    };
    var isAsyncFn = kindOfTest("AsyncFunction");
    var isThenable = (thing) => thing && (isObject(thing) || isFunction(thing)) && isFunction(thing.then) && isFunction(thing.catch);
    var _setImmediate = ((setImmediateSupported, postMessageSupported) => {
      if (setImmediateSupported) {
        return setImmediate;
      }
      return postMessageSupported ? ((token, callbacks) => {
        _global.addEventListener("message", ({ source, data }) => {
          if (source === _global && data === token) {
            callbacks.length && callbacks.shift()();
          }
        }, false);
        return (cb) => {
          callbacks.push(cb);
          _global.postMessage(token, "*");
        };
      })(`axios@${Math.random()}`, []) : (cb) => setTimeout(cb);
    })(
      typeof setImmediate === "function",
      isFunction(_global.postMessage)
    );
    var asap = typeof queueMicrotask !== "undefined" ? queueMicrotask.bind(_global) : typeof process !== "undefined" && process.nextTick || _setImmediate;
    var isIterable = (thing) => thing != null && isFunction(thing[iterator]);
    var utils$1 = {
      isArray,
      isArrayBuffer,
      isBuffer,
      isFormData,
      isArrayBufferView,
      isString,
      isNumber,
      isBoolean,
      isObject,
      isPlainObject,
      isReadableStream,
      isRequest,
      isResponse,
      isHeaders,
      isUndefined,
      isDate,
      isFile,
      isBlob,
      isRegExp,
      isFunction,
      isStream,
      isURLSearchParams,
      isTypedArray,
      isFileList,
      forEach,
      merge,
      extend,
      trim,
      stripBOM,
      inherits,
      toFlatObject,
      kindOf,
      kindOfTest,
      endsWith,
      toArray,
      forEachEntry,
      matchAll,
      isHTMLForm,
      hasOwnProperty,
      hasOwnProp: hasOwnProperty,
      // an alias to avoid ESLint no-prototype-builtins detection
      reduceDescriptors,
      freezeMethods,
      toObjectSet,
      toCamelCase,
      noop,
      toFiniteNumber,
      findKey,
      global: _global,
      isContextDefined,
      isSpecCompliantForm,
      toJSONObject,
      isAsyncFn,
      isThenable,
      setImmediate: _setImmediate,
      asap,
      isIterable
    };
    function AxiosError(message, code, config, request, response) {
      Error.call(this);
      if (Error.captureStackTrace) {
        Error.captureStackTrace(this, this.constructor);
      } else {
        this.stack = new Error().stack;
      }
      this.message = message;
      this.name = "AxiosError";
      code && (this.code = code);
      config && (this.config = config);
      request && (this.request = request);
      if (response) {
        this.response = response;
        this.status = response.status ? response.status : null;
      }
    }
    utils$1.inherits(AxiosError, Error, {
      toJSON: function toJSON() {
        return {
          // Standard
          message: this.message,
          name: this.name,
          // Microsoft
          description: this.description,
          number: this.number,
          // Mozilla
          fileName: this.fileName,
          lineNumber: this.lineNumber,
          columnNumber: this.columnNumber,
          stack: this.stack,
          // Axios
          config: utils$1.toJSONObject(this.config),
          code: this.code,
          status: this.status
        };
      }
    });
    var prototype$1 = AxiosError.prototype;
    var descriptors = {};
    [
      "ERR_BAD_OPTION_VALUE",
      "ERR_BAD_OPTION",
      "ECONNABORTED",
      "ETIMEDOUT",
      "ERR_NETWORK",
      "ERR_FR_TOO_MANY_REDIRECTS",
      "ERR_DEPRECATED",
      "ERR_BAD_RESPONSE",
      "ERR_BAD_REQUEST",
      "ERR_CANCELED",
      "ERR_NOT_SUPPORT",
      "ERR_INVALID_URL"
      // eslint-disable-next-line func-names
    ].forEach((code) => {
      descriptors[code] = { value: code };
    });
    Object.defineProperties(AxiosError, descriptors);
    Object.defineProperty(prototype$1, "isAxiosError", { value: true });
    AxiosError.from = (error, code, config, request, response, customProps) => {
      const axiosError = Object.create(prototype$1);
      utils$1.toFlatObject(error, axiosError, function filter(obj) {
        return obj !== Error.prototype;
      }, (prop) => {
        return prop !== "isAxiosError";
      });
      AxiosError.call(axiosError, error.message, code, config, request, response);
      axiosError.cause = error;
      axiosError.name = error.name;
      customProps && Object.assign(axiosError, customProps);
      return axiosError;
    };
    var httpAdapter = null;
    function isVisitable(thing) {
      return utils$1.isPlainObject(thing) || utils$1.isArray(thing);
    }
    function removeBrackets(key) {
      return utils$1.endsWith(key, "[]") ? key.slice(0, -2) : key;
    }
    function renderKey(path, key, dots) {
      if (!path)
        return key;
      return path.concat(key).map(function each(token, i) {
        token = removeBrackets(token);
        return !dots && i ? "[" + token + "]" : token;
      }).join(dots ? "." : "");
    }
    function isFlatArray(arr) {
      return utils$1.isArray(arr) && !arr.some(isVisitable);
    }
    var predicates = utils$1.toFlatObject(utils$1, {}, null, function filter(prop) {
      return /^is[A-Z]/.test(prop);
    });
    function toFormData(obj, formData, options) {
      if (!utils$1.isObject(obj)) {
        throw new TypeError("target must be an object");
      }
      formData = formData || new FormData();
      options = utils$1.toFlatObject(options, {
        metaTokens: true,
        dots: false,
        indexes: false
      }, false, function defined(option, source) {
        return !utils$1.isUndefined(source[option]);
      });
      const metaTokens = options.metaTokens;
      const visitor = options.visitor || defaultVisitor;
      const dots = options.dots;
      const indexes = options.indexes;
      const _Blob = options.Blob || typeof Blob !== "undefined" && Blob;
      const useBlob = _Blob && utils$1.isSpecCompliantForm(formData);
      if (!utils$1.isFunction(visitor)) {
        throw new TypeError("visitor must be a function");
      }
      function convertValue(value) {
        if (value === null)
          return "";
        if (utils$1.isDate(value)) {
          return value.toISOString();
        }
        if (utils$1.isBoolean(value)) {
          return value.toString();
        }
        if (!useBlob && utils$1.isBlob(value)) {
          throw new AxiosError("Blob is not supported. Use a Buffer instead.");
        }
        if (utils$1.isArrayBuffer(value) || utils$1.isTypedArray(value)) {
          return useBlob && typeof Blob === "function" ? new Blob([value]) : Buffer.from(value);
        }
        return value;
      }
      function defaultVisitor(value, key, path) {
        let arr = value;
        if (value && !path && typeof value === "object") {
          if (utils$1.endsWith(key, "{}")) {
            key = metaTokens ? key : key.slice(0, -2);
            value = JSON.stringify(value);
          } else if (utils$1.isArray(value) && isFlatArray(value) || (utils$1.isFileList(value) || utils$1.endsWith(key, "[]")) && (arr = utils$1.toArray(value))) {
            key = removeBrackets(key);
            arr.forEach(function each(el, index) {
              !(utils$1.isUndefined(el) || el === null) && formData.append(
                // eslint-disable-next-line no-nested-ternary
                indexes === true ? renderKey([key], index, dots) : indexes === null ? key : key + "[]",
                convertValue(el)
              );
            });
            return false;
          }
        }
        if (isVisitable(value)) {
          return true;
        }
        formData.append(renderKey(path, key, dots), convertValue(value));
        return false;
      }
      const stack = [];
      const exposedHelpers = Object.assign(predicates, {
        defaultVisitor,
        convertValue,
        isVisitable
      });
      function build(value, path) {
        if (utils$1.isUndefined(value))
          return;
        if (stack.indexOf(value) !== -1) {
          throw Error("Circular reference detected in " + path.join("."));
        }
        stack.push(value);
        utils$1.forEach(value, function each(el, key) {
          const result = !(utils$1.isUndefined(el) || el === null) && visitor.call(
            formData,
            el,
            utils$1.isString(key) ? key.trim() : key,
            path,
            exposedHelpers
          );
          if (result === true) {
            build(el, path ? path.concat(key) : [key]);
          }
        });
        stack.pop();
      }
      if (!utils$1.isObject(obj)) {
        throw new TypeError("data must be an object");
      }
      build(obj);
      return formData;
    }
    function encode$1(str) {
      const charMap = {
        "!": "%21",
        "'": "%27",
        "(": "%28",
        ")": "%29",
        "~": "%7E",
        "%20": "+",
        "%00": "\0"
      };
      return encodeURIComponent(str).replace(/[!'()~]|%20|%00/g, function replacer(match) {
        return charMap[match];
      });
    }
    function AxiosURLSearchParams(params, options) {
      this._pairs = [];
      params && toFormData(params, this, options);
    }
    var prototype = AxiosURLSearchParams.prototype;
    prototype.append = function append(name, value) {
      this._pairs.push([name, value]);
    };
    prototype.toString = function toString2(encoder) {
      const _encode = encoder ? function(value) {
        return encoder.call(this, value, encode$1);
      } : encode$1;
      return this._pairs.map(function each(pair) {
        return _encode(pair[0]) + "=" + _encode(pair[1]);
      }, "").join("&");
    };
    function encode(val) {
      return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
    }
    function buildURL(url, params, options) {
      if (!params) {
        return url;
      }
      const _encode = options && options.encode || encode;
      if (utils$1.isFunction(options)) {
        options = {
          serialize: options
        };
      }
      const serializeFn = options && options.serialize;
      let serializedParams;
      if (serializeFn) {
        serializedParams = serializeFn(params, options);
      } else {
        serializedParams = utils$1.isURLSearchParams(params) ? params.toString() : new AxiosURLSearchParams(params, options).toString(_encode);
      }
      if (serializedParams) {
        const hashmarkIndex = url.indexOf("#");
        if (hashmarkIndex !== -1) {
          url = url.slice(0, hashmarkIndex);
        }
        url += (url.indexOf("?") === -1 ? "?" : "&") + serializedParams;
      }
      return url;
    }
    var InterceptorManager = class {
      constructor() {
        this.handlers = [];
      }
      /**
       * Add a new interceptor to the stack
       *
       * @param {Function} fulfilled The function to handle `then` for a `Promise`
       * @param {Function} rejected The function to handle `reject` for a `Promise`
       *
       * @return {Number} An ID used to remove interceptor later
       */
      use(fulfilled, rejected, options) {
        this.handlers.push({
          fulfilled,
          rejected,
          synchronous: options ? options.synchronous : false,
          runWhen: options ? options.runWhen : null
        });
        return this.handlers.length - 1;
      }
      /**
       * Remove an interceptor from the stack
       *
       * @param {Number} id The ID that was returned by `use`
       *
       * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
       */
      eject(id) {
        if (this.handlers[id]) {
          this.handlers[id] = null;
        }
      }
      /**
       * Clear all interceptors from the stack
       *
       * @returns {void}
       */
      clear() {
        if (this.handlers) {
          this.handlers = [];
        }
      }
      /**
       * Iterate over all the registered interceptors
       *
       * This method is particularly useful for skipping over any
       * interceptors that may have become `null` calling `eject`.
       *
       * @param {Function} fn The function to call for each interceptor
       *
       * @returns {void}
       */
      forEach(fn) {
        utils$1.forEach(this.handlers, function forEachHandler(h) {
          if (h !== null) {
            fn(h);
          }
        });
      }
    };
    var InterceptorManager$1 = InterceptorManager;
    var transitionalDefaults = {
      silentJSONParsing: true,
      forcedJSONParsing: true,
      clarifyTimeoutError: false
    };
    var URLSearchParams$1 = typeof URLSearchParams !== "undefined" ? URLSearchParams : AxiosURLSearchParams;
    var FormData$1 = typeof FormData !== "undefined" ? FormData : null;
    var Blob$1 = typeof Blob !== "undefined" ? Blob : null;
    var platform$1 = {
      isBrowser: true,
      classes: {
        URLSearchParams: URLSearchParams$1,
        FormData: FormData$1,
        Blob: Blob$1
      },
      protocols: ["http", "https", "file", "blob", "url", "data"]
    };
    var hasBrowserEnv = typeof window !== "undefined" && typeof document !== "undefined";
    var _navigator = typeof navigator === "object" && navigator || void 0;
    var hasStandardBrowserEnv = hasBrowserEnv && (!_navigator || ["ReactNative", "NativeScript", "NS"].indexOf(_navigator.product) < 0);
    var hasStandardBrowserWebWorkerEnv = (() => {
      return typeof WorkerGlobalScope !== "undefined" && // eslint-disable-next-line no-undef
      self instanceof WorkerGlobalScope && typeof self.importScripts === "function";
    })();
    var origin = hasBrowserEnv && window.location.href || "http://localhost";
    var utils = Object.freeze({
      __proto__: null,
      hasBrowserEnv,
      hasStandardBrowserWebWorkerEnv,
      hasStandardBrowserEnv,
      navigator: _navigator,
      origin
    });
    var platform = {
      ...utils,
      ...platform$1
    };
    function toURLEncodedForm(data, options) {
      return toFormData(data, new platform.classes.URLSearchParams(), Object.assign({
        visitor: function(value, key, path, helpers) {
          if (platform.isNode && utils$1.isBuffer(value)) {
            this.append(key, value.toString("base64"));
            return false;
          }
          return helpers.defaultVisitor.apply(this, arguments);
        }
      }, options));
    }
    function parsePropPath(name) {
      return utils$1.matchAll(/\w+|\[(\w*)]/g, name).map((match) => {
        return match[0] === "[]" ? "" : match[1] || match[0];
      });
    }
    function arrayToObject(arr) {
      const obj = {};
      const keys = Object.keys(arr);
      let i;
      const len = keys.length;
      let key;
      for (i = 0; i < len; i++) {
        key = keys[i];
        obj[key] = arr[key];
      }
      return obj;
    }
    function formDataToJSON(formData) {
      function buildPath(path, value, target, index) {
        let name = path[index++];
        if (name === "__proto__")
          return true;
        const isNumericKey = Number.isFinite(+name);
        const isLast = index >= path.length;
        name = !name && utils$1.isArray(target) ? target.length : name;
        if (isLast) {
          if (utils$1.hasOwnProp(target, name)) {
            target[name] = [target[name], value];
          } else {
            target[name] = value;
          }
          return !isNumericKey;
        }
        if (!target[name] || !utils$1.isObject(target[name])) {
          target[name] = [];
        }
        const result = buildPath(path, value, target[name], index);
        if (result && utils$1.isArray(target[name])) {
          target[name] = arrayToObject(target[name]);
        }
        return !isNumericKey;
      }
      if (utils$1.isFormData(formData) && utils$1.isFunction(formData.entries)) {
        const obj = {};
        utils$1.forEachEntry(formData, (name, value) => {
          buildPath(parsePropPath(name), value, obj, 0);
        });
        return obj;
      }
      return null;
    }
    function stringifySafely(rawValue, parser, encoder) {
      if (utils$1.isString(rawValue)) {
        try {
          (parser || JSON.parse)(rawValue);
          return utils$1.trim(rawValue);
        } catch (e) {
          if (e.name !== "SyntaxError") {
            throw e;
          }
        }
      }
      return (encoder || JSON.stringify)(rawValue);
    }
    var defaults = {
      transitional: transitionalDefaults,
      adapter: ["xhr", "http", "fetch"],
      transformRequest: [function transformRequest(data, headers) {
        const contentType = headers.getContentType() || "";
        const hasJSONContentType = contentType.indexOf("application/json") > -1;
        const isObjectPayload = utils$1.isObject(data);
        if (isObjectPayload && utils$1.isHTMLForm(data)) {
          data = new FormData(data);
        }
        const isFormData2 = utils$1.isFormData(data);
        if (isFormData2) {
          return hasJSONContentType ? JSON.stringify(formDataToJSON(data)) : data;
        }
        if (utils$1.isArrayBuffer(data) || utils$1.isBuffer(data) || utils$1.isStream(data) || utils$1.isFile(data) || utils$1.isBlob(data) || utils$1.isReadableStream(data)) {
          return data;
        }
        if (utils$1.isArrayBufferView(data)) {
          return data.buffer;
        }
        if (utils$1.isURLSearchParams(data)) {
          headers.setContentType("application/x-www-form-urlencoded;charset=utf-8", false);
          return data.toString();
        }
        let isFileList2;
        if (isObjectPayload) {
          if (contentType.indexOf("application/x-www-form-urlencoded") > -1) {
            return toURLEncodedForm(data, this.formSerializer).toString();
          }
          if ((isFileList2 = utils$1.isFileList(data)) || contentType.indexOf("multipart/form-data") > -1) {
            const _FormData = this.env && this.env.FormData;
            return toFormData(
              isFileList2 ? { "files[]": data } : data,
              _FormData && new _FormData(),
              this.formSerializer
            );
          }
        }
        if (isObjectPayload || hasJSONContentType) {
          headers.setContentType("application/json", false);
          return stringifySafely(data);
        }
        return data;
      }],
      transformResponse: [function transformResponse(data) {
        const transitional = this.transitional || defaults.transitional;
        const forcedJSONParsing = transitional && transitional.forcedJSONParsing;
        const JSONRequested = this.responseType === "json";
        if (utils$1.isResponse(data) || utils$1.isReadableStream(data)) {
          return data;
        }
        if (data && utils$1.isString(data) && (forcedJSONParsing && !this.responseType || JSONRequested)) {
          const silentJSONParsing = transitional && transitional.silentJSONParsing;
          const strictJSONParsing = !silentJSONParsing && JSONRequested;
          try {
            return JSON.parse(data);
          } catch (e) {
            if (strictJSONParsing) {
              if (e.name === "SyntaxError") {
                throw AxiosError.from(e, AxiosError.ERR_BAD_RESPONSE, this, null, this.response);
              }
              throw e;
            }
          }
        }
        return data;
      }],
      /**
       * A timeout in milliseconds to abort a request. If set to 0 (default) a
       * timeout is not created.
       */
      timeout: 0,
      xsrfCookieName: "XSRF-TOKEN",
      xsrfHeaderName: "X-XSRF-TOKEN",
      maxContentLength: -1,
      maxBodyLength: -1,
      env: {
        FormData: platform.classes.FormData,
        Blob: platform.classes.Blob
      },
      validateStatus: function validateStatus(status) {
        return status >= 200 && status < 300;
      },
      headers: {
        common: {
          "Accept": "application/json, text/plain, */*",
          "Content-Type": void 0
        }
      }
    };
    utils$1.forEach(["delete", "get", "head", "post", "put", "patch"], (method) => {
      defaults.headers[method] = {};
    });
    var defaults$1 = defaults;
    var ignoreDuplicateOf = utils$1.toObjectSet([
      "age",
      "authorization",
      "content-length",
      "content-type",
      "etag",
      "expires",
      "from",
      "host",
      "if-modified-since",
      "if-unmodified-since",
      "last-modified",
      "location",
      "max-forwards",
      "proxy-authorization",
      "referer",
      "retry-after",
      "user-agent"
    ]);
    var parseHeaders = (rawHeaders) => {
      const parsed = {};
      let key;
      let val;
      let i;
      rawHeaders && rawHeaders.split("\n").forEach(function parser(line) {
        i = line.indexOf(":");
        key = line.substring(0, i).trim().toLowerCase();
        val = line.substring(i + 1).trim();
        if (!key || parsed[key] && ignoreDuplicateOf[key]) {
          return;
        }
        if (key === "set-cookie") {
          if (parsed[key]) {
            parsed[key].push(val);
          } else {
            parsed[key] = [val];
          }
        } else {
          parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
        }
      });
      return parsed;
    };
    var $internals = Symbol("internals");
    function normalizeHeader(header) {
      return header && String(header).trim().toLowerCase();
    }
    function normalizeValue(value) {
      if (value === false || value == null) {
        return value;
      }
      return utils$1.isArray(value) ? value.map(normalizeValue) : String(value);
    }
    function parseTokens(str) {
      const tokens = /* @__PURE__ */ Object.create(null);
      const tokensRE = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
      let match;
      while (match = tokensRE.exec(str)) {
        tokens[match[1]] = match[2];
      }
      return tokens;
    }
    var isValidHeaderName = (str) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(str.trim());
    function matchHeaderValue(context, value, header, filter, isHeaderNameFilter) {
      if (utils$1.isFunction(filter)) {
        return filter.call(this, value, header);
      }
      if (isHeaderNameFilter) {
        value = header;
      }
      if (!utils$1.isString(value))
        return;
      if (utils$1.isString(filter)) {
        return value.indexOf(filter) !== -1;
      }
      if (utils$1.isRegExp(filter)) {
        return filter.test(value);
      }
    }
    function formatHeader(header) {
      return header.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (w, char, str) => {
        return char.toUpperCase() + str;
      });
    }
    function buildAccessors(obj, header) {
      const accessorName = utils$1.toCamelCase(" " + header);
      ["get", "set", "has"].forEach((methodName) => {
        Object.defineProperty(obj, methodName + accessorName, {
          value: function(arg1, arg2, arg3) {
            return this[methodName].call(this, header, arg1, arg2, arg3);
          },
          configurable: true
        });
      });
    }
    var AxiosHeaders = class {
      constructor(headers) {
        headers && this.set(headers);
      }
      set(header, valueOrRewrite, rewrite) {
        const self2 = this;
        function setHeader(_value, _header, _rewrite) {
          const lHeader = normalizeHeader(_header);
          if (!lHeader) {
            throw new Error("header name must be a non-empty string");
          }
          const key = utils$1.findKey(self2, lHeader);
          if (!key || self2[key] === void 0 || _rewrite === true || _rewrite === void 0 && self2[key] !== false) {
            self2[key || _header] = normalizeValue(_value);
          }
        }
        const setHeaders = (headers, _rewrite) => utils$1.forEach(headers, (_value, _header) => setHeader(_value, _header, _rewrite));
        if (utils$1.isPlainObject(header) || header instanceof this.constructor) {
          setHeaders(header, valueOrRewrite);
        } else if (utils$1.isString(header) && (header = header.trim()) && !isValidHeaderName(header)) {
          setHeaders(parseHeaders(header), valueOrRewrite);
        } else if (utils$1.isObject(header) && utils$1.isIterable(header)) {
          let obj = {}, dest, key;
          for (const entry of header) {
            if (!utils$1.isArray(entry)) {
              throw TypeError("Object iterator must return a key-value pair");
            }
            obj[key = entry[0]] = (dest = obj[key]) ? utils$1.isArray(dest) ? [...dest, entry[1]] : [dest, entry[1]] : entry[1];
          }
          setHeaders(obj, valueOrRewrite);
        } else {
          header != null && setHeader(valueOrRewrite, header, rewrite);
        }
        return this;
      }
      get(header, parser) {
        header = normalizeHeader(header);
        if (header) {
          const key = utils$1.findKey(this, header);
          if (key) {
            const value = this[key];
            if (!parser) {
              return value;
            }
            if (parser === true) {
              return parseTokens(value);
            }
            if (utils$1.isFunction(parser)) {
              return parser.call(this, value, key);
            }
            if (utils$1.isRegExp(parser)) {
              return parser.exec(value);
            }
            throw new TypeError("parser must be boolean|regexp|function");
          }
        }
      }
      has(header, matcher) {
        header = normalizeHeader(header);
        if (header) {
          const key = utils$1.findKey(this, header);
          return !!(key && this[key] !== void 0 && (!matcher || matchHeaderValue(this, this[key], key, matcher)));
        }
        return false;
      }
      delete(header, matcher) {
        const self2 = this;
        let deleted = false;
        function deleteHeader(_header) {
          _header = normalizeHeader(_header);
          if (_header) {
            const key = utils$1.findKey(self2, _header);
            if (key && (!matcher || matchHeaderValue(self2, self2[key], key, matcher))) {
              delete self2[key];
              deleted = true;
            }
          }
        }
        if (utils$1.isArray(header)) {
          header.forEach(deleteHeader);
        } else {
          deleteHeader(header);
        }
        return deleted;
      }
      clear(matcher) {
        const keys = Object.keys(this);
        let i = keys.length;
        let deleted = false;
        while (i--) {
          const key = keys[i];
          if (!matcher || matchHeaderValue(this, this[key], key, matcher, true)) {
            delete this[key];
            deleted = true;
          }
        }
        return deleted;
      }
      normalize(format) {
        const self2 = this;
        const headers = {};
        utils$1.forEach(this, (value, header) => {
          const key = utils$1.findKey(headers, header);
          if (key) {
            self2[key] = normalizeValue(value);
            delete self2[header];
            return;
          }
          const normalized = format ? formatHeader(header) : String(header).trim();
          if (normalized !== header) {
            delete self2[header];
          }
          self2[normalized] = normalizeValue(value);
          headers[normalized] = true;
        });
        return this;
      }
      concat(...targets) {
        return this.constructor.concat(this, ...targets);
      }
      toJSON(asStrings) {
        const obj = /* @__PURE__ */ Object.create(null);
        utils$1.forEach(this, (value, header) => {
          value != null && value !== false && (obj[header] = asStrings && utils$1.isArray(value) ? value.join(", ") : value);
        });
        return obj;
      }
      [Symbol.iterator]() {
        return Object.entries(this.toJSON())[Symbol.iterator]();
      }
      toString() {
        return Object.entries(this.toJSON()).map(([header, value]) => header + ": " + value).join("\n");
      }
      getSetCookie() {
        return this.get("set-cookie") || [];
      }
      get [Symbol.toStringTag]() {
        return "AxiosHeaders";
      }
      static from(thing) {
        return thing instanceof this ? thing : new this(thing);
      }
      static concat(first, ...targets) {
        const computed = new this(first);
        targets.forEach((target) => computed.set(target));
        return computed;
      }
      static accessor(header) {
        const internals = this[$internals] = this[$internals] = {
          accessors: {}
        };
        const accessors = internals.accessors;
        const prototype2 = this.prototype;
        function defineAccessor(_header) {
          const lHeader = normalizeHeader(_header);
          if (!accessors[lHeader]) {
            buildAccessors(prototype2, _header);
            accessors[lHeader] = true;
          }
        }
        utils$1.isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);
        return this;
      }
    };
    AxiosHeaders.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
    utils$1.reduceDescriptors(AxiosHeaders.prototype, ({ value }, key) => {
      let mapped = key[0].toUpperCase() + key.slice(1);
      return {
        get: () => value,
        set(headerValue) {
          this[mapped] = headerValue;
        }
      };
    });
    utils$1.freezeMethods(AxiosHeaders);
    var AxiosHeaders$1 = AxiosHeaders;
    function transformData(fns, response) {
      const config = this || defaults$1;
      const context = response || config;
      const headers = AxiosHeaders$1.from(context.headers);
      let data = context.data;
      utils$1.forEach(fns, function transform(fn) {
        data = fn.call(config, data, headers.normalize(), response ? response.status : void 0);
      });
      headers.normalize();
      return data;
    }
    function isCancel(value) {
      return !!(value && value.__CANCEL__);
    }
    function CanceledError(message, config, request) {
      AxiosError.call(this, message == null ? "canceled" : message, AxiosError.ERR_CANCELED, config, request);
      this.name = "CanceledError";
    }
    utils$1.inherits(CanceledError, AxiosError, {
      __CANCEL__: true
    });
    function settle(resolve, reject, response) {
      const validateStatus = response.config.validateStatus;
      if (!response.status || !validateStatus || validateStatus(response.status)) {
        resolve(response);
      } else {
        reject(new AxiosError(
          "Request failed with status code " + response.status,
          [AxiosError.ERR_BAD_REQUEST, AxiosError.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4],
          response.config,
          response.request,
          response
        ));
      }
    }
    function parseProtocol(url) {
      const match = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url);
      return match && match[1] || "";
    }
    function speedometer(samplesCount, min) {
      samplesCount = samplesCount || 10;
      const bytes = new Array(samplesCount);
      const timestamps = new Array(samplesCount);
      let head = 0;
      let tail = 0;
      let firstSampleTS;
      min = min !== void 0 ? min : 1e3;
      return function push(chunkLength) {
        const now = Date.now();
        const startedAt = timestamps[tail];
        if (!firstSampleTS) {
          firstSampleTS = now;
        }
        bytes[head] = chunkLength;
        timestamps[head] = now;
        let i = tail;
        let bytesCount = 0;
        while (i !== head) {
          bytesCount += bytes[i++];
          i = i % samplesCount;
        }
        head = (head + 1) % samplesCount;
        if (head === tail) {
          tail = (tail + 1) % samplesCount;
        }
        if (now - firstSampleTS < min) {
          return;
        }
        const passed = startedAt && now - startedAt;
        return passed ? Math.round(bytesCount * 1e3 / passed) : void 0;
      };
    }
    function throttle(fn, freq) {
      let timestamp = 0;
      let threshold = 1e3 / freq;
      let lastArgs;
      let timer;
      const invoke = (args, now = Date.now()) => {
        timestamp = now;
        lastArgs = null;
        if (timer) {
          clearTimeout(timer);
          timer = null;
        }
        fn.apply(null, args);
      };
      const throttled = (...args) => {
        const now = Date.now();
        const passed = now - timestamp;
        if (passed >= threshold) {
          invoke(args, now);
        } else {
          lastArgs = args;
          if (!timer) {
            timer = setTimeout(() => {
              timer = null;
              invoke(lastArgs);
            }, threshold - passed);
          }
        }
      };
      const flush = () => lastArgs && invoke(lastArgs);
      return [throttled, flush];
    }
    var progressEventReducer = (listener, isDownloadStream, freq = 3) => {
      let bytesNotified = 0;
      const _speedometer = speedometer(50, 250);
      return throttle((e) => {
        const loaded = e.loaded;
        const total = e.lengthComputable ? e.total : void 0;
        const progressBytes = loaded - bytesNotified;
        const rate = _speedometer(progressBytes);
        const inRange = loaded <= total;
        bytesNotified = loaded;
        const data = {
          loaded,
          total,
          progress: total ? loaded / total : void 0,
          bytes: progressBytes,
          rate: rate ? rate : void 0,
          estimated: rate && total && inRange ? (total - loaded) / rate : void 0,
          event: e,
          lengthComputable: total != null,
          [isDownloadStream ? "download" : "upload"]: true
        };
        listener(data);
      }, freq);
    };
    var progressEventDecorator = (total, throttled) => {
      const lengthComputable = total != null;
      return [(loaded) => throttled[0]({
        lengthComputable,
        total,
        loaded
      }), throttled[1]];
    };
    var asyncDecorator = (fn) => (...args) => utils$1.asap(() => fn(...args));
    var isURLSameOrigin = platform.hasStandardBrowserEnv ? ((origin2, isMSIE) => (url) => {
      url = new URL(url, platform.origin);
      return origin2.protocol === url.protocol && origin2.host === url.host && (isMSIE || origin2.port === url.port);
    })(
      new URL(platform.origin),
      platform.navigator && /(msie|trident)/i.test(platform.navigator.userAgent)
    ) : () => true;
    var cookies = platform.hasStandardBrowserEnv ? (
      // Standard browser envs support document.cookie
      {
        write(name, value, expires, path, domain, secure) {
          const cookie = [name + "=" + encodeURIComponent(value)];
          utils$1.isNumber(expires) && cookie.push("expires=" + new Date(expires).toGMTString());
          utils$1.isString(path) && cookie.push("path=" + path);
          utils$1.isString(domain) && cookie.push("domain=" + domain);
          secure === true && cookie.push("secure");
          document.cookie = cookie.join("; ");
        },
        read(name) {
          const match = document.cookie.match(new RegExp("(^|;\\s*)(" + name + ")=([^;]*)"));
          return match ? decodeURIComponent(match[3]) : null;
        },
        remove(name) {
          this.write(name, "", Date.now() - 864e5);
        }
      }
    ) : (
      // Non-standard browser env (web workers, react-native) lack needed support.
      {
        write() {
        },
        read() {
          return null;
        },
        remove() {
        }
      }
    );
    function isAbsoluteURL(url) {
      return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
    }
    function combineURLs(baseURL, relativeURL) {
      return relativeURL ? baseURL.replace(/\/?\/$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
    }
    function buildFullPath(baseURL, requestedURL, allowAbsoluteUrls) {
      let isRelativeUrl = !isAbsoluteURL(requestedURL);
      if (baseURL && (isRelativeUrl || allowAbsoluteUrls == false)) {
        return combineURLs(baseURL, requestedURL);
      }
      return requestedURL;
    }
    var headersToObject = (thing) => thing instanceof AxiosHeaders$1 ? { ...thing } : thing;
    function mergeConfig(config1, config2) {
      config2 = config2 || {};
      const config = {};
      function getMergedValue(target, source, prop, caseless) {
        if (utils$1.isPlainObject(target) && utils$1.isPlainObject(source)) {
          return utils$1.merge.call({ caseless }, target, source);
        } else if (utils$1.isPlainObject(source)) {
          return utils$1.merge({}, source);
        } else if (utils$1.isArray(source)) {
          return source.slice();
        }
        return source;
      }
      function mergeDeepProperties(a, b, prop, caseless) {
        if (!utils$1.isUndefined(b)) {
          return getMergedValue(a, b, prop, caseless);
        } else if (!utils$1.isUndefined(a)) {
          return getMergedValue(void 0, a, prop, caseless);
        }
      }
      function valueFromConfig2(a, b) {
        if (!utils$1.isUndefined(b)) {
          return getMergedValue(void 0, b);
        }
      }
      function defaultToConfig2(a, b) {
        if (!utils$1.isUndefined(b)) {
          return getMergedValue(void 0, b);
        } else if (!utils$1.isUndefined(a)) {
          return getMergedValue(void 0, a);
        }
      }
      function mergeDirectKeys(a, b, prop) {
        if (prop in config2) {
          return getMergedValue(a, b);
        } else if (prop in config1) {
          return getMergedValue(void 0, a);
        }
      }
      const mergeMap = {
        url: valueFromConfig2,
        method: valueFromConfig2,
        data: valueFromConfig2,
        baseURL: defaultToConfig2,
        transformRequest: defaultToConfig2,
        transformResponse: defaultToConfig2,
        paramsSerializer: defaultToConfig2,
        timeout: defaultToConfig2,
        timeoutMessage: defaultToConfig2,
        withCredentials: defaultToConfig2,
        withXSRFToken: defaultToConfig2,
        adapter: defaultToConfig2,
        responseType: defaultToConfig2,
        xsrfCookieName: defaultToConfig2,
        xsrfHeaderName: defaultToConfig2,
        onUploadProgress: defaultToConfig2,
        onDownloadProgress: defaultToConfig2,
        decompress: defaultToConfig2,
        maxContentLength: defaultToConfig2,
        maxBodyLength: defaultToConfig2,
        beforeRedirect: defaultToConfig2,
        transport: defaultToConfig2,
        httpAgent: defaultToConfig2,
        httpsAgent: defaultToConfig2,
        cancelToken: defaultToConfig2,
        socketPath: defaultToConfig2,
        responseEncoding: defaultToConfig2,
        validateStatus: mergeDirectKeys,
        headers: (a, b, prop) => mergeDeepProperties(headersToObject(a), headersToObject(b), prop, true)
      };
      utils$1.forEach(Object.keys(Object.assign({}, config1, config2)), function computeConfigValue(prop) {
        const merge2 = mergeMap[prop] || mergeDeepProperties;
        const configValue = merge2(config1[prop], config2[prop], prop);
        utils$1.isUndefined(configValue) && merge2 !== mergeDirectKeys || (config[prop] = configValue);
      });
      return config;
    }
    var resolveConfig = (config) => {
      const newConfig = mergeConfig({}, config);
      let { data, withXSRFToken, xsrfHeaderName, xsrfCookieName, headers, auth } = newConfig;
      newConfig.headers = headers = AxiosHeaders$1.from(headers);
      newConfig.url = buildURL(buildFullPath(newConfig.baseURL, newConfig.url, newConfig.allowAbsoluteUrls), config.params, config.paramsSerializer);
      if (auth) {
        headers.set(
          "Authorization",
          "Basic " + btoa((auth.username || "") + ":" + (auth.password ? unescape(encodeURIComponent(auth.password)) : ""))
        );
      }
      let contentType;
      if (utils$1.isFormData(data)) {
        if (platform.hasStandardBrowserEnv || platform.hasStandardBrowserWebWorkerEnv) {
          headers.setContentType(void 0);
        } else if ((contentType = headers.getContentType()) !== false) {
          const [type, ...tokens] = contentType ? contentType.split(";").map((token) => token.trim()).filter(Boolean) : [];
          headers.setContentType([type || "multipart/form-data", ...tokens].join("; "));
        }
      }
      if (platform.hasStandardBrowserEnv) {
        withXSRFToken && utils$1.isFunction(withXSRFToken) && (withXSRFToken = withXSRFToken(newConfig));
        if (withXSRFToken || withXSRFToken !== false && isURLSameOrigin(newConfig.url)) {
          const xsrfValue = xsrfHeaderName && xsrfCookieName && cookies.read(xsrfCookieName);
          if (xsrfValue) {
            headers.set(xsrfHeaderName, xsrfValue);
          }
        }
      }
      return newConfig;
    };
    var isXHRAdapterSupported = typeof XMLHttpRequest !== "undefined";
    var xhrAdapter = isXHRAdapterSupported && function(config) {
      return new Promise(function dispatchXhrRequest(resolve, reject) {
        const _config = resolveConfig(config);
        let requestData = _config.data;
        const requestHeaders = AxiosHeaders$1.from(_config.headers).normalize();
        let { responseType, onUploadProgress, onDownloadProgress } = _config;
        let onCanceled;
        let uploadThrottled, downloadThrottled;
        let flushUpload, flushDownload;
        function done() {
          flushUpload && flushUpload();
          flushDownload && flushDownload();
          _config.cancelToken && _config.cancelToken.unsubscribe(onCanceled);
          _config.signal && _config.signal.removeEventListener("abort", onCanceled);
        }
        let request = new XMLHttpRequest();
        request.open(_config.method.toUpperCase(), _config.url, true);
        request.timeout = _config.timeout;
        function onloadend() {
          if (!request) {
            return;
          }
          const responseHeaders = AxiosHeaders$1.from(
            "getAllResponseHeaders" in request && request.getAllResponseHeaders()
          );
          const responseData = !responseType || responseType === "text" || responseType === "json" ? request.responseText : request.response;
          const response = {
            data: responseData,
            status: request.status,
            statusText: request.statusText,
            headers: responseHeaders,
            config,
            request
          };
          settle(function _resolve(value) {
            resolve(value);
            done();
          }, function _reject(err) {
            reject(err);
            done();
          }, response);
          request = null;
        }
        if ("onloadend" in request) {
          request.onloadend = onloadend;
        } else {
          request.onreadystatechange = function handleLoad() {
            if (!request || request.readyState !== 4) {
              return;
            }
            if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf("file:") === 0)) {
              return;
            }
            setTimeout(onloadend);
          };
        }
        request.onabort = function handleAbort() {
          if (!request) {
            return;
          }
          reject(new AxiosError("Request aborted", AxiosError.ECONNABORTED, config, request));
          request = null;
        };
        request.onerror = function handleError() {
          reject(new AxiosError("Network Error", AxiosError.ERR_NETWORK, config, request));
          request = null;
        };
        request.ontimeout = function handleTimeout() {
          let timeoutErrorMessage = _config.timeout ? "timeout of " + _config.timeout + "ms exceeded" : "timeout exceeded";
          const transitional = _config.transitional || transitionalDefaults;
          if (_config.timeoutErrorMessage) {
            timeoutErrorMessage = _config.timeoutErrorMessage;
          }
          reject(new AxiosError(
            timeoutErrorMessage,
            transitional.clarifyTimeoutError ? AxiosError.ETIMEDOUT : AxiosError.ECONNABORTED,
            config,
            request
          ));
          request = null;
        };
        requestData === void 0 && requestHeaders.setContentType(null);
        if ("setRequestHeader" in request) {
          utils$1.forEach(requestHeaders.toJSON(), function setRequestHeader(val, key) {
            request.setRequestHeader(key, val);
          });
        }
        if (!utils$1.isUndefined(_config.withCredentials)) {
          request.withCredentials = !!_config.withCredentials;
        }
        if (responseType && responseType !== "json") {
          request.responseType = _config.responseType;
        }
        if (onDownloadProgress) {
          [downloadThrottled, flushDownload] = progressEventReducer(onDownloadProgress, true);
          request.addEventListener("progress", downloadThrottled);
        }
        if (onUploadProgress && request.upload) {
          [uploadThrottled, flushUpload] = progressEventReducer(onUploadProgress);
          request.upload.addEventListener("progress", uploadThrottled);
          request.upload.addEventListener("loadend", flushUpload);
        }
        if (_config.cancelToken || _config.signal) {
          onCanceled = (cancel) => {
            if (!request) {
              return;
            }
            reject(!cancel || cancel.type ? new CanceledError(null, config, request) : cancel);
            request.abort();
            request = null;
          };
          _config.cancelToken && _config.cancelToken.subscribe(onCanceled);
          if (_config.signal) {
            _config.signal.aborted ? onCanceled() : _config.signal.addEventListener("abort", onCanceled);
          }
        }
        const protocol = parseProtocol(_config.url);
        if (protocol && platform.protocols.indexOf(protocol) === -1) {
          reject(new AxiosError("Unsupported protocol " + protocol + ":", AxiosError.ERR_BAD_REQUEST, config));
          return;
        }
        request.send(requestData || null);
      });
    };
    var composeSignals = (signals, timeout) => {
      const { length } = signals = signals ? signals.filter(Boolean) : [];
      if (timeout || length) {
        let controller = new AbortController();
        let aborted;
        const onabort = function(reason) {
          if (!aborted) {
            aborted = true;
            unsubscribe();
            const err = reason instanceof Error ? reason : this.reason;
            controller.abort(err instanceof AxiosError ? err : new CanceledError(err instanceof Error ? err.message : err));
          }
        };
        let timer = timeout && setTimeout(() => {
          timer = null;
          onabort(new AxiosError(`timeout ${timeout} of ms exceeded`, AxiosError.ETIMEDOUT));
        }, timeout);
        const unsubscribe = () => {
          if (signals) {
            timer && clearTimeout(timer);
            timer = null;
            signals.forEach((signal2) => {
              signal2.unsubscribe ? signal2.unsubscribe(onabort) : signal2.removeEventListener("abort", onabort);
            });
            signals = null;
          }
        };
        signals.forEach((signal2) => signal2.addEventListener("abort", onabort));
        const { signal } = controller;
        signal.unsubscribe = () => utils$1.asap(unsubscribe);
        return signal;
      }
    };
    var composeSignals$1 = composeSignals;
    var streamChunk = function* (chunk, chunkSize) {
      let len = chunk.byteLength;
      if (!chunkSize || len < chunkSize) {
        yield chunk;
        return;
      }
      let pos = 0;
      let end;
      while (pos < len) {
        end = pos + chunkSize;
        yield chunk.slice(pos, end);
        pos = end;
      }
    };
    var readBytes = async function* (iterable, chunkSize) {
      for await (const chunk of readStream(iterable)) {
        yield* streamChunk(chunk, chunkSize);
      }
    };
    var readStream = async function* (stream) {
      if (stream[Symbol.asyncIterator]) {
        yield* stream;
        return;
      }
      const reader = stream.getReader();
      try {
        for (; ; ) {
          const { done, value } = await reader.read();
          if (done) {
            break;
          }
          yield value;
        }
      } finally {
        await reader.cancel();
      }
    };
    var trackStream = (stream, chunkSize, onProgress, onFinish) => {
      const iterator2 = readBytes(stream, chunkSize);
      let bytes = 0;
      let done;
      let _onFinish = (e) => {
        if (!done) {
          done = true;
          onFinish && onFinish(e);
        }
      };
      return new ReadableStream({
        async pull(controller) {
          try {
            const { done: done2, value } = await iterator2.next();
            if (done2) {
              _onFinish();
              controller.close();
              return;
            }
            let len = value.byteLength;
            if (onProgress) {
              let loadedBytes = bytes += len;
              onProgress(loadedBytes);
            }
            controller.enqueue(new Uint8Array(value));
          } catch (err) {
            _onFinish(err);
            throw err;
          }
        },
        cancel(reason) {
          _onFinish(reason);
          return iterator2.return();
        }
      }, {
        highWaterMark: 2
      });
    };
    var isFetchSupported = typeof fetch === "function" && typeof Request === "function" && typeof Response === "function";
    var isReadableStreamSupported = isFetchSupported && typeof ReadableStream === "function";
    var encodeText = isFetchSupported && (typeof TextEncoder === "function" ? ((encoder) => (str) => encoder.encode(str))(new TextEncoder()) : async (str) => new Uint8Array(await new Response(str).arrayBuffer()));
    var test = (fn, ...args) => {
      try {
        return !!fn(...args);
      } catch (e) {
        return false;
      }
    };
    var supportsRequestStream = isReadableStreamSupported && test(() => {
      let duplexAccessed = false;
      const hasContentType = new Request(platform.origin, {
        body: new ReadableStream(),
        method: "POST",
        get duplex() {
          duplexAccessed = true;
          return "half";
        }
      }).headers.has("Content-Type");
      return duplexAccessed && !hasContentType;
    });
    var DEFAULT_CHUNK_SIZE = 64 * 1024;
    var supportsResponseStream = isReadableStreamSupported && test(() => utils$1.isReadableStream(new Response("").body));
    var resolvers = {
      stream: supportsResponseStream && ((res) => res.body)
    };
    isFetchSupported && ((res) => {
      ["text", "arrayBuffer", "blob", "formData", "stream"].forEach((type) => {
        !resolvers[type] && (resolvers[type] = utils$1.isFunction(res[type]) ? (res2) => res2[type]() : (_, config) => {
          throw new AxiosError(`Response type '${type}' is not supported`, AxiosError.ERR_NOT_SUPPORT, config);
        });
      });
    })(new Response());
    var getBodyLength = async (body) => {
      if (body == null) {
        return 0;
      }
      if (utils$1.isBlob(body)) {
        return body.size;
      }
      if (utils$1.isSpecCompliantForm(body)) {
        const _request = new Request(platform.origin, {
          method: "POST",
          body
        });
        return (await _request.arrayBuffer()).byteLength;
      }
      if (utils$1.isArrayBufferView(body) || utils$1.isArrayBuffer(body)) {
        return body.byteLength;
      }
      if (utils$1.isURLSearchParams(body)) {
        body = body + "";
      }
      if (utils$1.isString(body)) {
        return (await encodeText(body)).byteLength;
      }
    };
    var resolveBodyLength = async (headers, body) => {
      const length = utils$1.toFiniteNumber(headers.getContentLength());
      return length == null ? getBodyLength(body) : length;
    };
    var fetchAdapter = isFetchSupported && (async (config) => {
      let {
        url,
        method,
        data,
        signal,
        cancelToken,
        timeout,
        onDownloadProgress,
        onUploadProgress,
        responseType,
        headers,
        withCredentials = "same-origin",
        fetchOptions
      } = resolveConfig(config);
      responseType = responseType ? (responseType + "").toLowerCase() : "text";
      let composedSignal = composeSignals$1([signal, cancelToken && cancelToken.toAbortSignal()], timeout);
      let request;
      const unsubscribe = composedSignal && composedSignal.unsubscribe && (() => {
        composedSignal.unsubscribe();
      });
      let requestContentLength;
      try {
        if (onUploadProgress && supportsRequestStream && method !== "get" && method !== "head" && (requestContentLength = await resolveBodyLength(headers, data)) !== 0) {
          let _request = new Request(url, {
            method: "POST",
            body: data,
            duplex: "half"
          });
          let contentTypeHeader;
          if (utils$1.isFormData(data) && (contentTypeHeader = _request.headers.get("content-type"))) {
            headers.setContentType(contentTypeHeader);
          }
          if (_request.body) {
            const [onProgress, flush] = progressEventDecorator(
              requestContentLength,
              progressEventReducer(asyncDecorator(onUploadProgress))
            );
            data = trackStream(_request.body, DEFAULT_CHUNK_SIZE, onProgress, flush);
          }
        }
        if (!utils$1.isString(withCredentials)) {
          withCredentials = withCredentials ? "include" : "omit";
        }
        const isCredentialsSupported = "credentials" in Request.prototype;
        request = new Request(url, {
          ...fetchOptions,
          signal: composedSignal,
          method: method.toUpperCase(),
          headers: headers.normalize().toJSON(),
          body: data,
          duplex: "half",
          credentials: isCredentialsSupported ? withCredentials : void 0
        });
        let response = await fetch(request, fetchOptions);
        const isStreamResponse = supportsResponseStream && (responseType === "stream" || responseType === "response");
        if (supportsResponseStream && (onDownloadProgress || isStreamResponse && unsubscribe)) {
          const options = {};
          ["status", "statusText", "headers"].forEach((prop) => {
            options[prop] = response[prop];
          });
          const responseContentLength = utils$1.toFiniteNumber(response.headers.get("content-length"));
          const [onProgress, flush] = onDownloadProgress && progressEventDecorator(
            responseContentLength,
            progressEventReducer(asyncDecorator(onDownloadProgress), true)
          ) || [];
          response = new Response(
            trackStream(response.body, DEFAULT_CHUNK_SIZE, onProgress, () => {
              flush && flush();
              unsubscribe && unsubscribe();
            }),
            options
          );
        }
        responseType = responseType || "text";
        let responseData = await resolvers[utils$1.findKey(resolvers, responseType) || "text"](response, config);
        !isStreamResponse && unsubscribe && unsubscribe();
        return await new Promise((resolve, reject) => {
          settle(resolve, reject, {
            data: responseData,
            headers: AxiosHeaders$1.from(response.headers),
            status: response.status,
            statusText: response.statusText,
            config,
            request
          });
        });
      } catch (err) {
        unsubscribe && unsubscribe();
        if (err && err.name === "TypeError" && /Load failed|fetch/i.test(err.message)) {
          throw Object.assign(
            new AxiosError("Network Error", AxiosError.ERR_NETWORK, config, request),
            {
              cause: err.cause || err
            }
          );
        }
        throw AxiosError.from(err, err && err.code, config, request);
      }
    });
    var knownAdapters = {
      http: httpAdapter,
      xhr: xhrAdapter,
      fetch: fetchAdapter
    };
    utils$1.forEach(knownAdapters, (fn, value) => {
      if (fn) {
        try {
          Object.defineProperty(fn, "name", { value });
        } catch (e) {
        }
        Object.defineProperty(fn, "adapterName", { value });
      }
    });
    var renderReason = (reason) => `- ${reason}`;
    var isResolvedHandle = (adapter) => utils$1.isFunction(adapter) || adapter === null || adapter === false;
    var adapters = {
      getAdapter: (adapters2) => {
        adapters2 = utils$1.isArray(adapters2) ? adapters2 : [adapters2];
        const { length } = adapters2;
        let nameOrAdapter;
        let adapter;
        const rejectedReasons = {};
        for (let i = 0; i < length; i++) {
          nameOrAdapter = adapters2[i];
          let id;
          adapter = nameOrAdapter;
          if (!isResolvedHandle(nameOrAdapter)) {
            adapter = knownAdapters[(id = String(nameOrAdapter)).toLowerCase()];
            if (adapter === void 0) {
              throw new AxiosError(`Unknown adapter '${id}'`);
            }
          }
          if (adapter) {
            break;
          }
          rejectedReasons[id || "#" + i] = adapter;
        }
        if (!adapter) {
          const reasons = Object.entries(rejectedReasons).map(
            ([id, state]) => `adapter ${id} ` + (state === false ? "is not supported by the environment" : "is not available in the build")
          );
          let s = length ? reasons.length > 1 ? "since :\n" + reasons.map(renderReason).join("\n") : " " + renderReason(reasons[0]) : "as no adapter specified";
          throw new AxiosError(
            `There is no suitable adapter to dispatch the request ` + s,
            "ERR_NOT_SUPPORT"
          );
        }
        return adapter;
      },
      adapters: knownAdapters
    };
    function throwIfCancellationRequested(config) {
      if (config.cancelToken) {
        config.cancelToken.throwIfRequested();
      }
      if (config.signal && config.signal.aborted) {
        throw new CanceledError(null, config);
      }
    }
    function dispatchRequest(config) {
      throwIfCancellationRequested(config);
      config.headers = AxiosHeaders$1.from(config.headers);
      config.data = transformData.call(
        config,
        config.transformRequest
      );
      if (["post", "put", "patch"].indexOf(config.method) !== -1) {
        config.headers.setContentType("application/x-www-form-urlencoded", false);
      }
      const adapter = adapters.getAdapter(config.adapter || defaults$1.adapter);
      return adapter(config).then(function onAdapterResolution(response) {
        throwIfCancellationRequested(config);
        response.data = transformData.call(
          config,
          config.transformResponse,
          response
        );
        response.headers = AxiosHeaders$1.from(response.headers);
        return response;
      }, function onAdapterRejection(reason) {
        if (!isCancel(reason)) {
          throwIfCancellationRequested(config);
          if (reason && reason.response) {
            reason.response.data = transformData.call(
              config,
              config.transformResponse,
              reason.response
            );
            reason.response.headers = AxiosHeaders$1.from(reason.response.headers);
          }
        }
        return Promise.reject(reason);
      });
    }
    var VERSION = "1.10.0";
    var validators$1 = {};
    ["object", "boolean", "number", "function", "string", "symbol"].forEach((type, i) => {
      validators$1[type] = function validator2(thing) {
        return typeof thing === type || "a" + (i < 1 ? "n " : " ") + type;
      };
    });
    var deprecatedWarnings = {};
    validators$1.transitional = function transitional(validator2, version, message) {
      function formatMessage(opt, desc) {
        return "[Axios v" + VERSION + "] Transitional option '" + opt + "'" + desc + (message ? ". " + message : "");
      }
      return (value, opt, opts) => {
        if (validator2 === false) {
          throw new AxiosError(
            formatMessage(opt, " has been removed" + (version ? " in " + version : "")),
            AxiosError.ERR_DEPRECATED
          );
        }
        if (version && !deprecatedWarnings[opt]) {
          deprecatedWarnings[opt] = true;
          console.warn(
            formatMessage(
              opt,
              " has been deprecated since v" + version + " and will be removed in the near future"
            )
          );
        }
        return validator2 ? validator2(value, opt, opts) : true;
      };
    };
    validators$1.spelling = function spelling(correctSpelling) {
      return (value, opt) => {
        console.warn(`${opt} is likely a misspelling of ${correctSpelling}`);
        return true;
      };
    };
    function assertOptions(options, schema, allowUnknown) {
      if (typeof options !== "object") {
        throw new AxiosError("options must be an object", AxiosError.ERR_BAD_OPTION_VALUE);
      }
      const keys = Object.keys(options);
      let i = keys.length;
      while (i-- > 0) {
        const opt = keys[i];
        const validator2 = schema[opt];
        if (validator2) {
          const value = options[opt];
          const result = value === void 0 || validator2(value, opt, options);
          if (result !== true) {
            throw new AxiosError("option " + opt + " must be " + result, AxiosError.ERR_BAD_OPTION_VALUE);
          }
          continue;
        }
        if (allowUnknown !== true) {
          throw new AxiosError("Unknown option " + opt, AxiosError.ERR_BAD_OPTION);
        }
      }
    }
    var validator = {
      assertOptions,
      validators: validators$1
    };
    var validators = validator.validators;
    var Axios = class {
      constructor(instanceConfig) {
        this.defaults = instanceConfig || {};
        this.interceptors = {
          request: new InterceptorManager$1(),
          response: new InterceptorManager$1()
        };
      }
      /**
       * Dispatch a request
       *
       * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
       * @param {?Object} config
       *
       * @returns {Promise} The Promise to be fulfilled
       */
      async request(configOrUrl, config) {
        try {
          return await this._request(configOrUrl, config);
        } catch (err) {
          if (err instanceof Error) {
            let dummy = {};
            Error.captureStackTrace ? Error.captureStackTrace(dummy) : dummy = new Error();
            const stack = dummy.stack ? dummy.stack.replace(/^.+\n/, "") : "";
            try {
              if (!err.stack) {
                err.stack = stack;
              } else if (stack && !String(err.stack).endsWith(stack.replace(/^.+\n.+\n/, ""))) {
                err.stack += "\n" + stack;
              }
            } catch (e) {
            }
          }
          throw err;
        }
      }
      _request(configOrUrl, config) {
        if (typeof configOrUrl === "string") {
          config = config || {};
          config.url = configOrUrl;
        } else {
          config = configOrUrl || {};
        }
        config = mergeConfig(this.defaults, config);
        const { transitional, paramsSerializer, headers } = config;
        if (transitional !== void 0) {
          validator.assertOptions(transitional, {
            silentJSONParsing: validators.transitional(validators.boolean),
            forcedJSONParsing: validators.transitional(validators.boolean),
            clarifyTimeoutError: validators.transitional(validators.boolean)
          }, false);
        }
        if (paramsSerializer != null) {
          if (utils$1.isFunction(paramsSerializer)) {
            config.paramsSerializer = {
              serialize: paramsSerializer
            };
          } else {
            validator.assertOptions(paramsSerializer, {
              encode: validators.function,
              serialize: validators.function
            }, true);
          }
        }
        if (config.allowAbsoluteUrls !== void 0)
          ;
        else if (this.defaults.allowAbsoluteUrls !== void 0) {
          config.allowAbsoluteUrls = this.defaults.allowAbsoluteUrls;
        } else {
          config.allowAbsoluteUrls = true;
        }
        validator.assertOptions(config, {
          baseUrl: validators.spelling("baseURL"),
          withXsrfToken: validators.spelling("withXSRFToken")
        }, true);
        config.method = (config.method || this.defaults.method || "get").toLowerCase();
        let contextHeaders = headers && utils$1.merge(
          headers.common,
          headers[config.method]
        );
        headers && utils$1.forEach(
          ["delete", "get", "head", "post", "put", "patch", "common"],
          (method) => {
            delete headers[method];
          }
        );
        config.headers = AxiosHeaders$1.concat(contextHeaders, headers);
        const requestInterceptorChain = [];
        let synchronousRequestInterceptors = true;
        this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
          if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config) === false) {
            return;
          }
          synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
          requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
        });
        const responseInterceptorChain = [];
        this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
          responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
        });
        let promise;
        let i = 0;
        let len;
        if (!synchronousRequestInterceptors) {
          const chain = [dispatchRequest.bind(this), void 0];
          chain.unshift.apply(chain, requestInterceptorChain);
          chain.push.apply(chain, responseInterceptorChain);
          len = chain.length;
          promise = Promise.resolve(config);
          while (i < len) {
            promise = promise.then(chain[i++], chain[i++]);
          }
          return promise;
        }
        len = requestInterceptorChain.length;
        let newConfig = config;
        i = 0;
        while (i < len) {
          const onFulfilled = requestInterceptorChain[i++];
          const onRejected = requestInterceptorChain[i++];
          try {
            newConfig = onFulfilled(newConfig);
          } catch (error) {
            onRejected.call(this, error);
            break;
          }
        }
        try {
          promise = dispatchRequest.call(this, newConfig);
        } catch (error) {
          return Promise.reject(error);
        }
        i = 0;
        len = responseInterceptorChain.length;
        while (i < len) {
          promise = promise.then(responseInterceptorChain[i++], responseInterceptorChain[i++]);
        }
        return promise;
      }
      getUri(config) {
        config = mergeConfig(this.defaults, config);
        const fullPath = buildFullPath(config.baseURL, config.url, config.allowAbsoluteUrls);
        return buildURL(fullPath, config.params, config.paramsSerializer);
      }
    };
    utils$1.forEach(["delete", "get", "head", "options"], function forEachMethodNoData(method) {
      Axios.prototype[method] = function(url, config) {
        return this.request(mergeConfig(config || {}, {
          method,
          url,
          data: (config || {}).data
        }));
      };
    });
    utils$1.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
      function generateHTTPMethod(isForm) {
        return function httpMethod(url, data, config) {
          return this.request(mergeConfig(config || {}, {
            method,
            headers: isForm ? {
              "Content-Type": "multipart/form-data"
            } : {},
            url,
            data
          }));
        };
      }
      Axios.prototype[method] = generateHTTPMethod();
      Axios.prototype[method + "Form"] = generateHTTPMethod(true);
    });
    var Axios$1 = Axios;
    var CancelToken = class _CancelToken {
      constructor(executor) {
        if (typeof executor !== "function") {
          throw new TypeError("executor must be a function.");
        }
        let resolvePromise;
        this.promise = new Promise(function promiseExecutor(resolve) {
          resolvePromise = resolve;
        });
        const token = this;
        this.promise.then((cancel) => {
          if (!token._listeners)
            return;
          let i = token._listeners.length;
          while (i-- > 0) {
            token._listeners[i](cancel);
          }
          token._listeners = null;
        });
        this.promise.then = (onfulfilled) => {
          let _resolve;
          const promise = new Promise((resolve) => {
            token.subscribe(resolve);
            _resolve = resolve;
          }).then(onfulfilled);
          promise.cancel = function reject() {
            token.unsubscribe(_resolve);
          };
          return promise;
        };
        executor(function cancel(message, config, request) {
          if (token.reason) {
            return;
          }
          token.reason = new CanceledError(message, config, request);
          resolvePromise(token.reason);
        });
      }
      /**
       * Throws a `CanceledError` if cancellation has been requested.
       */
      throwIfRequested() {
        if (this.reason) {
          throw this.reason;
        }
      }
      /**
       * Subscribe to the cancel signal
       */
      subscribe(listener) {
        if (this.reason) {
          listener(this.reason);
          return;
        }
        if (this._listeners) {
          this._listeners.push(listener);
        } else {
          this._listeners = [listener];
        }
      }
      /**
       * Unsubscribe from the cancel signal
       */
      unsubscribe(listener) {
        if (!this._listeners) {
          return;
        }
        const index = this._listeners.indexOf(listener);
        if (index !== -1) {
          this._listeners.splice(index, 1);
        }
      }
      toAbortSignal() {
        const controller = new AbortController();
        const abort = (err) => {
          controller.abort(err);
        };
        this.subscribe(abort);
        controller.signal.unsubscribe = () => this.unsubscribe(abort);
        return controller.signal;
      }
      /**
       * Returns an object that contains a new `CancelToken` and a function that, when called,
       * cancels the `CancelToken`.
       */
      static source() {
        let cancel;
        const token = new _CancelToken(function executor(c) {
          cancel = c;
        });
        return {
          token,
          cancel
        };
      }
    };
    var CancelToken$1 = CancelToken;
    function spread(callback) {
      return function wrap(arr) {
        return callback.apply(null, arr);
      };
    }
    function isAxiosError(payload) {
      return utils$1.isObject(payload) && payload.isAxiosError === true;
    }
    var HttpStatusCode = {
      Continue: 100,
      SwitchingProtocols: 101,
      Processing: 102,
      EarlyHints: 103,
      Ok: 200,
      Created: 201,
      Accepted: 202,
      NonAuthoritativeInformation: 203,
      NoContent: 204,
      ResetContent: 205,
      PartialContent: 206,
      MultiStatus: 207,
      AlreadyReported: 208,
      ImUsed: 226,
      MultipleChoices: 300,
      MovedPermanently: 301,
      Found: 302,
      SeeOther: 303,
      NotModified: 304,
      UseProxy: 305,
      Unused: 306,
      TemporaryRedirect: 307,
      PermanentRedirect: 308,
      BadRequest: 400,
      Unauthorized: 401,
      PaymentRequired: 402,
      Forbidden: 403,
      NotFound: 404,
      MethodNotAllowed: 405,
      NotAcceptable: 406,
      ProxyAuthenticationRequired: 407,
      RequestTimeout: 408,
      Conflict: 409,
      Gone: 410,
      LengthRequired: 411,
      PreconditionFailed: 412,
      PayloadTooLarge: 413,
      UriTooLong: 414,
      UnsupportedMediaType: 415,
      RangeNotSatisfiable: 416,
      ExpectationFailed: 417,
      ImATeapot: 418,
      MisdirectedRequest: 421,
      UnprocessableEntity: 422,
      Locked: 423,
      FailedDependency: 424,
      TooEarly: 425,
      UpgradeRequired: 426,
      PreconditionRequired: 428,
      TooManyRequests: 429,
      RequestHeaderFieldsTooLarge: 431,
      UnavailableForLegalReasons: 451,
      InternalServerError: 500,
      NotImplemented: 501,
      BadGateway: 502,
      ServiceUnavailable: 503,
      GatewayTimeout: 504,
      HttpVersionNotSupported: 505,
      VariantAlsoNegotiates: 506,
      InsufficientStorage: 507,
      LoopDetected: 508,
      NotExtended: 510,
      NetworkAuthenticationRequired: 511
    };
    Object.entries(HttpStatusCode).forEach(([key, value]) => {
      HttpStatusCode[value] = key;
    });
    var HttpStatusCode$1 = HttpStatusCode;
    function createInstance(defaultConfig) {
      const context = new Axios$1(defaultConfig);
      const instance = bind(Axios$1.prototype.request, context);
      utils$1.extend(instance, Axios$1.prototype, context, { allOwnKeys: true });
      utils$1.extend(instance, context, null, { allOwnKeys: true });
      instance.create = function create(instanceConfig) {
        return createInstance(mergeConfig(defaultConfig, instanceConfig));
      };
      return instance;
    }
    var axios = createInstance(defaults$1);
    axios.Axios = Axios$1;
    axios.CanceledError = CanceledError;
    axios.CancelToken = CancelToken$1;
    axios.isCancel = isCancel;
    axios.VERSION = VERSION;
    axios.toFormData = toFormData;
    axios.AxiosError = AxiosError;
    axios.Cancel = axios.CanceledError;
    axios.all = function all(promises) {
      return Promise.all(promises);
    };
    axios.spread = spread;
    axios.isAxiosError = isAxiosError;
    axios.mergeConfig = mergeConfig;
    axios.AxiosHeaders = AxiosHeaders$1;
    axios.formToJSON = (thing) => formDataToJSON(utils$1.isHTMLForm(thing) ? new FormData(thing) : thing);
    axios.getAdapter = adapters.getAdapter;
    axios.HttpStatusCode = HttpStatusCode$1;
    axios.default = axios;
    module.exports = axios;
  }
});

// ../../node_modules/.pnpm/@cosmjs+tendermint-rpc@0.32.4/node_modules/@cosmjs/tendermint-rpc/build/rpcclients/http.js
var require_http = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+tendermint-rpc@0.32.4/node_modules/@cosmjs/tendermint-rpc/build/rpcclients/http.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.http = void 0;
    var axios_1 = __importDefault(require_axios());
    function filterBadStatus(res) {
      if (res.status >= 400) {
        throw new Error(`Bad status on response: ${res.status}`);
      }
      return res;
    }
    function isExperimental(nodeJsFunc) {
      return nodeJsFunc.toString().includes("emitExperimentalWarning");
    }
    async function http(method, url, headers, request) {
      if (typeof fetch === "function" && !isExperimental(fetch)) {
        const settings = {
          method,
          body: request ? JSON.stringify(request) : void 0,
          headers: {
            // eslint-disable-next-line @typescript-eslint/naming-convention
            "Content-Type": "application/json",
            ...headers
          }
        };
        return fetch(url, settings).then(filterBadStatus).then((res) => res.json());
      } else {
        return axios_1.default.request({ url, method, data: request, headers }).then((res) => res.data);
      }
    }
    exports.http = http;
  }
});

// ../../node_modules/.pnpm/@cosmjs+tendermint-rpc@0.32.4/node_modules/@cosmjs/tendermint-rpc/build/rpcclients/rpcclient.js
var require_rpcclient = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+tendermint-rpc@0.32.4/node_modules/@cosmjs/tendermint-rpc/build/rpcclients/rpcclient.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.hasProtocol = exports.instanceOfRpcStreamingClient = void 0;
    function instanceOfRpcStreamingClient(client) {
      return typeof client.listen === "function";
    }
    exports.instanceOfRpcStreamingClient = instanceOfRpcStreamingClient;
    function hasProtocol(url) {
      return url.search("://") !== -1;
    }
    exports.hasProtocol = hasProtocol;
  }
});

// ../../node_modules/.pnpm/@cosmjs+tendermint-rpc@0.32.4/node_modules/@cosmjs/tendermint-rpc/build/rpcclients/httpbatchclient.js
var require_httpbatchclient = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+tendermint-rpc@0.32.4/node_modules/@cosmjs/tendermint-rpc/build/rpcclients/httpbatchclient.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.HttpBatchClient = void 0;
    var json_rpc_1 = require_build9();
    var http_1 = require_http();
    var rpcclient_1 = require_rpcclient();
    var defaultHttpBatchClientOptions = {
      dispatchInterval: 20,
      batchSizeLimit: 20
    };
    var HttpBatchClient = class {
      constructor(endpoint, options = {}) {
        this.queue = [];
        this.options = {
          batchSizeLimit: options.batchSizeLimit ?? defaultHttpBatchClientOptions.batchSizeLimit,
          dispatchInterval: options.dispatchInterval ?? defaultHttpBatchClientOptions.dispatchInterval
        };
        if (typeof endpoint === "string") {
          if (!(0, rpcclient_1.hasProtocol)(endpoint)) {
            throw new Error("Endpoint URL is missing a protocol. Expected 'https://' or 'http://'.");
          }
          this.url = endpoint;
        } else {
          this.url = endpoint.url;
          this.headers = endpoint.headers;
        }
        this.timer = setInterval(() => this.tick(), options.dispatchInterval);
        this.validate();
      }
      disconnect() {
        this.timer && clearInterval(this.timer);
        this.timer = void 0;
      }
      async execute(request) {
        return new Promise((resolve, reject) => {
          this.queue.push({ request, resolve, reject });
          if (this.queue.length >= this.options.batchSizeLimit) {
            this.tick();
          }
        });
      }
      validate() {
        if (!this.options.batchSizeLimit || !Number.isSafeInteger(this.options.batchSizeLimit) || this.options.batchSizeLimit < 1) {
          throw new Error("batchSizeLimit must be a safe integer >= 1");
        }
      }
      /**
       * This is called in an interval where promise rejections cannot be handled.
       * So this is not async and HTTP errors need to be handled by the queued promises.
       */
      tick() {
        const batch = this.queue.splice(0, this.options.batchSizeLimit);
        if (!batch.length)
          return;
        const requests = batch.map((s) => s.request);
        const requestIds = requests.map((request) => request.id);
        (0, http_1.http)("POST", this.url, this.headers, requests).then((raw) => {
          const arr = Array.isArray(raw) ? raw : [raw];
          arr.forEach((el) => {
            const req = batch.find((s) => s.request.id === el.id);
            if (!req)
              return;
            const { reject, resolve } = req;
            const response = (0, json_rpc_1.parseJsonRpcResponse)(el);
            if ((0, json_rpc_1.isJsonRpcErrorResponse)(response)) {
              reject(new Error(JSON.stringify(response.error)));
            } else {
              resolve(response);
            }
          });
        }, (error) => {
          for (const requestId of requestIds) {
            const req = batch.find((s) => s.request.id === requestId);
            if (!req)
              return;
            req.reject(error);
          }
        });
      }
    };
    exports.HttpBatchClient = HttpBatchClient;
  }
});

// ../../node_modules/.pnpm/@cosmjs+tendermint-rpc@0.32.4/node_modules/@cosmjs/tendermint-rpc/build/rpcclients/httpclient.js
var require_httpclient = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+tendermint-rpc@0.32.4/node_modules/@cosmjs/tendermint-rpc/build/rpcclients/httpclient.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.HttpClient = void 0;
    var json_rpc_1 = require_build9();
    var http_1 = require_http();
    var rpcclient_1 = require_rpcclient();
    var HttpClient = class {
      constructor(endpoint) {
        if (typeof endpoint === "string") {
          if (!(0, rpcclient_1.hasProtocol)(endpoint)) {
            throw new Error("Endpoint URL is missing a protocol. Expected 'https://' or 'http://'.");
          }
          this.url = endpoint;
        } else {
          this.url = endpoint.url;
          this.headers = endpoint.headers;
        }
      }
      disconnect() {
      }
      async execute(request) {
        const response = (0, json_rpc_1.parseJsonRpcResponse)(await (0, http_1.http)("POST", this.url, this.headers, request));
        if ((0, json_rpc_1.isJsonRpcErrorResponse)(response)) {
          throw new Error(JSON.stringify(response.error));
        }
        return response;
      }
    };
    exports.HttpClient = HttpClient;
  }
});

// ../../node_modules/.pnpm/@cosmjs+socket@0.32.4/node_modules/@cosmjs/socket/build/socketwrapper.js
var require_socketwrapper = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+socket@0.32.4/node_modules/@cosmjs/socket/build/socketwrapper.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SocketWrapper = void 0;
    var isomorphic_ws_1 = __importDefault(require_browser());
    function environmentIsNodeJs() {
      return typeof process !== "undefined" && typeof process.versions !== "undefined" && typeof process.versions.node !== "undefined";
    }
    var SocketWrapper = class {
      constructor(url, messageHandler, errorHandler, openHandler, closeHandler, timeout = 1e4) {
        this.closed = false;
        this.connected = new Promise((resolve, reject) => {
          this.connectedResolver = resolve;
          this.connectedRejecter = reject;
        });
        this.url = url;
        this.messageHandler = messageHandler;
        this.errorHandler = errorHandler;
        this.openHandler = openHandler;
        this.closeHandler = closeHandler;
        this.timeout = timeout;
      }
      /**
       * returns a promise that resolves when connection is open
       */
      connect() {
        const socket = new isomorphic_ws_1.default(this.url);
        socket.onerror = (error) => {
          this.clearTimeout();
          if (this.errorHandler) {
            this.errorHandler(error);
          }
        };
        socket.onmessage = (messageEvent) => {
          this.messageHandler({
            type: messageEvent.type,
            data: messageEvent.data
          });
        };
        socket.onopen = (_) => {
          this.clearTimeout();
          this.connectedResolver();
          if (this.openHandler) {
            this.openHandler();
          }
        };
        socket.onclose = (closeEvent) => {
          this.closed = true;
          if (this.closeHandler) {
            this.closeHandler(closeEvent);
          }
        };
        const started = Date.now();
        this.timeoutId = setTimeout(() => {
          socket.onmessage = () => 0;
          socket.onerror = () => 0;
          socket.onopen = () => 0;
          socket.onclose = () => 0;
          socket.close();
          this.socket = void 0;
          const elapsed = Math.floor(Date.now() - started);
          this.connectedRejecter(`Connection attempt timed out after ${elapsed} ms`);
        }, this.timeout);
        this.socket = socket;
      }
      /**
       * Closes an established connection and aborts other connection states
       */
      disconnect() {
        if (!this.socket) {
          throw new Error("Socket undefined. This must be called after connecting.");
        }
        this.clearTimeout();
        switch (this.socket.readyState) {
          case isomorphic_ws_1.default.OPEN:
            this.socket.close(
              1e3
              /* Normal Closure */
            );
            break;
          case isomorphic_ws_1.default.CLOSED:
            break;
          case isomorphic_ws_1.default.CONNECTING:
            this.socket.onopen = () => 0;
            this.socket.onclose = () => 0;
            this.socket.onerror = () => 0;
            this.socket.onmessage = () => 0;
            this.socket = void 0;
            if (this.closeHandler) {
              this.closeHandler({ wasClean: false, code: 4001 });
            }
            break;
          case isomorphic_ws_1.default.CLOSING:
            break;
          default:
            throw new Error(`Unknown readyState: ${this.socket.readyState}`);
        }
      }
      async send(data) {
        return new Promise((resolve, reject) => {
          if (!this.socket) {
            throw new Error("Socket undefined. This must be called after connecting.");
          }
          if (this.closed) {
            throw new Error("Socket was closed, so no data can be sent anymore.");
          }
          if (this.socket.readyState !== isomorphic_ws_1.default.OPEN) {
            throw new Error("Websocket is not open");
          }
          if (environmentIsNodeJs()) {
            this.socket.send(data, (err) => err ? reject(err) : resolve());
          } else {
            this.socket.send(data);
            resolve();
          }
        });
      }
      /**
       * Clears the timeout function, such that no timeout error will be raised anymore. This should be
       * called when the connection is established, a connection error occurred or the socket is disconnected.
       *
       * This method must not be called before `connect()`.
       * This method is idempotent.
       */
      clearTimeout() {
        if (!this.timeoutId) {
          throw new Error("Timeout ID not set. This should not happen and usually means connect() was not called.");
        }
        clearTimeout(this.timeoutId);
      }
    };
    exports.SocketWrapper = SocketWrapper;
  }
});

// ../../node_modules/.pnpm/@cosmjs+socket@0.32.4/node_modules/@cosmjs/socket/build/streamingsocket.js
var require_streamingsocket = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+socket@0.32.4/node_modules/@cosmjs/socket/build/streamingsocket.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.StreamingSocket = void 0;
    var xstream_1 = require_xstream();
    var socketwrapper_1 = require_socketwrapper();
    var StreamingSocket = class {
      constructor(url, timeout = 1e4) {
        this.socket = new socketwrapper_1.SocketWrapper(url, (event) => {
          if (this.eventProducerListener) {
            this.eventProducerListener.next(event);
          }
        }, (errorEvent) => {
          if (this.eventProducerListener) {
            this.eventProducerListener.error(errorEvent);
          }
        }, () => {
        }, (closeEvent) => {
          if (this.eventProducerListener) {
            if (closeEvent.wasClean) {
              this.eventProducerListener.complete();
            } else {
              this.eventProducerListener.error("Socket was closed unclean");
            }
          }
        }, timeout);
        this.connected = this.socket.connected;
        const eventProducer = {
          start: (listener) => this.eventProducerListener = listener,
          stop: () => this.eventProducerListener = void 0
        };
        this.events = xstream_1.Stream.create(eventProducer);
      }
      connect() {
        this.socket.connect();
      }
      disconnect() {
        this.socket.disconnect();
      }
      async send(data) {
        return this.socket.send(data);
      }
    };
    exports.StreamingSocket = StreamingSocket;
  }
});

// ../../node_modules/.pnpm/@cosmjs+socket@0.32.4/node_modules/@cosmjs/socket/build/queueingstreamingsocket.js
var require_queueingstreamingsocket = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+socket@0.32.4/node_modules/@cosmjs/socket/build/queueingstreamingsocket.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.QueueingStreamingSocket = exports.ConnectionStatus = void 0;
    var stream_1 = require_build8();
    var xstream_1 = require_xstream();
    var streamingsocket_1 = require_streamingsocket();
    var ConnectionStatus;
    (function(ConnectionStatus2) {
      ConnectionStatus2[ConnectionStatus2["Unconnected"] = 0] = "Unconnected";
      ConnectionStatus2[ConnectionStatus2["Connecting"] = 1] = "Connecting";
      ConnectionStatus2[ConnectionStatus2["Connected"] = 2] = "Connected";
      ConnectionStatus2[ConnectionStatus2["Disconnected"] = 3] = "Disconnected";
    })(ConnectionStatus = exports.ConnectionStatus || (exports.ConnectionStatus = {}));
    var QueueingStreamingSocket = class {
      constructor(url, timeout = 1e4, reconnectedHandler) {
        this.queue = [];
        this.isProcessingQueue = false;
        this.url = url;
        this.timeout = timeout;
        this.reconnectedHandler = reconnectedHandler;
        const eventProducer = {
          start: (listener) => this.eventProducerListener = listener,
          stop: () => this.eventProducerListener = void 0
        };
        this.events = xstream_1.Stream.create(eventProducer);
        this.connectionStatusProducer = new stream_1.DefaultValueProducer(ConnectionStatus.Unconnected);
        this.connectionStatus = new stream_1.ValueAndUpdates(this.connectionStatusProducer);
        this.socket = new streamingsocket_1.StreamingSocket(this.url, this.timeout);
        this.socket.events.subscribe({
          next: (event) => {
            if (!this.eventProducerListener)
              throw new Error("No event producer listener set");
            this.eventProducerListener.next(event);
          },
          error: () => this.connectionStatusProducer.update(ConnectionStatus.Disconnected)
        });
      }
      connect() {
        this.connectionStatusProducer.update(ConnectionStatus.Connecting);
        this.socket.connected.then(async () => {
          this.connectionStatusProducer.update(ConnectionStatus.Connected);
          return this.processQueue();
        }, () => this.connectionStatusProducer.update(ConnectionStatus.Disconnected));
        this.socket.connect();
      }
      disconnect() {
        this.connectionStatusProducer.update(ConnectionStatus.Disconnected);
        this.socket.disconnect();
      }
      reconnect() {
        this.socket = new streamingsocket_1.StreamingSocket(this.url, this.timeout);
        this.socket.events.subscribe({
          next: (event) => {
            if (!this.eventProducerListener)
              throw new Error("No event producer listener set");
            this.eventProducerListener.next(event);
          },
          error: () => this.connectionStatusProducer.update(ConnectionStatus.Disconnected)
        });
        this.socket.connected.then(() => {
          if (this.reconnectedHandler) {
            this.reconnectedHandler();
          }
        });
        this.connect();
      }
      getQueueLength() {
        return this.queue.length;
      }
      queueRequest(request) {
        this.queue.push(request);
        this.processQueue();
      }
      async processQueue() {
        if (this.isProcessingQueue || this.connectionStatus.value !== ConnectionStatus.Connected) {
          return;
        }
        this.isProcessingQueue = true;
        let request;
        while (request = this.queue.shift()) {
          try {
            await this.socket.send(request);
            this.isProcessingQueue = false;
          } catch (error) {
            this.queue.unshift(request);
            this.isProcessingQueue = false;
            return;
          }
        }
      }
    };
    exports.QueueingStreamingSocket = QueueingStreamingSocket;
  }
});

// ../../node_modules/.pnpm/@cosmjs+socket@0.32.4/node_modules/@cosmjs/socket/build/reconnectingsocket.js
var require_reconnectingsocket = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+socket@0.32.4/node_modules/@cosmjs/socket/build/reconnectingsocket.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ReconnectingSocket = void 0;
    var xstream_1 = require_xstream();
    var queueingstreamingsocket_1 = require_queueingstreamingsocket();
    var ReconnectingSocket = class _ReconnectingSocket {
      /** Starts with a 0.1 second timeout, then doubles every attempt with a maximum timeout of 5 seconds. */
      static calculateTimeout(index) {
        return Math.min(2 ** index * 100, 5e3);
      }
      constructor(url, timeout = 1e4, reconnectedHandler) {
        this.unconnected = true;
        this.disconnected = false;
        this.timeoutIndex = 0;
        this.reconnectTimeout = null;
        const eventProducer = {
          start: (listener) => this.eventProducerListener = listener,
          stop: () => this.eventProducerListener = void 0
        };
        this.events = xstream_1.Stream.create(eventProducer);
        this.socket = new queueingstreamingsocket_1.QueueingStreamingSocket(url, timeout, reconnectedHandler);
        this.socket.events.subscribe({
          next: (event) => {
            if (this.eventProducerListener) {
              this.eventProducerListener.next(event);
            }
          },
          error: (error) => {
            if (this.eventProducerListener) {
              this.eventProducerListener.error(error);
            }
          }
        });
        this.connectionStatus = this.socket.connectionStatus;
        this.connectionStatus.updates.subscribe({
          next: (status) => {
            if (status === queueingstreamingsocket_1.ConnectionStatus.Connected) {
              this.timeoutIndex = 0;
            }
            if (status === queueingstreamingsocket_1.ConnectionStatus.Disconnected) {
              if (this.reconnectTimeout) {
                clearTimeout(this.reconnectTimeout);
                this.reconnectTimeout = null;
              }
              this.reconnectTimeout = setTimeout(() => this.socket.reconnect(), _ReconnectingSocket.calculateTimeout(this.timeoutIndex++));
            }
          }
        });
      }
      connect() {
        if (!this.unconnected) {
          throw new Error("Cannot connect: socket has already connected");
        }
        this.socket.connect();
        this.unconnected = false;
      }
      disconnect() {
        if (this.unconnected) {
          throw new Error("Cannot disconnect: socket has not yet connected");
        }
        this.socket.disconnect();
        if (this.eventProducerListener) {
          this.eventProducerListener.complete();
        }
        this.disconnected = true;
      }
      queueRequest(request) {
        if (this.disconnected) {
          throw new Error("Cannot queue request: socket has disconnected");
        }
        this.socket.queueRequest(request);
      }
    };
    exports.ReconnectingSocket = ReconnectingSocket;
  }
});

// ../../node_modules/.pnpm/@cosmjs+socket@0.32.4/node_modules/@cosmjs/socket/build/index.js
var require_build10 = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+socket@0.32.4/node_modules/@cosmjs/socket/build/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.StreamingSocket = exports.SocketWrapper = exports.ReconnectingSocket = exports.QueueingStreamingSocket = exports.ConnectionStatus = void 0;
    var queueingstreamingsocket_1 = require_queueingstreamingsocket();
    Object.defineProperty(exports, "ConnectionStatus", { enumerable: true, get: function() {
      return queueingstreamingsocket_1.ConnectionStatus;
    } });
    Object.defineProperty(exports, "QueueingStreamingSocket", { enumerable: true, get: function() {
      return queueingstreamingsocket_1.QueueingStreamingSocket;
    } });
    var reconnectingsocket_1 = require_reconnectingsocket();
    Object.defineProperty(exports, "ReconnectingSocket", { enumerable: true, get: function() {
      return reconnectingsocket_1.ReconnectingSocket;
    } });
    var socketwrapper_1 = require_socketwrapper();
    Object.defineProperty(exports, "SocketWrapper", { enumerable: true, get: function() {
      return socketwrapper_1.SocketWrapper;
    } });
    var streamingsocket_1 = require_streamingsocket();
    Object.defineProperty(exports, "StreamingSocket", { enumerable: true, get: function() {
      return streamingsocket_1.StreamingSocket;
    } });
  }
});

// ../../node_modules/.pnpm/@cosmjs+tendermint-rpc@0.32.4/node_modules/@cosmjs/tendermint-rpc/build/rpcclients/websocketclient.js
var require_websocketclient = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+tendermint-rpc@0.32.4/node_modules/@cosmjs/tendermint-rpc/build/rpcclients/websocketclient.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WebsocketClient = void 0;
    var json_rpc_1 = require_build9();
    var socket_1 = require_build10();
    var stream_1 = require_build8();
    var xstream_1 = require_xstream();
    var rpcclient_1 = require_rpcclient();
    function defaultErrorHandler(error) {
      throw error;
    }
    function toJsonRpcResponse(message) {
      if (message.type !== "message") {
        throw new Error(`Unexcepted message type on websocket: ${message.type}`);
      }
      const jsonRpcEvent = (0, json_rpc_1.parseJsonRpcResponse)(JSON.parse(message.data));
      return jsonRpcEvent;
    }
    var RpcEventProducer = class {
      constructor(request, socket) {
        this.running = false;
        this.subscriptions = [];
        this.request = request;
        this.socket = socket;
      }
      /**
       * Implementation of Producer.start
       */
      start(listener) {
        if (this.running) {
          throw Error("Already started. Please stop first before restarting.");
        }
        this.running = true;
        this.connectToClient(listener);
        this.socket.queueRequest(JSON.stringify(this.request));
      }
      /**
       * Implementation of Producer.stop
       *
       * Called by the stream when the stream's last listener stopped listening
       * or when the producer completed.
       */
      stop() {
        this.running = false;
        const endRequest = { ...this.request, method: "unsubscribe" };
        try {
          this.socket.queueRequest(JSON.stringify(endRequest));
        } catch (error) {
          if (error instanceof Error && error.message.match(/socket has disconnected/i)) {
          } else {
            throw error;
          }
        }
      }
      connectToClient(listener) {
        const responseStream = this.socket.events.map(toJsonRpcResponse);
        const idSubscription = responseStream.filter((response) => response.id === this.request.id).subscribe({
          next: (response) => {
            if ((0, json_rpc_1.isJsonRpcErrorResponse)(response)) {
              this.closeSubscriptions();
              listener.error(JSON.stringify(response.error));
            }
            idSubscription.unsubscribe();
          }
        });
        const idEventSubscription = responseStream.filter((response) => response.id === this.request.id).subscribe({
          next: (response) => {
            if ((0, json_rpc_1.isJsonRpcErrorResponse)(response)) {
              this.closeSubscriptions();
              listener.error(JSON.stringify(response.error));
            } else {
              listener.next(response.result);
            }
          }
        });
        const nonResponseSubscription = responseStream.subscribe({
          error: (error) => {
            this.closeSubscriptions();
            listener.error(error);
          },
          complete: () => {
            this.closeSubscriptions();
            listener.complete();
          }
        });
        this.subscriptions.push(idSubscription, idEventSubscription, nonResponseSubscription);
      }
      closeSubscriptions() {
        for (const subscription of this.subscriptions) {
          subscription.unsubscribe();
        }
        this.subscriptions = [];
      }
    };
    var WebsocketClient = class {
      constructor(baseUrl, onError = defaultErrorHandler) {
        this.subscriptionStreams = /* @__PURE__ */ new Map();
        if (!(0, rpcclient_1.hasProtocol)(baseUrl)) {
          throw new Error("Base URL is missing a protocol. Expected 'ws://' or 'wss://'.");
        }
        const path = baseUrl.endsWith("/") ? "websocket" : "/websocket";
        this.url = baseUrl + path;
        this.socket = new socket_1.ReconnectingSocket(this.url);
        const errorSubscription = this.socket.events.subscribe({
          error: (error) => {
            onError(error);
            errorSubscription.unsubscribe();
          }
        });
        this.jsonRpcResponseStream = this.socket.events.map(toJsonRpcResponse);
        this.socket.connect();
      }
      async execute(request) {
        const pendingResponse = this.responseForRequestId(request.id);
        this.socket.queueRequest(JSON.stringify(request));
        const response = await pendingResponse;
        if ((0, json_rpc_1.isJsonRpcErrorResponse)(response)) {
          throw new Error(JSON.stringify(response.error));
        }
        return response;
      }
      listen(request) {
        if (request.method !== "subscribe") {
          throw new Error(`Request method must be "subscribe" to start event listening`);
        }
        const query = request.params.query;
        if (typeof query !== "string") {
          throw new Error("request.params.query must be a string");
        }
        if (!this.subscriptionStreams.has(query)) {
          const producer = new RpcEventProducer(request, this.socket);
          const stream = xstream_1.Stream.create(producer);
          this.subscriptionStreams.set(query, stream);
        }
        return this.subscriptionStreams.get(query).filter((response) => response.query !== void 0);
      }
      /**
       * Resolves as soon as websocket is connected. execute() queues requests automatically,
       * so this should be required for testing purposes only.
       */
      async connected() {
        await this.socket.connectionStatus.waitFor(socket_1.ConnectionStatus.Connected);
      }
      disconnect() {
        this.socket.disconnect();
      }
      async responseForRequestId(id) {
        return (0, stream_1.firstEvent)(this.jsonRpcResponseStream.filter((r) => r.id === id));
      }
    };
    exports.WebsocketClient = WebsocketClient;
  }
});

// ../../node_modules/.pnpm/@cosmjs+tendermint-rpc@0.32.4/node_modules/@cosmjs/tendermint-rpc/build/rpcclients/index.js
var require_rpcclients = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+tendermint-rpc@0.32.4/node_modules/@cosmjs/tendermint-rpc/build/rpcclients/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WebsocketClient = exports.instanceOfRpcStreamingClient = exports.HttpClient = exports.HttpBatchClient = void 0;
    var httpbatchclient_1 = require_httpbatchclient();
    Object.defineProperty(exports, "HttpBatchClient", { enumerable: true, get: function() {
      return httpbatchclient_1.HttpBatchClient;
    } });
    var httpclient_1 = require_httpclient();
    Object.defineProperty(exports, "HttpClient", { enumerable: true, get: function() {
      return httpclient_1.HttpClient;
    } });
    var rpcclient_1 = require_rpcclient();
    Object.defineProperty(exports, "instanceOfRpcStreamingClient", { enumerable: true, get: function() {
      return rpcclient_1.instanceOfRpcStreamingClient;
    } });
    var websocketclient_1 = require_websocketclient();
    Object.defineProperty(exports, "WebsocketClient", { enumerable: true, get: function() {
      return websocketclient_1.WebsocketClient;
    } });
  }
});

// ../../node_modules/.pnpm/@cosmjs+tendermint-rpc@0.32.4/node_modules/@cosmjs/tendermint-rpc/build/tendermint34/encodings.js
var require_encodings = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+tendermint-rpc@0.32.4/node_modules/@cosmjs/tendermint-rpc/build/tendermint34/encodings.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.encodeBlockId = exports.encodeVersion = exports.encodeBytes = exports.encodeTime = exports.encodeUvarint = exports.encodeString = exports.dictionaryToStringMap = exports.may = exports.assertNotEmpty = exports.assertObject = exports.assertArray = exports.assertNumber = exports.assertString = exports.assertBoolean = exports.assertSet = void 0;
    var encoding_1 = require_build2();
    function assertSet(value) {
      if (value === void 0) {
        throw new Error("Value must not be undefined");
      }
      if (value === null) {
        throw new Error("Value must not be null");
      }
      return value;
    }
    exports.assertSet = assertSet;
    function assertBoolean(value) {
      assertSet(value);
      if (typeof value !== "boolean") {
        throw new Error("Value must be a boolean");
      }
      return value;
    }
    exports.assertBoolean = assertBoolean;
    function assertString(value) {
      assertSet(value);
      if (typeof value !== "string") {
        throw new Error("Value must be a string");
      }
      return value;
    }
    exports.assertString = assertString;
    function assertNumber(value) {
      assertSet(value);
      if (typeof value !== "number") {
        throw new Error("Value must be a number");
      }
      return value;
    }
    exports.assertNumber = assertNumber;
    function assertArray(value) {
      assertSet(value);
      if (!Array.isArray(value)) {
        throw new Error("Value must be a an array");
      }
      return value;
    }
    exports.assertArray = assertArray;
    function assertObject(value) {
      assertSet(value);
      if (typeof value !== "object") {
        throw new Error("Value must be an object");
      }
      if (Object.prototype.toString.call(value) !== "[object Object]") {
        throw new Error("Value must be a simple object");
      }
      return value;
    }
    exports.assertObject = assertObject;
    function assertNotEmpty(value) {
      assertSet(value);
      if (typeof value === "number" && value === 0) {
        throw new Error("must provide a non-zero value");
      } else if (value.length === 0) {
        throw new Error("must provide a non-empty value");
      }
      return value;
    }
    exports.assertNotEmpty = assertNotEmpty;
    function may(transform, value) {
      return value === void 0 || value === null ? void 0 : transform(value);
    }
    exports.may = may;
    function dictionaryToStringMap(obj) {
      const out = /* @__PURE__ */ new Map();
      for (const key of Object.keys(obj)) {
        const value = obj[key];
        if (typeof value !== "string") {
          throw new Error("Found dictionary value of type other than string");
        }
        out.set(key, value);
      }
      return out;
    }
    exports.dictionaryToStringMap = dictionaryToStringMap;
    function encodeString(s) {
      const utf8 = (0, encoding_1.toUtf8)(s);
      return Uint8Array.from([utf8.length, ...utf8]);
    }
    exports.encodeString = encodeString;
    function encodeUvarint(n) {
      return n >= 128 ? (
        // eslint-disable-next-line no-bitwise
        Uint8Array.from([n & 255 | 128, ...encodeUvarint(n >> 7)])
      ) : (
        // eslint-disable-next-line no-bitwise
        Uint8Array.from([n & 255])
      );
    }
    exports.encodeUvarint = encodeUvarint;
    function encodeTime(time) {
      const milliseconds = time.getTime();
      const seconds = Math.floor(milliseconds / 1e3);
      const secondsArray = seconds ? [8, ...encodeUvarint(seconds)] : new Uint8Array();
      const nanoseconds = (time.nanoseconds || 0) + milliseconds % 1e3 * 1e6;
      const nanosecondsArray = nanoseconds ? [16, ...encodeUvarint(nanoseconds)] : new Uint8Array();
      return Uint8Array.from([...secondsArray, ...nanosecondsArray]);
    }
    exports.encodeTime = encodeTime;
    function encodeBytes(bytes) {
      if (bytes.length >= 128)
        throw new Error("Not implemented for byte arrays of length 128 or more");
      return bytes.length ? Uint8Array.from([bytes.length, ...bytes]) : new Uint8Array();
    }
    exports.encodeBytes = encodeBytes;
    function encodeVersion(version) {
      const blockArray = version.block ? Uint8Array.from([8, ...encodeUvarint(version.block)]) : new Uint8Array();
      const appArray = version.app ? Uint8Array.from([16, ...encodeUvarint(version.app)]) : new Uint8Array();
      return Uint8Array.from([...blockArray, ...appArray]);
    }
    exports.encodeVersion = encodeVersion;
    function encodeBlockId(blockId) {
      return Uint8Array.from([
        10,
        blockId.hash.length,
        ...blockId.hash,
        18,
        blockId.parts.hash.length + 4,
        8,
        blockId.parts.total,
        18,
        blockId.parts.hash.length,
        ...blockId.parts.hash
      ]);
    }
    exports.encodeBlockId = encodeBlockId;
  }
});

// ../../node_modules/.pnpm/@cosmjs+tendermint-rpc@0.32.4/node_modules/@cosmjs/tendermint-rpc/build/inthelpers.js
var require_inthelpers = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+tendermint-rpc@0.32.4/node_modules/@cosmjs/tendermint-rpc/build/inthelpers.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.smallIntToApi = exports.apiToBigInt = exports.apiToSmallInt = void 0;
    var math_1 = require_build();
    var encodings_1 = require_encodings();
    function apiToSmallInt(input) {
      const asInt = typeof input === "number" ? new math_1.Int53(input) : math_1.Int53.fromString(input);
      return asInt.toNumber();
    }
    exports.apiToSmallInt = apiToSmallInt;
    function apiToBigInt(input) {
      (0, encodings_1.assertString)(input);
      if (!input.match(/^-?[0-9]+$/)) {
        throw new Error("Invalid string format");
      }
      return BigInt(input);
    }
    exports.apiToBigInt = apiToBigInt;
    function smallIntToApi(num) {
      return new math_1.Int53(num).toString();
    }
    exports.smallIntToApi = smallIntToApi;
  }
});

// ../../node_modules/.pnpm/@cosmjs+tendermint-rpc@0.32.4/node_modules/@cosmjs/tendermint-rpc/build/comet38/encodings.js
var require_encodings2 = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+tendermint-rpc@0.32.4/node_modules/@cosmjs/tendermint-rpc/build/comet38/encodings.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.encodeBlockId = exports.encodeVersion = exports.encodeBytes = exports.encodeTime = exports.encodeUvarint = exports.encodeString = exports.dictionaryToStringMap = exports.may = exports.assertNotEmpty = exports.assertObject = exports.assertArray = exports.assertNumber = exports.assertString = exports.assertBoolean = exports.assertSet = void 0;
    var encoding_1 = require_build2();
    function assertSet(value) {
      if (value === void 0) {
        throw new Error("Value must not be undefined");
      }
      if (value === null) {
        throw new Error("Value must not be null");
      }
      return value;
    }
    exports.assertSet = assertSet;
    function assertBoolean(value) {
      assertSet(value);
      if (typeof value !== "boolean") {
        throw new Error("Value must be a boolean");
      }
      return value;
    }
    exports.assertBoolean = assertBoolean;
    function assertString(value) {
      assertSet(value);
      if (typeof value !== "string") {
        throw new Error("Value must be a string");
      }
      return value;
    }
    exports.assertString = assertString;
    function assertNumber(value) {
      assertSet(value);
      if (typeof value !== "number") {
        throw new Error("Value must be a number");
      }
      return value;
    }
    exports.assertNumber = assertNumber;
    function assertArray(value) {
      assertSet(value);
      if (!Array.isArray(value)) {
        throw new Error("Value must be a an array");
      }
      return value;
    }
    exports.assertArray = assertArray;
    function assertObject(value) {
      assertSet(value);
      if (typeof value !== "object") {
        throw new Error("Value must be an object");
      }
      if (Object.prototype.toString.call(value) !== "[object Object]") {
        throw new Error("Value must be a simple object");
      }
      return value;
    }
    exports.assertObject = assertObject;
    function assertNotEmpty(value) {
      assertSet(value);
      if (typeof value === "number" && value === 0) {
        throw new Error("must provide a non-zero value");
      } else if (value.length === 0) {
        throw new Error("must provide a non-empty value");
      }
      return value;
    }
    exports.assertNotEmpty = assertNotEmpty;
    function may(transform, value) {
      return value === void 0 || value === null ? void 0 : transform(value);
    }
    exports.may = may;
    function dictionaryToStringMap(obj) {
      const out = /* @__PURE__ */ new Map();
      for (const key of Object.keys(obj)) {
        const value = obj[key];
        if (typeof value !== "string") {
          throw new Error("Found dictionary value of type other than string");
        }
        out.set(key, value);
      }
      return out;
    }
    exports.dictionaryToStringMap = dictionaryToStringMap;
    function encodeString(s) {
      const utf8 = (0, encoding_1.toUtf8)(s);
      return Uint8Array.from([utf8.length, ...utf8]);
    }
    exports.encodeString = encodeString;
    function encodeUvarint(n) {
      return n >= 128 ? (
        // eslint-disable-next-line no-bitwise
        Uint8Array.from([n & 255 | 128, ...encodeUvarint(n >> 7)])
      ) : (
        // eslint-disable-next-line no-bitwise
        Uint8Array.from([n & 255])
      );
    }
    exports.encodeUvarint = encodeUvarint;
    function encodeTime(time) {
      const milliseconds = time.getTime();
      const seconds = Math.floor(milliseconds / 1e3);
      const secondsArray = seconds ? [8, ...encodeUvarint(seconds)] : new Uint8Array();
      const nanoseconds = (time.nanoseconds || 0) + milliseconds % 1e3 * 1e6;
      const nanosecondsArray = nanoseconds ? [16, ...encodeUvarint(nanoseconds)] : new Uint8Array();
      return Uint8Array.from([...secondsArray, ...nanosecondsArray]);
    }
    exports.encodeTime = encodeTime;
    function encodeBytes(bytes) {
      if (bytes.length >= 128)
        throw new Error("Not implemented for byte arrays of length 128 or more");
      return bytes.length ? Uint8Array.from([bytes.length, ...bytes]) : new Uint8Array();
    }
    exports.encodeBytes = encodeBytes;
    function encodeVersion(version) {
      const blockArray = version.block ? Uint8Array.from([8, ...encodeUvarint(version.block)]) : new Uint8Array();
      const appArray = version.app ? Uint8Array.from([16, ...encodeUvarint(version.app)]) : new Uint8Array();
      return Uint8Array.from([...blockArray, ...appArray]);
    }
    exports.encodeVersion = encodeVersion;
    function encodeBlockId(blockId) {
      return Uint8Array.from([
        10,
        blockId.hash.length,
        ...blockId.hash,
        18,
        blockId.parts.hash.length + 4,
        8,
        blockId.parts.total,
        18,
        blockId.parts.hash.length,
        ...blockId.parts.hash
      ]);
    }
    exports.encodeBlockId = encodeBlockId;
  }
});

// ../../node_modules/.pnpm/@cosmjs+tendermint-rpc@0.32.4/node_modules/@cosmjs/tendermint-rpc/build/comet38/requests.js
var require_requests = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+tendermint-rpc@0.32.4/node_modules/@cosmjs/tendermint-rpc/build/comet38/requests.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.buildQuery = exports.SubscriptionEventType = exports.Method = void 0;
    var Method;
    (function(Method2) {
      Method2["AbciInfo"] = "abci_info";
      Method2["AbciQuery"] = "abci_query";
      Method2["Block"] = "block";
      Method2["Blockchain"] = "blockchain";
      Method2["BlockResults"] = "block_results";
      Method2["BlockSearch"] = "block_search";
      Method2["BroadcastTxAsync"] = "broadcast_tx_async";
      Method2["BroadcastTxSync"] = "broadcast_tx_sync";
      Method2["BroadcastTxCommit"] = "broadcast_tx_commit";
      Method2["Commit"] = "commit";
      Method2["Genesis"] = "genesis";
      Method2["Health"] = "health";
      Method2["NumUnconfirmedTxs"] = "num_unconfirmed_txs";
      Method2["Status"] = "status";
      Method2["Subscribe"] = "subscribe";
      Method2["Tx"] = "tx";
      Method2["TxSearch"] = "tx_search";
      Method2["Validators"] = "validators";
      Method2["Unsubscribe"] = "unsubscribe";
    })(Method = exports.Method || (exports.Method = {}));
    var SubscriptionEventType;
    (function(SubscriptionEventType2) {
      SubscriptionEventType2["NewBlock"] = "NewBlock";
      SubscriptionEventType2["NewBlockHeader"] = "NewBlockHeader";
      SubscriptionEventType2["Tx"] = "Tx";
    })(SubscriptionEventType = exports.SubscriptionEventType || (exports.SubscriptionEventType = {}));
    function buildQuery(components) {
      const tags = components.tags ? components.tags : [];
      const tagComponents = tags.map((tag) => `${tag.key}='${tag.value}'`);
      const rawComponents = components.raw ? [components.raw] : [];
      return [...tagComponents, ...rawComponents].join(" AND ");
    }
    exports.buildQuery = buildQuery;
  }
});

// ../../node_modules/.pnpm/@cosmjs+tendermint-rpc@0.32.4/node_modules/@cosmjs/tendermint-rpc/build/comet38/adaptor/requests.js
var require_requests2 = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+tendermint-rpc@0.32.4/node_modules/@cosmjs/tendermint-rpc/build/comet38/adaptor/requests.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Params = void 0;
    var encoding_1 = require_build2();
    var inthelpers_1 = require_inthelpers();
    var jsonrpc_1 = require_jsonrpc();
    var encodings_1 = require_encodings2();
    var requests = __importStar(require_requests());
    function encodeHeightParam(param) {
      return {
        height: (0, encodings_1.may)(inthelpers_1.smallIntToApi, param.height)
      };
    }
    function encodeBlockchainRequestParams(param) {
      return {
        minHeight: (0, encodings_1.may)(inthelpers_1.smallIntToApi, param.minHeight),
        maxHeight: (0, encodings_1.may)(inthelpers_1.smallIntToApi, param.maxHeight)
      };
    }
    function encodeBlockSearchParams(params) {
      return {
        query: params.query,
        page: (0, encodings_1.may)(inthelpers_1.smallIntToApi, params.page),
        per_page: (0, encodings_1.may)(inthelpers_1.smallIntToApi, params.per_page),
        order_by: params.order_by
      };
    }
    function encodeAbciQueryParams(params) {
      return {
        path: (0, encodings_1.assertNotEmpty)(params.path),
        data: (0, encoding_1.toHex)(params.data),
        height: (0, encodings_1.may)(inthelpers_1.smallIntToApi, params.height),
        prove: params.prove
      };
    }
    function encodeBroadcastTxParams(params) {
      return {
        tx: (0, encoding_1.toBase64)((0, encodings_1.assertNotEmpty)(params.tx))
      };
    }
    function encodeTxParams(params) {
      return {
        hash: (0, encoding_1.toBase64)((0, encodings_1.assertNotEmpty)(params.hash)),
        prove: params.prove
      };
    }
    function encodeTxSearchParams(params) {
      return {
        query: params.query,
        prove: params.prove,
        page: (0, encodings_1.may)(inthelpers_1.smallIntToApi, params.page),
        per_page: (0, encodings_1.may)(inthelpers_1.smallIntToApi, params.per_page),
        order_by: params.order_by
      };
    }
    function encodeValidatorsParams(params) {
      return {
        height: (0, encodings_1.may)(inthelpers_1.smallIntToApi, params.height),
        page: (0, encodings_1.may)(inthelpers_1.smallIntToApi, params.page),
        per_page: (0, encodings_1.may)(inthelpers_1.smallIntToApi, params.per_page)
      };
    }
    var Params = class {
      static encodeAbciInfo(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method);
      }
      static encodeAbciQuery(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeAbciQueryParams(req.params));
      }
      static encodeBlock(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeHeightParam(req.params));
      }
      static encodeBlockchain(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeBlockchainRequestParams(req.params));
      }
      static encodeBlockResults(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeHeightParam(req.params));
      }
      static encodeBlockSearch(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeBlockSearchParams(req.params));
      }
      static encodeBroadcastTx(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeBroadcastTxParams(req.params));
      }
      static encodeCommit(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeHeightParam(req.params));
      }
      static encodeGenesis(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method);
      }
      static encodeHealth(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method);
      }
      static encodeNumUnconfirmedTxs(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method);
      }
      static encodeStatus(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method);
      }
      static encodeSubscribe(req) {
        const eventTag = { key: "tm.event", value: req.query.type };
        const query = requests.buildQuery({ tags: [eventTag], raw: req.query.raw });
        return (0, jsonrpc_1.createJsonRpcRequest)("subscribe", { query });
      }
      static encodeTx(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeTxParams(req.params));
      }
      // TODO: encode params for query string???
      static encodeTxSearch(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeTxSearchParams(req.params));
      }
      static encodeValidators(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeValidatorsParams(req.params));
      }
    };
    exports.Params = Params;
  }
});

// ../../node_modules/.pnpm/@cosmjs+tendermint-rpc@0.32.4/node_modules/@cosmjs/tendermint-rpc/build/types.js
var require_types2 = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+tendermint-rpc@0.32.4/node_modules/@cosmjs/tendermint-rpc/build/types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BlockIdFlag = void 0;
    var BlockIdFlag;
    (function(BlockIdFlag2) {
      BlockIdFlag2[BlockIdFlag2["Unknown"] = 0] = "Unknown";
      BlockIdFlag2[BlockIdFlag2["Absent"] = 1] = "Absent";
      BlockIdFlag2[BlockIdFlag2["Commit"] = 2] = "Commit";
      BlockIdFlag2[BlockIdFlag2["Nil"] = 3] = "Nil";
      BlockIdFlag2[BlockIdFlag2["Unrecognized"] = -1] = "Unrecognized";
    })(BlockIdFlag = exports.BlockIdFlag || (exports.BlockIdFlag = {}));
  }
});

// ../../node_modules/.pnpm/@cosmjs+tendermint-rpc@0.32.4/node_modules/@cosmjs/tendermint-rpc/build/comet38/hasher.js
var require_hasher = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+tendermint-rpc@0.32.4/node_modules/@cosmjs/tendermint-rpc/build/comet38/hasher.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.hashBlock = exports.hashTx = void 0;
    var crypto_1 = require_build4();
    var encodings_1 = require_encodings2();
    function hashTx(tx) {
      return (0, crypto_1.sha256)(tx);
    }
    exports.hashTx = hashTx;
    function getSplitPoint(n) {
      if (n < 1)
        throw new Error("Cannot split an empty tree");
      const largestPowerOf2 = 2 ** Math.floor(Math.log2(n));
      return largestPowerOf2 < n ? largestPowerOf2 : largestPowerOf2 / 2;
    }
    function hashLeaf(leaf) {
      const hash = new crypto_1.Sha256(Uint8Array.from([0]));
      hash.update(leaf);
      return hash.digest();
    }
    function hashInner(left, right) {
      const hash = new crypto_1.Sha256(Uint8Array.from([1]));
      hash.update(left);
      hash.update(right);
      return hash.digest();
    }
    function hashTree(hashes) {
      switch (hashes.length) {
        case 0:
          throw new Error("Cannot hash empty tree");
        case 1:
          return hashLeaf(hashes[0]);
        default: {
          const slicePoint = getSplitPoint(hashes.length);
          const left = hashTree(hashes.slice(0, slicePoint));
          const right = hashTree(hashes.slice(slicePoint));
          return hashInner(left, right);
        }
      }
    }
    function hashBlock(header) {
      if (!header.lastBlockId) {
        throw new Error("Hashing a block header with no last block ID (i.e. header at height 1) is not supported. If you need this, contributions are welcome. Please add documentation and test vectors for this case.");
      }
      const encodedFields = [
        (0, encodings_1.encodeVersion)(header.version),
        (0, encodings_1.encodeString)(header.chainId),
        (0, encodings_1.encodeUvarint)(header.height),
        (0, encodings_1.encodeTime)(header.time),
        (0, encodings_1.encodeBlockId)(header.lastBlockId),
        (0, encodings_1.encodeBytes)(header.lastCommitHash),
        (0, encodings_1.encodeBytes)(header.dataHash),
        (0, encodings_1.encodeBytes)(header.validatorsHash),
        (0, encodings_1.encodeBytes)(header.nextValidatorsHash),
        (0, encodings_1.encodeBytes)(header.consensusHash),
        (0, encodings_1.encodeBytes)(header.appHash),
        (0, encodings_1.encodeBytes)(header.lastResultsHash),
        (0, encodings_1.encodeBytes)(header.evidenceHash),
        (0, encodings_1.encodeBytes)(header.proposerAddress)
      ];
      return hashTree(encodedFields);
    }
    exports.hashBlock = hashBlock;
  }
});

// ../../node_modules/.pnpm/@cosmjs+tendermint-rpc@0.32.4/node_modules/@cosmjs/tendermint-rpc/build/comet38/adaptor/responses.js
var require_responses = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+tendermint-rpc@0.32.4/node_modules/@cosmjs/tendermint-rpc/build/comet38/adaptor/responses.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Responses = exports.decodeValidatorInfo = exports.decodeValidatorGenesis = exports.decodeValidatorUpdate = exports.decodeEvent = void 0;
    var encoding_1 = require_build2();
    var utils_1 = require_build3();
    var dates_1 = require_dates();
    var inthelpers_1 = require_inthelpers();
    var types_1 = require_types2();
    var encodings_1 = require_encodings2();
    var hasher_1 = require_hasher();
    function decodeAbciInfo(data) {
      return {
        data: data.data,
        lastBlockHeight: (0, encodings_1.may)(inthelpers_1.apiToSmallInt, data.last_block_height),
        lastBlockAppHash: (0, encodings_1.may)(encoding_1.fromBase64, data.last_block_app_hash)
      };
    }
    function decodeQueryProof(data) {
      return {
        ops: data.ops.map((op) => ({
          type: op.type,
          key: (0, encoding_1.fromBase64)(op.key),
          data: (0, encoding_1.fromBase64)(op.data)
        }))
      };
    }
    function decodeAbciQuery(data) {
      return {
        key: (0, encoding_1.fromBase64)((0, encodings_1.assertString)(data.key ?? "")),
        value: (0, encoding_1.fromBase64)((0, encodings_1.assertString)(data.value ?? "")),
        proof: (0, encodings_1.may)(decodeQueryProof, data.proofOps),
        height: (0, encodings_1.may)(inthelpers_1.apiToSmallInt, data.height),
        code: (0, encodings_1.may)(inthelpers_1.apiToSmallInt, data.code),
        codespace: (0, encodings_1.assertString)(data.codespace ?? ""),
        index: (0, encodings_1.may)(inthelpers_1.apiToSmallInt, data.index),
        log: data.log,
        info: (0, encodings_1.assertString)(data.info ?? "")
      };
    }
    function decodeEventAttribute(attribute) {
      return {
        key: (0, encodings_1.assertNotEmpty)(attribute.key),
        value: attribute.value ?? ""
      };
    }
    function decodeAttributes(attributes) {
      return (0, encodings_1.assertArray)(attributes).map(decodeEventAttribute);
    }
    function decodeEvent(event) {
      return {
        type: event.type,
        attributes: event.attributes ? decodeAttributes(event.attributes) : []
      };
    }
    exports.decodeEvent = decodeEvent;
    function decodeEvents(events) {
      return (0, encodings_1.assertArray)(events).map(decodeEvent);
    }
    function decodeTxData(data) {
      return {
        code: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNumber)(data.code ?? 0)),
        codespace: data.codespace,
        log: data.log,
        data: (0, encodings_1.may)(encoding_1.fromBase64, data.data),
        events: data.events ? decodeEvents(data.events) : [],
        gasWanted: (0, inthelpers_1.apiToBigInt)(data.gas_wanted ?? "0"),
        gasUsed: (0, inthelpers_1.apiToBigInt)(data.gas_used ?? "0")
      };
    }
    function decodePubkey(data) {
      if ("Sum" in data) {
        const [[algorithm, value]] = Object.entries(data.Sum.value);
        (0, utils_1.assert)(algorithm === "ed25519" || algorithm === "secp256k1", `unknown pubkey type: ${algorithm}`);
        return {
          algorithm,
          data: (0, encoding_1.fromBase64)((0, encodings_1.assertNotEmpty)(value))
        };
      } else {
        switch (data.type) {
          case "tendermint/PubKeyEd25519":
            return {
              algorithm: "ed25519",
              data: (0, encoding_1.fromBase64)((0, encodings_1.assertNotEmpty)(data.value))
            };
          case "tendermint/PubKeySecp256k1":
            return {
              algorithm: "secp256k1",
              data: (0, encoding_1.fromBase64)((0, encodings_1.assertNotEmpty)(data.value))
            };
          default:
            throw new Error(`unknown pubkey type: ${data.type}`);
        }
      }
    }
    function decodeBlockParams(data) {
      return {
        maxBytes: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.max_bytes)),
        maxGas: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.max_gas))
      };
    }
    function decodeEvidenceParams(data) {
      return {
        maxAgeNumBlocks: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.max_age_num_blocks)),
        maxAgeDuration: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.max_age_duration))
      };
    }
    function decodeConsensusParams(data) {
      return {
        block: decodeBlockParams((0, encodings_1.assertObject)(data.block)),
        evidence: decodeEvidenceParams((0, encodings_1.assertObject)(data.evidence))
      };
    }
    function decodeValidatorUpdate(data) {
      return {
        pubkey: decodePubkey((0, encodings_1.assertObject)(data.pub_key)),
        votingPower: (0, inthelpers_1.apiToBigInt)(data.power ?? "0")
      };
    }
    exports.decodeValidatorUpdate = decodeValidatorUpdate;
    function decodeBlockResults(data) {
      return {
        height: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.height)),
        results: (data.txs_results || []).map(decodeTxData),
        validatorUpdates: (data.validator_updates || []).map(decodeValidatorUpdate),
        consensusUpdates: (0, encodings_1.may)(decodeConsensusParams, data.consensus_param_updates),
        beginBlockEvents: decodeEvents(data.begin_block_events || []),
        endBlockEvents: decodeEvents(data.end_block_events || [])
      };
    }
    function decodeBlockId(data) {
      return {
        hash: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data.hash)),
        parts: {
          total: (0, encodings_1.assertNotEmpty)(data.parts.total),
          hash: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data.parts.hash))
        }
      };
    }
    function decodeBlockVersion(data) {
      return {
        block: (0, inthelpers_1.apiToSmallInt)(data.block),
        app: (0, inthelpers_1.apiToSmallInt)(data.app ?? 0)
      };
    }
    function decodeHeader(data) {
      return {
        version: decodeBlockVersion(data.version),
        chainId: (0, encodings_1.assertNotEmpty)(data.chain_id),
        height: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.height)),
        time: (0, dates_1.fromRfc3339WithNanoseconds)((0, encodings_1.assertNotEmpty)(data.time)),
        // When there is no last block ID (i.e. this block's height is 1), we get an empty structure like this:
        // { hash: '', parts: { total: 0, hash: '' } }
        lastBlockId: data.last_block_id.hash ? decodeBlockId(data.last_block_id) : null,
        lastCommitHash: (0, encoding_1.fromHex)((0, encodings_1.assertSet)(data.last_commit_hash)),
        dataHash: (0, encoding_1.fromHex)((0, encodings_1.assertSet)(data.data_hash)),
        validatorsHash: (0, encoding_1.fromHex)((0, encodings_1.assertSet)(data.validators_hash)),
        nextValidatorsHash: (0, encoding_1.fromHex)((0, encodings_1.assertSet)(data.next_validators_hash)),
        consensusHash: (0, encoding_1.fromHex)((0, encodings_1.assertSet)(data.consensus_hash)),
        appHash: (0, encoding_1.fromHex)((0, encodings_1.assertSet)(data.app_hash)),
        lastResultsHash: (0, encoding_1.fromHex)((0, encodings_1.assertSet)(data.last_results_hash)),
        evidenceHash: (0, encoding_1.fromHex)((0, encodings_1.assertSet)(data.evidence_hash)),
        proposerAddress: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data.proposer_address))
      };
    }
    function decodeBlockMeta(data) {
      return {
        blockId: decodeBlockId(data.block_id),
        blockSize: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.block_size)),
        header: decodeHeader(data.header),
        numTxs: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.num_txs))
      };
    }
    function decodeBlockchain(data) {
      return {
        lastHeight: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.last_height)),
        blockMetas: (0, encodings_1.assertArray)(data.block_metas).map(decodeBlockMeta)
      };
    }
    function decodeBroadcastTxSync(data) {
      return {
        ...decodeTxData(data),
        hash: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data.hash))
      };
    }
    function decodeBroadcastTxCommit(data) {
      const txResult = data.tx_result ? decodeTxData(data.tx_result) : void 0;
      return {
        height: (0, inthelpers_1.apiToSmallInt)(data.height),
        hash: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data.hash)),
        checkTx: decodeTxData((0, encodings_1.assertObject)(data.check_tx)),
        deliverTx: txResult,
        txResult
      };
    }
    function decodeBlockIdFlag(blockIdFlag) {
      (0, utils_1.assert)(blockIdFlag in types_1.BlockIdFlag);
      return blockIdFlag;
    }
    function decodeCommitSignature(data) {
      return {
        blockIdFlag: decodeBlockIdFlag(data.block_id_flag),
        validatorAddress: data.validator_address ? (0, encoding_1.fromHex)(data.validator_address) : void 0,
        timestamp: data.timestamp ? (0, dates_1.fromRfc3339WithNanoseconds)(data.timestamp) : void 0,
        signature: data.signature ? (0, encoding_1.fromBase64)(data.signature) : void 0
      };
    }
    function decodeCommit(data) {
      return {
        blockId: decodeBlockId((0, encodings_1.assertObject)(data.block_id)),
        height: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.height)),
        round: (0, inthelpers_1.apiToSmallInt)(data.round),
        signatures: (0, encodings_1.assertArray)(data.signatures).map(decodeCommitSignature)
      };
    }
    function decodeCommitResponse(data) {
      return {
        canonical: (0, encodings_1.assertBoolean)(data.canonical),
        header: decodeHeader(data.signed_header.header),
        commit: decodeCommit(data.signed_header.commit)
      };
    }
    function decodeValidatorGenesis(data) {
      return {
        address: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data.address)),
        pubkey: decodePubkey((0, encodings_1.assertObject)(data.pub_key)),
        votingPower: (0, inthelpers_1.apiToBigInt)((0, encodings_1.assertNotEmpty)(data.power))
      };
    }
    exports.decodeValidatorGenesis = decodeValidatorGenesis;
    function decodeGenesis(data) {
      return {
        genesisTime: (0, dates_1.fromRfc3339WithNanoseconds)((0, encodings_1.assertNotEmpty)(data.genesis_time)),
        chainId: (0, encodings_1.assertNotEmpty)(data.chain_id),
        consensusParams: decodeConsensusParams(data.consensus_params),
        validators: data.validators ? (0, encodings_1.assertArray)(data.validators).map(decodeValidatorGenesis) : [],
        appHash: (0, encoding_1.fromHex)((0, encodings_1.assertSet)(data.app_hash)),
        appState: data.app_state
      };
    }
    function decodeValidatorInfo(data) {
      return {
        pubkey: decodePubkey((0, encodings_1.assertObject)(data.pub_key)),
        votingPower: (0, inthelpers_1.apiToBigInt)((0, encodings_1.assertNotEmpty)(data.voting_power)),
        address: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data.address)),
        proposerPriority: data.proposer_priority ? (0, inthelpers_1.apiToSmallInt)(data.proposer_priority) : void 0
      };
    }
    exports.decodeValidatorInfo = decodeValidatorInfo;
    function decodeNodeInfo(data) {
      return {
        id: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data.id)),
        listenAddr: (0, encodings_1.assertNotEmpty)(data.listen_addr),
        network: (0, encodings_1.assertNotEmpty)(data.network),
        version: (0, encodings_1.assertString)(data.version),
        channels: (0, encodings_1.assertString)(data.channels),
        moniker: (0, encodings_1.assertNotEmpty)(data.moniker),
        other: (0, encodings_1.dictionaryToStringMap)(data.other),
        protocolVersion: {
          app: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.protocol_version.app)),
          block: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.protocol_version.block)),
          p2p: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.protocol_version.p2p))
        }
      };
    }
    function decodeSyncInfo(data) {
      const earliestBlockHeight = data.earliest_block_height ? (0, inthelpers_1.apiToSmallInt)(data.earliest_block_height) : void 0;
      const earliestBlockTime = data.earliest_block_time ? (0, dates_1.fromRfc3339WithNanoseconds)(data.earliest_block_time) : void 0;
      return {
        earliestAppHash: data.earliest_app_hash ? (0, encoding_1.fromHex)(data.earliest_app_hash) : void 0,
        earliestBlockHash: data.earliest_block_hash ? (0, encoding_1.fromHex)(data.earliest_block_hash) : void 0,
        earliestBlockHeight: earliestBlockHeight || void 0,
        earliestBlockTime: (earliestBlockTime == null ? void 0 : earliestBlockTime.getTime()) ? earliestBlockTime : void 0,
        latestBlockHash: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data.latest_block_hash)),
        latestAppHash: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data.latest_app_hash)),
        latestBlockTime: (0, dates_1.fromRfc3339WithNanoseconds)((0, encodings_1.assertNotEmpty)(data.latest_block_time)),
        latestBlockHeight: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.latest_block_height)),
        catchingUp: (0, encodings_1.assertBoolean)(data.catching_up)
      };
    }
    function decodeStatus(data) {
      return {
        nodeInfo: decodeNodeInfo(data.node_info),
        syncInfo: decodeSyncInfo(data.sync_info),
        validatorInfo: decodeValidatorInfo(data.validator_info)
      };
    }
    function decodeTxProof(data) {
      return {
        data: (0, encoding_1.fromBase64)((0, encodings_1.assertNotEmpty)(data.data)),
        rootHash: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data.root_hash)),
        proof: {
          total: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.proof.total)),
          index: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.proof.index)),
          leafHash: (0, encoding_1.fromBase64)((0, encodings_1.assertNotEmpty)(data.proof.leaf_hash)),
          aunts: (0, encodings_1.assertArray)(data.proof.aunts).map(encoding_1.fromBase64)
        }
      };
    }
    function decodeTxResponse(data) {
      return {
        tx: (0, encoding_1.fromBase64)((0, encodings_1.assertNotEmpty)(data.tx)),
        result: decodeTxData((0, encodings_1.assertObject)(data.tx_result)),
        height: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.height)),
        index: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNumber)(data.index)),
        hash: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data.hash)),
        proof: (0, encodings_1.may)(decodeTxProof, data.proof)
      };
    }
    function decodeTxSearch(data) {
      return {
        totalCount: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.total_count)),
        txs: (0, encodings_1.assertArray)(data.txs).map(decodeTxResponse)
      };
    }
    function decodeTxEvent(data) {
      const tx = (0, encoding_1.fromBase64)((0, encodings_1.assertNotEmpty)(data.tx));
      return {
        tx,
        hash: (0, hasher_1.hashTx)(tx),
        result: decodeTxData(data.result),
        height: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.height))
      };
    }
    function decodeValidators(data) {
      return {
        blockHeight: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.block_height)),
        validators: (0, encodings_1.assertArray)(data.validators).map(decodeValidatorInfo),
        count: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.count)),
        total: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.total))
      };
    }
    function decodeBlock(data) {
      var _a;
      return {
        header: decodeHeader((0, encodings_1.assertObject)(data.header)),
        // For the block at height 1, last commit is not set. This is represented in an empty object like this:
        // { height: '0', round: 0, block_id: { hash: '', parts: [Object] }, signatures: [] }
        lastCommit: data.last_commit.block_id.hash ? decodeCommit((0, encodings_1.assertObject)(data.last_commit)) : null,
        txs: data.data.txs ? (0, encodings_1.assertArray)(data.data.txs).map(encoding_1.fromBase64) : [],
        // Lift up .evidence.evidence to just .evidence
        // See https://github.com/tendermint/tendermint/issues/7697
        evidence: ((_a = data.evidence) == null ? void 0 : _a.evidence) ?? []
      };
    }
    function decodeBlockResponse(data) {
      return {
        blockId: decodeBlockId(data.block_id),
        block: decodeBlock(data.block)
      };
    }
    function decodeBlockSearch(data) {
      return {
        totalCount: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.total_count)),
        blocks: (0, encodings_1.assertArray)(data.blocks).map(decodeBlockResponse)
      };
    }
    function decodeNumUnconfirmedTxs(data) {
      return {
        total: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.total)),
        totalBytes: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.total_bytes))
      };
    }
    var Responses = class _Responses {
      static decodeAbciInfo(response) {
        return decodeAbciInfo((0, encodings_1.assertObject)(response.result.response));
      }
      static decodeAbciQuery(response) {
        return decodeAbciQuery((0, encodings_1.assertObject)(response.result.response));
      }
      static decodeBlock(response) {
        return decodeBlockResponse(response.result);
      }
      static decodeBlockResults(response) {
        return decodeBlockResults(response.result);
      }
      static decodeBlockSearch(response) {
        return decodeBlockSearch(response.result);
      }
      static decodeBlockchain(response) {
        return decodeBlockchain(response.result);
      }
      static decodeBroadcastTxSync(response) {
        return decodeBroadcastTxSync(response.result);
      }
      static decodeBroadcastTxAsync(response) {
        return _Responses.decodeBroadcastTxSync(response);
      }
      static decodeBroadcastTxCommit(response) {
        return decodeBroadcastTxCommit(response.result);
      }
      static decodeCommit(response) {
        return decodeCommitResponse(response.result);
      }
      static decodeGenesis(response) {
        return decodeGenesis((0, encodings_1.assertObject)(response.result.genesis));
      }
      static decodeHealth() {
        return null;
      }
      static decodeNumUnconfirmedTxs(response) {
        return decodeNumUnconfirmedTxs(response.result);
      }
      static decodeStatus(response) {
        return decodeStatus(response.result);
      }
      static decodeNewBlockEvent(event) {
        return decodeBlock(event.data.value.block);
      }
      static decodeNewBlockHeaderEvent(event) {
        return decodeHeader(event.data.value.header);
      }
      static decodeTxEvent(event) {
        return decodeTxEvent(event.data.value.TxResult);
      }
      static decodeTx(response) {
        return decodeTxResponse(response.result);
      }
      static decodeTxSearch(response) {
        return decodeTxSearch(response.result);
      }
      static decodeValidators(response) {
        return decodeValidators(response.result);
      }
    };
    exports.Responses = Responses;
  }
});

// ../../node_modules/.pnpm/@cosmjs+tendermint-rpc@0.32.4/node_modules/@cosmjs/tendermint-rpc/build/comet38/adaptor/index.js
var require_adaptor = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+tendermint-rpc@0.32.4/node_modules/@cosmjs/tendermint-rpc/build/comet38/adaptor/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Responses = exports.Params = void 0;
    var requests_1 = require_requests2();
    Object.defineProperty(exports, "Params", { enumerable: true, get: function() {
      return requests_1.Params;
    } });
    var responses_1 = require_responses();
    Object.defineProperty(exports, "Responses", { enumerable: true, get: function() {
      return responses_1.Responses;
    } });
  }
});

// ../../node_modules/.pnpm/@cosmjs+tendermint-rpc@0.32.4/node_modules/@cosmjs/tendermint-rpc/build/comet38/comet38client.js
var require_comet38client = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+tendermint-rpc@0.32.4/node_modules/@cosmjs/tendermint-rpc/build/comet38/comet38client.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Comet38Client = void 0;
    var jsonrpc_1 = require_jsonrpc();
    var rpcclients_1 = require_rpcclients();
    var adaptor_1 = require_adaptor();
    var requests = __importStar(require_requests());
    var Comet38Client = class _Comet38Client {
      /**
       * Creates a new Tendermint client for the given endpoint.
       *
       * Uses HTTP when the URL schema is http or https. Uses WebSockets otherwise.
       */
      static async connect(endpoint) {
        let rpcClient;
        if (typeof endpoint === "object") {
          rpcClient = new rpcclients_1.HttpClient(endpoint);
        } else {
          const useHttp = endpoint.startsWith("http://") || endpoint.startsWith("https://");
          rpcClient = useHttp ? new rpcclients_1.HttpClient(endpoint) : new rpcclients_1.WebsocketClient(endpoint);
        }
        const _version = await this.detectVersion(rpcClient);
        return _Comet38Client.create(rpcClient);
      }
      /**
       * Creates a new Tendermint client given an RPC client.
       */
      static async create(rpcClient) {
        return new _Comet38Client(rpcClient);
      }
      static async detectVersion(client) {
        const req = (0, jsonrpc_1.createJsonRpcRequest)(requests.Method.Status);
        const response = await client.execute(req);
        const result = response.result;
        if (!result || !result.node_info) {
          throw new Error("Unrecognized format for status response");
        }
        const version = result.node_info.version;
        if (typeof version !== "string") {
          throw new Error("Unrecognized version format: must be string");
        }
        return version;
      }
      /**
       * Use `Tendermint37Client.connect` or `Tendermint37Client.create` to create an instance.
       */
      constructor(client) {
        this.client = client;
      }
      disconnect() {
        this.client.disconnect();
      }
      async abciInfo() {
        const query = { method: requests.Method.AbciInfo };
        return this.doCall(query, adaptor_1.Params.encodeAbciInfo, adaptor_1.Responses.decodeAbciInfo);
      }
      async abciQuery(params) {
        const query = { params, method: requests.Method.AbciQuery };
        return this.doCall(query, adaptor_1.Params.encodeAbciQuery, adaptor_1.Responses.decodeAbciQuery);
      }
      async block(height) {
        const query = { method: requests.Method.Block, params: { height } };
        return this.doCall(query, adaptor_1.Params.encodeBlock, adaptor_1.Responses.decodeBlock);
      }
      async blockResults(height) {
        const query = {
          method: requests.Method.BlockResults,
          params: { height }
        };
        return this.doCall(query, adaptor_1.Params.encodeBlockResults, adaptor_1.Responses.decodeBlockResults);
      }
      /**
       * Search for events that are in a block.
       *
       * NOTE
       * This method will error on any node that is running a Tendermint version lower than 0.34.9.
       *
       * @see https://docs.tendermint.com/master/rpc/#/Info/block_search
       */
      async blockSearch(params) {
        const query = { params, method: requests.Method.BlockSearch };
        const resp = await this.doCall(query, adaptor_1.Params.encodeBlockSearch, adaptor_1.Responses.decodeBlockSearch);
        return {
          ...resp,
          // make sure we sort by height, as tendermint may be sorting by string value of the height
          blocks: [...resp.blocks].sort((a, b) => a.block.header.height - b.block.header.height)
        };
      }
      // this should paginate through all blockSearch options to ensure it returns all results.
      // starts with page 1 or whatever was provided (eg. to start on page 7)
      //
      // NOTE
      // This method will error on any node that is running a Tendermint version lower than 0.34.9.
      async blockSearchAll(params) {
        let page = params.page || 1;
        const blocks = [];
        let done = false;
        while (!done) {
          const resp = await this.blockSearch({ ...params, page });
          blocks.push(...resp.blocks);
          if (blocks.length < resp.totalCount) {
            page++;
          } else {
            done = true;
          }
        }
        blocks.sort((a, b) => a.block.header.height - b.block.header.height);
        return {
          totalCount: blocks.length,
          blocks
        };
      }
      /**
       * Queries block headers filtered by minHeight <= height <= maxHeight.
       *
       * @param minHeight The minimum height to be included in the result. Defaults to 0.
       * @param maxHeight The maximum height to be included in the result. Defaults to infinity.
       */
      async blockchain(minHeight, maxHeight) {
        const query = {
          method: requests.Method.Blockchain,
          params: {
            minHeight,
            maxHeight
          }
        };
        return this.doCall(query, adaptor_1.Params.encodeBlockchain, adaptor_1.Responses.decodeBlockchain);
      }
      /**
       * Broadcast transaction to mempool and wait for response
       *
       * @see https://docs.tendermint.com/master/rpc/#/Tx/broadcast_tx_sync
       */
      async broadcastTxSync(params) {
        const query = { params, method: requests.Method.BroadcastTxSync };
        return this.doCall(query, adaptor_1.Params.encodeBroadcastTx, adaptor_1.Responses.decodeBroadcastTxSync);
      }
      /**
       * Broadcast transaction to mempool and do not wait for result
       *
       * @see https://docs.tendermint.com/master/rpc/#/Tx/broadcast_tx_async
       */
      async broadcastTxAsync(params) {
        const query = { params, method: requests.Method.BroadcastTxAsync };
        return this.doCall(query, adaptor_1.Params.encodeBroadcastTx, adaptor_1.Responses.decodeBroadcastTxAsync);
      }
      /**
       * Broadcast transaction to mempool and wait for block
       *
       * @see https://docs.tendermint.com/master/rpc/#/Tx/broadcast_tx_commit
       */
      async broadcastTxCommit(params) {
        const query = { params, method: requests.Method.BroadcastTxCommit };
        return this.doCall(query, adaptor_1.Params.encodeBroadcastTx, adaptor_1.Responses.decodeBroadcastTxCommit);
      }
      async commit(height) {
        const query = { method: requests.Method.Commit, params: { height } };
        return this.doCall(query, adaptor_1.Params.encodeCommit, adaptor_1.Responses.decodeCommit);
      }
      async genesis() {
        const query = { method: requests.Method.Genesis };
        return this.doCall(query, adaptor_1.Params.encodeGenesis, adaptor_1.Responses.decodeGenesis);
      }
      async health() {
        const query = { method: requests.Method.Health };
        return this.doCall(query, adaptor_1.Params.encodeHealth, adaptor_1.Responses.decodeHealth);
      }
      async numUnconfirmedTxs() {
        const query = { method: requests.Method.NumUnconfirmedTxs };
        return this.doCall(query, adaptor_1.Params.encodeNumUnconfirmedTxs, adaptor_1.Responses.decodeNumUnconfirmedTxs);
      }
      async status() {
        const query = { method: requests.Method.Status };
        return this.doCall(query, adaptor_1.Params.encodeStatus, adaptor_1.Responses.decodeStatus);
      }
      subscribeNewBlock() {
        const request = {
          method: requests.Method.Subscribe,
          query: { type: requests.SubscriptionEventType.NewBlock }
        };
        return this.subscribe(request, adaptor_1.Responses.decodeNewBlockEvent);
      }
      subscribeNewBlockHeader() {
        const request = {
          method: requests.Method.Subscribe,
          query: { type: requests.SubscriptionEventType.NewBlockHeader }
        };
        return this.subscribe(request, adaptor_1.Responses.decodeNewBlockHeaderEvent);
      }
      subscribeTx(query) {
        const request = {
          method: requests.Method.Subscribe,
          query: {
            type: requests.SubscriptionEventType.Tx,
            raw: query
          }
        };
        return this.subscribe(request, adaptor_1.Responses.decodeTxEvent);
      }
      /**
       * Get a single transaction by hash
       *
       * @see https://docs.tendermint.com/master/rpc/#/Info/tx
       */
      async tx(params) {
        const query = { params, method: requests.Method.Tx };
        return this.doCall(query, adaptor_1.Params.encodeTx, adaptor_1.Responses.decodeTx);
      }
      /**
       * Search for transactions that are in a block
       *
       * @see https://docs.tendermint.com/master/rpc/#/Info/tx_search
       */
      async txSearch(params) {
        const query = { params, method: requests.Method.TxSearch };
        return this.doCall(query, adaptor_1.Params.encodeTxSearch, adaptor_1.Responses.decodeTxSearch);
      }
      // this should paginate through all txSearch options to ensure it returns all results.
      // starts with page 1 or whatever was provided (eg. to start on page 7)
      async txSearchAll(params) {
        let page = params.page || 1;
        const txs = [];
        let done = false;
        while (!done) {
          const resp = await this.txSearch({ ...params, page });
          txs.push(...resp.txs);
          if (txs.length < resp.totalCount) {
            page++;
          } else {
            done = true;
          }
        }
        return {
          totalCount: txs.length,
          txs
        };
      }
      async validators(params) {
        const query = {
          method: requests.Method.Validators,
          params
        };
        return this.doCall(query, adaptor_1.Params.encodeValidators, adaptor_1.Responses.decodeValidators);
      }
      async validatorsAll(height) {
        const validators = [];
        let page = 1;
        let done = false;
        let blockHeight = height;
        while (!done) {
          const response = await this.validators({
            per_page: 50,
            height: blockHeight,
            page
          });
          validators.push(...response.validators);
          blockHeight = blockHeight || response.blockHeight;
          if (validators.length < response.total) {
            page++;
          } else {
            done = true;
          }
        }
        return {
          // NOTE: Default value is for type safety but this should always be set
          blockHeight: blockHeight ?? 0,
          count: validators.length,
          total: validators.length,
          validators
        };
      }
      // doCall is a helper to handle the encode/call/decode logic
      async doCall(request, encode, decode) {
        const req = encode(request);
        const result = await this.client.execute(req);
        return decode(result);
      }
      subscribe(request, decode) {
        if (!(0, rpcclients_1.instanceOfRpcStreamingClient)(this.client)) {
          throw new Error("This RPC client type cannot subscribe to events");
        }
        const req = adaptor_1.Params.encodeSubscribe(request);
        const eventStream = this.client.listen(req);
        return eventStream.map((event) => {
          return decode(event);
        });
      }
    };
    exports.Comet38Client = Comet38Client;
  }
});

// ../../node_modules/.pnpm/@cosmjs+tendermint-rpc@0.32.4/node_modules/@cosmjs/tendermint-rpc/build/comet38/responses.js
var require_responses2 = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+tendermint-rpc@0.32.4/node_modules/@cosmjs/tendermint-rpc/build/comet38/responses.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.VoteType = exports.broadcastTxCommitSuccess = exports.broadcastTxSyncSuccess = void 0;
    function broadcastTxSyncSuccess(res) {
      return res.code === 0;
    }
    exports.broadcastTxSyncSuccess = broadcastTxSyncSuccess;
    function broadcastTxCommitSuccess(response) {
      return response.checkTx.code === 0 && !!response.deliverTx && response.deliverTx.code === 0;
    }
    exports.broadcastTxCommitSuccess = broadcastTxCommitSuccess;
    var VoteType;
    (function(VoteType2) {
      VoteType2[VoteType2["PreVote"] = 1] = "PreVote";
      VoteType2[VoteType2["PreCommit"] = 2] = "PreCommit";
    })(VoteType = exports.VoteType || (exports.VoteType = {}));
  }
});

// ../../node_modules/.pnpm/@cosmjs+tendermint-rpc@0.32.4/node_modules/@cosmjs/tendermint-rpc/build/comet38/index.js
var require_comet38 = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+tendermint-rpc@0.32.4/node_modules/@cosmjs/tendermint-rpc/build/comet38/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.VoteType = exports.broadcastTxSyncSuccess = exports.broadcastTxCommitSuccess = exports.SubscriptionEventType = exports.Method = exports.Comet38Client = void 0;
    var comet38client_1 = require_comet38client();
    Object.defineProperty(exports, "Comet38Client", { enumerable: true, get: function() {
      return comet38client_1.Comet38Client;
    } });
    var requests_1 = require_requests();
    Object.defineProperty(exports, "Method", { enumerable: true, get: function() {
      return requests_1.Method;
    } });
    Object.defineProperty(exports, "SubscriptionEventType", { enumerable: true, get: function() {
      return requests_1.SubscriptionEventType;
    } });
    var responses_1 = require_responses2();
    Object.defineProperty(exports, "broadcastTxCommitSuccess", { enumerable: true, get: function() {
      return responses_1.broadcastTxCommitSuccess;
    } });
    Object.defineProperty(exports, "broadcastTxSyncSuccess", { enumerable: true, get: function() {
      return responses_1.broadcastTxSyncSuccess;
    } });
    Object.defineProperty(exports, "VoteType", { enumerable: true, get: function() {
      return responses_1.VoteType;
    } });
  }
});

// ../../node_modules/.pnpm/@cosmjs+tendermint-rpc@0.32.4/node_modules/@cosmjs/tendermint-rpc/build/tendermint34/requests.js
var require_requests3 = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+tendermint-rpc@0.32.4/node_modules/@cosmjs/tendermint-rpc/build/tendermint34/requests.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.buildQuery = exports.SubscriptionEventType = exports.Method = void 0;
    var Method;
    (function(Method2) {
      Method2["AbciInfo"] = "abci_info";
      Method2["AbciQuery"] = "abci_query";
      Method2["Block"] = "block";
      Method2["Blockchain"] = "blockchain";
      Method2["BlockResults"] = "block_results";
      Method2["BlockSearch"] = "block_search";
      Method2["BroadcastTxAsync"] = "broadcast_tx_async";
      Method2["BroadcastTxSync"] = "broadcast_tx_sync";
      Method2["BroadcastTxCommit"] = "broadcast_tx_commit";
      Method2["Commit"] = "commit";
      Method2["Genesis"] = "genesis";
      Method2["Health"] = "health";
      Method2["NumUnconfirmedTxs"] = "num_unconfirmed_txs";
      Method2["Status"] = "status";
      Method2["Subscribe"] = "subscribe";
      Method2["Tx"] = "tx";
      Method2["TxSearch"] = "tx_search";
      Method2["Validators"] = "validators";
      Method2["Unsubscribe"] = "unsubscribe";
    })(Method = exports.Method || (exports.Method = {}));
    var SubscriptionEventType;
    (function(SubscriptionEventType2) {
      SubscriptionEventType2["NewBlock"] = "NewBlock";
      SubscriptionEventType2["NewBlockHeader"] = "NewBlockHeader";
      SubscriptionEventType2["Tx"] = "Tx";
    })(SubscriptionEventType = exports.SubscriptionEventType || (exports.SubscriptionEventType = {}));
    function buildQuery(components) {
      const tags = components.tags ? components.tags : [];
      const tagComponents = tags.map((tag) => `${tag.key}='${tag.value}'`);
      const rawComponents = components.raw ? [components.raw] : [];
      return [...tagComponents, ...rawComponents].join(" AND ");
    }
    exports.buildQuery = buildQuery;
  }
});

// ../../node_modules/.pnpm/@cosmjs+tendermint-rpc@0.32.4/node_modules/@cosmjs/tendermint-rpc/build/tendermint34/responses.js
var require_responses3 = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+tendermint-rpc@0.32.4/node_modules/@cosmjs/tendermint-rpc/build/tendermint34/responses.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.VoteType = exports.broadcastTxCommitSuccess = exports.broadcastTxSyncSuccess = void 0;
    function broadcastTxSyncSuccess(res) {
      return res.code === 0;
    }
    exports.broadcastTxSyncSuccess = broadcastTxSyncSuccess;
    function broadcastTxCommitSuccess(response) {
      return response.checkTx.code === 0 && !!response.deliverTx && response.deliverTx.code === 0;
    }
    exports.broadcastTxCommitSuccess = broadcastTxCommitSuccess;
    var VoteType;
    (function(VoteType2) {
      VoteType2[VoteType2["PreVote"] = 1] = "PreVote";
      VoteType2[VoteType2["PreCommit"] = 2] = "PreCommit";
    })(VoteType = exports.VoteType || (exports.VoteType = {}));
  }
});

// ../../node_modules/.pnpm/@cosmjs+tendermint-rpc@0.32.4/node_modules/@cosmjs/tendermint-rpc/build/tendermint34/adaptor/requests.js
var require_requests4 = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+tendermint-rpc@0.32.4/node_modules/@cosmjs/tendermint-rpc/build/tendermint34/adaptor/requests.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Params = void 0;
    var encoding_1 = require_build2();
    var inthelpers_1 = require_inthelpers();
    var jsonrpc_1 = require_jsonrpc();
    var encodings_1 = require_encodings();
    var requests = __importStar(require_requests3());
    function encodeHeightParam(param) {
      return {
        height: (0, encodings_1.may)(inthelpers_1.smallIntToApi, param.height)
      };
    }
    function encodeBlockchainRequestParams(param) {
      return {
        minHeight: (0, encodings_1.may)(inthelpers_1.smallIntToApi, param.minHeight),
        maxHeight: (0, encodings_1.may)(inthelpers_1.smallIntToApi, param.maxHeight)
      };
    }
    function encodeBlockSearchParams(params) {
      return {
        query: params.query,
        page: (0, encodings_1.may)(inthelpers_1.smallIntToApi, params.page),
        per_page: (0, encodings_1.may)(inthelpers_1.smallIntToApi, params.per_page),
        order_by: params.order_by
      };
    }
    function encodeAbciQueryParams(params) {
      return {
        path: (0, encodings_1.assertNotEmpty)(params.path),
        data: (0, encoding_1.toHex)(params.data),
        height: (0, encodings_1.may)(inthelpers_1.smallIntToApi, params.height),
        prove: params.prove
      };
    }
    function encodeBroadcastTxParams(params) {
      return {
        tx: (0, encoding_1.toBase64)((0, encodings_1.assertNotEmpty)(params.tx))
      };
    }
    function encodeTxParams(params) {
      return {
        hash: (0, encoding_1.toBase64)((0, encodings_1.assertNotEmpty)(params.hash)),
        prove: params.prove
      };
    }
    function encodeTxSearchParams(params) {
      return {
        query: params.query,
        prove: params.prove,
        page: (0, encodings_1.may)(inthelpers_1.smallIntToApi, params.page),
        per_page: (0, encodings_1.may)(inthelpers_1.smallIntToApi, params.per_page),
        order_by: params.order_by
      };
    }
    function encodeValidatorsParams(params) {
      return {
        height: (0, encodings_1.may)(inthelpers_1.smallIntToApi, params.height),
        page: (0, encodings_1.may)(inthelpers_1.smallIntToApi, params.page),
        per_page: (0, encodings_1.may)(inthelpers_1.smallIntToApi, params.per_page)
      };
    }
    var Params = class {
      static encodeAbciInfo(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method);
      }
      static encodeAbciQuery(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeAbciQueryParams(req.params));
      }
      static encodeBlock(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeHeightParam(req.params));
      }
      static encodeBlockchain(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeBlockchainRequestParams(req.params));
      }
      static encodeBlockResults(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeHeightParam(req.params));
      }
      static encodeBlockSearch(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeBlockSearchParams(req.params));
      }
      static encodeBroadcastTx(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeBroadcastTxParams(req.params));
      }
      static encodeCommit(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeHeightParam(req.params));
      }
      static encodeGenesis(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method);
      }
      static encodeHealth(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method);
      }
      static encodeNumUnconfirmedTxs(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method);
      }
      static encodeStatus(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method);
      }
      static encodeSubscribe(req) {
        const eventTag = { key: "tm.event", value: req.query.type };
        const query = requests.buildQuery({ tags: [eventTag], raw: req.query.raw });
        return (0, jsonrpc_1.createJsonRpcRequest)("subscribe", { query });
      }
      static encodeTx(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeTxParams(req.params));
      }
      // TODO: encode params for query string???
      static encodeTxSearch(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeTxSearchParams(req.params));
      }
      static encodeValidators(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeValidatorsParams(req.params));
      }
    };
    exports.Params = Params;
  }
});

// ../../node_modules/.pnpm/@cosmjs+tendermint-rpc@0.32.4/node_modules/@cosmjs/tendermint-rpc/build/tendermint34/hasher.js
var require_hasher2 = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+tendermint-rpc@0.32.4/node_modules/@cosmjs/tendermint-rpc/build/tendermint34/hasher.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.hashBlock = exports.hashTx = void 0;
    var crypto_1 = require_build4();
    var encodings_1 = require_encodings();
    function hashTx(tx) {
      return (0, crypto_1.sha256)(tx);
    }
    exports.hashTx = hashTx;
    function getSplitPoint(n) {
      if (n < 1)
        throw new Error("Cannot split an empty tree");
      const largestPowerOf2 = 2 ** Math.floor(Math.log2(n));
      return largestPowerOf2 < n ? largestPowerOf2 : largestPowerOf2 / 2;
    }
    function hashLeaf(leaf) {
      const hash = new crypto_1.Sha256(Uint8Array.from([0]));
      hash.update(leaf);
      return hash.digest();
    }
    function hashInner(left, right) {
      const hash = new crypto_1.Sha256(Uint8Array.from([1]));
      hash.update(left);
      hash.update(right);
      return hash.digest();
    }
    function hashTree(hashes) {
      switch (hashes.length) {
        case 0:
          throw new Error("Cannot hash empty tree");
        case 1:
          return hashLeaf(hashes[0]);
        default: {
          const slicePoint = getSplitPoint(hashes.length);
          const left = hashTree(hashes.slice(0, slicePoint));
          const right = hashTree(hashes.slice(slicePoint));
          return hashInner(left, right);
        }
      }
    }
    function hashBlock(header) {
      if (!header.lastBlockId) {
        throw new Error("Hashing a block header with no last block ID (i.e. header at height 1) is not supported. If you need this, contributions are welcome. Please add documentation and test vectors for this case.");
      }
      const encodedFields = [
        (0, encodings_1.encodeVersion)(header.version),
        (0, encodings_1.encodeString)(header.chainId),
        (0, encodings_1.encodeUvarint)(header.height),
        (0, encodings_1.encodeTime)(header.time),
        (0, encodings_1.encodeBlockId)(header.lastBlockId),
        (0, encodings_1.encodeBytes)(header.lastCommitHash),
        (0, encodings_1.encodeBytes)(header.dataHash),
        (0, encodings_1.encodeBytes)(header.validatorsHash),
        (0, encodings_1.encodeBytes)(header.nextValidatorsHash),
        (0, encodings_1.encodeBytes)(header.consensusHash),
        (0, encodings_1.encodeBytes)(header.appHash),
        (0, encodings_1.encodeBytes)(header.lastResultsHash),
        (0, encodings_1.encodeBytes)(header.evidenceHash),
        (0, encodings_1.encodeBytes)(header.proposerAddress)
      ];
      return hashTree(encodedFields);
    }
    exports.hashBlock = hashBlock;
  }
});

// ../../node_modules/.pnpm/@cosmjs+tendermint-rpc@0.32.4/node_modules/@cosmjs/tendermint-rpc/build/tendermint34/adaptor/responses.js
var require_responses4 = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+tendermint-rpc@0.32.4/node_modules/@cosmjs/tendermint-rpc/build/tendermint34/adaptor/responses.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Responses = exports.decodeValidatorInfo = exports.decodeValidatorGenesis = exports.decodeValidatorUpdate = exports.decodeEvent = void 0;
    var encoding_1 = require_build2();
    var utils_1 = require_build3();
    var dates_1 = require_dates();
    var inthelpers_1 = require_inthelpers();
    var types_1 = require_types2();
    var encodings_1 = require_encodings();
    var hasher_1 = require_hasher2();
    function decodeAbciInfo(data) {
      return {
        data: data.data,
        lastBlockHeight: (0, encodings_1.may)(inthelpers_1.apiToSmallInt, data.last_block_height),
        lastBlockAppHash: (0, encodings_1.may)(encoding_1.fromBase64, data.last_block_app_hash)
      };
    }
    function decodeQueryProof(data) {
      return {
        ops: data.ops.map((op) => ({
          type: op.type,
          key: (0, encoding_1.fromBase64)(op.key),
          data: (0, encoding_1.fromBase64)(op.data)
        }))
      };
    }
    function decodeAbciQuery(data) {
      return {
        key: (0, encoding_1.fromBase64)((0, encodings_1.assertString)(data.key ?? "")),
        value: (0, encoding_1.fromBase64)((0, encodings_1.assertString)(data.value ?? "")),
        proof: (0, encodings_1.may)(decodeQueryProof, data.proofOps),
        height: (0, encodings_1.may)(inthelpers_1.apiToSmallInt, data.height),
        code: (0, encodings_1.may)(inthelpers_1.apiToSmallInt, data.code),
        codespace: (0, encodings_1.assertString)(data.codespace ?? ""),
        index: (0, encodings_1.may)(inthelpers_1.apiToSmallInt, data.index),
        log: data.log,
        info: (0, encodings_1.assertString)(data.info ?? "")
      };
    }
    function decodeAttribute(attribute) {
      return {
        key: (0, encoding_1.fromBase64)((0, encodings_1.assertNotEmpty)(attribute.key)),
        value: (0, encoding_1.fromBase64)((0, encodings_1.assertString)(attribute.value ?? ""))
      };
    }
    function decodeAttributes(attributes) {
      return (0, encodings_1.assertArray)(attributes).map(decodeAttribute);
    }
    function decodeEvent(event) {
      return {
        type: event.type,
        attributes: event.attributes ? decodeAttributes(event.attributes) : []
      };
    }
    exports.decodeEvent = decodeEvent;
    function decodeEvents(events) {
      return (0, encodings_1.assertArray)(events).map(decodeEvent);
    }
    function decodeTxData(data) {
      return {
        code: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNumber)(data.code ?? 0)),
        codespace: data.codespace,
        log: data.log,
        data: (0, encodings_1.may)(encoding_1.fromBase64, data.data),
        events: data.events ? decodeEvents(data.events) : [],
        gasWanted: (0, inthelpers_1.apiToBigInt)(data.gas_wanted ?? "0"),
        gasUsed: (0, inthelpers_1.apiToBigInt)(data.gas_used ?? "0")
      };
    }
    function decodePubkey(data) {
      if ("Sum" in data) {
        const [[algorithm, value]] = Object.entries(data.Sum.value);
        (0, utils_1.assert)(algorithm === "ed25519" || algorithm === "secp256k1", `unknown pubkey type: ${algorithm}`);
        return {
          algorithm,
          data: (0, encoding_1.fromBase64)((0, encodings_1.assertNotEmpty)(value))
        };
      } else {
        switch (data.type) {
          case "tendermint/PubKeyEd25519":
            return {
              algorithm: "ed25519",
              data: (0, encoding_1.fromBase64)((0, encodings_1.assertNotEmpty)(data.value))
            };
          case "tendermint/PubKeySecp256k1":
            return {
              algorithm: "secp256k1",
              data: (0, encoding_1.fromBase64)((0, encodings_1.assertNotEmpty)(data.value))
            };
          default:
            throw new Error(`unknown pubkey type: ${data.type}`);
        }
      }
    }
    function decodeBlockParams(data) {
      return {
        maxBytes: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.max_bytes)),
        maxGas: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.max_gas))
      };
    }
    function decodeEvidenceParams(data) {
      return {
        maxAgeNumBlocks: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.max_age_num_blocks)),
        maxAgeDuration: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.max_age_duration))
      };
    }
    function decodeConsensusParams(data) {
      return {
        block: decodeBlockParams((0, encodings_1.assertObject)(data.block)),
        evidence: decodeEvidenceParams((0, encodings_1.assertObject)(data.evidence))
      };
    }
    function decodeValidatorUpdate(data) {
      return {
        pubkey: decodePubkey((0, encodings_1.assertObject)(data.pub_key)),
        votingPower: (0, inthelpers_1.apiToBigInt)(data.power ?? "0")
      };
    }
    exports.decodeValidatorUpdate = decodeValidatorUpdate;
    function decodeBlockResults(data) {
      return {
        height: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.height)),
        results: (data.txs_results || []).map(decodeTxData),
        validatorUpdates: (data.validator_updates || []).map(decodeValidatorUpdate),
        consensusUpdates: (0, encodings_1.may)(decodeConsensusParams, data.consensus_param_updates),
        beginBlockEvents: decodeEvents(data.begin_block_events || []),
        endBlockEvents: decodeEvents(data.end_block_events || [])
      };
    }
    function decodeBlockId(data) {
      return {
        hash: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data.hash)),
        parts: {
          total: (0, encodings_1.assertNotEmpty)(data.parts.total),
          hash: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data.parts.hash))
        }
      };
    }
    function decodeBlockVersion(data) {
      return {
        block: (0, inthelpers_1.apiToSmallInt)(data.block),
        app: (0, inthelpers_1.apiToSmallInt)(data.app ?? 0)
      };
    }
    function decodeHeader(data) {
      return {
        version: decodeBlockVersion(data.version),
        chainId: (0, encodings_1.assertNotEmpty)(data.chain_id),
        height: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.height)),
        time: (0, dates_1.fromRfc3339WithNanoseconds)((0, encodings_1.assertNotEmpty)(data.time)),
        // When there is no last block ID (i.e. this block's height is 1), we get an empty structure like this:
        // { hash: '', parts: { total: 0, hash: '' } }
        lastBlockId: data.last_block_id.hash ? decodeBlockId(data.last_block_id) : null,
        lastCommitHash: (0, encoding_1.fromHex)((0, encodings_1.assertSet)(data.last_commit_hash)),
        dataHash: (0, encoding_1.fromHex)((0, encodings_1.assertSet)(data.data_hash)),
        validatorsHash: (0, encoding_1.fromHex)((0, encodings_1.assertSet)(data.validators_hash)),
        nextValidatorsHash: (0, encoding_1.fromHex)((0, encodings_1.assertSet)(data.next_validators_hash)),
        consensusHash: (0, encoding_1.fromHex)((0, encodings_1.assertSet)(data.consensus_hash)),
        appHash: (0, encoding_1.fromHex)((0, encodings_1.assertSet)(data.app_hash)),
        lastResultsHash: (0, encoding_1.fromHex)((0, encodings_1.assertSet)(data.last_results_hash)),
        evidenceHash: (0, encoding_1.fromHex)((0, encodings_1.assertSet)(data.evidence_hash)),
        proposerAddress: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data.proposer_address))
      };
    }
    function decodeBlockMeta(data) {
      return {
        blockId: decodeBlockId(data.block_id),
        blockSize: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.block_size)),
        header: decodeHeader(data.header),
        numTxs: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.num_txs))
      };
    }
    function decodeBlockchain(data) {
      return {
        lastHeight: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.last_height)),
        blockMetas: (0, encodings_1.assertArray)(data.block_metas).map(decodeBlockMeta)
      };
    }
    function decodeBroadcastTxSync(data) {
      return {
        ...decodeTxData(data),
        hash: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data.hash))
      };
    }
    function decodeBroadcastTxCommit(data) {
      return {
        height: (0, inthelpers_1.apiToSmallInt)(data.height),
        hash: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data.hash)),
        checkTx: decodeTxData((0, encodings_1.assertObject)(data.check_tx)),
        deliverTx: (0, encodings_1.may)(decodeTxData, data.deliver_tx)
      };
    }
    function decodeBlockIdFlag(blockIdFlag) {
      (0, utils_1.assert)(blockIdFlag in types_1.BlockIdFlag);
      return blockIdFlag;
    }
    function decodeCommitSignature(data) {
      return {
        blockIdFlag: decodeBlockIdFlag(data.block_id_flag),
        validatorAddress: data.validator_address ? (0, encoding_1.fromHex)(data.validator_address) : void 0,
        timestamp: data.timestamp ? (0, dates_1.fromRfc3339WithNanoseconds)(data.timestamp) : void 0,
        signature: data.signature ? (0, encoding_1.fromBase64)(data.signature) : void 0
      };
    }
    function decodeCommit(data) {
      return {
        blockId: decodeBlockId((0, encodings_1.assertObject)(data.block_id)),
        height: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.height)),
        round: (0, inthelpers_1.apiToSmallInt)(data.round),
        signatures: (0, encodings_1.assertArray)(data.signatures).map(decodeCommitSignature)
      };
    }
    function decodeCommitResponse(data) {
      return {
        canonical: (0, encodings_1.assertBoolean)(data.canonical),
        header: decodeHeader(data.signed_header.header),
        commit: decodeCommit(data.signed_header.commit)
      };
    }
    function decodeValidatorGenesis(data) {
      return {
        address: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data.address)),
        pubkey: decodePubkey((0, encodings_1.assertObject)(data.pub_key)),
        votingPower: (0, inthelpers_1.apiToBigInt)((0, encodings_1.assertNotEmpty)(data.power))
      };
    }
    exports.decodeValidatorGenesis = decodeValidatorGenesis;
    function decodeGenesis(data) {
      return {
        genesisTime: (0, dates_1.fromRfc3339WithNanoseconds)((0, encodings_1.assertNotEmpty)(data.genesis_time)),
        chainId: (0, encodings_1.assertNotEmpty)(data.chain_id),
        consensusParams: decodeConsensusParams(data.consensus_params),
        validators: data.validators ? (0, encodings_1.assertArray)(data.validators).map(decodeValidatorGenesis) : [],
        appHash: (0, encoding_1.fromHex)((0, encodings_1.assertSet)(data.app_hash)),
        appState: data.app_state
      };
    }
    function decodeValidatorInfo(data) {
      return {
        pubkey: decodePubkey((0, encodings_1.assertObject)(data.pub_key)),
        votingPower: (0, inthelpers_1.apiToBigInt)((0, encodings_1.assertNotEmpty)(data.voting_power)),
        address: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data.address)),
        proposerPriority: data.proposer_priority ? (0, inthelpers_1.apiToSmallInt)(data.proposer_priority) : void 0
      };
    }
    exports.decodeValidatorInfo = decodeValidatorInfo;
    function decodeNodeInfo(data) {
      return {
        id: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data.id)),
        listenAddr: (0, encodings_1.assertNotEmpty)(data.listen_addr),
        network: (0, encodings_1.assertNotEmpty)(data.network),
        version: (0, encodings_1.assertString)(data.version),
        channels: (0, encodings_1.assertNotEmpty)(data.channels),
        moniker: (0, encodings_1.assertNotEmpty)(data.moniker),
        other: (0, encodings_1.dictionaryToStringMap)(data.other),
        protocolVersion: {
          app: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.protocol_version.app)),
          block: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.protocol_version.block)),
          p2p: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.protocol_version.p2p))
        }
      };
    }
    function decodeSyncInfo(data) {
      const earliestBlockHeight = data.earliest_block_height ? (0, inthelpers_1.apiToSmallInt)(data.earliest_block_height) : void 0;
      const earliestBlockTime = data.earliest_block_time ? (0, dates_1.fromRfc3339WithNanoseconds)(data.earliest_block_time) : void 0;
      return {
        earliestAppHash: data.earliest_app_hash ? (0, encoding_1.fromHex)(data.earliest_app_hash) : void 0,
        earliestBlockHash: data.earliest_block_hash ? (0, encoding_1.fromHex)(data.earliest_block_hash) : void 0,
        earliestBlockHeight: earliestBlockHeight || void 0,
        earliestBlockTime: (earliestBlockTime == null ? void 0 : earliestBlockTime.getTime()) ? earliestBlockTime : void 0,
        latestBlockHash: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data.latest_block_hash)),
        latestAppHash: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data.latest_app_hash)),
        latestBlockTime: (0, dates_1.fromRfc3339WithNanoseconds)((0, encodings_1.assertNotEmpty)(data.latest_block_time)),
        latestBlockHeight: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.latest_block_height)),
        catchingUp: (0, encodings_1.assertBoolean)(data.catching_up)
      };
    }
    function decodeStatus(data) {
      return {
        nodeInfo: decodeNodeInfo(data.node_info),
        syncInfo: decodeSyncInfo(data.sync_info),
        validatorInfo: decodeValidatorInfo(data.validator_info)
      };
    }
    function decodeTxProof(data) {
      return {
        data: (0, encoding_1.fromBase64)((0, encodings_1.assertNotEmpty)(data.data)),
        rootHash: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data.root_hash)),
        proof: {
          total: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.proof.total)),
          index: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.proof.index)),
          leafHash: (0, encoding_1.fromBase64)((0, encodings_1.assertNotEmpty)(data.proof.leaf_hash)),
          aunts: (0, encodings_1.assertArray)(data.proof.aunts).map(encoding_1.fromBase64)
        }
      };
    }
    function decodeTxResponse(data) {
      return {
        tx: (0, encoding_1.fromBase64)((0, encodings_1.assertNotEmpty)(data.tx)),
        result: decodeTxData((0, encodings_1.assertObject)(data.tx_result)),
        height: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.height)),
        index: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNumber)(data.index)),
        hash: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data.hash)),
        proof: (0, encodings_1.may)(decodeTxProof, data.proof)
      };
    }
    function decodeTxSearch(data) {
      return {
        totalCount: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.total_count)),
        txs: (0, encodings_1.assertArray)(data.txs).map(decodeTxResponse)
      };
    }
    function decodeTxEvent(data) {
      const tx = (0, encoding_1.fromBase64)((0, encodings_1.assertNotEmpty)(data.tx));
      return {
        tx,
        hash: (0, hasher_1.hashTx)(tx),
        result: decodeTxData(data.result),
        height: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.height))
      };
    }
    function decodeValidators(data) {
      return {
        blockHeight: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.block_height)),
        validators: (0, encodings_1.assertArray)(data.validators).map(decodeValidatorInfo),
        count: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.count)),
        total: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.total))
      };
    }
    function decodeBlock(data) {
      var _a;
      return {
        header: decodeHeader((0, encodings_1.assertObject)(data.header)),
        // For the block at height 1, last commit is not set. This is represented in an empty object like this:
        // { height: '0', round: 0, block_id: { hash: '', parts: [Object] }, signatures: [] }
        lastCommit: data.last_commit.block_id.hash ? decodeCommit((0, encodings_1.assertObject)(data.last_commit)) : null,
        txs: data.data.txs ? (0, encodings_1.assertArray)(data.data.txs).map(encoding_1.fromBase64) : [],
        // Lift up .evidence.evidence to just .evidence
        // See https://github.com/tendermint/tendermint/issues/7697
        evidence: ((_a = data.evidence) == null ? void 0 : _a.evidence) ?? []
      };
    }
    function decodeBlockResponse(data) {
      return {
        blockId: decodeBlockId(data.block_id),
        block: decodeBlock(data.block)
      };
    }
    function decodeBlockSearch(data) {
      return {
        totalCount: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.total_count)),
        blocks: (0, encodings_1.assertArray)(data.blocks).map(decodeBlockResponse)
      };
    }
    function decodeNumUnconfirmedTxs(data) {
      return {
        total: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.total)),
        totalBytes: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.total_bytes))
      };
    }
    var Responses = class _Responses {
      static decodeAbciInfo(response) {
        return decodeAbciInfo((0, encodings_1.assertObject)(response.result.response));
      }
      static decodeAbciQuery(response) {
        return decodeAbciQuery((0, encodings_1.assertObject)(response.result.response));
      }
      static decodeBlock(response) {
        return decodeBlockResponse(response.result);
      }
      static decodeBlockResults(response) {
        return decodeBlockResults(response.result);
      }
      static decodeBlockSearch(response) {
        return decodeBlockSearch(response.result);
      }
      static decodeBlockchain(response) {
        return decodeBlockchain(response.result);
      }
      static decodeBroadcastTxSync(response) {
        return decodeBroadcastTxSync(response.result);
      }
      static decodeBroadcastTxAsync(response) {
        return _Responses.decodeBroadcastTxSync(response);
      }
      static decodeBroadcastTxCommit(response) {
        return decodeBroadcastTxCommit(response.result);
      }
      static decodeCommit(response) {
        return decodeCommitResponse(response.result);
      }
      static decodeGenesis(response) {
        return decodeGenesis((0, encodings_1.assertObject)(response.result.genesis));
      }
      static decodeHealth() {
        return null;
      }
      static decodeNumUnconfirmedTxs(response) {
        return decodeNumUnconfirmedTxs(response.result);
      }
      static decodeStatus(response) {
        return decodeStatus(response.result);
      }
      static decodeNewBlockEvent(event) {
        return decodeBlock(event.data.value.block);
      }
      static decodeNewBlockHeaderEvent(event) {
        return decodeHeader(event.data.value.header);
      }
      static decodeTxEvent(event) {
        return decodeTxEvent(event.data.value.TxResult);
      }
      static decodeTx(response) {
        return decodeTxResponse(response.result);
      }
      static decodeTxSearch(response) {
        return decodeTxSearch(response.result);
      }
      static decodeValidators(response) {
        return decodeValidators(response.result);
      }
    };
    exports.Responses = Responses;
  }
});

// ../../node_modules/.pnpm/@cosmjs+tendermint-rpc@0.32.4/node_modules/@cosmjs/tendermint-rpc/build/tendermint34/adaptor/index.js
var require_adaptor2 = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+tendermint-rpc@0.32.4/node_modules/@cosmjs/tendermint-rpc/build/tendermint34/adaptor/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Responses = exports.Params = void 0;
    var requests_1 = require_requests4();
    Object.defineProperty(exports, "Params", { enumerable: true, get: function() {
      return requests_1.Params;
    } });
    var responses_1 = require_responses4();
    Object.defineProperty(exports, "Responses", { enumerable: true, get: function() {
      return responses_1.Responses;
    } });
  }
});

// ../../node_modules/.pnpm/@cosmjs+tendermint-rpc@0.32.4/node_modules/@cosmjs/tendermint-rpc/build/tendermint34/tendermint34client.js
var require_tendermint34client = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+tendermint-rpc@0.32.4/node_modules/@cosmjs/tendermint-rpc/build/tendermint34/tendermint34client.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Tendermint34Client = void 0;
    var jsonrpc_1 = require_jsonrpc();
    var rpcclients_1 = require_rpcclients();
    var adaptor_1 = require_adaptor2();
    var requests = __importStar(require_requests3());
    var Tendermint34Client = class _Tendermint34Client {
      /**
       * Creates a new Tendermint client for the given endpoint.
       *
       * Uses HTTP when the URL schema is http or https. Uses WebSockets otherwise.
       */
      static async connect(endpoint) {
        let rpcClient;
        if (typeof endpoint === "object") {
          rpcClient = new rpcclients_1.HttpClient(endpoint);
        } else {
          const useHttp = endpoint.startsWith("http://") || endpoint.startsWith("https://");
          rpcClient = useHttp ? new rpcclients_1.HttpClient(endpoint) : new rpcclients_1.WebsocketClient(endpoint);
        }
        const _version = await this.detectVersion(rpcClient);
        return _Tendermint34Client.create(rpcClient);
      }
      /**
       * Creates a new Tendermint client given an RPC client.
       */
      static async create(rpcClient) {
        return new _Tendermint34Client(rpcClient);
      }
      static async detectVersion(client) {
        const req = (0, jsonrpc_1.createJsonRpcRequest)(requests.Method.Status);
        const response = await client.execute(req);
        const result = response.result;
        if (!result || !result.node_info) {
          throw new Error("Unrecognized format for status response");
        }
        const version = result.node_info.version;
        if (typeof version !== "string") {
          throw new Error("Unrecognized version format: must be string");
        }
        return version;
      }
      /**
       * Use `Tendermint34Client.connect` or `Tendermint34Client.create` to create an instance.
       */
      constructor(client) {
        this.client = client;
      }
      disconnect() {
        this.client.disconnect();
      }
      async abciInfo() {
        const query = { method: requests.Method.AbciInfo };
        return this.doCall(query, adaptor_1.Params.encodeAbciInfo, adaptor_1.Responses.decodeAbciInfo);
      }
      async abciQuery(params) {
        const query = { params, method: requests.Method.AbciQuery };
        return this.doCall(query, adaptor_1.Params.encodeAbciQuery, adaptor_1.Responses.decodeAbciQuery);
      }
      async block(height) {
        const query = { method: requests.Method.Block, params: { height } };
        return this.doCall(query, adaptor_1.Params.encodeBlock, adaptor_1.Responses.decodeBlock);
      }
      async blockResults(height) {
        const query = {
          method: requests.Method.BlockResults,
          params: { height }
        };
        return this.doCall(query, adaptor_1.Params.encodeBlockResults, adaptor_1.Responses.decodeBlockResults);
      }
      /**
       * Search for events that are in a block.
       *
       * NOTE
       * This method will error on any node that is running a Tendermint version lower than 0.34.9.
       *
       * @see https://docs.tendermint.com/master/rpc/#/Info/block_search
       */
      async blockSearch(params) {
        const query = { params, method: requests.Method.BlockSearch };
        const resp = await this.doCall(query, adaptor_1.Params.encodeBlockSearch, adaptor_1.Responses.decodeBlockSearch);
        return {
          ...resp,
          // make sure we sort by height, as tendermint may be sorting by string value of the height
          blocks: [...resp.blocks].sort((a, b) => a.block.header.height - b.block.header.height)
        };
      }
      // this should paginate through all blockSearch options to ensure it returns all results.
      // starts with page 1 or whatever was provided (eg. to start on page 7)
      //
      // NOTE
      // This method will error on any node that is running a Tendermint version lower than 0.34.9.
      async blockSearchAll(params) {
        let page = params.page || 1;
        const blocks = [];
        let done = false;
        while (!done) {
          const resp = await this.blockSearch({ ...params, page });
          blocks.push(...resp.blocks);
          if (blocks.length < resp.totalCount) {
            page++;
          } else {
            done = true;
          }
        }
        blocks.sort((a, b) => a.block.header.height - b.block.header.height);
        return {
          totalCount: blocks.length,
          blocks
        };
      }
      /**
       * Queries block headers filtered by minHeight <= height <= maxHeight.
       *
       * @param minHeight The minimum height to be included in the result. Defaults to 0.
       * @param maxHeight The maximum height to be included in the result. Defaults to infinity.
       */
      async blockchain(minHeight, maxHeight) {
        const query = {
          method: requests.Method.Blockchain,
          params: {
            minHeight,
            maxHeight
          }
        };
        return this.doCall(query, adaptor_1.Params.encodeBlockchain, adaptor_1.Responses.decodeBlockchain);
      }
      /**
       * Broadcast transaction to mempool and wait for response
       *
       * @see https://docs.tendermint.com/master/rpc/#/Tx/broadcast_tx_sync
       */
      async broadcastTxSync(params) {
        const query = { params, method: requests.Method.BroadcastTxSync };
        return this.doCall(query, adaptor_1.Params.encodeBroadcastTx, adaptor_1.Responses.decodeBroadcastTxSync);
      }
      /**
       * Broadcast transaction to mempool and do not wait for result
       *
       * @see https://docs.tendermint.com/master/rpc/#/Tx/broadcast_tx_async
       */
      async broadcastTxAsync(params) {
        const query = { params, method: requests.Method.BroadcastTxAsync };
        return this.doCall(query, adaptor_1.Params.encodeBroadcastTx, adaptor_1.Responses.decodeBroadcastTxAsync);
      }
      /**
       * Broadcast transaction to mempool and wait for block
       *
       * @see https://docs.tendermint.com/master/rpc/#/Tx/broadcast_tx_commit
       */
      async broadcastTxCommit(params) {
        const query = { params, method: requests.Method.BroadcastTxCommit };
        return this.doCall(query, adaptor_1.Params.encodeBroadcastTx, adaptor_1.Responses.decodeBroadcastTxCommit);
      }
      async commit(height) {
        const query = { method: requests.Method.Commit, params: { height } };
        return this.doCall(query, adaptor_1.Params.encodeCommit, adaptor_1.Responses.decodeCommit);
      }
      async genesis() {
        const query = { method: requests.Method.Genesis };
        return this.doCall(query, adaptor_1.Params.encodeGenesis, adaptor_1.Responses.decodeGenesis);
      }
      async health() {
        const query = { method: requests.Method.Health };
        return this.doCall(query, adaptor_1.Params.encodeHealth, adaptor_1.Responses.decodeHealth);
      }
      async numUnconfirmedTxs() {
        const query = { method: requests.Method.NumUnconfirmedTxs };
        return this.doCall(query, adaptor_1.Params.encodeNumUnconfirmedTxs, adaptor_1.Responses.decodeNumUnconfirmedTxs);
      }
      async status() {
        const query = { method: requests.Method.Status };
        return this.doCall(query, adaptor_1.Params.encodeStatus, adaptor_1.Responses.decodeStatus);
      }
      subscribeNewBlock() {
        const request = {
          method: requests.Method.Subscribe,
          query: { type: requests.SubscriptionEventType.NewBlock }
        };
        return this.subscribe(request, adaptor_1.Responses.decodeNewBlockEvent);
      }
      subscribeNewBlockHeader() {
        const request = {
          method: requests.Method.Subscribe,
          query: { type: requests.SubscriptionEventType.NewBlockHeader }
        };
        return this.subscribe(request, adaptor_1.Responses.decodeNewBlockHeaderEvent);
      }
      subscribeTx(query) {
        const request = {
          method: requests.Method.Subscribe,
          query: {
            type: requests.SubscriptionEventType.Tx,
            raw: query
          }
        };
        return this.subscribe(request, adaptor_1.Responses.decodeTxEvent);
      }
      /**
       * Get a single transaction by hash
       *
       * @see https://docs.tendermint.com/master/rpc/#/Info/tx
       */
      async tx(params) {
        const query = { params, method: requests.Method.Tx };
        return this.doCall(query, adaptor_1.Params.encodeTx, adaptor_1.Responses.decodeTx);
      }
      /**
       * Search for transactions that are in a block
       *
       * @see https://docs.tendermint.com/master/rpc/#/Info/tx_search
       */
      async txSearch(params) {
        const query = { params, method: requests.Method.TxSearch };
        return this.doCall(query, adaptor_1.Params.encodeTxSearch, adaptor_1.Responses.decodeTxSearch);
      }
      // this should paginate through all txSearch options to ensure it returns all results.
      // starts with page 1 or whatever was provided (eg. to start on page 7)
      async txSearchAll(params) {
        let page = params.page || 1;
        const txs = [];
        let done = false;
        while (!done) {
          const resp = await this.txSearch({ ...params, page });
          txs.push(...resp.txs);
          if (txs.length < resp.totalCount) {
            page++;
          } else {
            done = true;
          }
        }
        return {
          totalCount: txs.length,
          txs
        };
      }
      async validators(params) {
        const query = {
          method: requests.Method.Validators,
          params
        };
        return this.doCall(query, adaptor_1.Params.encodeValidators, adaptor_1.Responses.decodeValidators);
      }
      async validatorsAll(height) {
        const validators = [];
        let page = 1;
        let done = false;
        let blockHeight = height;
        while (!done) {
          const response = await this.validators({
            per_page: 50,
            height: blockHeight,
            page
          });
          validators.push(...response.validators);
          blockHeight = blockHeight || response.blockHeight;
          if (validators.length < response.total) {
            page++;
          } else {
            done = true;
          }
        }
        return {
          // NOTE: Default value is for type safety but this should always be set
          blockHeight: blockHeight ?? 0,
          count: validators.length,
          total: validators.length,
          validators
        };
      }
      // doCall is a helper to handle the encode/call/decode logic
      async doCall(request, encode, decode) {
        const req = encode(request);
        const result = await this.client.execute(req);
        return decode(result);
      }
      subscribe(request, decode) {
        if (!(0, rpcclients_1.instanceOfRpcStreamingClient)(this.client)) {
          throw new Error("This RPC client type cannot subscribe to events");
        }
        const req = adaptor_1.Params.encodeSubscribe(request);
        const eventStream = this.client.listen(req);
        return eventStream.map((event) => {
          return decode(event);
        });
      }
    };
    exports.Tendermint34Client = Tendermint34Client;
  }
});

// ../../node_modules/.pnpm/@cosmjs+tendermint-rpc@0.32.4/node_modules/@cosmjs/tendermint-rpc/build/tendermint34/index.js
var require_tendermint34 = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+tendermint-rpc@0.32.4/node_modules/@cosmjs/tendermint-rpc/build/tendermint34/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Tendermint34Client = exports.VoteType = exports.broadcastTxSyncSuccess = exports.broadcastTxCommitSuccess = exports.SubscriptionEventType = exports.Method = void 0;
    var requests_1 = require_requests3();
    Object.defineProperty(exports, "Method", { enumerable: true, get: function() {
      return requests_1.Method;
    } });
    Object.defineProperty(exports, "SubscriptionEventType", { enumerable: true, get: function() {
      return requests_1.SubscriptionEventType;
    } });
    var responses_1 = require_responses3();
    Object.defineProperty(exports, "broadcastTxCommitSuccess", { enumerable: true, get: function() {
      return responses_1.broadcastTxCommitSuccess;
    } });
    Object.defineProperty(exports, "broadcastTxSyncSuccess", { enumerable: true, get: function() {
      return responses_1.broadcastTxSyncSuccess;
    } });
    Object.defineProperty(exports, "VoteType", { enumerable: true, get: function() {
      return responses_1.VoteType;
    } });
    var tendermint34client_1 = require_tendermint34client();
    Object.defineProperty(exports, "Tendermint34Client", { enumerable: true, get: function() {
      return tendermint34client_1.Tendermint34Client;
    } });
  }
});

// ../../node_modules/.pnpm/@cosmjs+tendermint-rpc@0.32.4/node_modules/@cosmjs/tendermint-rpc/build/tendermint37/requests.js
var require_requests5 = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+tendermint-rpc@0.32.4/node_modules/@cosmjs/tendermint-rpc/build/tendermint37/requests.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.buildQuery = exports.SubscriptionEventType = exports.Method = void 0;
    var Method;
    (function(Method2) {
      Method2["AbciInfo"] = "abci_info";
      Method2["AbciQuery"] = "abci_query";
      Method2["Block"] = "block";
      Method2["Blockchain"] = "blockchain";
      Method2["BlockResults"] = "block_results";
      Method2["BlockSearch"] = "block_search";
      Method2["BroadcastTxAsync"] = "broadcast_tx_async";
      Method2["BroadcastTxSync"] = "broadcast_tx_sync";
      Method2["BroadcastTxCommit"] = "broadcast_tx_commit";
      Method2["Commit"] = "commit";
      Method2["Genesis"] = "genesis";
      Method2["Health"] = "health";
      Method2["NumUnconfirmedTxs"] = "num_unconfirmed_txs";
      Method2["Status"] = "status";
      Method2["Subscribe"] = "subscribe";
      Method2["Tx"] = "tx";
      Method2["TxSearch"] = "tx_search";
      Method2["Validators"] = "validators";
      Method2["Unsubscribe"] = "unsubscribe";
    })(Method = exports.Method || (exports.Method = {}));
    var SubscriptionEventType;
    (function(SubscriptionEventType2) {
      SubscriptionEventType2["NewBlock"] = "NewBlock";
      SubscriptionEventType2["NewBlockHeader"] = "NewBlockHeader";
      SubscriptionEventType2["Tx"] = "Tx";
    })(SubscriptionEventType = exports.SubscriptionEventType || (exports.SubscriptionEventType = {}));
    function buildQuery(components) {
      const tags = components.tags ? components.tags : [];
      const tagComponents = tags.map((tag) => `${tag.key}='${tag.value}'`);
      const rawComponents = components.raw ? [components.raw] : [];
      return [...tagComponents, ...rawComponents].join(" AND ");
    }
    exports.buildQuery = buildQuery;
  }
});

// ../../node_modules/.pnpm/@cosmjs+tendermint-rpc@0.32.4/node_modules/@cosmjs/tendermint-rpc/build/tendermint37/responses.js
var require_responses5 = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+tendermint-rpc@0.32.4/node_modules/@cosmjs/tendermint-rpc/build/tendermint37/responses.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.VoteType = exports.broadcastTxCommitSuccess = exports.broadcastTxSyncSuccess = void 0;
    function broadcastTxSyncSuccess(res) {
      return res.code === 0;
    }
    exports.broadcastTxSyncSuccess = broadcastTxSyncSuccess;
    function broadcastTxCommitSuccess(response) {
      return response.checkTx.code === 0 && !!response.deliverTx && response.deliverTx.code === 0;
    }
    exports.broadcastTxCommitSuccess = broadcastTxCommitSuccess;
    var VoteType;
    (function(VoteType2) {
      VoteType2[VoteType2["PreVote"] = 1] = "PreVote";
      VoteType2[VoteType2["PreCommit"] = 2] = "PreCommit";
    })(VoteType = exports.VoteType || (exports.VoteType = {}));
  }
});

// ../../node_modules/.pnpm/@cosmjs+tendermint-rpc@0.32.4/node_modules/@cosmjs/tendermint-rpc/build/tendermint37/encodings.js
var require_encodings3 = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+tendermint-rpc@0.32.4/node_modules/@cosmjs/tendermint-rpc/build/tendermint37/encodings.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.encodeBlockId = exports.encodeVersion = exports.encodeBytes = exports.encodeTime = exports.encodeUvarint = exports.encodeString = exports.dictionaryToStringMap = exports.may = exports.assertNotEmpty = exports.assertObject = exports.assertArray = exports.assertNumber = exports.assertString = exports.assertBoolean = exports.assertSet = void 0;
    var encoding_1 = require_build2();
    function assertSet(value) {
      if (value === void 0) {
        throw new Error("Value must not be undefined");
      }
      if (value === null) {
        throw new Error("Value must not be null");
      }
      return value;
    }
    exports.assertSet = assertSet;
    function assertBoolean(value) {
      assertSet(value);
      if (typeof value !== "boolean") {
        throw new Error("Value must be a boolean");
      }
      return value;
    }
    exports.assertBoolean = assertBoolean;
    function assertString(value) {
      assertSet(value);
      if (typeof value !== "string") {
        throw new Error("Value must be a string");
      }
      return value;
    }
    exports.assertString = assertString;
    function assertNumber(value) {
      assertSet(value);
      if (typeof value !== "number") {
        throw new Error("Value must be a number");
      }
      return value;
    }
    exports.assertNumber = assertNumber;
    function assertArray(value) {
      assertSet(value);
      if (!Array.isArray(value)) {
        throw new Error("Value must be a an array");
      }
      return value;
    }
    exports.assertArray = assertArray;
    function assertObject(value) {
      assertSet(value);
      if (typeof value !== "object") {
        throw new Error("Value must be an object");
      }
      if (Object.prototype.toString.call(value) !== "[object Object]") {
        throw new Error("Value must be a simple object");
      }
      return value;
    }
    exports.assertObject = assertObject;
    function assertNotEmpty(value) {
      assertSet(value);
      if (typeof value === "number" && value === 0) {
        throw new Error("must provide a non-zero value");
      } else if (value.length === 0) {
        throw new Error("must provide a non-empty value");
      }
      return value;
    }
    exports.assertNotEmpty = assertNotEmpty;
    function may(transform, value) {
      return value === void 0 || value === null ? void 0 : transform(value);
    }
    exports.may = may;
    function dictionaryToStringMap(obj) {
      const out = /* @__PURE__ */ new Map();
      for (const key of Object.keys(obj)) {
        const value = obj[key];
        if (typeof value !== "string") {
          throw new Error("Found dictionary value of type other than string");
        }
        out.set(key, value);
      }
      return out;
    }
    exports.dictionaryToStringMap = dictionaryToStringMap;
    function encodeString(s) {
      const utf8 = (0, encoding_1.toUtf8)(s);
      return Uint8Array.from([utf8.length, ...utf8]);
    }
    exports.encodeString = encodeString;
    function encodeUvarint(n) {
      return n >= 128 ? (
        // eslint-disable-next-line no-bitwise
        Uint8Array.from([n & 255 | 128, ...encodeUvarint(n >> 7)])
      ) : (
        // eslint-disable-next-line no-bitwise
        Uint8Array.from([n & 255])
      );
    }
    exports.encodeUvarint = encodeUvarint;
    function encodeTime(time) {
      const milliseconds = time.getTime();
      const seconds = Math.floor(milliseconds / 1e3);
      const secondsArray = seconds ? [8, ...encodeUvarint(seconds)] : new Uint8Array();
      const nanoseconds = (time.nanoseconds || 0) + milliseconds % 1e3 * 1e6;
      const nanosecondsArray = nanoseconds ? [16, ...encodeUvarint(nanoseconds)] : new Uint8Array();
      return Uint8Array.from([...secondsArray, ...nanosecondsArray]);
    }
    exports.encodeTime = encodeTime;
    function encodeBytes(bytes) {
      if (bytes.length >= 128)
        throw new Error("Not implemented for byte arrays of length 128 or more");
      return bytes.length ? Uint8Array.from([bytes.length, ...bytes]) : new Uint8Array();
    }
    exports.encodeBytes = encodeBytes;
    function encodeVersion(version) {
      const blockArray = version.block ? Uint8Array.from([8, ...encodeUvarint(version.block)]) : new Uint8Array();
      const appArray = version.app ? Uint8Array.from([16, ...encodeUvarint(version.app)]) : new Uint8Array();
      return Uint8Array.from([...blockArray, ...appArray]);
    }
    exports.encodeVersion = encodeVersion;
    function encodeBlockId(blockId) {
      return Uint8Array.from([
        10,
        blockId.hash.length,
        ...blockId.hash,
        18,
        blockId.parts.hash.length + 4,
        8,
        blockId.parts.total,
        18,
        blockId.parts.hash.length,
        ...blockId.parts.hash
      ]);
    }
    exports.encodeBlockId = encodeBlockId;
  }
});

// ../../node_modules/.pnpm/@cosmjs+tendermint-rpc@0.32.4/node_modules/@cosmjs/tendermint-rpc/build/tendermint37/adaptor/requests.js
var require_requests6 = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+tendermint-rpc@0.32.4/node_modules/@cosmjs/tendermint-rpc/build/tendermint37/adaptor/requests.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Params = void 0;
    var encoding_1 = require_build2();
    var inthelpers_1 = require_inthelpers();
    var jsonrpc_1 = require_jsonrpc();
    var encodings_1 = require_encodings3();
    var requests = __importStar(require_requests5());
    function encodeHeightParam(param) {
      return {
        height: (0, encodings_1.may)(inthelpers_1.smallIntToApi, param.height)
      };
    }
    function encodeBlockchainRequestParams(param) {
      return {
        minHeight: (0, encodings_1.may)(inthelpers_1.smallIntToApi, param.minHeight),
        maxHeight: (0, encodings_1.may)(inthelpers_1.smallIntToApi, param.maxHeight)
      };
    }
    function encodeBlockSearchParams(params) {
      return {
        query: params.query,
        page: (0, encodings_1.may)(inthelpers_1.smallIntToApi, params.page),
        per_page: (0, encodings_1.may)(inthelpers_1.smallIntToApi, params.per_page),
        order_by: params.order_by
      };
    }
    function encodeAbciQueryParams(params) {
      return {
        path: (0, encodings_1.assertNotEmpty)(params.path),
        data: (0, encoding_1.toHex)(params.data),
        height: (0, encodings_1.may)(inthelpers_1.smallIntToApi, params.height),
        prove: params.prove
      };
    }
    function encodeBroadcastTxParams(params) {
      return {
        tx: (0, encoding_1.toBase64)((0, encodings_1.assertNotEmpty)(params.tx))
      };
    }
    function encodeTxParams(params) {
      return {
        hash: (0, encoding_1.toBase64)((0, encodings_1.assertNotEmpty)(params.hash)),
        prove: params.prove
      };
    }
    function encodeTxSearchParams(params) {
      return {
        query: params.query,
        prove: params.prove,
        page: (0, encodings_1.may)(inthelpers_1.smallIntToApi, params.page),
        per_page: (0, encodings_1.may)(inthelpers_1.smallIntToApi, params.per_page),
        order_by: params.order_by
      };
    }
    function encodeValidatorsParams(params) {
      return {
        height: (0, encodings_1.may)(inthelpers_1.smallIntToApi, params.height),
        page: (0, encodings_1.may)(inthelpers_1.smallIntToApi, params.page),
        per_page: (0, encodings_1.may)(inthelpers_1.smallIntToApi, params.per_page)
      };
    }
    var Params = class {
      static encodeAbciInfo(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method);
      }
      static encodeAbciQuery(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeAbciQueryParams(req.params));
      }
      static encodeBlock(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeHeightParam(req.params));
      }
      static encodeBlockchain(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeBlockchainRequestParams(req.params));
      }
      static encodeBlockResults(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeHeightParam(req.params));
      }
      static encodeBlockSearch(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeBlockSearchParams(req.params));
      }
      static encodeBroadcastTx(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeBroadcastTxParams(req.params));
      }
      static encodeCommit(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeHeightParam(req.params));
      }
      static encodeGenesis(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method);
      }
      static encodeHealth(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method);
      }
      static encodeNumUnconfirmedTxs(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method);
      }
      static encodeStatus(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method);
      }
      static encodeSubscribe(req) {
        const eventTag = { key: "tm.event", value: req.query.type };
        const query = requests.buildQuery({ tags: [eventTag], raw: req.query.raw });
        return (0, jsonrpc_1.createJsonRpcRequest)("subscribe", { query });
      }
      static encodeTx(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeTxParams(req.params));
      }
      // TODO: encode params for query string???
      static encodeTxSearch(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeTxSearchParams(req.params));
      }
      static encodeValidators(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeValidatorsParams(req.params));
      }
    };
    exports.Params = Params;
  }
});

// ../../node_modules/.pnpm/@cosmjs+tendermint-rpc@0.32.4/node_modules/@cosmjs/tendermint-rpc/build/tendermint37/hasher.js
var require_hasher3 = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+tendermint-rpc@0.32.4/node_modules/@cosmjs/tendermint-rpc/build/tendermint37/hasher.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.hashBlock = exports.hashTx = void 0;
    var crypto_1 = require_build4();
    var encodings_1 = require_encodings3();
    function hashTx(tx) {
      return (0, crypto_1.sha256)(tx);
    }
    exports.hashTx = hashTx;
    function getSplitPoint(n) {
      if (n < 1)
        throw new Error("Cannot split an empty tree");
      const largestPowerOf2 = 2 ** Math.floor(Math.log2(n));
      return largestPowerOf2 < n ? largestPowerOf2 : largestPowerOf2 / 2;
    }
    function hashLeaf(leaf) {
      const hash = new crypto_1.Sha256(Uint8Array.from([0]));
      hash.update(leaf);
      return hash.digest();
    }
    function hashInner(left, right) {
      const hash = new crypto_1.Sha256(Uint8Array.from([1]));
      hash.update(left);
      hash.update(right);
      return hash.digest();
    }
    function hashTree(hashes) {
      switch (hashes.length) {
        case 0:
          throw new Error("Cannot hash empty tree");
        case 1:
          return hashLeaf(hashes[0]);
        default: {
          const slicePoint = getSplitPoint(hashes.length);
          const left = hashTree(hashes.slice(0, slicePoint));
          const right = hashTree(hashes.slice(slicePoint));
          return hashInner(left, right);
        }
      }
    }
    function hashBlock(header) {
      if (!header.lastBlockId) {
        throw new Error("Hashing a block header with no last block ID (i.e. header at height 1) is not supported. If you need this, contributions are welcome. Please add documentation and test vectors for this case.");
      }
      const encodedFields = [
        (0, encodings_1.encodeVersion)(header.version),
        (0, encodings_1.encodeString)(header.chainId),
        (0, encodings_1.encodeUvarint)(header.height),
        (0, encodings_1.encodeTime)(header.time),
        (0, encodings_1.encodeBlockId)(header.lastBlockId),
        (0, encodings_1.encodeBytes)(header.lastCommitHash),
        (0, encodings_1.encodeBytes)(header.dataHash),
        (0, encodings_1.encodeBytes)(header.validatorsHash),
        (0, encodings_1.encodeBytes)(header.nextValidatorsHash),
        (0, encodings_1.encodeBytes)(header.consensusHash),
        (0, encodings_1.encodeBytes)(header.appHash),
        (0, encodings_1.encodeBytes)(header.lastResultsHash),
        (0, encodings_1.encodeBytes)(header.evidenceHash),
        (0, encodings_1.encodeBytes)(header.proposerAddress)
      ];
      return hashTree(encodedFields);
    }
    exports.hashBlock = hashBlock;
  }
});

// ../../node_modules/.pnpm/@cosmjs+tendermint-rpc@0.32.4/node_modules/@cosmjs/tendermint-rpc/build/tendermint37/adaptor/responses.js
var require_responses6 = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+tendermint-rpc@0.32.4/node_modules/@cosmjs/tendermint-rpc/build/tendermint37/adaptor/responses.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Responses = exports.decodeValidatorInfo = exports.decodeValidatorGenesis = exports.decodeValidatorUpdate = exports.decodeEvent = void 0;
    var encoding_1 = require_build2();
    var utils_1 = require_build3();
    var dates_1 = require_dates();
    var inthelpers_1 = require_inthelpers();
    var types_1 = require_types2();
    var encodings_1 = require_encodings3();
    var hasher_1 = require_hasher3();
    function decodeAbciInfo(data) {
      return {
        data: data.data,
        lastBlockHeight: (0, encodings_1.may)(inthelpers_1.apiToSmallInt, data.last_block_height),
        lastBlockAppHash: (0, encodings_1.may)(encoding_1.fromBase64, data.last_block_app_hash)
      };
    }
    function decodeQueryProof(data) {
      return {
        ops: data.ops.map((op) => ({
          type: op.type,
          key: (0, encoding_1.fromBase64)(op.key),
          data: (0, encoding_1.fromBase64)(op.data)
        }))
      };
    }
    function decodeAbciQuery(data) {
      return {
        key: (0, encoding_1.fromBase64)((0, encodings_1.assertString)(data.key ?? "")),
        value: (0, encoding_1.fromBase64)((0, encodings_1.assertString)(data.value ?? "")),
        proof: (0, encodings_1.may)(decodeQueryProof, data.proofOps),
        height: (0, encodings_1.may)(inthelpers_1.apiToSmallInt, data.height),
        code: (0, encodings_1.may)(inthelpers_1.apiToSmallInt, data.code),
        codespace: (0, encodings_1.assertString)(data.codespace ?? ""),
        index: (0, encodings_1.may)(inthelpers_1.apiToSmallInt, data.index),
        log: data.log,
        info: (0, encodings_1.assertString)(data.info ?? "")
      };
    }
    function decodeEventAttribute(attribute) {
      return {
        key: (0, encodings_1.assertNotEmpty)(attribute.key),
        value: attribute.value ?? ""
      };
    }
    function decodeAttributes(attributes) {
      return (0, encodings_1.assertArray)(attributes).map(decodeEventAttribute);
    }
    function decodeEvent(event) {
      return {
        type: event.type,
        attributes: event.attributes ? decodeAttributes(event.attributes) : []
      };
    }
    exports.decodeEvent = decodeEvent;
    function decodeEvents(events) {
      return (0, encodings_1.assertArray)(events).map(decodeEvent);
    }
    function decodeTxData(data) {
      return {
        code: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNumber)(data.code ?? 0)),
        codespace: data.codespace,
        log: data.log,
        data: (0, encodings_1.may)(encoding_1.fromBase64, data.data),
        events: data.events ? decodeEvents(data.events) : [],
        gasWanted: (0, inthelpers_1.apiToBigInt)(data.gas_wanted ?? "0"),
        gasUsed: (0, inthelpers_1.apiToBigInt)(data.gas_used ?? "0")
      };
    }
    function decodePubkey(data) {
      if ("Sum" in data) {
        const [[algorithm, value]] = Object.entries(data.Sum.value);
        (0, utils_1.assert)(algorithm === "ed25519" || algorithm === "secp256k1", `unknown pubkey type: ${algorithm}`);
        return {
          algorithm,
          data: (0, encoding_1.fromBase64)((0, encodings_1.assertNotEmpty)(value))
        };
      } else {
        switch (data.type) {
          case "tendermint/PubKeyEd25519":
            return {
              algorithm: "ed25519",
              data: (0, encoding_1.fromBase64)((0, encodings_1.assertNotEmpty)(data.value))
            };
          case "tendermint/PubKeySecp256k1":
            return {
              algorithm: "secp256k1",
              data: (0, encoding_1.fromBase64)((0, encodings_1.assertNotEmpty)(data.value))
            };
          default:
            throw new Error(`unknown pubkey type: ${data.type}`);
        }
      }
    }
    function decodeBlockParams(data) {
      return {
        maxBytes: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.max_bytes)),
        maxGas: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.max_gas))
      };
    }
    function decodeEvidenceParams(data) {
      return {
        maxAgeNumBlocks: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.max_age_num_blocks)),
        maxAgeDuration: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.max_age_duration))
      };
    }
    function decodeConsensusParams(data) {
      return {
        block: decodeBlockParams((0, encodings_1.assertObject)(data.block)),
        evidence: decodeEvidenceParams((0, encodings_1.assertObject)(data.evidence))
      };
    }
    function decodeValidatorUpdate(data) {
      return {
        pubkey: decodePubkey((0, encodings_1.assertObject)(data.pub_key)),
        votingPower: (0, inthelpers_1.apiToBigInt)(data.power ?? "0")
      };
    }
    exports.decodeValidatorUpdate = decodeValidatorUpdate;
    function decodeBlockResults(data) {
      return {
        height: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.height)),
        results: (data.txs_results || []).map(decodeTxData),
        validatorUpdates: (data.validator_updates || []).map(decodeValidatorUpdate),
        consensusUpdates: (0, encodings_1.may)(decodeConsensusParams, data.consensus_param_updates),
        beginBlockEvents: decodeEvents(data.begin_block_events || []),
        endBlockEvents: decodeEvents(data.end_block_events || [])
      };
    }
    function decodeBlockId(data) {
      return {
        hash: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data.hash)),
        parts: {
          total: (0, encodings_1.assertNotEmpty)(data.parts.total),
          hash: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data.parts.hash))
        }
      };
    }
    function decodeBlockVersion(data) {
      return {
        block: (0, inthelpers_1.apiToSmallInt)(data.block),
        app: (0, inthelpers_1.apiToSmallInt)(data.app ?? 0)
      };
    }
    function decodeHeader(data) {
      return {
        version: decodeBlockVersion(data.version),
        chainId: (0, encodings_1.assertNotEmpty)(data.chain_id),
        height: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.height)),
        time: (0, dates_1.fromRfc3339WithNanoseconds)((0, encodings_1.assertNotEmpty)(data.time)),
        // When there is no last block ID (i.e. this block's height is 1), we get an empty structure like this:
        // { hash: '', parts: { total: 0, hash: '' } }
        lastBlockId: data.last_block_id.hash ? decodeBlockId(data.last_block_id) : null,
        lastCommitHash: (0, encoding_1.fromHex)((0, encodings_1.assertSet)(data.last_commit_hash)),
        dataHash: (0, encoding_1.fromHex)((0, encodings_1.assertSet)(data.data_hash)),
        validatorsHash: (0, encoding_1.fromHex)((0, encodings_1.assertSet)(data.validators_hash)),
        nextValidatorsHash: (0, encoding_1.fromHex)((0, encodings_1.assertSet)(data.next_validators_hash)),
        consensusHash: (0, encoding_1.fromHex)((0, encodings_1.assertSet)(data.consensus_hash)),
        appHash: (0, encoding_1.fromHex)((0, encodings_1.assertSet)(data.app_hash)),
        lastResultsHash: (0, encoding_1.fromHex)((0, encodings_1.assertSet)(data.last_results_hash)),
        evidenceHash: (0, encoding_1.fromHex)((0, encodings_1.assertSet)(data.evidence_hash)),
        proposerAddress: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data.proposer_address))
      };
    }
    function decodeBlockMeta(data) {
      return {
        blockId: decodeBlockId(data.block_id),
        blockSize: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.block_size)),
        header: decodeHeader(data.header),
        numTxs: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.num_txs))
      };
    }
    function decodeBlockchain(data) {
      return {
        lastHeight: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.last_height)),
        blockMetas: (0, encodings_1.assertArray)(data.block_metas).map(decodeBlockMeta)
      };
    }
    function decodeBroadcastTxSync(data) {
      return {
        ...decodeTxData(data),
        hash: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data.hash))
      };
    }
    function decodeBroadcastTxCommit(data) {
      return {
        height: (0, inthelpers_1.apiToSmallInt)(data.height),
        hash: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data.hash)),
        checkTx: decodeTxData((0, encodings_1.assertObject)(data.check_tx)),
        deliverTx: (0, encodings_1.may)(decodeTxData, data.deliver_tx)
      };
    }
    function decodeBlockIdFlag(blockIdFlag) {
      (0, utils_1.assert)(blockIdFlag in types_1.BlockIdFlag);
      return blockIdFlag;
    }
    function decodeCommitSignature(data) {
      return {
        blockIdFlag: decodeBlockIdFlag(data.block_id_flag),
        validatorAddress: data.validator_address ? (0, encoding_1.fromHex)(data.validator_address) : void 0,
        timestamp: data.timestamp ? (0, dates_1.fromRfc3339WithNanoseconds)(data.timestamp) : void 0,
        signature: data.signature ? (0, encoding_1.fromBase64)(data.signature) : void 0
      };
    }
    function decodeCommit(data) {
      return {
        blockId: decodeBlockId((0, encodings_1.assertObject)(data.block_id)),
        height: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.height)),
        round: (0, inthelpers_1.apiToSmallInt)(data.round),
        signatures: (0, encodings_1.assertArray)(data.signatures).map(decodeCommitSignature)
      };
    }
    function decodeCommitResponse(data) {
      return {
        canonical: (0, encodings_1.assertBoolean)(data.canonical),
        header: decodeHeader(data.signed_header.header),
        commit: decodeCommit(data.signed_header.commit)
      };
    }
    function decodeValidatorGenesis(data) {
      return {
        address: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data.address)),
        pubkey: decodePubkey((0, encodings_1.assertObject)(data.pub_key)),
        votingPower: (0, inthelpers_1.apiToBigInt)((0, encodings_1.assertNotEmpty)(data.power))
      };
    }
    exports.decodeValidatorGenesis = decodeValidatorGenesis;
    function decodeGenesis(data) {
      return {
        genesisTime: (0, dates_1.fromRfc3339WithNanoseconds)((0, encodings_1.assertNotEmpty)(data.genesis_time)),
        chainId: (0, encodings_1.assertNotEmpty)(data.chain_id),
        consensusParams: decodeConsensusParams(data.consensus_params),
        validators: data.validators ? (0, encodings_1.assertArray)(data.validators).map(decodeValidatorGenesis) : [],
        appHash: (0, encoding_1.fromHex)((0, encodings_1.assertSet)(data.app_hash)),
        appState: data.app_state
      };
    }
    function decodeValidatorInfo(data) {
      return {
        pubkey: decodePubkey((0, encodings_1.assertObject)(data.pub_key)),
        votingPower: (0, inthelpers_1.apiToBigInt)((0, encodings_1.assertNotEmpty)(data.voting_power)),
        address: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data.address)),
        proposerPriority: data.proposer_priority ? (0, inthelpers_1.apiToSmallInt)(data.proposer_priority) : void 0
      };
    }
    exports.decodeValidatorInfo = decodeValidatorInfo;
    function decodeNodeInfo(data) {
      return {
        id: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data.id)),
        listenAddr: (0, encodings_1.assertNotEmpty)(data.listen_addr),
        network: (0, encodings_1.assertNotEmpty)(data.network),
        version: (0, encodings_1.assertString)(data.version),
        channels: (0, encodings_1.assertString)(data.channels),
        moniker: (0, encodings_1.assertNotEmpty)(data.moniker),
        other: (0, encodings_1.dictionaryToStringMap)(data.other),
        protocolVersion: {
          app: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.protocol_version.app)),
          block: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.protocol_version.block)),
          p2p: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.protocol_version.p2p))
        }
      };
    }
    function decodeSyncInfo(data) {
      const earliestBlockHeight = data.earliest_block_height ? (0, inthelpers_1.apiToSmallInt)(data.earliest_block_height) : void 0;
      const earliestBlockTime = data.earliest_block_time ? (0, dates_1.fromRfc3339WithNanoseconds)(data.earliest_block_time) : void 0;
      return {
        earliestAppHash: data.earliest_app_hash ? (0, encoding_1.fromHex)(data.earliest_app_hash) : void 0,
        earliestBlockHash: data.earliest_block_hash ? (0, encoding_1.fromHex)(data.earliest_block_hash) : void 0,
        earliestBlockHeight: earliestBlockHeight || void 0,
        earliestBlockTime: (earliestBlockTime == null ? void 0 : earliestBlockTime.getTime()) ? earliestBlockTime : void 0,
        latestBlockHash: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data.latest_block_hash)),
        latestAppHash: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data.latest_app_hash)),
        latestBlockTime: (0, dates_1.fromRfc3339WithNanoseconds)((0, encodings_1.assertNotEmpty)(data.latest_block_time)),
        latestBlockHeight: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.latest_block_height)),
        catchingUp: (0, encodings_1.assertBoolean)(data.catching_up)
      };
    }
    function decodeStatus(data) {
      return {
        nodeInfo: decodeNodeInfo(data.node_info),
        syncInfo: decodeSyncInfo(data.sync_info),
        validatorInfo: decodeValidatorInfo(data.validator_info)
      };
    }
    function decodeTxProof(data) {
      return {
        data: (0, encoding_1.fromBase64)((0, encodings_1.assertNotEmpty)(data.data)),
        rootHash: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data.root_hash)),
        proof: {
          total: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.proof.total)),
          index: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.proof.index)),
          leafHash: (0, encoding_1.fromBase64)((0, encodings_1.assertNotEmpty)(data.proof.leaf_hash)),
          aunts: (0, encodings_1.assertArray)(data.proof.aunts).map(encoding_1.fromBase64)
        }
      };
    }
    function decodeTxResponse(data) {
      return {
        tx: (0, encoding_1.fromBase64)((0, encodings_1.assertNotEmpty)(data.tx)),
        result: decodeTxData((0, encodings_1.assertObject)(data.tx_result)),
        height: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.height)),
        index: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNumber)(data.index)),
        hash: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data.hash)),
        proof: (0, encodings_1.may)(decodeTxProof, data.proof)
      };
    }
    function decodeTxSearch(data) {
      return {
        totalCount: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.total_count)),
        txs: (0, encodings_1.assertArray)(data.txs).map(decodeTxResponse)
      };
    }
    function decodeTxEvent(data) {
      const tx = (0, encoding_1.fromBase64)((0, encodings_1.assertNotEmpty)(data.tx));
      return {
        tx,
        hash: (0, hasher_1.hashTx)(tx),
        result: decodeTxData(data.result),
        height: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.height))
      };
    }
    function decodeValidators(data) {
      return {
        blockHeight: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.block_height)),
        validators: (0, encodings_1.assertArray)(data.validators).map(decodeValidatorInfo),
        count: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.count)),
        total: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.total))
      };
    }
    function decodeBlock(data) {
      var _a;
      return {
        header: decodeHeader((0, encodings_1.assertObject)(data.header)),
        // For the block at height 1, last commit is not set. This is represented in an empty object like this:
        // { height: '0', round: 0, block_id: { hash: '', parts: [Object] }, signatures: [] }
        lastCommit: data.last_commit.block_id.hash ? decodeCommit((0, encodings_1.assertObject)(data.last_commit)) : null,
        txs: data.data.txs ? (0, encodings_1.assertArray)(data.data.txs).map(encoding_1.fromBase64) : [],
        // Lift up .evidence.evidence to just .evidence
        // See https://github.com/tendermint/tendermint/issues/7697
        evidence: ((_a = data.evidence) == null ? void 0 : _a.evidence) ?? []
      };
    }
    function decodeBlockResponse(data) {
      return {
        blockId: decodeBlockId(data.block_id),
        block: decodeBlock(data.block)
      };
    }
    function decodeBlockSearch(data) {
      return {
        totalCount: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.total_count)),
        blocks: (0, encodings_1.assertArray)(data.blocks).map(decodeBlockResponse)
      };
    }
    function decodeNumUnconfirmedTxs(data) {
      return {
        total: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.total)),
        totalBytes: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.total_bytes))
      };
    }
    var Responses = class _Responses {
      static decodeAbciInfo(response) {
        return decodeAbciInfo((0, encodings_1.assertObject)(response.result.response));
      }
      static decodeAbciQuery(response) {
        return decodeAbciQuery((0, encodings_1.assertObject)(response.result.response));
      }
      static decodeBlock(response) {
        return decodeBlockResponse(response.result);
      }
      static decodeBlockResults(response) {
        return decodeBlockResults(response.result);
      }
      static decodeBlockSearch(response) {
        return decodeBlockSearch(response.result);
      }
      static decodeBlockchain(response) {
        return decodeBlockchain(response.result);
      }
      static decodeBroadcastTxSync(response) {
        return decodeBroadcastTxSync(response.result);
      }
      static decodeBroadcastTxAsync(response) {
        return _Responses.decodeBroadcastTxSync(response);
      }
      static decodeBroadcastTxCommit(response) {
        return decodeBroadcastTxCommit(response.result);
      }
      static decodeCommit(response) {
        return decodeCommitResponse(response.result);
      }
      static decodeGenesis(response) {
        return decodeGenesis((0, encodings_1.assertObject)(response.result.genesis));
      }
      static decodeHealth() {
        return null;
      }
      static decodeNumUnconfirmedTxs(response) {
        return decodeNumUnconfirmedTxs(response.result);
      }
      static decodeStatus(response) {
        return decodeStatus(response.result);
      }
      static decodeNewBlockEvent(event) {
        return decodeBlock(event.data.value.block);
      }
      static decodeNewBlockHeaderEvent(event) {
        return decodeHeader(event.data.value.header);
      }
      static decodeTxEvent(event) {
        return decodeTxEvent(event.data.value.TxResult);
      }
      static decodeTx(response) {
        return decodeTxResponse(response.result);
      }
      static decodeTxSearch(response) {
        return decodeTxSearch(response.result);
      }
      static decodeValidators(response) {
        return decodeValidators(response.result);
      }
    };
    exports.Responses = Responses;
  }
});

// ../../node_modules/.pnpm/@cosmjs+tendermint-rpc@0.32.4/node_modules/@cosmjs/tendermint-rpc/build/tendermint37/adaptor/index.js
var require_adaptor3 = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+tendermint-rpc@0.32.4/node_modules/@cosmjs/tendermint-rpc/build/tendermint37/adaptor/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Responses = exports.Params = void 0;
    var requests_1 = require_requests6();
    Object.defineProperty(exports, "Params", { enumerable: true, get: function() {
      return requests_1.Params;
    } });
    var responses_1 = require_responses6();
    Object.defineProperty(exports, "Responses", { enumerable: true, get: function() {
      return responses_1.Responses;
    } });
  }
});

// ../../node_modules/.pnpm/@cosmjs+tendermint-rpc@0.32.4/node_modules/@cosmjs/tendermint-rpc/build/tendermint37/tendermint37client.js
var require_tendermint37client = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+tendermint-rpc@0.32.4/node_modules/@cosmjs/tendermint-rpc/build/tendermint37/tendermint37client.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Tendermint37Client = void 0;
    var jsonrpc_1 = require_jsonrpc();
    var rpcclients_1 = require_rpcclients();
    var adaptor_1 = require_adaptor3();
    var requests = __importStar(require_requests5());
    var Tendermint37Client = class _Tendermint37Client {
      /**
       * Creates a new Tendermint client for the given endpoint.
       *
       * Uses HTTP when the URL schema is http or https. Uses WebSockets otherwise.
       */
      static async connect(endpoint) {
        let rpcClient;
        if (typeof endpoint === "object") {
          rpcClient = new rpcclients_1.HttpClient(endpoint);
        } else {
          const useHttp = endpoint.startsWith("http://") || endpoint.startsWith("https://");
          rpcClient = useHttp ? new rpcclients_1.HttpClient(endpoint) : new rpcclients_1.WebsocketClient(endpoint);
        }
        const _version = await this.detectVersion(rpcClient);
        return _Tendermint37Client.create(rpcClient);
      }
      /**
       * Creates a new Tendermint client given an RPC client.
       */
      static async create(rpcClient) {
        return new _Tendermint37Client(rpcClient);
      }
      static async detectVersion(client) {
        const req = (0, jsonrpc_1.createJsonRpcRequest)(requests.Method.Status);
        const response = await client.execute(req);
        const result = response.result;
        if (!result || !result.node_info) {
          throw new Error("Unrecognized format for status response");
        }
        const version = result.node_info.version;
        if (typeof version !== "string") {
          throw new Error("Unrecognized version format: must be string");
        }
        return version;
      }
      /**
       * Use `Tendermint37Client.connect` or `Tendermint37Client.create` to create an instance.
       */
      constructor(client) {
        this.client = client;
      }
      disconnect() {
        this.client.disconnect();
      }
      async abciInfo() {
        const query = { method: requests.Method.AbciInfo };
        return this.doCall(query, adaptor_1.Params.encodeAbciInfo, adaptor_1.Responses.decodeAbciInfo);
      }
      async abciQuery(params) {
        const query = { params, method: requests.Method.AbciQuery };
        return this.doCall(query, adaptor_1.Params.encodeAbciQuery, adaptor_1.Responses.decodeAbciQuery);
      }
      async block(height) {
        const query = { method: requests.Method.Block, params: { height } };
        return this.doCall(query, adaptor_1.Params.encodeBlock, adaptor_1.Responses.decodeBlock);
      }
      async blockResults(height) {
        const query = {
          method: requests.Method.BlockResults,
          params: { height }
        };
        return this.doCall(query, adaptor_1.Params.encodeBlockResults, adaptor_1.Responses.decodeBlockResults);
      }
      /**
       * Search for events that are in a block.
       *
       * NOTE
       * This method will error on any node that is running a Tendermint version lower than 0.34.9.
       *
       * @see https://docs.tendermint.com/master/rpc/#/Info/block_search
       */
      async blockSearch(params) {
        const query = { params, method: requests.Method.BlockSearch };
        const resp = await this.doCall(query, adaptor_1.Params.encodeBlockSearch, adaptor_1.Responses.decodeBlockSearch);
        return {
          ...resp,
          // make sure we sort by height, as tendermint may be sorting by string value of the height
          blocks: [...resp.blocks].sort((a, b) => a.block.header.height - b.block.header.height)
        };
      }
      // this should paginate through all blockSearch options to ensure it returns all results.
      // starts with page 1 or whatever was provided (eg. to start on page 7)
      //
      // NOTE
      // This method will error on any node that is running a Tendermint version lower than 0.34.9.
      async blockSearchAll(params) {
        let page = params.page || 1;
        const blocks = [];
        let done = false;
        while (!done) {
          const resp = await this.blockSearch({ ...params, page });
          blocks.push(...resp.blocks);
          if (blocks.length < resp.totalCount) {
            page++;
          } else {
            done = true;
          }
        }
        blocks.sort((a, b) => a.block.header.height - b.block.header.height);
        return {
          totalCount: blocks.length,
          blocks
        };
      }
      /**
       * Queries block headers filtered by minHeight <= height <= maxHeight.
       *
       * @param minHeight The minimum height to be included in the result. Defaults to 0.
       * @param maxHeight The maximum height to be included in the result. Defaults to infinity.
       */
      async blockchain(minHeight, maxHeight) {
        const query = {
          method: requests.Method.Blockchain,
          params: {
            minHeight,
            maxHeight
          }
        };
        return this.doCall(query, adaptor_1.Params.encodeBlockchain, adaptor_1.Responses.decodeBlockchain);
      }
      /**
       * Broadcast transaction to mempool and wait for response
       *
       * @see https://docs.tendermint.com/master/rpc/#/Tx/broadcast_tx_sync
       */
      async broadcastTxSync(params) {
        const query = { params, method: requests.Method.BroadcastTxSync };
        return this.doCall(query, adaptor_1.Params.encodeBroadcastTx, adaptor_1.Responses.decodeBroadcastTxSync);
      }
      /**
       * Broadcast transaction to mempool and do not wait for result
       *
       * @see https://docs.tendermint.com/master/rpc/#/Tx/broadcast_tx_async
       */
      async broadcastTxAsync(params) {
        const query = { params, method: requests.Method.BroadcastTxAsync };
        return this.doCall(query, adaptor_1.Params.encodeBroadcastTx, adaptor_1.Responses.decodeBroadcastTxAsync);
      }
      /**
       * Broadcast transaction to mempool and wait for block
       *
       * @see https://docs.tendermint.com/master/rpc/#/Tx/broadcast_tx_commit
       */
      async broadcastTxCommit(params) {
        const query = { params, method: requests.Method.BroadcastTxCommit };
        return this.doCall(query, adaptor_1.Params.encodeBroadcastTx, adaptor_1.Responses.decodeBroadcastTxCommit);
      }
      async commit(height) {
        const query = { method: requests.Method.Commit, params: { height } };
        return this.doCall(query, adaptor_1.Params.encodeCommit, adaptor_1.Responses.decodeCommit);
      }
      async genesis() {
        const query = { method: requests.Method.Genesis };
        return this.doCall(query, adaptor_1.Params.encodeGenesis, adaptor_1.Responses.decodeGenesis);
      }
      async health() {
        const query = { method: requests.Method.Health };
        return this.doCall(query, adaptor_1.Params.encodeHealth, adaptor_1.Responses.decodeHealth);
      }
      async numUnconfirmedTxs() {
        const query = { method: requests.Method.NumUnconfirmedTxs };
        return this.doCall(query, adaptor_1.Params.encodeNumUnconfirmedTxs, adaptor_1.Responses.decodeNumUnconfirmedTxs);
      }
      async status() {
        const query = { method: requests.Method.Status };
        return this.doCall(query, adaptor_1.Params.encodeStatus, adaptor_1.Responses.decodeStatus);
      }
      subscribeNewBlock() {
        const request = {
          method: requests.Method.Subscribe,
          query: { type: requests.SubscriptionEventType.NewBlock }
        };
        return this.subscribe(request, adaptor_1.Responses.decodeNewBlockEvent);
      }
      subscribeNewBlockHeader() {
        const request = {
          method: requests.Method.Subscribe,
          query: { type: requests.SubscriptionEventType.NewBlockHeader }
        };
        return this.subscribe(request, adaptor_1.Responses.decodeNewBlockHeaderEvent);
      }
      subscribeTx(query) {
        const request = {
          method: requests.Method.Subscribe,
          query: {
            type: requests.SubscriptionEventType.Tx,
            raw: query
          }
        };
        return this.subscribe(request, adaptor_1.Responses.decodeTxEvent);
      }
      /**
       * Get a single transaction by hash
       *
       * @see https://docs.tendermint.com/master/rpc/#/Info/tx
       */
      async tx(params) {
        const query = { params, method: requests.Method.Tx };
        return this.doCall(query, adaptor_1.Params.encodeTx, adaptor_1.Responses.decodeTx);
      }
      /**
       * Search for transactions that are in a block
       *
       * @see https://docs.tendermint.com/master/rpc/#/Info/tx_search
       */
      async txSearch(params) {
        const query = { params, method: requests.Method.TxSearch };
        return this.doCall(query, adaptor_1.Params.encodeTxSearch, adaptor_1.Responses.decodeTxSearch);
      }
      // this should paginate through all txSearch options to ensure it returns all results.
      // starts with page 1 or whatever was provided (eg. to start on page 7)
      async txSearchAll(params) {
        let page = params.page || 1;
        const txs = [];
        let done = false;
        while (!done) {
          const resp = await this.txSearch({ ...params, page });
          txs.push(...resp.txs);
          if (txs.length < resp.totalCount) {
            page++;
          } else {
            done = true;
          }
        }
        return {
          totalCount: txs.length,
          txs
        };
      }
      async validators(params) {
        const query = {
          method: requests.Method.Validators,
          params
        };
        return this.doCall(query, adaptor_1.Params.encodeValidators, adaptor_1.Responses.decodeValidators);
      }
      async validatorsAll(height) {
        const validators = [];
        let page = 1;
        let done = false;
        let blockHeight = height;
        while (!done) {
          const response = await this.validators({
            per_page: 50,
            height: blockHeight,
            page
          });
          validators.push(...response.validators);
          blockHeight = blockHeight || response.blockHeight;
          if (validators.length < response.total) {
            page++;
          } else {
            done = true;
          }
        }
        return {
          // NOTE: Default value is for type safety but this should always be set
          blockHeight: blockHeight ?? 0,
          count: validators.length,
          total: validators.length,
          validators
        };
      }
      // doCall is a helper to handle the encode/call/decode logic
      async doCall(request, encode, decode) {
        const req = encode(request);
        const result = await this.client.execute(req);
        return decode(result);
      }
      subscribe(request, decode) {
        if (!(0, rpcclients_1.instanceOfRpcStreamingClient)(this.client)) {
          throw new Error("This RPC client type cannot subscribe to events");
        }
        const req = adaptor_1.Params.encodeSubscribe(request);
        const eventStream = this.client.listen(req);
        return eventStream.map((event) => {
          return decode(event);
        });
      }
    };
    exports.Tendermint37Client = Tendermint37Client;
  }
});

// ../../node_modules/.pnpm/@cosmjs+tendermint-rpc@0.32.4/node_modules/@cosmjs/tendermint-rpc/build/tendermint37/index.js
var require_tendermint37 = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+tendermint-rpc@0.32.4/node_modules/@cosmjs/tendermint-rpc/build/tendermint37/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Tendermint37Client = exports.VoteType = exports.broadcastTxSyncSuccess = exports.broadcastTxCommitSuccess = exports.SubscriptionEventType = exports.Method = void 0;
    var requests_1 = require_requests5();
    Object.defineProperty(exports, "Method", { enumerable: true, get: function() {
      return requests_1.Method;
    } });
    Object.defineProperty(exports, "SubscriptionEventType", { enumerable: true, get: function() {
      return requests_1.SubscriptionEventType;
    } });
    var responses_1 = require_responses5();
    Object.defineProperty(exports, "broadcastTxCommitSuccess", { enumerable: true, get: function() {
      return responses_1.broadcastTxCommitSuccess;
    } });
    Object.defineProperty(exports, "broadcastTxSyncSuccess", { enumerable: true, get: function() {
      return responses_1.broadcastTxSyncSuccess;
    } });
    Object.defineProperty(exports, "VoteType", { enumerable: true, get: function() {
      return responses_1.VoteType;
    } });
    var tendermint37client_1 = require_tendermint37client();
    Object.defineProperty(exports, "Tendermint37Client", { enumerable: true, get: function() {
      return tendermint37client_1.Tendermint37Client;
    } });
  }
});

// ../../node_modules/.pnpm/@cosmjs+tendermint-rpc@0.32.4/node_modules/@cosmjs/tendermint-rpc/build/tendermintclient.js
var require_tendermintclient = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+tendermint-rpc@0.32.4/node_modules/@cosmjs/tendermint-rpc/build/tendermintclient.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.connectComet = exports.isComet38Client = exports.isTendermint37Client = exports.isTendermint34Client = void 0;
    var comet38_1 = require_comet38();
    var tendermint34_1 = require_tendermint34();
    var tendermint37_1 = require_tendermint37();
    function isTendermint34Client(client) {
      return client instanceof tendermint34_1.Tendermint34Client;
    }
    exports.isTendermint34Client = isTendermint34Client;
    function isTendermint37Client(client) {
      return client instanceof tendermint37_1.Tendermint37Client;
    }
    exports.isTendermint37Client = isTendermint37Client;
    function isComet38Client(client) {
      return client instanceof comet38_1.Comet38Client;
    }
    exports.isComet38Client = isComet38Client;
    async function connectComet(endpoint) {
      let out;
      const tm37Client = await tendermint37_1.Tendermint37Client.connect(endpoint);
      const version = (await tm37Client.status()).nodeInfo.version;
      if (version.startsWith("0.37.")) {
        out = tm37Client;
      } else if (version.startsWith("0.38.")) {
        tm37Client.disconnect();
        out = await comet38_1.Comet38Client.connect(endpoint);
      } else {
        tm37Client.disconnect();
        out = await tendermint34_1.Tendermint34Client.connect(endpoint);
      }
      return out;
    }
    exports.connectComet = connectComet;
  }
});

// ../../node_modules/.pnpm/@cosmjs+tendermint-rpc@0.32.4/node_modules/@cosmjs/tendermint-rpc/build/index.js
var require_build11 = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+tendermint-rpc@0.32.4/node_modules/@cosmjs/tendermint-rpc/build/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BlockIdFlag = exports.isTendermint37Client = exports.isTendermint34Client = exports.isComet38Client = exports.connectComet = exports.Tendermint37Client = exports.tendermint37 = exports.Tendermint34Client = exports.tendermint34 = exports.VoteType = exports.SubscriptionEventType = exports.Method = exports.broadcastTxSyncSuccess = exports.broadcastTxCommitSuccess = exports.WebsocketClient = exports.HttpClient = exports.HttpBatchClient = exports.Comet38Client = exports.comet38 = exports.toSeconds = exports.toRfc3339WithNanoseconds = exports.fromSeconds = exports.fromRfc3339WithNanoseconds = exports.DateTime = exports.rawSecp256k1PubkeyToRawAddress = exports.rawEd25519PubkeyToRawAddress = exports.pubkeyToRawAddress = exports.pubkeyToAddress = void 0;
    var addresses_1 = require_addresses2();
    Object.defineProperty(exports, "pubkeyToAddress", { enumerable: true, get: function() {
      return addresses_1.pubkeyToAddress;
    } });
    Object.defineProperty(exports, "pubkeyToRawAddress", { enumerable: true, get: function() {
      return addresses_1.pubkeyToRawAddress;
    } });
    Object.defineProperty(exports, "rawEd25519PubkeyToRawAddress", { enumerable: true, get: function() {
      return addresses_1.rawEd25519PubkeyToRawAddress;
    } });
    Object.defineProperty(exports, "rawSecp256k1PubkeyToRawAddress", { enumerable: true, get: function() {
      return addresses_1.rawSecp256k1PubkeyToRawAddress;
    } });
    var dates_1 = require_dates();
    Object.defineProperty(exports, "DateTime", { enumerable: true, get: function() {
      return dates_1.DateTime;
    } });
    Object.defineProperty(exports, "fromRfc3339WithNanoseconds", { enumerable: true, get: function() {
      return dates_1.fromRfc3339WithNanoseconds;
    } });
    Object.defineProperty(exports, "fromSeconds", { enumerable: true, get: function() {
      return dates_1.fromSeconds;
    } });
    Object.defineProperty(exports, "toRfc3339WithNanoseconds", { enumerable: true, get: function() {
      return dates_1.toRfc3339WithNanoseconds;
    } });
    Object.defineProperty(exports, "toSeconds", { enumerable: true, get: function() {
      return dates_1.toSeconds;
    } });
    exports.comet38 = __importStar(require_comet38());
    var comet38_1 = require_comet38();
    Object.defineProperty(exports, "Comet38Client", { enumerable: true, get: function() {
      return comet38_1.Comet38Client;
    } });
    var rpcclients_1 = require_rpcclients();
    Object.defineProperty(exports, "HttpBatchClient", { enumerable: true, get: function() {
      return rpcclients_1.HttpBatchClient;
    } });
    Object.defineProperty(exports, "HttpClient", { enumerable: true, get: function() {
      return rpcclients_1.HttpClient;
    } });
    Object.defineProperty(exports, "WebsocketClient", { enumerable: true, get: function() {
      return rpcclients_1.WebsocketClient;
    } });
    var tendermint34_1 = require_tendermint34();
    Object.defineProperty(exports, "broadcastTxCommitSuccess", { enumerable: true, get: function() {
      return tendermint34_1.broadcastTxCommitSuccess;
    } });
    Object.defineProperty(exports, "broadcastTxSyncSuccess", { enumerable: true, get: function() {
      return tendermint34_1.broadcastTxSyncSuccess;
    } });
    Object.defineProperty(exports, "Method", { enumerable: true, get: function() {
      return tendermint34_1.Method;
    } });
    Object.defineProperty(exports, "SubscriptionEventType", { enumerable: true, get: function() {
      return tendermint34_1.SubscriptionEventType;
    } });
    Object.defineProperty(exports, "VoteType", { enumerable: true, get: function() {
      return tendermint34_1.VoteType;
    } });
    exports.tendermint34 = __importStar(require_tendermint34());
    var tendermint34_2 = require_tendermint34();
    Object.defineProperty(exports, "Tendermint34Client", { enumerable: true, get: function() {
      return tendermint34_2.Tendermint34Client;
    } });
    exports.tendermint37 = __importStar(require_tendermint37());
    var tendermint37_1 = require_tendermint37();
    Object.defineProperty(exports, "Tendermint37Client", { enumerable: true, get: function() {
      return tendermint37_1.Tendermint37Client;
    } });
    var tendermintclient_1 = require_tendermintclient();
    Object.defineProperty(exports, "connectComet", { enumerable: true, get: function() {
      return tendermintclient_1.connectComet;
    } });
    Object.defineProperty(exports, "isComet38Client", { enumerable: true, get: function() {
      return tendermintclient_1.isComet38Client;
    } });
    Object.defineProperty(exports, "isTendermint34Client", { enumerable: true, get: function() {
      return tendermintclient_1.isTendermint34Client;
    } });
    Object.defineProperty(exports, "isTendermint37Client", { enumerable: true, get: function() {
      return tendermintclient_1.isTendermint37Client;
    } });
    var types_1 = require_types2();
    Object.defineProperty(exports, "BlockIdFlag", { enumerable: true, get: function() {
      return types_1.BlockIdFlag;
    } });
  }
});

// ../../node_modules/.pnpm/@cosmjs+stargate@0.32.4/node_modules/@cosmjs/stargate/build/stargateclient.js
var require_stargateclient = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+stargate@0.32.4/node_modules/@cosmjs/stargate/build/stargateclient.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.StargateClient = exports.BroadcastTxError = exports.assertIsDeliverTxFailure = exports.assertIsDeliverTxSuccess = exports.isDeliverTxSuccess = exports.isDeliverTxFailure = exports.TimeoutError = void 0;
    var amino_1 = require_build5();
    var encoding_1 = require_build2();
    var math_1 = require_build();
    var tendermint_rpc_1 = require_build11();
    var utils_1 = require_build3();
    var abci_1 = require_abci();
    var accounts_1 = require_accounts();
    var events_1 = require_events();
    var modules_1 = require_modules();
    var queryclient_1 = require_queryclient2();
    var search_1 = require_search();
    var TimeoutError = class extends Error {
      constructor(message, txId) {
        super(message);
        this.txId = txId;
      }
    };
    exports.TimeoutError = TimeoutError;
    function isDeliverTxFailure(result) {
      return !!result.code;
    }
    exports.isDeliverTxFailure = isDeliverTxFailure;
    function isDeliverTxSuccess(result) {
      return !isDeliverTxFailure(result);
    }
    exports.isDeliverTxSuccess = isDeliverTxSuccess;
    function assertIsDeliverTxSuccess(result) {
      if (isDeliverTxFailure(result)) {
        throw new Error(`Error when broadcasting tx ${result.transactionHash} at height ${result.height}. Code: ${result.code}; Raw log: ${result.rawLog}`);
      }
    }
    exports.assertIsDeliverTxSuccess = assertIsDeliverTxSuccess;
    function assertIsDeliverTxFailure(result) {
      if (isDeliverTxSuccess(result)) {
        throw new Error(`Transaction ${result.transactionHash} did not fail at height ${result.height}. Code: ${result.code}; Raw log: ${result.rawLog}`);
      }
    }
    exports.assertIsDeliverTxFailure = assertIsDeliverTxFailure;
    var BroadcastTxError = class extends Error {
      constructor(code, codespace, log) {
        super(`Broadcasting transaction failed with code ${code} (codespace: ${codespace}). Log: ${log}`);
        this.code = code;
        this.codespace = codespace;
        this.log = log;
      }
    };
    exports.BroadcastTxError = BroadcastTxError;
    var StargateClient = class _StargateClient {
      /**
       * Creates an instance by connecting to the given CometBFT RPC endpoint.
       *
       * This uses auto-detection to decide between a CometBFT 0.38, Tendermint 0.37 and 0.34 client.
       * To set the Comet client explicitly, use `create`.
       */
      static async connect(endpoint, options = {}) {
        const cometClient = await (0, tendermint_rpc_1.connectComet)(endpoint);
        return _StargateClient.create(cometClient, options);
      }
      /**
       * Creates an instance from a manually created Comet client.
       * Use this to use `Comet38Client` or `Tendermint37Client` instead of `Tendermint34Client`.
       */
      static async create(cometClient, options = {}) {
        return new _StargateClient(cometClient, options);
      }
      constructor(cometClient, options) {
        if (cometClient) {
          this.cometClient = cometClient;
          this.queryClient = queryclient_1.QueryClient.withExtensions(cometClient, modules_1.setupAuthExtension, modules_1.setupBankExtension, modules_1.setupStakingExtension, modules_1.setupTxExtension);
        }
        const { accountParser = accounts_1.accountFromAny } = options;
        this.accountParser = accountParser;
      }
      getCometClient() {
        return this.cometClient;
      }
      forceGetCometClient() {
        if (!this.cometClient) {
          throw new Error("Comet client not available. You cannot use online functionality in offline mode.");
        }
        return this.cometClient;
      }
      getQueryClient() {
        return this.queryClient;
      }
      forceGetQueryClient() {
        if (!this.queryClient) {
          throw new Error("Query client not available. You cannot use online functionality in offline mode.");
        }
        return this.queryClient;
      }
      async getChainId() {
        if (!this.chainId) {
          const response = await this.forceGetCometClient().status();
          const chainId = response.nodeInfo.network;
          if (!chainId)
            throw new Error("Chain ID must not be empty");
          this.chainId = chainId;
        }
        return this.chainId;
      }
      async getHeight() {
        const status = await this.forceGetCometClient().status();
        return status.syncInfo.latestBlockHeight;
      }
      async getAccount(searchAddress) {
        try {
          const account = await this.forceGetQueryClient().auth.account(searchAddress);
          return account ? this.accountParser(account) : null;
        } catch (error) {
          if (/rpc error: code = NotFound/i.test(error.toString())) {
            return null;
          }
          throw error;
        }
      }
      async getSequence(address) {
        const account = await this.getAccount(address);
        if (!account) {
          throw new Error(`Account '${address}' does not exist on chain. Send some tokens there before trying to query sequence.`);
        }
        return {
          accountNumber: account.accountNumber,
          sequence: account.sequence
        };
      }
      async getBlock(height) {
        const response = await this.forceGetCometClient().block(height);
        return {
          id: (0, encoding_1.toHex)(response.blockId.hash).toUpperCase(),
          header: {
            version: {
              block: new math_1.Uint53(response.block.header.version.block).toString(),
              app: new math_1.Uint53(response.block.header.version.app).toString()
            },
            height: response.block.header.height,
            chainId: response.block.header.chainId,
            time: (0, tendermint_rpc_1.toRfc3339WithNanoseconds)(response.block.header.time)
          },
          txs: response.block.txs
        };
      }
      async getBalance(address, searchDenom) {
        return this.forceGetQueryClient().bank.balance(address, searchDenom);
      }
      /**
       * Queries all balances for all denoms that belong to this address.
       *
       * Uses the grpc queries (which iterates over the store internally), and we cannot get
       * proofs from such a method.
       */
      async getAllBalances(address) {
        return this.forceGetQueryClient().bank.allBalances(address);
      }
      async getBalanceStaked(address) {
        const allDelegations = [];
        let startAtKey = void 0;
        do {
          const { delegationResponses, pagination } = await this.forceGetQueryClient().staking.delegatorDelegations(address, startAtKey);
          const loadedDelegations = delegationResponses || [];
          allDelegations.push(...loadedDelegations);
          startAtKey = pagination == null ? void 0 : pagination.nextKey;
        } while (startAtKey !== void 0 && startAtKey.length !== 0);
        const sumValues = allDelegations.reduce((previousValue, currentValue) => {
          (0, utils_1.assert)(currentValue.balance);
          return previousValue !== null ? (0, amino_1.addCoins)(previousValue, currentValue.balance) : currentValue.balance;
        }, null);
        return sumValues;
      }
      async getDelegation(delegatorAddress, validatorAddress) {
        var _a;
        let delegatedAmount;
        try {
          delegatedAmount = (_a = (await this.forceGetQueryClient().staking.delegation(delegatorAddress, validatorAddress)).delegationResponse) == null ? void 0 : _a.balance;
        } catch (e) {
          if (e.toString().includes("key not found")) {
          } else {
            throw e;
          }
        }
        return delegatedAmount || null;
      }
      async getTx(id) {
        const results = await this.txsQuery(`tx.hash='${id}'`);
        return results[0] ?? null;
      }
      async searchTx(query) {
        let rawQuery;
        if (typeof query === "string") {
          rawQuery = query;
        } else if ((0, search_1.isSearchTxQueryArray)(query)) {
          rawQuery = query.map((t) => {
            if (typeof t.value === "string")
              return `${t.key}='${t.value}'`;
            else
              return `${t.key}=${t.value}`;
          }).join(" AND ");
        } else {
          throw new Error("Got unsupported query type. See CosmJS 0.31 CHANGELOG for API breaking changes here.");
        }
        return this.txsQuery(rawQuery);
      }
      disconnect() {
        if (this.cometClient)
          this.cometClient.disconnect();
      }
      /**
       * Broadcasts a signed transaction to the network and monitors its inclusion in a block.
       *
       * If broadcasting is rejected by the node for some reason (e.g. because of a CheckTx failure),
       * an error is thrown.
       *
       * If the transaction is not included in a block before the provided timeout, this errors with a `TimeoutError`.
       *
       * If the transaction is included in a block, a `DeliverTxResponse` is returned. The caller then
       * usually needs to check for execution success or failure.
       */
      async broadcastTx(tx, timeoutMs = 6e4, pollIntervalMs = 3e3) {
        let timedOut = false;
        const txPollTimeout = setTimeout(() => {
          timedOut = true;
        }, timeoutMs);
        const pollForTx = async (txId) => {
          if (timedOut) {
            throw new TimeoutError(`Transaction with ID ${txId} was submitted but was not yet found on the chain. You might want to check later. There was a wait of ${timeoutMs / 1e3} seconds.`, txId);
          }
          await (0, utils_1.sleep)(pollIntervalMs);
          const result = await this.getTx(txId);
          return result ? {
            code: result.code,
            height: result.height,
            txIndex: result.txIndex,
            events: result.events,
            rawLog: result.rawLog,
            transactionHash: txId,
            msgResponses: result.msgResponses,
            gasUsed: result.gasUsed,
            gasWanted: result.gasWanted
          } : pollForTx(txId);
        };
        const transactionId = await this.broadcastTxSync(tx);
        return new Promise((resolve, reject) => pollForTx(transactionId).then((value) => {
          clearTimeout(txPollTimeout);
          resolve(value);
        }, (error) => {
          clearTimeout(txPollTimeout);
          reject(error);
        }));
      }
      /**
       * Broadcasts a signed transaction to the network without monitoring it.
       *
       * If broadcasting is rejected by the node for some reason (e.g. because of a CheckTx failure),
       * an error is thrown.
       *
       * If the transaction is broadcasted, a `string` containing the hash of the transaction is returned. The caller then
       * usually needs to check if the transaction was included in a block and was successful.
       *
       * @returns Returns the hash of the transaction
       */
      async broadcastTxSync(tx) {
        const broadcasted = await this.forceGetCometClient().broadcastTxSync({ tx });
        if (broadcasted.code) {
          return Promise.reject(new BroadcastTxError(broadcasted.code, broadcasted.codespace ?? "", broadcasted.log));
        }
        const transactionId = (0, encoding_1.toHex)(broadcasted.hash).toUpperCase();
        return transactionId;
      }
      async txsQuery(query) {
        const results = await this.forceGetCometClient().txSearchAll({ query });
        return results.txs.map((tx) => {
          const txMsgData = abci_1.TxMsgData.decode(tx.result.data ?? new Uint8Array());
          return {
            height: tx.height,
            txIndex: tx.index,
            hash: (0, encoding_1.toHex)(tx.hash).toUpperCase(),
            code: tx.result.code,
            events: tx.result.events.map(events_1.fromTendermintEvent),
            rawLog: tx.result.log || "",
            tx: tx.tx,
            msgResponses: txMsgData.msgResponses,
            gasUsed: tx.result.gasUsed,
            gasWanted: tx.result.gasWanted
          };
        });
      }
    };
    exports.StargateClient = StargateClient;
  }
});

// ../../node_modules/.pnpm/@cosmjs+stargate@0.32.4/node_modules/@cosmjs/stargate/build/signingstargateclient.js
var require_signingstargateclient = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+stargate@0.32.4/node_modules/@cosmjs/stargate/build/signingstargateclient.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SigningStargateClient = exports.createDefaultAminoConverters = exports.defaultRegistryTypes = void 0;
    var amino_1 = require_build5();
    var encoding_1 = require_build2();
    var math_1 = require_build();
    var proto_signing_1 = require_build6();
    var tendermint_rpc_1 = require_build11();
    var utils_1 = require_build3();
    var coin_1 = require_coin();
    var tx_1 = require_tx4();
    var tx_2 = require_tx13();
    var signing_1 = require_signing();
    var tx_3 = require_tx();
    var tx_4 = require_tx9();
    var aminotypes_1 = require_aminotypes();
    var fee_1 = require_fee();
    var modules_1 = require_modules();
    var modules_2 = require_modules();
    var stargateclient_1 = require_stargateclient();
    exports.defaultRegistryTypes = [
      ["/cosmos.base.v1beta1.Coin", coin_1.Coin],
      ...modules_1.authzTypes,
      ...modules_1.bankTypes,
      ...modules_1.distributionTypes,
      ...modules_1.feegrantTypes,
      ...modules_1.govTypes,
      ...modules_1.groupTypes,
      ...modules_1.stakingTypes,
      ...modules_1.ibcTypes,
      ...modules_1.vestingTypes
    ];
    function createDefaultAminoConverters() {
      return {
        ...(0, modules_2.createAuthzAminoConverters)(),
        ...(0, modules_2.createBankAminoConverters)(),
        ...(0, modules_2.createDistributionAminoConverters)(),
        ...(0, modules_2.createGovAminoConverters)(),
        ...(0, modules_2.createStakingAminoConverters)(),
        ...(0, modules_2.createIbcAminoConverters)(),
        ...(0, modules_2.createFeegrantAminoConverters)(),
        ...(0, modules_2.createVestingAminoConverters)()
      };
    }
    exports.createDefaultAminoConverters = createDefaultAminoConverters;
    var SigningStargateClient = class _SigningStargateClient extends stargateclient_1.StargateClient {
      /**
       * Creates an instance by connecting to the given CometBFT RPC endpoint.
       *
       * This uses auto-detection to decide between a CometBFT 0.38, Tendermint 0.37 and 0.34 client.
       * To set the Comet client explicitly, use `createWithSigner`.
       */
      static async connectWithSigner(endpoint, signer, options = {}) {
        const cometClient = await (0, tendermint_rpc_1.connectComet)(endpoint);
        return _SigningStargateClient.createWithSigner(cometClient, signer, options);
      }
      /**
       * Creates an instance from a manually created Comet client.
       * Use this to use `Comet38Client` or `Tendermint37Client` instead of `Tendermint34Client`.
       */
      static async createWithSigner(cometClient, signer, options = {}) {
        return new _SigningStargateClient(cometClient, signer, options);
      }
      /**
       * Creates a client in offline mode.
       *
       * This should only be used in niche cases where you know exactly what you're doing,
       * e.g. when building an offline signing application.
       *
       * When you try to use online functionality with such a signer, an
       * exception will be raised.
       */
      static async offline(signer, options = {}) {
        return new _SigningStargateClient(void 0, signer, options);
      }
      constructor(cometClient, signer, options) {
        super(cometClient, options);
        this.defaultGasMultiplier = 1.4;
        const { registry = new proto_signing_1.Registry(exports.defaultRegistryTypes), aminoTypes = new aminotypes_1.AminoTypes(createDefaultAminoConverters()) } = options;
        this.registry = registry;
        this.aminoTypes = aminoTypes;
        this.signer = signer;
        this.broadcastTimeoutMs = options.broadcastTimeoutMs;
        this.broadcastPollIntervalMs = options.broadcastPollIntervalMs;
        this.gasPrice = options.gasPrice;
      }
      async simulate(signerAddress, messages, memo) {
        const anyMsgs = messages.map((m) => this.registry.encodeAsAny(m));
        const accountFromSigner = (await this.signer.getAccounts()).find((account) => account.address === signerAddress);
        if (!accountFromSigner) {
          throw new Error("Failed to retrieve account from signer");
        }
        const pubkey = (0, amino_1.encodeSecp256k1Pubkey)(accountFromSigner.pubkey);
        const { sequence } = await this.getSequence(signerAddress);
        const { gasInfo } = await this.forceGetQueryClient().tx.simulate(anyMsgs, memo, pubkey, sequence);
        (0, utils_1.assertDefined)(gasInfo);
        return math_1.Uint53.fromString(gasInfo.gasUsed.toString()).toNumber();
      }
      async sendTokens(senderAddress, recipientAddress, amount, fee, memo = "") {
        const sendMsg = {
          typeUrl: "/cosmos.bank.v1beta1.MsgSend",
          value: {
            fromAddress: senderAddress,
            toAddress: recipientAddress,
            amount: [...amount]
          }
        };
        return this.signAndBroadcast(senderAddress, [sendMsg], fee, memo);
      }
      async delegateTokens(delegatorAddress, validatorAddress, amount, fee, memo = "") {
        const delegateMsg = {
          typeUrl: "/cosmos.staking.v1beta1.MsgDelegate",
          value: tx_2.MsgDelegate.fromPartial({
            delegatorAddress,
            validatorAddress,
            amount
          })
        };
        return this.signAndBroadcast(delegatorAddress, [delegateMsg], fee, memo);
      }
      async undelegateTokens(delegatorAddress, validatorAddress, amount, fee, memo = "") {
        const undelegateMsg = {
          typeUrl: "/cosmos.staking.v1beta1.MsgUndelegate",
          value: tx_2.MsgUndelegate.fromPartial({
            delegatorAddress,
            validatorAddress,
            amount
          })
        };
        return this.signAndBroadcast(delegatorAddress, [undelegateMsg], fee, memo);
      }
      async withdrawRewards(delegatorAddress, validatorAddress, fee, memo = "") {
        const withdrawMsg = {
          typeUrl: "/cosmos.distribution.v1beta1.MsgWithdrawDelegatorReward",
          value: tx_1.MsgWithdrawDelegatorReward.fromPartial({
            delegatorAddress,
            validatorAddress
          })
        };
        return this.signAndBroadcast(delegatorAddress, [withdrawMsg], fee, memo);
      }
      /**
       * @deprecated This API does not support setting the memo field of `MsgTransfer` (only the transaction memo).
       * We'll remove this method at some point because trying to wrap the various message types is a losing strategy.
       * Please migrate to `signAndBroadcast` with an `MsgTransferEncodeObject` created in the caller code instead.
       * @see https://github.com/cosmos/cosmjs/issues/1493
       */
      async sendIbcTokens(senderAddress, recipientAddress, transferAmount, sourcePort, sourceChannel, timeoutHeight, timeoutTimestamp, fee, memo = "") {
        const timeoutTimestampNanoseconds = timeoutTimestamp ? BigInt(timeoutTimestamp) * BigInt(1e9) : void 0;
        const transferMsg = {
          typeUrl: "/ibc.applications.transfer.v1.MsgTransfer",
          value: tx_4.MsgTransfer.fromPartial({
            sourcePort,
            sourceChannel,
            sender: senderAddress,
            receiver: recipientAddress,
            token: transferAmount,
            timeoutHeight,
            timeoutTimestamp: timeoutTimestampNanoseconds
          })
        };
        return this.signAndBroadcast(senderAddress, [transferMsg], fee, memo);
      }
      async signAndBroadcast(signerAddress, messages, fee, memo = "", timeoutHeight) {
        let usedFee;
        if (fee == "auto" || typeof fee === "number") {
          (0, utils_1.assertDefined)(this.gasPrice, "Gas price must be set in the client options when auto gas is used.");
          const gasEstimation = await this.simulate(signerAddress, messages, memo);
          const multiplier = typeof fee === "number" ? fee : this.defaultGasMultiplier;
          usedFee = (0, fee_1.calculateFee)(Math.round(gasEstimation * multiplier), this.gasPrice);
        } else {
          usedFee = fee;
        }
        const txRaw = await this.sign(signerAddress, messages, usedFee, memo, void 0, timeoutHeight);
        const txBytes = tx_3.TxRaw.encode(txRaw).finish();
        return this.broadcastTx(txBytes, this.broadcastTimeoutMs, this.broadcastPollIntervalMs);
      }
      /**
       * This method is useful if you want to send a transaction in broadcast,
       * without waiting for it to be placed inside a block, because for example
       * I would like to receive the hash to later track the transaction with another tool.
       * @returns Returns the hash of the transaction
       */
      async signAndBroadcastSync(signerAddress, messages, fee, memo = "", timeoutHeight) {
        let usedFee;
        if (fee == "auto" || typeof fee === "number") {
          (0, utils_1.assertDefined)(this.gasPrice, "Gas price must be set in the client options when auto gas is used.");
          const gasEstimation = await this.simulate(signerAddress, messages, memo);
          const multiplier = typeof fee === "number" ? fee : this.defaultGasMultiplier;
          usedFee = (0, fee_1.calculateFee)(Math.round(gasEstimation * multiplier), this.gasPrice);
        } else {
          usedFee = fee;
        }
        const txRaw = await this.sign(signerAddress, messages, usedFee, memo, void 0, timeoutHeight);
        const txBytes = tx_3.TxRaw.encode(txRaw).finish();
        return this.broadcastTxSync(txBytes);
      }
      /**
       * Gets account number and sequence from the API, creates a sign doc,
       * creates a single signature and assembles the signed transaction.
       *
       * The sign mode (SIGN_MODE_DIRECT or SIGN_MODE_LEGACY_AMINO_JSON) is determined by this client's signer.
       *
       * You can pass signer data (account number, sequence and chain ID) explicitly instead of querying them
       * from the chain. This is needed when signing for a multisig account, but it also allows for offline signing
       * (See the SigningStargateClient.offline constructor).
       */
      async sign(signerAddress, messages, fee, memo, explicitSignerData, timeoutHeight) {
        let signerData;
        if (explicitSignerData) {
          signerData = explicitSignerData;
        } else {
          const { accountNumber, sequence } = await this.getSequence(signerAddress);
          const chainId = await this.getChainId();
          signerData = {
            accountNumber,
            sequence,
            chainId
          };
        }
        return (0, proto_signing_1.isOfflineDirectSigner)(this.signer) ? this.signDirect(signerAddress, messages, fee, memo, signerData, timeoutHeight) : this.signAmino(signerAddress, messages, fee, memo, signerData, timeoutHeight);
      }
      async signAmino(signerAddress, messages, fee, memo, { accountNumber, sequence, chainId }, timeoutHeight) {
        (0, utils_1.assert)(!(0, proto_signing_1.isOfflineDirectSigner)(this.signer));
        const accountFromSigner = (await this.signer.getAccounts()).find((account) => account.address === signerAddress);
        if (!accountFromSigner) {
          throw new Error("Failed to retrieve account from signer");
        }
        const pubkey = (0, proto_signing_1.encodePubkey)((0, amino_1.encodeSecp256k1Pubkey)(accountFromSigner.pubkey));
        const signMode = signing_1.SignMode.SIGN_MODE_LEGACY_AMINO_JSON;
        const msgs = messages.map((msg) => this.aminoTypes.toAmino(msg));
        const signDoc = (0, amino_1.makeSignDoc)(msgs, fee, chainId, memo, accountNumber, sequence, timeoutHeight);
        const { signature, signed } = await this.signer.signAmino(signerAddress, signDoc);
        const signedTxBody = {
          messages: signed.msgs.map((msg) => this.aminoTypes.fromAmino(msg)),
          memo: signed.memo,
          timeoutHeight
        };
        const signedTxBodyEncodeObject = {
          typeUrl: "/cosmos.tx.v1beta1.TxBody",
          value: signedTxBody
        };
        const signedTxBodyBytes = this.registry.encode(signedTxBodyEncodeObject);
        const signedGasLimit = math_1.Int53.fromString(signed.fee.gas).toNumber();
        const signedSequence = math_1.Int53.fromString(signed.sequence).toNumber();
        const signedAuthInfoBytes = (0, proto_signing_1.makeAuthInfoBytes)([{ pubkey, sequence: signedSequence }], signed.fee.amount, signedGasLimit, signed.fee.granter, signed.fee.payer, signMode);
        return tx_3.TxRaw.fromPartial({
          bodyBytes: signedTxBodyBytes,
          authInfoBytes: signedAuthInfoBytes,
          signatures: [(0, encoding_1.fromBase64)(signature.signature)]
        });
      }
      async signDirect(signerAddress, messages, fee, memo, { accountNumber, sequence, chainId }, timeoutHeight) {
        (0, utils_1.assert)((0, proto_signing_1.isOfflineDirectSigner)(this.signer));
        const accountFromSigner = (await this.signer.getAccounts()).find((account) => account.address === signerAddress);
        if (!accountFromSigner) {
          throw new Error("Failed to retrieve account from signer");
        }
        const pubkey = (0, proto_signing_1.encodePubkey)((0, amino_1.encodeSecp256k1Pubkey)(accountFromSigner.pubkey));
        const txBodyEncodeObject = {
          typeUrl: "/cosmos.tx.v1beta1.TxBody",
          value: {
            messages,
            memo,
            timeoutHeight
          }
        };
        const txBodyBytes = this.registry.encode(txBodyEncodeObject);
        const gasLimit = math_1.Int53.fromString(fee.gas).toNumber();
        const authInfoBytes = (0, proto_signing_1.makeAuthInfoBytes)([{ pubkey, sequence }], fee.amount, gasLimit, fee.granter, fee.payer);
        const signDoc = (0, proto_signing_1.makeSignDoc)(txBodyBytes, authInfoBytes, chainId, accountNumber);
        const { signature, signed } = await this.signer.signDirect(signerAddress, signDoc);
        return tx_3.TxRaw.fromPartial({
          bodyBytes: signed.bodyBytes,
          authInfoBytes: signed.authInfoBytes,
          signatures: [(0, encoding_1.fromBase64)(signature.signature)]
        });
      }
    };
    exports.SigningStargateClient = SigningStargateClient;
  }
});

// ../../node_modules/.pnpm/@cosmjs+stargate@0.32.4/node_modules/@cosmjs/stargate/build/index.js
var require_build12 = __commonJS({
  "../../node_modules/.pnpm/@cosmjs+stargate@0.32.4/node_modules/@cosmjs/stargate/build/index.js"(exports) {
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isMsgVoteWeightedEncodeObject = exports.isMsgVoteEncodeObject = exports.isMsgUndelegateEncodeObject = exports.isMsgTransferEncodeObject = exports.isMsgSubmitProposalEncodeObject = exports.isMsgSendEncodeObject = exports.isMsgEditValidatorEncodeObject = exports.isMsgDepositEncodeObject = exports.isMsgDelegateEncodeObject = exports.isMsgCreateValidatorEncodeObject = exports.isMsgCancelUnbondingDelegationEncodeObject = exports.isMsgBeginRedelegateEncodeObject = exports.isAminoMsgWithdrawValidatorCommission = exports.isAminoMsgWithdrawDelegatorReward = exports.isAminoMsgVoteWeighted = exports.isAminoMsgVote = exports.isAminoMsgVerifyInvariant = exports.isAminoMsgUnjail = exports.isAminoMsgUndelegate = exports.isAminoMsgTransfer = exports.isAminoMsgSubmitProposal = exports.isAminoMsgSubmitEvidence = exports.isAminoMsgSetWithdrawAddress = exports.isAminoMsgSend = exports.isAminoMsgMultiSend = exports.isAminoMsgFundCommunityPool = exports.isAminoMsgEditValidator = exports.isAminoMsgDeposit = exports.isAminoMsgDelegate = exports.isAminoMsgCreateVestingAccount = exports.isAminoMsgCreateValidator = exports.isAminoMsgBeginRedelegate = exports.createVestingAminoConverters = exports.createStakingAminoConverters = exports.createSlashingAminoConverters = exports.createIbcAminoConverters = exports.createGroupAminoConverters = exports.createGovAminoConverters = exports.createFeegrantAminoConverters = exports.createEvidenceAminoConverters = exports.createDistributionAminoConverters = exports.createCrysisAminoConverters = exports.createBankAminoConverters = exports.createAuthzAminoConverters = exports.logs = exports.GasPrice = exports.calculateFee = exports.fromTendermintEvent = exports.AminoTypes = exports.accountFromAny = void 0;
    exports.parseCoins = exports.makeCosmoshubPath = exports.coins = exports.coin = exports.TimeoutError = exports.StargateClient = exports.isDeliverTxSuccess = exports.isDeliverTxFailure = exports.BroadcastTxError = exports.assertIsDeliverTxSuccess = exports.assertIsDeliverTxFailure = exports.SigningStargateClient = exports.defaultRegistryTypes = exports.createDefaultAminoConverters = exports.isSearchTxQueryArray = exports.QueryClient = exports.decodeCosmosSdkDecFromProto = exports.createProtobufRpcClient = exports.createPagination = exports.makeMultisignedTxBytes = exports.makeMultisignedTx = exports.setupTxExtension = exports.setupStakingExtension = exports.setupSlashingExtension = exports.setupMintExtension = exports.setupIbcExtension = exports.setupGovExtension = exports.setupFeegrantExtension = exports.setupDistributionExtension = exports.setupBankExtension = exports.setupAuthzExtension = exports.setupAuthExtension = exports.isMsgWithdrawDelegatorRewardEncodeObject = void 0;
    var accounts_1 = require_accounts();
    Object.defineProperty(exports, "accountFromAny", { enumerable: true, get: function() {
      return accounts_1.accountFromAny;
    } });
    var aminotypes_1 = require_aminotypes();
    Object.defineProperty(exports, "AminoTypes", { enumerable: true, get: function() {
      return aminotypes_1.AminoTypes;
    } });
    var events_1 = require_events();
    Object.defineProperty(exports, "fromTendermintEvent", { enumerable: true, get: function() {
      return events_1.fromTendermintEvent;
    } });
    var fee_1 = require_fee();
    Object.defineProperty(exports, "calculateFee", { enumerable: true, get: function() {
      return fee_1.calculateFee;
    } });
    Object.defineProperty(exports, "GasPrice", { enumerable: true, get: function() {
      return fee_1.GasPrice;
    } });
    exports.logs = __importStar(require_logs());
    var modules_1 = require_modules();
    Object.defineProperty(exports, "createAuthzAminoConverters", { enumerable: true, get: function() {
      return modules_1.createAuthzAminoConverters;
    } });
    Object.defineProperty(exports, "createBankAminoConverters", { enumerable: true, get: function() {
      return modules_1.createBankAminoConverters;
    } });
    Object.defineProperty(exports, "createCrysisAminoConverters", { enumerable: true, get: function() {
      return modules_1.createCrysisAminoConverters;
    } });
    Object.defineProperty(exports, "createDistributionAminoConverters", { enumerable: true, get: function() {
      return modules_1.createDistributionAminoConverters;
    } });
    Object.defineProperty(exports, "createEvidenceAminoConverters", { enumerable: true, get: function() {
      return modules_1.createEvidenceAminoConverters;
    } });
    Object.defineProperty(exports, "createFeegrantAminoConverters", { enumerable: true, get: function() {
      return modules_1.createFeegrantAminoConverters;
    } });
    Object.defineProperty(exports, "createGovAminoConverters", { enumerable: true, get: function() {
      return modules_1.createGovAminoConverters;
    } });
    Object.defineProperty(exports, "createGroupAminoConverters", { enumerable: true, get: function() {
      return modules_1.createGroupAminoConverters;
    } });
    Object.defineProperty(exports, "createIbcAminoConverters", { enumerable: true, get: function() {
      return modules_1.createIbcAminoConverters;
    } });
    Object.defineProperty(exports, "createSlashingAminoConverters", { enumerable: true, get: function() {
      return modules_1.createSlashingAminoConverters;
    } });
    Object.defineProperty(exports, "createStakingAminoConverters", { enumerable: true, get: function() {
      return modules_1.createStakingAminoConverters;
    } });
    Object.defineProperty(exports, "createVestingAminoConverters", { enumerable: true, get: function() {
      return modules_1.createVestingAminoConverters;
    } });
    Object.defineProperty(exports, "isAminoMsgBeginRedelegate", { enumerable: true, get: function() {
      return modules_1.isAminoMsgBeginRedelegate;
    } });
    Object.defineProperty(exports, "isAminoMsgCreateValidator", { enumerable: true, get: function() {
      return modules_1.isAminoMsgCreateValidator;
    } });
    Object.defineProperty(exports, "isAminoMsgCreateVestingAccount", { enumerable: true, get: function() {
      return modules_1.isAminoMsgCreateVestingAccount;
    } });
    Object.defineProperty(exports, "isAminoMsgDelegate", { enumerable: true, get: function() {
      return modules_1.isAminoMsgDelegate;
    } });
    Object.defineProperty(exports, "isAminoMsgDeposit", { enumerable: true, get: function() {
      return modules_1.isAminoMsgDeposit;
    } });
    Object.defineProperty(exports, "isAminoMsgEditValidator", { enumerable: true, get: function() {
      return modules_1.isAminoMsgEditValidator;
    } });
    Object.defineProperty(exports, "isAminoMsgFundCommunityPool", { enumerable: true, get: function() {
      return modules_1.isAminoMsgFundCommunityPool;
    } });
    Object.defineProperty(exports, "isAminoMsgMultiSend", { enumerable: true, get: function() {
      return modules_1.isAminoMsgMultiSend;
    } });
    Object.defineProperty(exports, "isAminoMsgSend", { enumerable: true, get: function() {
      return modules_1.isAminoMsgSend;
    } });
    Object.defineProperty(exports, "isAminoMsgSetWithdrawAddress", { enumerable: true, get: function() {
      return modules_1.isAminoMsgSetWithdrawAddress;
    } });
    Object.defineProperty(exports, "isAminoMsgSubmitEvidence", { enumerable: true, get: function() {
      return modules_1.isAminoMsgSubmitEvidence;
    } });
    Object.defineProperty(exports, "isAminoMsgSubmitProposal", { enumerable: true, get: function() {
      return modules_1.isAminoMsgSubmitProposal;
    } });
    Object.defineProperty(exports, "isAminoMsgTransfer", { enumerable: true, get: function() {
      return modules_1.isAminoMsgTransfer;
    } });
    Object.defineProperty(exports, "isAminoMsgUndelegate", { enumerable: true, get: function() {
      return modules_1.isAminoMsgUndelegate;
    } });
    Object.defineProperty(exports, "isAminoMsgUnjail", { enumerable: true, get: function() {
      return modules_1.isAminoMsgUnjail;
    } });
    Object.defineProperty(exports, "isAminoMsgVerifyInvariant", { enumerable: true, get: function() {
      return modules_1.isAminoMsgVerifyInvariant;
    } });
    Object.defineProperty(exports, "isAminoMsgVote", { enumerable: true, get: function() {
      return modules_1.isAminoMsgVote;
    } });
    Object.defineProperty(exports, "isAminoMsgVoteWeighted", { enumerable: true, get: function() {
      return modules_1.isAminoMsgVoteWeighted;
    } });
    Object.defineProperty(exports, "isAminoMsgWithdrawDelegatorReward", { enumerable: true, get: function() {
      return modules_1.isAminoMsgWithdrawDelegatorReward;
    } });
    Object.defineProperty(exports, "isAminoMsgWithdrawValidatorCommission", { enumerable: true, get: function() {
      return modules_1.isAminoMsgWithdrawValidatorCommission;
    } });
    Object.defineProperty(exports, "isMsgBeginRedelegateEncodeObject", { enumerable: true, get: function() {
      return modules_1.isMsgBeginRedelegateEncodeObject;
    } });
    Object.defineProperty(exports, "isMsgCancelUnbondingDelegationEncodeObject", { enumerable: true, get: function() {
      return modules_1.isMsgCancelUnbondingDelegationEncodeObject;
    } });
    Object.defineProperty(exports, "isMsgCreateValidatorEncodeObject", { enumerable: true, get: function() {
      return modules_1.isMsgCreateValidatorEncodeObject;
    } });
    Object.defineProperty(exports, "isMsgDelegateEncodeObject", { enumerable: true, get: function() {
      return modules_1.isMsgDelegateEncodeObject;
    } });
    Object.defineProperty(exports, "isMsgDepositEncodeObject", { enumerable: true, get: function() {
      return modules_1.isMsgDepositEncodeObject;
    } });
    Object.defineProperty(exports, "isMsgEditValidatorEncodeObject", { enumerable: true, get: function() {
      return modules_1.isMsgEditValidatorEncodeObject;
    } });
    Object.defineProperty(exports, "isMsgSendEncodeObject", { enumerable: true, get: function() {
      return modules_1.isMsgSendEncodeObject;
    } });
    Object.defineProperty(exports, "isMsgSubmitProposalEncodeObject", { enumerable: true, get: function() {
      return modules_1.isMsgSubmitProposalEncodeObject;
    } });
    Object.defineProperty(exports, "isMsgTransferEncodeObject", { enumerable: true, get: function() {
      return modules_1.isMsgTransferEncodeObject;
    } });
    Object.defineProperty(exports, "isMsgUndelegateEncodeObject", { enumerable: true, get: function() {
      return modules_1.isMsgUndelegateEncodeObject;
    } });
    Object.defineProperty(exports, "isMsgVoteEncodeObject", { enumerable: true, get: function() {
      return modules_1.isMsgVoteEncodeObject;
    } });
    Object.defineProperty(exports, "isMsgVoteWeightedEncodeObject", { enumerable: true, get: function() {
      return modules_1.isMsgVoteWeightedEncodeObject;
    } });
    Object.defineProperty(exports, "isMsgWithdrawDelegatorRewardEncodeObject", { enumerable: true, get: function() {
      return modules_1.isMsgWithdrawDelegatorRewardEncodeObject;
    } });
    Object.defineProperty(exports, "setupAuthExtension", { enumerable: true, get: function() {
      return modules_1.setupAuthExtension;
    } });
    Object.defineProperty(exports, "setupAuthzExtension", { enumerable: true, get: function() {
      return modules_1.setupAuthzExtension;
    } });
    Object.defineProperty(exports, "setupBankExtension", { enumerable: true, get: function() {
      return modules_1.setupBankExtension;
    } });
    Object.defineProperty(exports, "setupDistributionExtension", { enumerable: true, get: function() {
      return modules_1.setupDistributionExtension;
    } });
    Object.defineProperty(exports, "setupFeegrantExtension", { enumerable: true, get: function() {
      return modules_1.setupFeegrantExtension;
    } });
    Object.defineProperty(exports, "setupGovExtension", { enumerable: true, get: function() {
      return modules_1.setupGovExtension;
    } });
    Object.defineProperty(exports, "setupIbcExtension", { enumerable: true, get: function() {
      return modules_1.setupIbcExtension;
    } });
    Object.defineProperty(exports, "setupMintExtension", { enumerable: true, get: function() {
      return modules_1.setupMintExtension;
    } });
    Object.defineProperty(exports, "setupSlashingExtension", { enumerable: true, get: function() {
      return modules_1.setupSlashingExtension;
    } });
    Object.defineProperty(exports, "setupStakingExtension", { enumerable: true, get: function() {
      return modules_1.setupStakingExtension;
    } });
    Object.defineProperty(exports, "setupTxExtension", { enumerable: true, get: function() {
      return modules_1.setupTxExtension;
    } });
    var multisignature_1 = require_multisignature();
    Object.defineProperty(exports, "makeMultisignedTx", { enumerable: true, get: function() {
      return multisignature_1.makeMultisignedTx;
    } });
    Object.defineProperty(exports, "makeMultisignedTxBytes", { enumerable: true, get: function() {
      return multisignature_1.makeMultisignedTxBytes;
    } });
    var queryclient_1 = require_queryclient2();
    Object.defineProperty(exports, "createPagination", { enumerable: true, get: function() {
      return queryclient_1.createPagination;
    } });
    Object.defineProperty(exports, "createProtobufRpcClient", { enumerable: true, get: function() {
      return queryclient_1.createProtobufRpcClient;
    } });
    Object.defineProperty(exports, "decodeCosmosSdkDecFromProto", { enumerable: true, get: function() {
      return queryclient_1.decodeCosmosSdkDecFromProto;
    } });
    Object.defineProperty(exports, "QueryClient", { enumerable: true, get: function() {
      return queryclient_1.QueryClient;
    } });
    var search_1 = require_search();
    Object.defineProperty(exports, "isSearchTxQueryArray", { enumerable: true, get: function() {
      return search_1.isSearchTxQueryArray;
    } });
    var signingstargateclient_1 = require_signingstargateclient();
    Object.defineProperty(exports, "createDefaultAminoConverters", { enumerable: true, get: function() {
      return signingstargateclient_1.createDefaultAminoConverters;
    } });
    Object.defineProperty(exports, "defaultRegistryTypes", { enumerable: true, get: function() {
      return signingstargateclient_1.defaultRegistryTypes;
    } });
    Object.defineProperty(exports, "SigningStargateClient", { enumerable: true, get: function() {
      return signingstargateclient_1.SigningStargateClient;
    } });
    var stargateclient_1 = require_stargateclient();
    Object.defineProperty(exports, "assertIsDeliverTxFailure", { enumerable: true, get: function() {
      return stargateclient_1.assertIsDeliverTxFailure;
    } });
    Object.defineProperty(exports, "assertIsDeliverTxSuccess", { enumerable: true, get: function() {
      return stargateclient_1.assertIsDeliverTxSuccess;
    } });
    Object.defineProperty(exports, "BroadcastTxError", { enumerable: true, get: function() {
      return stargateclient_1.BroadcastTxError;
    } });
    Object.defineProperty(exports, "isDeliverTxFailure", { enumerable: true, get: function() {
      return stargateclient_1.isDeliverTxFailure;
    } });
    Object.defineProperty(exports, "isDeliverTxSuccess", { enumerable: true, get: function() {
      return stargateclient_1.isDeliverTxSuccess;
    } });
    Object.defineProperty(exports, "StargateClient", { enumerable: true, get: function() {
      return stargateclient_1.StargateClient;
    } });
    Object.defineProperty(exports, "TimeoutError", { enumerable: true, get: function() {
      return stargateclient_1.TimeoutError;
    } });
    var proto_signing_1 = require_build6();
    Object.defineProperty(exports, "coin", { enumerable: true, get: function() {
      return proto_signing_1.coin;
    } });
    Object.defineProperty(exports, "coins", { enumerable: true, get: function() {
      return proto_signing_1.coins;
    } });
    Object.defineProperty(exports, "makeCosmoshubPath", { enumerable: true, get: function() {
      return proto_signing_1.makeCosmoshubPath;
    } });
    Object.defineProperty(exports, "parseCoins", { enumerable: true, get: function() {
      return proto_signing_1.parseCoins;
    } });
  }
});

export {
  require_build,
  require_build2,
  require_build3,
  require_build4,
  require_build5,
  require_build6,
  require_build11 as require_build7,
  require_build12 as require_build8
};
/*! Bundled license information:

axios/dist/browser/axios.cjs:
  (*! Axios v1.10.0 Copyright (c) 2025 Matt Zabriskie and contributors *)
*/
//# sourceMappingURL=chunk-JBNZR5MM.js.map
