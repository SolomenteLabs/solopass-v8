import {
  Aa,
  Af,
  Ba,
  Bf,
  Bt,
  De,
  Ea,
  Ef,
  Et,
  Fc,
  Fe,
  Gc,
  Ha,
  Ho,
  Ia,
  If,
  Jc,
  Ka,
  Kc,
  Ks,
  Kt,
  La,
  Me,
  Ms,
  Na,
  Oa,
  Oe,
  Pa,
  Po,
  Qc,
  Qe,
  Qo,
  Qt,
  Ra,
  Sa,
  Ta,
  Ua,
  Vc,
  Ve,
  Vr,
  Vs,
  Vt,
  Wc,
  Xc,
  Xs,
  Yc,
  Ye,
  Ys,
  Zc,
  _a,
  af,
  ai,
  ba,
  cf,
  ci,
  cr,
  cs,
  di,
  dn,
  ea,
  ee,
  ei,
  ff,
  fi,
  fs,
  ga,
  ge,
  gi,
  hi,
  ii,
  init_tslib_es6,
  is,
  it,
  ja,
  ka,
  kt,
  li,
  ma,
  me,
  na,
  ni,
  oa,
  oi,
  pi,
  qc,
  qr,
  qs,
  ra,
  require_cjs as require_cjs2,
  require_cjs2 as require_cjs3,
  ri,
  sa,
  safeJsonParse,
  safeJsonStringify,
  sf,
  si,
  sn,
  sr,
  ta,
  toString,
  tslib_es6_exports,
  tt,
  uf,
  ui,
  va,
  wa,
  xa,
  ya,
  yf,
  zc,
  zs,
  zt
} from "./chunk-TYSBVODB.js";
import {
  ChainWalletBase,
  MainWalletBase,
  require_buffer,
  require_cjs,
  require_events,
  require_safe_buffer,
  require_sha
} from "./chunk-ES7L4QSX.js";
import {
  ExpiredError,
  RejectedError,
  State
} from "./chunk-OKZF6SRO.js";
import {
  require_bn as require_bn2,
  require_elliptic,
  require_minimal
} from "./chunk-3MQ3WXIC.js";
import {
  require_inherits_browser
} from "./chunk-J7D363UZ.js";
import "./chunk-KR3AE3QM.js";
import "./chunk-UPKEDSHG.js";
import "./chunk-U4AWZYNG.js";
import "./chunk-2QC6MWIG.js";
import {
  require_bech32,
  require_bn,
  require_crypto,
  require_pbkdf2,
  require_sha256,
  require_sha512,
  require_utils
} from "./chunk-2OGY5FFR.js";
import "./chunk-N6KZBFW2.js";
import {
  __commonJS,
  __esm,
  __export,
  __publicField,
  __reExport,
  __require,
  __toCommonJS,
  __toESM
} from "./chunk-JE6AHIQZ.js";

// ../../node_modules/.pnpm/@keplr-wallet+types@0.12.252_starknet@7.6.4/node_modules/@keplr-wallet/types/build/currency.js
var require_currency = __commonJS({
  "../../node_modules/.pnpm/@keplr-wallet+types@0.12.252_starknet@7.6.4/node_modules/@keplr-wallet/types/build/currency.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// ../../node_modules/.pnpm/@keplr-wallet+types@0.12.252_starknet@7.6.4/node_modules/@keplr-wallet/types/build/bech32.js
var require_bech322 = __commonJS({
  "../../node_modules/.pnpm/@keplr-wallet+types@0.12.252_starknet@7.6.4/node_modules/@keplr-wallet/types/build/bech32.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// ../../node_modules/.pnpm/@keplr-wallet+types@0.12.252_starknet@7.6.4/node_modules/@keplr-wallet/types/build/bip44.js
var require_bip44 = __commonJS({
  "../../node_modules/.pnpm/@keplr-wallet+types@0.12.252_starknet@7.6.4/node_modules/@keplr-wallet/types/build/bip44.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// ../../node_modules/.pnpm/@keplr-wallet+types@0.12.252_starknet@7.6.4/node_modules/@keplr-wallet/types/build/chain-info.js
var require_chain_info = __commonJS({
  "../../node_modules/.pnpm/@keplr-wallet+types@0.12.252_starknet@7.6.4/node_modules/@keplr-wallet/types/build/chain-info.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// ../../node_modules/.pnpm/@keplr-wallet+types@0.12.252_starknet@7.6.4/node_modules/@keplr-wallet/types/build/wallet/keplr.js
var require_keplr = __commonJS({
  "../../node_modules/.pnpm/@keplr-wallet+types@0.12.252_starknet@7.6.4/node_modules/@keplr-wallet/types/build/wallet/keplr.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// ../../node_modules/.pnpm/@keplr-wallet+types@0.12.252_starknet@7.6.4/node_modules/@keplr-wallet/types/build/wallet/eip6963.js
var require_eip6963 = __commonJS({
  "../../node_modules/.pnpm/@keplr-wallet+types@0.12.252_starknet@7.6.4/node_modules/@keplr-wallet/types/build/wallet/eip6963.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.EIP6963EventNames = void 0;
    var EIP6963EventNames;
    (function(EIP6963EventNames2) {
      EIP6963EventNames2["Announce"] = "eip6963:announceProvider";
      EIP6963EventNames2["Request"] = "eip6963:requestProvider";
    })(EIP6963EventNames = exports.EIP6963EventNames || (exports.EIP6963EventNames = {}));
  }
});

// ../../node_modules/.pnpm/@keplr-wallet+types@0.12.252_starknet@7.6.4/node_modules/@keplr-wallet/types/build/wallet/ethereum.js
var require_ethereum = __commonJS({
  "../../node_modules/.pnpm/@keplr-wallet+types@0.12.252_starknet@7.6.4/node_modules/@keplr-wallet/types/build/wallet/ethereum.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// ../../node_modules/.pnpm/@keplr-wallet+types@0.12.252_starknet@7.6.4/node_modules/@keplr-wallet/types/build/wallet/starknet.js
var require_starknet = __commonJS({
  "../../node_modules/.pnpm/@keplr-wallet+types@0.12.252_starknet@7.6.4/node_modules/@keplr-wallet/types/build/wallet/starknet.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// ../../node_modules/.pnpm/@keplr-wallet+types@0.12.252_starknet@7.6.4/node_modules/@keplr-wallet/types/build/wallet/bitcoin.js
var require_bitcoin = __commonJS({
  "../../node_modules/.pnpm/@keplr-wallet+types@0.12.252_starknet@7.6.4/node_modules/@keplr-wallet/types/build/wallet/bitcoin.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CHAIN_TYPE_TO_GENESIS_HASH = exports.GENESIS_HASH_TO_CHAIN_TYPE = exports.NETWORK_TO_GENESIS_HASH = exports.GENESIS_HASH_TO_NETWORK = exports.ChainType = exports.Network = exports.GenesisHash = exports.BitcoinSignMessageType = void 0;
    var BitcoinSignMessageType;
    (function(BitcoinSignMessageType2) {
      BitcoinSignMessageType2["ECDSA"] = "ecdsa";
      BitcoinSignMessageType2["BIP322_SIMPLE"] = "bip322-simple";
    })(BitcoinSignMessageType = exports.BitcoinSignMessageType || (exports.BitcoinSignMessageType = {}));
    var GenesisHash;
    (function(GenesisHash2) {
      GenesisHash2["MAINNET"] = "000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f";
      GenesisHash2["TESTNET"] = "000000000933ea01ad0ee984209779baaec3ced90fa3f408719526f8d77f4943";
      GenesisHash2["SIGNET"] = "00000008819873e925422c1ff0f99f7cc9bbb232af63a077a480a3633bee1ef6";
    })(GenesisHash = exports.GenesisHash || (exports.GenesisHash = {}));
    var Network;
    (function(Network2) {
      Network2["MAINNET"] = "mainnet";
      Network2["LIVENET"] = "livenet";
      Network2["TESTNET"] = "testnet";
      Network2["SIGNET"] = "signet";
    })(Network = exports.Network || (exports.Network = {}));
    var ChainType;
    (function(ChainType2) {
      ChainType2["BITCOIN_MAINNET"] = "BITCOIN_MAINNET";
      ChainType2["BITCOIN_TESTNET"] = "BITCOIN_TESTNET";
      ChainType2["BITCOIN_SIGNET"] = "BITCOIN_SIGNET";
    })(ChainType = exports.ChainType || (exports.ChainType = {}));
    exports.GENESIS_HASH_TO_NETWORK = {
      [GenesisHash.MAINNET]: Network.MAINNET,
      [GenesisHash.TESTNET]: Network.TESTNET,
      [GenesisHash.SIGNET]: Network.SIGNET
    };
    exports.NETWORK_TO_GENESIS_HASH = {
      [Network.MAINNET]: GenesisHash.MAINNET,
      [Network.LIVENET]: GenesisHash.MAINNET,
      [Network.TESTNET]: GenesisHash.TESTNET,
      [Network.SIGNET]: GenesisHash.SIGNET
    };
    exports.GENESIS_HASH_TO_CHAIN_TYPE = {
      [GenesisHash.MAINNET]: ChainType.BITCOIN_MAINNET,
      [GenesisHash.TESTNET]: ChainType.BITCOIN_TESTNET,
      [GenesisHash.SIGNET]: ChainType.BITCOIN_SIGNET
    };
    exports.CHAIN_TYPE_TO_GENESIS_HASH = {
      [ChainType.BITCOIN_MAINNET]: GenesisHash.MAINNET,
      [ChainType.BITCOIN_TESTNET]: GenesisHash.TESTNET,
      [ChainType.BITCOIN_SIGNET]: GenesisHash.SIGNET
    };
  }
});

// ../../node_modules/.pnpm/@keplr-wallet+types@0.12.252_starknet@7.6.4/node_modules/@keplr-wallet/types/build/wallet/index.js
var require_wallet = __commonJS({
  "../../node_modules/.pnpm/@keplr-wallet+types@0.12.252_starknet@7.6.4/node_modules/@keplr-wallet/types/build/wallet/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o4, m3, k5, k22) {
      if (k22 === void 0)
        k22 = k5;
      var desc = Object.getOwnPropertyDescriptor(m3, k5);
      if (!desc || ("get" in desc ? !m3.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m3[k5];
        } };
      }
      Object.defineProperty(o4, k22, desc);
    } : function(o4, m3, k5, k22) {
      if (k22 === void 0)
        k22 = k5;
      o4[k22] = m3[k5];
    });
    var __exportStar = exports && exports.__exportStar || function(m3, exports2) {
      for (var p4 in m3)
        if (p4 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p4))
          __createBinding(exports2, m3, p4);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_keplr(), exports);
    __exportStar(require_eip6963(), exports);
    __exportStar(require_ethereum(), exports);
    __exportStar(require_starknet(), exports);
    __exportStar(require_bitcoin(), exports);
  }
});

// ../../node_modules/.pnpm/@keplr-wallet+types@0.12.252_starknet@7.6.4/node_modules/@keplr-wallet/types/build/window.js
var require_window = __commonJS({
  "../../node_modules/.pnpm/@keplr-wallet+types@0.12.252_starknet@7.6.4/node_modules/@keplr-wallet/types/build/window.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// ../../node_modules/.pnpm/@keplr-wallet+types@0.12.252_starknet@7.6.4/node_modules/@keplr-wallet/types/build/ethereum.js
var require_ethereum2 = __commonJS({
  "../../node_modules/.pnpm/@keplr-wallet+types@0.12.252_starknet@7.6.4/node_modules/@keplr-wallet/types/build/ethereum.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.EthTxStatus = exports.EthSignType = void 0;
    var EthSignType;
    (function(EthSignType2) {
      EthSignType2["MESSAGE"] = "message";
      EthSignType2["TRANSACTION"] = "transaction";
      EthSignType2["EIP712"] = "eip-712";
    })(EthSignType = exports.EthSignType || (exports.EthSignType = {}));
    var EthTxStatus;
    (function(EthTxStatus2) {
      EthTxStatus2["Success"] = "0x1";
      EthTxStatus2["Failure"] = "0x0";
    })(EthTxStatus = exports.EthTxStatus || (exports.EthTxStatus = {}));
  }
});

// ../../node_modules/.pnpm/@keplr-wallet+types@0.12.252_starknet@7.6.4/node_modules/@keplr-wallet/types/build/cosmjs.js
var require_cosmjs = __commonJS({
  "../../node_modules/.pnpm/@keplr-wallet+types@0.12.252_starknet@7.6.4/node_modules/@keplr-wallet/types/build/cosmjs.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// ../../node_modules/.pnpm/@keplr-wallet+types@0.12.252_starknet@7.6.4/node_modules/@keplr-wallet/types/build/cosmjs-alt.js
var require_cosmjs_alt = __commonJS({
  "../../node_modules/.pnpm/@keplr-wallet+types@0.12.252_starknet@7.6.4/node_modules/@keplr-wallet/types/build/cosmjs-alt.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// ../../node_modules/.pnpm/@keplr-wallet+types@0.12.252_starknet@7.6.4/node_modules/@keplr-wallet/types/build/secretjs.js
var require_secretjs = __commonJS({
  "../../node_modules/.pnpm/@keplr-wallet+types@0.12.252_starknet@7.6.4/node_modules/@keplr-wallet/types/build/secretjs.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// ../../node_modules/.pnpm/@keplr-wallet+types@0.12.252_starknet@7.6.4/node_modules/@keplr-wallet/types/build/settled.js
var require_settled = __commonJS({
  "../../node_modules/.pnpm/@keplr-wallet+types@0.12.252_starknet@7.6.4/node_modules/@keplr-wallet/types/build/settled.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// ../../node_modules/.pnpm/@keplr-wallet+types@0.12.252_starknet@7.6.4/node_modules/@keplr-wallet/types/build/index.js
var require_build = __commonJS({
  "../../node_modules/.pnpm/@keplr-wallet+types@0.12.252_starknet@7.6.4/node_modules/@keplr-wallet/types/build/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o4, m3, k5, k22) {
      if (k22 === void 0)
        k22 = k5;
      var desc = Object.getOwnPropertyDescriptor(m3, k5);
      if (!desc || ("get" in desc ? !m3.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m3[k5];
        } };
      }
      Object.defineProperty(o4, k22, desc);
    } : function(o4, m3, k5, k22) {
      if (k22 === void 0)
        k22 = k5;
      o4[k22] = m3[k5];
    });
    var __exportStar = exports && exports.__exportStar || function(m3, exports2) {
      for (var p4 in m3)
        if (p4 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p4))
          __createBinding(exports2, m3, p4);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_currency(), exports);
    __exportStar(require_bech322(), exports);
    __exportStar(require_bip44(), exports);
    __exportStar(require_chain_info(), exports);
    __exportStar(require_wallet(), exports);
    __exportStar(require_window(), exports);
    __exportStar(require_ethereum2(), exports);
    __exportStar(require_cosmjs(), exports);
    __exportStar(require_cosmjs_alt(), exports);
    __exportStar(require_secretjs(), exports);
    __exportStar(require_settled(), exports);
  }
});

// ../../node_modules/.pnpm/@keplr-wallet+provider-extension@0.12.252_starknet@7.6.4/node_modules/@keplr-wallet/provider-extension/build/hex.js
var require_hex = __commonJS({
  "../../node_modules/.pnpm/@keplr-wallet+provider-extension@0.12.252_starknet@7.6.4/node_modules/@keplr-wallet/provider-extension/build/hex.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.fromHex = exports.toHex = void 0;
    function toHex2(data) {
      let out = "";
      for (const byte of data) {
        out += ("0" + byte.toString(16)).slice(-2);
      }
      return out;
    }
    exports.toHex = toHex2;
    function fromHex(hexstring) {
      if (hexstring.length % 2 !== 0) {
        throw new Error("hex string length must be a multiple of 2");
      }
      const listOfInts = [];
      for (let i4 = 0; i4 < hexstring.length; i4 += 2) {
        const hexByteAsString = hexstring.substr(i4, 2);
        if (!hexByteAsString.match(/[0-9a-f]{2}/i)) {
          throw new Error("hex string contains invalid characters");
        }
        listOfInts.push(parseInt(hexByteAsString, 16));
      }
      return new Uint8Array(listOfInts);
    }
    exports.fromHex = fromHex;
  }
});

// ../../node_modules/.pnpm/@keplr-wallet+provider-extension@0.12.252_starknet@7.6.4/node_modules/@keplr-wallet/provider-extension/build/uint8-array.js
var require_uint8_array = __commonJS({
  "../../node_modules/.pnpm/@keplr-wallet+provider-extension@0.12.252_starknet@7.6.4/node_modules/@keplr-wallet/provider-extension/build/uint8-array.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.JSONUint8Array = void 0;
    var hex_1 = require_hex();
    var JSONUint8Array = class _JSONUint8Array {
      static parse(text) {
        return JSON.parse(text, (key, value) => {
          if (key === "__proto__") {
            throw new Error("__proto__ is disallowed");
          }
          if (value && typeof value === "string" && value.startsWith("__uint8array__")) {
            return (0, hex_1.fromHex)(value.replace("__uint8array__", ""));
          }
          if (typeof BigInt !== "undefined" && value && typeof value === "string" && value.startsWith("__bigint__")) {
            return BigInt(value.replace("__bigint__", ""));
          }
          return value;
        });
      }
      static stringify(obj) {
        return JSON.stringify(obj, (key, value) => {
          if (key === "__proto__") {
            throw new Error("__proto__ is disallowed");
          }
          if (value && (value instanceof Uint8Array || typeof value === "object" && "type" in value && "data" in value && value.type === "Buffer" && Array.isArray(value.data))) {
            const array2 = value instanceof Uint8Array ? value : new Uint8Array(value.data);
            return `__uint8array__${(0, hex_1.toHex)(array2)}`;
          }
          if (typeof value === "bigint") {
            return `__bigint__${value.toString()}`;
          }
          return value;
        });
      }
      static wrap(obj) {
        if (obj === void 0)
          return void 0;
        return JSON.parse(_JSONUint8Array.stringify(obj));
      }
      static unwrap(obj) {
        if (obj === void 0)
          return void 0;
        return _JSONUint8Array.parse(_JSONUint8Array.stringify(obj));
      }
    };
    exports.JSONUint8Array = JSONUint8Array;
  }
});

// ../../node_modules/.pnpm/long@4.0.0/node_modules/long/src/long.js
var require_long = __commonJS({
  "../../node_modules/.pnpm/long@4.0.0/node_modules/long/src/long.js"(exports, module) {
    module.exports = Long3;
    var wasm = null;
    try {
      wasm = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([
        0,
        97,
        115,
        109,
        1,
        0,
        0,
        0,
        1,
        13,
        2,
        96,
        0,
        1,
        127,
        96,
        4,
        127,
        127,
        127,
        127,
        1,
        127,
        3,
        7,
        6,
        0,
        1,
        1,
        1,
        1,
        1,
        6,
        6,
        1,
        127,
        1,
        65,
        0,
        11,
        7,
        50,
        6,
        3,
        109,
        117,
        108,
        0,
        1,
        5,
        100,
        105,
        118,
        95,
        115,
        0,
        2,
        5,
        100,
        105,
        118,
        95,
        117,
        0,
        3,
        5,
        114,
        101,
        109,
        95,
        115,
        0,
        4,
        5,
        114,
        101,
        109,
        95,
        117,
        0,
        5,
        8,
        103,
        101,
        116,
        95,
        104,
        105,
        103,
        104,
        0,
        0,
        10,
        191,
        1,
        6,
        4,
        0,
        35,
        0,
        11,
        36,
        1,
        1,
        126,
        32,
        0,
        173,
        32,
        1,
        173,
        66,
        32,
        134,
        132,
        32,
        2,
        173,
        32,
        3,
        173,
        66,
        32,
        134,
        132,
        126,
        34,
        4,
        66,
        32,
        135,
        167,
        36,
        0,
        32,
        4,
        167,
        11,
        36,
        1,
        1,
        126,
        32,
        0,
        173,
        32,
        1,
        173,
        66,
        32,
        134,
        132,
        32,
        2,
        173,
        32,
        3,
        173,
        66,
        32,
        134,
        132,
        127,
        34,
        4,
        66,
        32,
        135,
        167,
        36,
        0,
        32,
        4,
        167,
        11,
        36,
        1,
        1,
        126,
        32,
        0,
        173,
        32,
        1,
        173,
        66,
        32,
        134,
        132,
        32,
        2,
        173,
        32,
        3,
        173,
        66,
        32,
        134,
        132,
        128,
        34,
        4,
        66,
        32,
        135,
        167,
        36,
        0,
        32,
        4,
        167,
        11,
        36,
        1,
        1,
        126,
        32,
        0,
        173,
        32,
        1,
        173,
        66,
        32,
        134,
        132,
        32,
        2,
        173,
        32,
        3,
        173,
        66,
        32,
        134,
        132,
        129,
        34,
        4,
        66,
        32,
        135,
        167,
        36,
        0,
        32,
        4,
        167,
        11,
        36,
        1,
        1,
        126,
        32,
        0,
        173,
        32,
        1,
        173,
        66,
        32,
        134,
        132,
        32,
        2,
        173,
        32,
        3,
        173,
        66,
        32,
        134,
        132,
        130,
        34,
        4,
        66,
        32,
        135,
        167,
        36,
        0,
        32,
        4,
        167,
        11
      ])), {}).exports;
    } catch (e2) {
    }
    function Long3(low, high, unsigned) {
      this.low = low | 0;
      this.high = high | 0;
      this.unsigned = !!unsigned;
    }
    Long3.prototype.__isLong__;
    Object.defineProperty(Long3.prototype, "__isLong__", { value: true });
    function isLong(obj) {
      return (obj && obj["__isLong__"]) === true;
    }
    Long3.isLong = isLong;
    var INT_CACHE = {};
    var UINT_CACHE = {};
    function fromInt(value, unsigned) {
      var obj, cachedObj, cache2;
      if (unsigned) {
        value >>>= 0;
        if (cache2 = 0 <= value && value < 256) {
          cachedObj = UINT_CACHE[value];
          if (cachedObj)
            return cachedObj;
        }
        obj = fromBits(value, (value | 0) < 0 ? -1 : 0, true);
        if (cache2)
          UINT_CACHE[value] = obj;
        return obj;
      } else {
        value |= 0;
        if (cache2 = -128 <= value && value < 128) {
          cachedObj = INT_CACHE[value];
          if (cachedObj)
            return cachedObj;
        }
        obj = fromBits(value, value < 0 ? -1 : 0, false);
        if (cache2)
          INT_CACHE[value] = obj;
        return obj;
      }
    }
    Long3.fromInt = fromInt;
    function fromNumber(value, unsigned) {
      if (isNaN(value))
        return unsigned ? UZERO : ZERO;
      if (unsigned) {
        if (value < 0)
          return UZERO;
        if (value >= TWO_PWR_64_DBL)
          return MAX_UNSIGNED_VALUE;
      } else {
        if (value <= -TWO_PWR_63_DBL)
          return MIN_VALUE;
        if (value + 1 >= TWO_PWR_63_DBL)
          return MAX_VALUE;
      }
      if (value < 0)
        return fromNumber(-value, unsigned).neg();
      return fromBits(value % TWO_PWR_32_DBL | 0, value / TWO_PWR_32_DBL | 0, unsigned);
    }
    Long3.fromNumber = fromNumber;
    function fromBits(lowBits, highBits, unsigned) {
      return new Long3(lowBits, highBits, unsigned);
    }
    Long3.fromBits = fromBits;
    var pow_dbl = Math.pow;
    function fromString(str, unsigned, radix) {
      if (str.length === 0)
        throw Error("empty string");
      if (str === "NaN" || str === "Infinity" || str === "+Infinity" || str === "-Infinity")
        return ZERO;
      if (typeof unsigned === "number") {
        radix = unsigned, unsigned = false;
      } else {
        unsigned = !!unsigned;
      }
      radix = radix || 10;
      if (radix < 2 || 36 < radix)
        throw RangeError("radix");
      var p4;
      if ((p4 = str.indexOf("-")) > 0)
        throw Error("interior hyphen");
      else if (p4 === 0) {
        return fromString(str.substring(1), unsigned, radix).neg();
      }
      var radixToPower = fromNumber(pow_dbl(radix, 8));
      var result = ZERO;
      for (var i4 = 0; i4 < str.length; i4 += 8) {
        var size = Math.min(8, str.length - i4), value = parseInt(str.substring(i4, i4 + size), radix);
        if (size < 8) {
          var power = fromNumber(pow_dbl(radix, size));
          result = result.mul(power).add(fromNumber(value));
        } else {
          result = result.mul(radixToPower);
          result = result.add(fromNumber(value));
        }
      }
      result.unsigned = unsigned;
      return result;
    }
    Long3.fromString = fromString;
    function fromValue(val, unsigned) {
      if (typeof val === "number")
        return fromNumber(val, unsigned);
      if (typeof val === "string")
        return fromString(val, unsigned);
      return fromBits(val.low, val.high, typeof unsigned === "boolean" ? unsigned : val.unsigned);
    }
    Long3.fromValue = fromValue;
    var TWO_PWR_16_DBL = 1 << 16;
    var TWO_PWR_24_DBL = 1 << 24;
    var TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;
    var TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;
    var TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;
    var TWO_PWR_24 = fromInt(TWO_PWR_24_DBL);
    var ZERO = fromInt(0);
    Long3.ZERO = ZERO;
    var UZERO = fromInt(0, true);
    Long3.UZERO = UZERO;
    var ONE2 = fromInt(1);
    Long3.ONE = ONE2;
    var UONE = fromInt(1, true);
    Long3.UONE = UONE;
    var NEG_ONE = fromInt(-1);
    Long3.NEG_ONE = NEG_ONE;
    var MAX_VALUE = fromBits(4294967295 | 0, 2147483647 | 0, false);
    Long3.MAX_VALUE = MAX_VALUE;
    var MAX_UNSIGNED_VALUE = fromBits(4294967295 | 0, 4294967295 | 0, true);
    Long3.MAX_UNSIGNED_VALUE = MAX_UNSIGNED_VALUE;
    var MIN_VALUE = fromBits(0, 2147483648 | 0, false);
    Long3.MIN_VALUE = MIN_VALUE;
    var LongPrototype = Long3.prototype;
    LongPrototype.toInt = function toInt() {
      return this.unsigned ? this.low >>> 0 : this.low;
    };
    LongPrototype.toNumber = function toNumber() {
      if (this.unsigned)
        return (this.high >>> 0) * TWO_PWR_32_DBL + (this.low >>> 0);
      return this.high * TWO_PWR_32_DBL + (this.low >>> 0);
    };
    LongPrototype.toString = function toString3(radix) {
      radix = radix || 10;
      if (radix < 2 || 36 < radix)
        throw RangeError("radix");
      if (this.isZero())
        return "0";
      if (this.isNegative()) {
        if (this.eq(MIN_VALUE)) {
          var radixLong = fromNumber(radix), div = this.div(radixLong), rem1 = div.mul(radixLong).sub(this);
          return div.toString(radix) + rem1.toInt().toString(radix);
        } else
          return "-" + this.neg().toString(radix);
      }
      var radixToPower = fromNumber(pow_dbl(radix, 6), this.unsigned), rem = this;
      var result = "";
      while (true) {
        var remDiv = rem.div(radixToPower), intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0, digits = intval.toString(radix);
        rem = remDiv;
        if (rem.isZero())
          return digits + result;
        else {
          while (digits.length < 6)
            digits = "0" + digits;
          result = "" + digits + result;
        }
      }
    };
    LongPrototype.getHighBits = function getHighBits() {
      return this.high;
    };
    LongPrototype.getHighBitsUnsigned = function getHighBitsUnsigned() {
      return this.high >>> 0;
    };
    LongPrototype.getLowBits = function getLowBits() {
      return this.low;
    };
    LongPrototype.getLowBitsUnsigned = function getLowBitsUnsigned() {
      return this.low >>> 0;
    };
    LongPrototype.getNumBitsAbs = function getNumBitsAbs() {
      if (this.isNegative())
        return this.eq(MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();
      var val = this.high != 0 ? this.high : this.low;
      for (var bit = 31; bit > 0; bit--)
        if ((val & 1 << bit) != 0)
          break;
      return this.high != 0 ? bit + 33 : bit + 1;
    };
    LongPrototype.isZero = function isZero() {
      return this.high === 0 && this.low === 0;
    };
    LongPrototype.eqz = LongPrototype.isZero;
    LongPrototype.isNegative = function isNegative() {
      return !this.unsigned && this.high < 0;
    };
    LongPrototype.isPositive = function isPositive() {
      return this.unsigned || this.high >= 0;
    };
    LongPrototype.isOdd = function isOdd() {
      return (this.low & 1) === 1;
    };
    LongPrototype.isEven = function isEven() {
      return (this.low & 1) === 0;
    };
    LongPrototype.equals = function equals(other) {
      if (!isLong(other))
        other = fromValue(other);
      if (this.unsigned !== other.unsigned && this.high >>> 31 === 1 && other.high >>> 31 === 1)
        return false;
      return this.high === other.high && this.low === other.low;
    };
    LongPrototype.eq = LongPrototype.equals;
    LongPrototype.notEquals = function notEquals(other) {
      return !this.eq(
        /* validates */
        other
      );
    };
    LongPrototype.neq = LongPrototype.notEquals;
    LongPrototype.ne = LongPrototype.notEquals;
    LongPrototype.lessThan = function lessThan(other) {
      return this.comp(
        /* validates */
        other
      ) < 0;
    };
    LongPrototype.lt = LongPrototype.lessThan;
    LongPrototype.lessThanOrEqual = function lessThanOrEqual(other) {
      return this.comp(
        /* validates */
        other
      ) <= 0;
    };
    LongPrototype.lte = LongPrototype.lessThanOrEqual;
    LongPrototype.le = LongPrototype.lessThanOrEqual;
    LongPrototype.greaterThan = function greaterThan(other) {
      return this.comp(
        /* validates */
        other
      ) > 0;
    };
    LongPrototype.gt = LongPrototype.greaterThan;
    LongPrototype.greaterThanOrEqual = function greaterThanOrEqual(other) {
      return this.comp(
        /* validates */
        other
      ) >= 0;
    };
    LongPrototype.gte = LongPrototype.greaterThanOrEqual;
    LongPrototype.ge = LongPrototype.greaterThanOrEqual;
    LongPrototype.compare = function compare(other) {
      if (!isLong(other))
        other = fromValue(other);
      if (this.eq(other))
        return 0;
      var thisNeg = this.isNegative(), otherNeg = other.isNegative();
      if (thisNeg && !otherNeg)
        return -1;
      if (!thisNeg && otherNeg)
        return 1;
      if (!this.unsigned)
        return this.sub(other).isNegative() ? -1 : 1;
      return other.high >>> 0 > this.high >>> 0 || other.high === this.high && other.low >>> 0 > this.low >>> 0 ? -1 : 1;
    };
    LongPrototype.comp = LongPrototype.compare;
    LongPrototype.negate = function negate() {
      if (!this.unsigned && this.eq(MIN_VALUE))
        return MIN_VALUE;
      return this.not().add(ONE2);
    };
    LongPrototype.neg = LongPrototype.negate;
    LongPrototype.add = function add(addend) {
      if (!isLong(addend))
        addend = fromValue(addend);
      var a48 = this.high >>> 16;
      var a32 = this.high & 65535;
      var a16 = this.low >>> 16;
      var a00 = this.low & 65535;
      var b48 = addend.high >>> 16;
      var b32 = addend.high & 65535;
      var b16 = addend.low >>> 16;
      var b00 = addend.low & 65535;
      var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
      c00 += a00 + b00;
      c16 += c00 >>> 16;
      c00 &= 65535;
      c16 += a16 + b16;
      c32 += c16 >>> 16;
      c16 &= 65535;
      c32 += a32 + b32;
      c48 += c32 >>> 16;
      c32 &= 65535;
      c48 += a48 + b48;
      c48 &= 65535;
      return fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
    };
    LongPrototype.subtract = function subtract(subtrahend) {
      if (!isLong(subtrahend))
        subtrahend = fromValue(subtrahend);
      return this.add(subtrahend.neg());
    };
    LongPrototype.sub = LongPrototype.subtract;
    LongPrototype.multiply = function multiply(multiplier) {
      if (this.isZero())
        return ZERO;
      if (!isLong(multiplier))
        multiplier = fromValue(multiplier);
      if (wasm) {
        var low = wasm.mul(
          this.low,
          this.high,
          multiplier.low,
          multiplier.high
        );
        return fromBits(low, wasm.get_high(), this.unsigned);
      }
      if (multiplier.isZero())
        return ZERO;
      if (this.eq(MIN_VALUE))
        return multiplier.isOdd() ? MIN_VALUE : ZERO;
      if (multiplier.eq(MIN_VALUE))
        return this.isOdd() ? MIN_VALUE : ZERO;
      if (this.isNegative()) {
        if (multiplier.isNegative())
          return this.neg().mul(multiplier.neg());
        else
          return this.neg().mul(multiplier).neg();
      } else if (multiplier.isNegative())
        return this.mul(multiplier.neg()).neg();
      if (this.lt(TWO_PWR_24) && multiplier.lt(TWO_PWR_24))
        return fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned);
      var a48 = this.high >>> 16;
      var a32 = this.high & 65535;
      var a16 = this.low >>> 16;
      var a00 = this.low & 65535;
      var b48 = multiplier.high >>> 16;
      var b32 = multiplier.high & 65535;
      var b16 = multiplier.low >>> 16;
      var b00 = multiplier.low & 65535;
      var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
      c00 += a00 * b00;
      c16 += c00 >>> 16;
      c00 &= 65535;
      c16 += a16 * b00;
      c32 += c16 >>> 16;
      c16 &= 65535;
      c16 += a00 * b16;
      c32 += c16 >>> 16;
      c16 &= 65535;
      c32 += a32 * b00;
      c48 += c32 >>> 16;
      c32 &= 65535;
      c32 += a16 * b16;
      c48 += c32 >>> 16;
      c32 &= 65535;
      c32 += a00 * b32;
      c48 += c32 >>> 16;
      c32 &= 65535;
      c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
      c48 &= 65535;
      return fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
    };
    LongPrototype.mul = LongPrototype.multiply;
    LongPrototype.divide = function divide(divisor) {
      if (!isLong(divisor))
        divisor = fromValue(divisor);
      if (divisor.isZero())
        throw Error("division by zero");
      if (wasm) {
        if (!this.unsigned && this.high === -2147483648 && divisor.low === -1 && divisor.high === -1) {
          return this;
        }
        var low = (this.unsigned ? wasm.div_u : wasm.div_s)(
          this.low,
          this.high,
          divisor.low,
          divisor.high
        );
        return fromBits(low, wasm.get_high(), this.unsigned);
      }
      if (this.isZero())
        return this.unsigned ? UZERO : ZERO;
      var approx, rem, res;
      if (!this.unsigned) {
        if (this.eq(MIN_VALUE)) {
          if (divisor.eq(ONE2) || divisor.eq(NEG_ONE))
            return MIN_VALUE;
          else if (divisor.eq(MIN_VALUE))
            return ONE2;
          else {
            var halfThis = this.shr(1);
            approx = halfThis.div(divisor).shl(1);
            if (approx.eq(ZERO)) {
              return divisor.isNegative() ? ONE2 : NEG_ONE;
            } else {
              rem = this.sub(divisor.mul(approx));
              res = approx.add(rem.div(divisor));
              return res;
            }
          }
        } else if (divisor.eq(MIN_VALUE))
          return this.unsigned ? UZERO : ZERO;
        if (this.isNegative()) {
          if (divisor.isNegative())
            return this.neg().div(divisor.neg());
          return this.neg().div(divisor).neg();
        } else if (divisor.isNegative())
          return this.div(divisor.neg()).neg();
        res = ZERO;
      } else {
        if (!divisor.unsigned)
          divisor = divisor.toUnsigned();
        if (divisor.gt(this))
          return UZERO;
        if (divisor.gt(this.shru(1)))
          return UONE;
        res = UZERO;
      }
      rem = this;
      while (rem.gte(divisor)) {
        approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber()));
        var log2 = Math.ceil(Math.log(approx) / Math.LN2), delta = log2 <= 48 ? 1 : pow_dbl(2, log2 - 48), approxRes = fromNumber(approx), approxRem = approxRes.mul(divisor);
        while (approxRem.isNegative() || approxRem.gt(rem)) {
          approx -= delta;
          approxRes = fromNumber(approx, this.unsigned);
          approxRem = approxRes.mul(divisor);
        }
        if (approxRes.isZero())
          approxRes = ONE2;
        res = res.add(approxRes);
        rem = rem.sub(approxRem);
      }
      return res;
    };
    LongPrototype.div = LongPrototype.divide;
    LongPrototype.modulo = function modulo(divisor) {
      if (!isLong(divisor))
        divisor = fromValue(divisor);
      if (wasm) {
        var low = (this.unsigned ? wasm.rem_u : wasm.rem_s)(
          this.low,
          this.high,
          divisor.low,
          divisor.high
        );
        return fromBits(low, wasm.get_high(), this.unsigned);
      }
      return this.sub(this.div(divisor).mul(divisor));
    };
    LongPrototype.mod = LongPrototype.modulo;
    LongPrototype.rem = LongPrototype.modulo;
    LongPrototype.not = function not() {
      return fromBits(~this.low, ~this.high, this.unsigned);
    };
    LongPrototype.and = function and(other) {
      if (!isLong(other))
        other = fromValue(other);
      return fromBits(this.low & other.low, this.high & other.high, this.unsigned);
    };
    LongPrototype.or = function or2(other) {
      if (!isLong(other))
        other = fromValue(other);
      return fromBits(this.low | other.low, this.high | other.high, this.unsigned);
    };
    LongPrototype.xor = function xor(other) {
      if (!isLong(other))
        other = fromValue(other);
      return fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned);
    };
    LongPrototype.shiftLeft = function shiftLeft(numBits) {
      if (isLong(numBits))
        numBits = numBits.toInt();
      if ((numBits &= 63) === 0)
        return this;
      else if (numBits < 32)
        return fromBits(this.low << numBits, this.high << numBits | this.low >>> 32 - numBits, this.unsigned);
      else
        return fromBits(0, this.low << numBits - 32, this.unsigned);
    };
    LongPrototype.shl = LongPrototype.shiftLeft;
    LongPrototype.shiftRight = function shiftRight(numBits) {
      if (isLong(numBits))
        numBits = numBits.toInt();
      if ((numBits &= 63) === 0)
        return this;
      else if (numBits < 32)
        return fromBits(this.low >>> numBits | this.high << 32 - numBits, this.high >> numBits, this.unsigned);
      else
        return fromBits(this.high >> numBits - 32, this.high >= 0 ? 0 : -1, this.unsigned);
    };
    LongPrototype.shr = LongPrototype.shiftRight;
    LongPrototype.shiftRightUnsigned = function shiftRightUnsigned(numBits) {
      if (isLong(numBits))
        numBits = numBits.toInt();
      numBits &= 63;
      if (numBits === 0)
        return this;
      else {
        var high = this.high;
        if (numBits < 32) {
          var low = this.low;
          return fromBits(low >>> numBits | high << 32 - numBits, high >>> numBits, this.unsigned);
        } else if (numBits === 32)
          return fromBits(high, 0, this.unsigned);
        else
          return fromBits(high >>> numBits - 32, 0, this.unsigned);
      }
    };
    LongPrototype.shru = LongPrototype.shiftRightUnsigned;
    LongPrototype.shr_u = LongPrototype.shiftRightUnsigned;
    LongPrototype.toSigned = function toSigned() {
      if (!this.unsigned)
        return this;
      return fromBits(this.low, this.high, false);
    };
    LongPrototype.toUnsigned = function toUnsigned() {
      if (this.unsigned)
        return this;
      return fromBits(this.low, this.high, true);
    };
    LongPrototype.toBytes = function toBytes(le2) {
      return le2 ? this.toBytesLE() : this.toBytesBE();
    };
    LongPrototype.toBytesLE = function toBytesLE() {
      var hi3 = this.high, lo2 = this.low;
      return [
        lo2 & 255,
        lo2 >>> 8 & 255,
        lo2 >>> 16 & 255,
        lo2 >>> 24,
        hi3 & 255,
        hi3 >>> 8 & 255,
        hi3 >>> 16 & 255,
        hi3 >>> 24
      ];
    };
    LongPrototype.toBytesBE = function toBytesBE() {
      var hi3 = this.high, lo2 = this.low;
      return [
        hi3 >>> 24,
        hi3 >>> 16 & 255,
        hi3 >>> 8 & 255,
        hi3 & 255,
        lo2 >>> 24,
        lo2 >>> 16 & 255,
        lo2 >>> 8 & 255,
        lo2 & 255
      ];
    };
    Long3.fromBytes = function fromBytes(bytes, unsigned, le2) {
      return le2 ? Long3.fromBytesLE(bytes, unsigned) : Long3.fromBytesBE(bytes, unsigned);
    };
    Long3.fromBytesLE = function fromBytesLE(bytes, unsigned) {
      return new Long3(
        bytes[0] | bytes[1] << 8 | bytes[2] << 16 | bytes[3] << 24,
        bytes[4] | bytes[5] << 8 | bytes[6] << 16 | bytes[7] << 24,
        unsigned
      );
    };
    Long3.fromBytesBE = function fromBytesBE(bytes, unsigned) {
      return new Long3(
        bytes[4] << 24 | bytes[5] << 16 | bytes[6] << 8 | bytes[7],
        bytes[0] << 24 | bytes[1] << 16 | bytes[2] << 8 | bytes[3],
        unsigned
      );
    };
  }
});

// ../../node_modules/.pnpm/@keplr-wallet+provider-extension@0.12.252_starknet@7.6.4/node_modules/@keplr-wallet/provider-extension/build/cosmjs.js
var require_cosmjs2 = __commonJS({
  "../../node_modules/.pnpm/@keplr-wallet+provider-extension@0.12.252_starknet@7.6.4/node_modules/@keplr-wallet/provider-extension/build/cosmjs.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P3, generator) {
      function adopt(value) {
        return value instanceof P3 ? value : new P3(function(resolve) {
          resolve(value);
        });
      }
      return new (P3 || (P3 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e2) {
            reject(e2);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e2) {
            reject(e2);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CosmJSOfflineSigner = exports.CosmJSOfflineSignerOnlyAmino = void 0;
    var CosmJSOfflineSignerOnlyAmino = class {
      constructor(chainId, keplr, signOptions) {
        this.chainId = chainId;
        this.keplr = keplr;
        this.signOptions = signOptions;
      }
      getAccounts() {
        return __awaiter(this, void 0, void 0, function* () {
          const key = yield this.keplr.getKey(this.chainId);
          return [
            {
              address: key.bech32Address,
              // Currently, only secp256k1 is supported.
              algo: "secp256k1",
              pubkey: key.pubKey
            }
          ];
        });
      }
      signAmino(signerAddress, signDoc) {
        return __awaiter(this, void 0, void 0, function* () {
          if (this.chainId !== signDoc.chain_id) {
            throw new Error("Unmatched chain id with the offline signer");
          }
          const key = yield this.keplr.getKey(signDoc.chain_id);
          if (key.bech32Address !== signerAddress) {
            throw new Error("Unknown signer address");
          }
          return yield this.keplr.signAmino(this.chainId, signerAddress, signDoc, this.signOptions);
        });
      }
      // Fallback function for the legacy cosmjs implementation before the stargate.
      sign(signerAddress, signDoc) {
        return __awaiter(this, void 0, void 0, function* () {
          return yield this.signAmino(signerAddress, signDoc);
        });
      }
    };
    exports.CosmJSOfflineSignerOnlyAmino = CosmJSOfflineSignerOnlyAmino;
    var CosmJSOfflineSigner = class extends CosmJSOfflineSignerOnlyAmino {
      constructor(chainId, keplr, signOptions) {
        super(chainId, keplr, signOptions);
      }
      signDirect(signerAddress, signDoc) {
        return __awaiter(this, void 0, void 0, function* () {
          if (this.chainId !== signDoc.chainId) {
            throw new Error("Unmatched chain id with the offline signer");
          }
          const key = yield this.keplr.getKey(signDoc.chainId);
          if (key.bech32Address !== signerAddress) {
            throw new Error("Unknown signer address");
          }
          return yield this.keplr.signDirect(this.chainId, signerAddress, signDoc, this.signOptions);
        });
      }
    };
    exports.CosmJSOfflineSigner = CosmJSOfflineSigner;
  }
});

// ../../node_modules/.pnpm/@keplr-wallet+provider-extension@0.12.252_starknet@7.6.4/node_modules/@keplr-wallet/provider-extension/build/enigma.js
var require_enigma = __commonJS({
  "../../node_modules/.pnpm/@keplr-wallet+provider-extension@0.12.252_starknet@7.6.4/node_modules/@keplr-wallet/provider-extension/build/enigma.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P3, generator) {
      function adopt(value) {
        return value instanceof P3 ? value : new P3(function(resolve) {
          resolve(value);
        });
      }
      return new (P3 || (P3 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e2) {
            reject(e2);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e2) {
            reject(e2);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.KeplrEnigmaUtils = void 0;
    var KeplrEnigmaUtils = class {
      constructor(chainId, keplr) {
        this.chainId = chainId;
        this.keplr = keplr;
      }
      getPubkey() {
        return __awaiter(this, void 0, void 0, function* () {
          return yield this.keplr.getEnigmaPubKey(this.chainId);
        });
      }
      getTxEncryptionKey(nonce) {
        return __awaiter(this, void 0, void 0, function* () {
          return yield this.keplr.getEnigmaTxEncryptionKey(this.chainId, nonce);
        });
      }
      encrypt(contractCodeHash, msg) {
        return __awaiter(this, void 0, void 0, function* () {
          return yield this.keplr.enigmaEncrypt(this.chainId, contractCodeHash, msg);
        });
      }
      decrypt(ciphertext, nonce) {
        return __awaiter(this, void 0, void 0, function* () {
          return yield this.keplr.enigmaDecrypt(this.chainId, ciphertext, nonce);
        });
      }
    };
    exports.KeplrEnigmaUtils = KeplrEnigmaUtils;
  }
});

// ../../node_modules/.pnpm/@keplr-wallet+provider-extension@0.12.252_starknet@7.6.4/node_modules/@keplr-wallet/provider-extension/build/version.js
var require_version = __commonJS({
  "../../node_modules/.pnpm/@keplr-wallet+provider-extension@0.12.252_starknet@7.6.4/node_modules/@keplr-wallet/provider-extension/build/version.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BUILD_VERSION = void 0;
    exports.BUILD_VERSION = "0.12.252";
  }
});

// ../../node_modules/.pnpm/@keplr-wallet+provider-extension@0.12.252_starknet@7.6.4/node_modules/@keplr-wallet/provider-extension/build/constants.js
var require_constants = __commonJS({
  "../../node_modules/.pnpm/@keplr-wallet+provider-extension@0.12.252_starknet@7.6.4/node_modules/@keplr-wallet/provider-extension/build/constants.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.metaId = exports.KeplrLogoBase64 = void 0;
    exports.KeplrLogoBase64 = "iVBORw0KGgoAAAANSUhEUgAAAIAAAACACAYAAADDPmHLAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAACPfSURBVHgBzV0L0B9VdT9nvy/vB6nVOg4GEx/VER3A1iqo9aMzFgWtoOhgsYaHYNV2lNEqxAdfmKHTakuDTge1FJK2tqOtGqoWFWti8TFSxGDriFSbIK+qgB95h+Tb09397+49r3t3/99/LT0zm//e9917fud3zr27SRB+EbKd1gAcOhFg/kSYmjoBiJ4JhMsB6LHFJetS+wfoAowOQOKnumGVUfSX+23Ba0uRfFaGsh6pNKDqP2PzQN5TbNxqjAeqi2CuWLuvAuU74eT1O+AXIAhDSaX0g+fBFL6ymHShfFhT5RvdknNLzsTIb+cChmzb2OJqJY8aQG9gaAUXaXLbOH0gL4mXmXHC/HYUv1thEWyDk9bPwQAyOQC2H1wHGb29uNtQdLcmFJBv2AsFAPVQJDQPlFBYFACpso7+kFm17g/9sUgr3QFWNI3VtQWO0KaCGXbDBLJwAFSKz2cLjtvglhNFGmr6NomgxEQdT1kYK8N0uzBwH3bosHJo3EKkD1ZG0X6ctAFEW6cAAiwYCAsDwM2HL4e8tHpa45a7NN2UUaxBmFAPmpdt+rGDq0zdrpP2I6yRig06ANHNHuAwjxlzFp67fhOMKeMBoLT6Kby+GHMGmklySVosJAO+ajK9LX6Uxl51eyqZp/tYvVcPbRklynQ7au913aaeBwLRz+6CDU4dhw2yvhVh++EzIcPvBOXXc+SXJz3LMVYeEblOYxKZMx/kF4V70aZPv+q+7ceUmaivHTu0hDSWqzwRWa4rAsTtcOuuM6Gn9APAzYfeVszsM8UAazoVCgDj1DELneqrBgrq/ilyKUFwFE2R8cX8UABD1OmaOx87pkw137gxoP9ssq91xfUZ+Pddl0MP6QbAVwt/Pw+boY+MCQzsquNY6VhCHUoGNeY4fUKjVLR9JdIC8IkxkTrqkerVPsNsHxCk17RUPtFstJw6tE2RfNAPl35Cs7XrSHcGhWPHADBWIJj25XJ8ipbJcUmlZR01Fs+bh0vg+eujBhwHQOnzoaD9pFAi25ZhD2XzPKmHNAAQyC/zHbCelFNGicBPpxP8jZFA0El37xyaHA8oqm8uBGfB89Zv84p8AJTRPuD24m4dpKSLAdhPPGKv8wx4+1l8dO/vtVWL1PvQKMIIxOtFo3VKKy9y4JNmkboflef2N5K5gglO8nYHfgxAhfJHwQQkL9EmXgfHqNcnLkBSwWAPEUFfrG3Xs6k8b+dg66N6RpS7DNMvAp+vwTXrB2Lt7dqugWm4HhyxANhe+P2U5fcBQy0mYh+nntOmL0BcoMREK8vNr8uiCgnKkAEixIO5Zo41IOKKrgPNWFvw1liuVDWHvNi+f/NHs6BErmdJ/Tnugt5Clhl5mVPdUnCkLnMhfVwC8hUz5c69qifm4vYBLrWT285Jq7aUdAOM4ut02ycAkLECilgGb1+1naNcugLJAPPF1iFlid7FxmjH6VO3R99d2zdOwa2k+gNpNVGGcObc5vPRExZvKFwxjahLil1olGf7qd0DgWIXjM+5Hbusg2syxMvVU9RSWv/R/tbvWyUflMZoQ9YwE6vfhxHK1ensy3HC6FlypG56ixZnBDJ1bf/2OwPeU8Qyeh6n5kDrGxZoGSA7CrMiqPEubjFdF5tTnzbGkrkoy+L5HgslGSbyPG4QR85YTp7PABi10sbqTTBIym8T2jnpvsV8EEwQ6EhG8Ha+ZtXHHHjk8M+hr1D7R1TQK1ftumIAtI1Nuo+Vpw+GAHod8rR5qXSqX5mOWzixcpanrIM8RhL9yP6UzM0fLljg1PVzIwY4cujMTovuQBVQD2tnc+zy2ynG6NoGdjJBbO5QWxdoa4aoj9fHwl46jIMBX6Tqt8+j/DwEixcswNsTJNYSwxVkzaIlcF55UwEAc9wwFgA8ZUQnYOt2AcN1b4mybvCh7IN6UH8zLx2ggVcnnY66BqpnxdcILDCaZ3Dn3/RK/nNJAGN7EUy9slkTwBsPeXZhJE3JuoicNn47jJhllwvoVe5RuaJ5Mz7avgCHTZutnBqzy0U0eXblKGIlRuaOHMnXT8ONB2d6Bo+9JeaeTJ2By9pyXslbQ8RRAUU6oI68sdOlpkikkSQIRxoPL4dadmgUSqHzURH5ukaOiqQS1kxPw4nTWfkFL/WDTEr6xR5xBY6v9NGqoFeJEu08BdcrHoDLFr7KQ9np2Glv/EKRSAYoCJQED0GDX2Q5wOYKajAuoW55N5UXAKA8m1mI+jvbUL+6CwGEKFdKQlHDmYRrNWBAgYMzAbZWG5IIZIASGpGTZ+eFdXEPGsf6yZs1wEUnTBeJYzrbmZyOwWgMBRZy7YlL4A1rp2Eh8m8PzsNp39yfrOMqE5i76FK0l1d0+tHjV8Hrj10KQ8h39x2Bk2/5WRisZCQ2HrXKU7GCmKDM6SpCmC9cQA7rus25n3TFEgMNY8U8mErEXIK2UOZvEdK0vvEpKwZT/l2H5uGc2x8S7KDHQzFPaDOC21LlvDCqF1xTmt06sX1JAMk0h8nqDAaICOOgp2BWiB20GZvfZU9bARufuhyGkFL5p9/6INx9KHdezTb7EwfhdQxAKV9LXqaQddOdf3Uu0ndKMIEet58eYIsKBeuIWT7P8sow0UazxGW/unw45R8slP/tB+HHxW87mAoMUbOBmZ4T/Y4h0ykAjSPj+Pxx23aOrQOvUmKgAMdVeaxXBwicJc5duwQ2Pm0Y5T98lODlheXfUyi/sXxyqF9s/2KULgJhgLRPlDKNOSxIJqJ/VGUTMIDxgaQsGsaZq7Q03u7Zx0zDNSesgiGkVP4ZtxSWfyAHHnsYP68WBhNl4NQEVZMzc3M3PZSv71O3nYAecxIXULdHM5Zfry1DVpHS8z5u+RR8/uTOzVJvOffbP4fv7Tka37K2WU5+m9Of+jFxNz3pKeBCqX9S2hd9eXSfGqu1NpTbKrS3xy2fhs+dshqOWTTMjN/63T3w9QcfsSwIvrI9RWOPOn3FBoEdgj0QM57SaTIwELjbz9Y1CDfgLzKKotFN2efaFVPwuResLkDQ/2/QpWTj9/bCP9x9UG4x7UwgrsT+9E88Va0DgbfJmx4jXpAt3WETZThem7HEYYCkwgnc7TLPO2YxwudeOJzy//TO/fDRXQeqIcLcmoHNDE0ZueWx9s7alm8BHYabyAXELDpeFmk3qRsa0wWkqLdRzmdfdMxgyv/AD/bDBwsA8LDDzmYhjFDXEeBN1FUgL2V6nMVfqL+vymI0HWPDvlK6gJx3qG4JBPLdOSj5y+euLKL+KRhCKuXfsb+eQ+phVZlQFgoqT0vsYcnNMjFAWslxIupL8UNbP+/DuoDE+CY+GMm7j18Gr3vSYhhCPvajg/Bn39+/YIvXRI9Obuvr2fOknILGz1guIAkOitdDb2ToZpQ+gqxrFJEPq2OsyVJ++QDvKpT/rmcugyHkE3cdgvfdvq+w/BBUsgFHWzyMW7ws8IHbMoMoGy+oFgzQ2/r1AkdamMlBhDUmdQEx9xJJe2UXP31pBYAh5BsPHIG33bqX+fwI9VcgAIguQKVQC4aktH0mK7V3CwsCo0EXQ2sPl4A0iebNsGYMce9F/rWc8+QlcOVJwxzxfm9uHs7/+sMOKBNb0Ja71cKaJrVyqWMr1rms4el7BoHUL6p3wJqyxDZvoF2ATuvAS4OgzH72L0/Blc8ZxvLv3p/Dq3fMwd4jsfUKGvLjIzU5cpuCH9WS2vz3k+4gMNKZmx1jBow9sGy3YMnB3eM2/jIGwrUrM9j6opWweoBTvlL5Z29/GPYeptbvV2M5oAuTJVtu6tQZ3ikOF17f61MUBul2AWQjUlccJccUjBEqXpDUMYAOsqIgqBf3uJUIn3nJquK0b/K9fqn813zlYbh3/zx7nsaeO/bwVRWKzlvWg3jMYILM2GgouhrvbWDKr8diRHTyqudldDEBA3Dl60+/YiA4rrD8T79k5WDKf+2/KuXrSL2OzsEtr6HClIuReiEvZjYUtf5Yi44YgEwSI/Vic9KBHjpbtElZoF1bh/Kb8Zo6q4sj3utnVlT0P6nsKXz9a7/8MNyzb/RaF1Nb3fYolsRcRb0u6mfZsnM1mhc7RCTxMigR+EWsWhUn66EpmEB4n6RcDFusMvtDL1wOz3rM5Kd8lfJvKix/b171G+iVfV6uwc7+hORxjZ/y2k26hNYFJIIC36ezQxVj3Y5FMCsQljuBYP1dBbbjgutTr3j+MnjpcYtgCLlo+174/oPz7nd8Md9vlOvRvicC1F3BHiWTuotpo8y+lBz17baOuCWHIYaIATzLZ+l3PGcpXHT8EhhC3vn1/fCt+4+MLF8xdgAitidzdcpnBU37VP+BDnNG1lNm9tAea1MwQI/V96iM2j9kFTYzTET/VXpCy9f9mMOeOv8dv7a0AsAQcsUtB+BT/3UYmtM9d0wBCt/3G8OJWQ7PoQ7r9PrukM6DID53t8wJUPSzSLTKv7SZ6r+XlG35OQDJeV307MUVAIaQq79zELb85yFBx9jhkxF4XT5pv36b79I7hngnsRGId2wXeox3AayOg2jZ3qe9NOoXLsiBxeZ52vpFsOmUYU75rr7tYAWACtA84FV/d6/ZiiaftfmXP7hleOuRUmaXtWtdu9ba4xzAt/IIgiMTEqDRwdoA4sUAzyqOeDfPDKf8D912cOTzXcrn/5SL3RLz8wkNDLHArnVTXNkOQHoDopZ+L4NUoOi5q0AK4UmNFXj5zQNOIDoGWLsqg2tftgJWL5mcYq7/j8Pw4VsPyrknAk7sEfwhv0kCo+4PIK3sCbbWvT8KxWYkPQEFDr5Ioh6SzUfmRhYq5ZB5mFep/E+eWZzyrZpc+Z/6wSNw5TcOmICPK5UrQdO8LjfH5R7tq/VzrR57Wjp248EFAEZHBp+2sQuNZA5kmroY67OntBZZXE88plD+WYXyV0+u/HKPf+lX9tf/hg60IBBKM0qH5FYU2bt6Ga+Q7ENXaOqxcUU+RMSNA6TEXYBAIEVHCdbAKK8pY/my7uhmcjXV/RYgXr0U4dozVgym/Ndv2xuOqVvF1kzAx3Zjgjgz+FtVBxie23DcgJOMZzq69oNAdFpRpLhRpqH80BxVQ5zAZxmprf+q314Gxz9u8vP98mj39z69F/YVr3UzV3HsX/5Cct2BOYl0QCHSAO62D2MKj+QDqDFNphX/HIBsD+gkRgMpCxeKl44sgITES5pJdwOXzyyF054y+RHvvXtq5R+i4JoSikT2Sdc4ls/7AkgDw+tL5IsOrIi+HVExgKVx25NUZJXWflDeKP9PJg8mAMDJa6eqa1Iplf+GT+2F+/bkYlGxy7qhiQ9AKCpm+e5a6TYAFgiNLaWAwCcVEV083ee7PI9SxL+pKw291a4J/PjHJej3+2hIpfx/rJWP2u+Dq1hUAPHKYuWectHz95ohmnyAxOt3nQFJSW4DvUFa6zZ5jdhPoMVJnWEFGuxAaCGyp/D1Gz7JLF9t9bjiW4tnrBVYQIqXj2OUJ9Ns/FT9UC+OgvRBkLZstRuwL3sUMJyI37iDR1v5nyiUP1e/0/don8Ac77b1HIYw7Vm5Trf16zw3Jqg7cllAVJaCrJ5fOJL4OUCkN49iWlZwJsb/QUSJ9kS88X8k77nxAPzgJ/PGvyOApG6eX2Y0ZcyHx2IFnQaQykHzKhj6uwMAP45ICgpg9NoGJg9/qP3D+RKHVD0Ir0b5xB8FFii/3r3jf45WZwiefxfWD5D09a2ylQFYJkD/lbhj+bFX596HIcbae4Oh/MeiSwCoC+ehOl4dXaq83raN8qm6qkWkum19VS9F2nqhHa/flj8KAFhVvCfY8rpVcOzqrJpDVs8nq+fE58fvm3q6LMtZ+ypd/8PMObtYm0zUleNnTV7RJiN5NX1lug/TNugCKX6FD0I0XLR/Nwl1IoaqTPh6aJnC97OPAgIKObY4Ov7wq1bCBX8/2vsLyua/nrU7ZdzCOXUbt8AeV7AF4Ni7gSrfNXXGEInlzaqOaut1Lb2x3PaqmYFknbYNYw3OAMgYAdu6MGIEePTk6Y+fgut+d1X15jBlKfwKLIDqitfNTFsYWXRj2YRifQwLGUu2rICCLSRDGJZoruiDardQKT0ovqH7AJYRMCTdw0jBRKG+6P/R3QI2UoLg2nNXVZ+Me/Ru6D8HV+GZqhdLY94oXbqczOmrAUqj6Ky9wKX+Biyesl2AejGAVToJpQsrdhTfx+pFjPD/BARXnb0y6ddDmVQAt9A4CLiF2jqZUlxbt7LuiDUbhTuxQtclqZ7EFVN6UHRQPHDFp6zeAwUsXO64fx6+f/88DCG//qRpmH3FingQSMFydVnMelv3kPt1Mt13zkDCrTfX1uwFh77VZ6kL60geGmW2SrRKh1ZxdX2+EMzqgS2Asfq2HiubgAH2FMHbH358P9z78xyGkFecsBhmf2eFQ//oAEJZsirLcnQZRLKDVbi2+Ma6W4t2ACKAwi8OQkIDnGgMwJXeBnQ0UiJnAREcEsn8PFg9VzaqsknjgPsemofzrt07GAheXoDg8lesgNjauL7U/MYBwxnFA4Z2N0gWSJnDKC1QuILreIFfgrmiMYB4QMkQyJQIudoViLYUKJ9NPjBFzQiTSN3vfQ/lcP6AIDjjxMXwxt9c5isuB0PPoUzuCDKKW73IF+5EKY8snTcMk+UIOr7IHHCaqwEEKL/fXto1kKN4kooP9yRcBOigESQoJpEqfqjHvv/BHC74WHG2PxAI3jizFN744hoE4ARtpC8UytTKDb4bbKDYKLTD/4vtn1Kmr/AI9bcuIMEAMuADq/hcKr5hA7sbgPb8AEw+THwQxK3y/oIJLhwQBBcWILhwZpmlaQDDbD6FB+WiVm4uleqCh7T/t0wQ+mt2DfJswmOFpAuoJj8PMuBzjoa14jkbiLgh4iJaMMEE4ix6yQSX/M0+2Nvvf8PrlAsKEJRXbHdQLS4gWKrnQZhVbuMyLBMEV4COq8hUfCAOkhQr6CNhuwtw6B+aq6Z/swVkwDCgYFRv3EDbnkLw1/Q7gQj3U4995z1H4eKP7B0MBOefurS6hPVQ3OJH1tVY97juAMUOQlpveMfgsgCrZ+g+V+8mmnMA7xI+us3jAJFlwbrDwZBemPZUkEAywaQAaINNuRO5896j8KZr9gwGgvMKAJw3sxQs7aNRBDr5zfsDz2K5xWdkAWb8PmmLtkfBaOo4l97zy32+WlhB7aBiAgpRPXGrp+BCCMwZwKT/VFz7QiaXTNMo6M575+GqGw7AULLht5bC2ScvERQe/LwCgYkDwFV8AIV1IXrHIGMIeXCURRSOFGeF6DeB3jvm8L6awLwbbxO1IpDi79Rrv88/rVqwKOtqxuFf4Hz+lsNV3vvPWQFDyFtOXwb7DxLcdNsjclwIz1jFBM380CsPec1bRPkmEsX3EqFMfQdQj1Gl1bcCqdiqKRt9ENIRhYlPt7gy63RYeFIgYACpG9h8GMAFKCWwqxnjXwoQlD75vQOB4I9evbwa98u3HbEgYArwlOoqGqSSuUq08k1Z8wdZVXaotvx7ARRVgPtRaGPFlYRTPPcLWoKAFNbOWsGEboDCLyI4ChldJRM84ZcyuPC0Yf7W8DvPXl6A6iB8+duP+B+PAgchGoYSytfMIfItSMI9CmPUdUDUtyVj/YcRozIydc1XsvyvSCtAhIVijDCJ/gmES0GS8x39/f2Qvu4Lo7/pe8FAIHjTy5fCrvvmYdf981bxag58vaq/VAJ6DR2GwKBgzRyhTp0v1hE7rb8sN+8C+Nl+CN5U9C+2exBe9DSBIIA5OWy2Z+L7AD7egoVE0Kd3MPyVdpN3/Y0H4fovHoQhZMVShD+5eAU85QlTIZKv14ef3aMO3kgHfF4gh87BUNgpiLMBE+SpMckPDjPgR778DEAp0L4QIrGft9E/2F0EA5moN4FUFuPswVGN1cydg2DLF4YDwR9ftAKe3IIAROQtlQRW+Y1CnQMgpLB70DsFAYhcbTnNhe6VgTr4QXbxMv5CSCyuOCCSdTWrCOXzwyeYQJwxtNXJvADaLQUItt44EAiWIVx5cQCBVnQzPn9LGBSrLdwHiGYC8W0Ce2bzIanaRsqTQHVUKA6EnPyWEbhbiB3wcErWboIrblIhClSfx6xf543qlwD44i2PwBBSguDSDcvgV4pAs6F1CQKb1m8BAzBip4XOsS8HRf1hiKdwvRajgyClcO9wJ5z1M0bglt+Ape2HjJsQ4NBtJwSBfDAC8ckZgXNULK8P/N0++NJAICiVf8XvL69+o0xAMYrW1oxuHXtSKNmAuxOPETgzRF4Hg/kuwGUEQanE3AUYyvfoH5irmESQHMYhAP1No11gaOf7wb/dBzd9azgQbHrzcni8AAE6vtuCI+4KGDu0v5HXx8S/J9Ag0i6gUaa6+CLqKF+k2Y7A+9QLybbnjDGY8sm3LB6feGXBHQB85J/2w3/fM8z3hY8rlH/5m2NM4LgCBxwyKPR3ArZfZweQg/92MHd2AeaNoFIoGAVDS/tim9fSv1YEmLyJ4wBHuT4o1GtrVbb/AMG7rt4zHAgeg/D+N6fdgWUCT9mJdC4BYdmAMYL7QQhJWnQ/BqnuLUBQvDACNx7gfr/px7y9m1AaBRrQUowVKFJGcKAAwaWbhwXBe9/CQeBTsssE0AUGSCievx2044W3gWLhyFI8W9SUu/B//X5MX0NI2SfUDwksluFj1L8tG2hg1HXKFz1Xfmwv/OShHIaQEgTveesyWLlMWXvzbsADI3QEgDCqk0HcDRhXQDYYzbQC2rNzT8kqyPKULH99cBhWmEQobukcCLbMAUEe8n76QA7v+Ys98NMHhwHBYwsQXFaAoDw0atY46grAugV7VuDFDd5BkWQY831g6xdzbalkYwLQ0T65jBC7tCsRY00g2DGmPgrWtN+CEzgQAH5WgOC9m4cDwXHHZnDpHywdgUAoawSKkVVbKpdWa1nD21FkAhTy7IAbo38OIBTmpzllBn9PCTYg8W2gYJIJpH351GHt0IJPPhN/Bg2KBgTvK5jgZwOC4N0tCOxcpc9mbAGS8vl2L27pum/rCvxPwtj+3rNYewIYgjmP8mOAGWQXQBHaB3DB5oOEDGB4+oECBO+/au9gIFhbgOCcVy1ulZUBRIErlaqVz+YLUMcUGJgEAngyVSfUjVI+WMv3joUTlwSBBdEg7wIgNhc+jlIsOCAweSSA8ECh/A9cs6/aJQwhp/zGFJx/7hJB+RiNA/wj5fBMXf4fAWPvBLQFxZSoF9ZjBzfqhyYPJO3za0JxT/rEAkllgqNgrvSYm7jr7nnYVDDBUCA4+XlTsOHcxc6cOX2jejaUVk/xj0hjShduwQv8YoEaZwYc81fcK2VMJFx5RBBnJRJj6zwNertLGN2XILjiz/fCUFKC4DWvXhQUCRbEbkxAUvkcIPotoa3DyooH3u1ZPTp5niLdxQa58CiYILKrmFTacSnQOTgWLhSsqB+00lUf9f2PCxB8dMtwXxqfOjMNp58+zeicWzFjBYi4AbIuhFt9iAVQX7vLfyZubqTRkbDP/UIe+xYJeT7VeaoMdV/8vv58zC1boAhKbC8KH03Vcxt9ikWj7/NI1eV56PTJ84o/bv7GI1X64vOH+V/HGwB88fPzzazDuoJe28AEIVXfI69X35G/xsVT7y6Cw/nbMWL1bcPmXm8RAaJM4ZWjYgnk/S9YSLKO+vXdQqQNYxFxD4xB2P3XChB8/JPDfFBSyssKELz0jGlh8dbaI+cCAGaL6AWGgiHy/OGseKW406VwABsQ6bRSZnpRWT1w6i5QAm0z5bDf0RheGdk0gOMinGdjc/7STYdh22cPw1Dy0tOnAgj0BZHL1LUHQ55rAMId0zngzoyU1slShvnyl6Vj4rkCYBNvZM/+HO776Xy0fUr27a8nQe0foAiwnjuNbuqfoHRFp8hA1bqFhIso/rjhnw9V9y84ZbEaPS6YSD/1aRncRPVXxsjmRz71hzz2J/rz4HmLpvKduG5m15psesmuIr3Gq9Tmad+CctHMwOoX0VlkZGlWnqGth6pepTjeDmsKFG0w5LM8Xcek2X1m8oMSwj3KOl66XYtYHQBQ9SUArLLl3yaSoOe/tsZINl2TYbZ7x/q5Auw7Y9G/jgOi9B6heoz1BX7fyPLRqR/GIvC3dqB2IHo8SrsCfWYAcm7YsQayL5AuVdM58XroUH1sO4c9KV+eBag2O8o5jf5PJMpvcM8DYLSlEucAwO75r8oX5wcQ+gvbNCetFRgBA0/LQyevPjlgIqU4smNqcLC2QnnqXgNDKpqxB0HEv7vKkuWij0h9J1+u7fzWFgB5fmRLkTmnAxyMKMSz+CgLEFtQ3Z/pvwnmNIiYYsAfpwGDzzAeOLwzgcAC4OQZxUMcCEbJntJArrWsLykf1TomlQ8g3IB3wdKpbdAAYOQG8q3tbBxlcaoW9M7y3bYAUQWio0itqFGaAiM5fcrfUE8zhQUPBwaFcfXYoMbQz9z2EQGCkzdqg37dpr+YwgEiSsZ2HVNXcQC0ZXYzzpV12/9mK4fpzRA5yxcW2Ty5dgcgT/hSCtMg8KzaWnejFP4iSS2+AA654IjRLweB159v5WT6cEHi5MVo35ajVTQHQ9sO3efyrnmETc10WgDs3vGE3QUMtoIW9RDIHyhxL3wmB4UBiV3wuHWrcYAilg2tQtH0TfLZmOW3z8jrseqBtkkCBdSCewpI5ZEcW5eDUqqpp0ACrL1mkuJ4ecvsR3B380ziP9qbh/lZ5LEAG7BdDAUE9PIBXEsWymFWaRgF4sxh5iP6CGNxANq5BK0KyoUwL48BWrCQbMfn4wJB5RlWaMvQdRVCycz6gXwlx/sAODIVrL8UAYAiFthdLObVYmYeGNRDg14MDwzk1ImAJSjOWSmlKM/ivb5QK1gwB5m6fLymHJ3n5n256+PVB3BZIZRhWDOSoNd169rmAgDDMDnRJm79AMqgGnnqi+/eXjSYMf9tCWvRDtKkEUUdrMsWknYPfrC2glRdVi+L5MfSmXfAg/WHGTwPMHIwNHrDljoQAq8viNeXOwFO8+weffp39LZ7419l61URuP/X6jQePb/4Ea6glZYOQ3r0GywWDa3ruvIXY1Zt6vboUyccJmiExwg8NhCflEFiTvwZmoS2fgLr35Xlo1fGWFNavQoKHRfguITdeARPBUdcANxRuALK6Hyehx4Q2H0zIVB5DTVDT1Dwh5V9gPXtjrjBHuhFjIHYWg9XgrwnoTTpEqxitSEZZXvP0tZBoVT3eVQ7nl/M9JLLtkjqbyT6vy3/aMdx24jwEr3OGEO/p8iExQswgO3Tt2w2XlUWwKTHG6XJmQdZVmjmq8qE8kDuNjQQBUCbbK1wXYc/k2KF6DMDuFs/DyB15U0b/xq3QUSS/932D29+4uZiDTeBY/3Jew8kGkg8EWMHSPQtWIHMYsu+nc7IB2mUaUi2bccin/lilg9OHjplmkUA4pauJew0aNNl107NQkI6/7/1H35t7SyWINCKid0n8jymAFL5dabew7t9eQN6IHRcDjptkfz+uFW7lqyUjo5yXZ9f5aFsCw6LJIwHI78EdMll16WVX0onAEq5swBBcUpwVtHtbnM6qBYee1ovn2y8rnr6SD+h3BschOLCHC3di04pbX1cXJB6Fh5bm4iSfdqHliF0//XvHOV41sbrpjZDD+kFgFLuvHn9tmxq/tQRCEA+gHgKiitIC7N+jNVXykqCBqQ7kP6QlKJ5G9uXl5e8F2mPUfw2xuJTcwMHyBwQ5SveHE/auCXu87v67yXPeOFds8XG+fK2E2STQp7HPoRo6tS/sX08r8t/Rx9moO3D1BmN2/ccoK0H3pkAqnbe3r9Jh7Lmr3G19I7+fj9jtXg5APoflMTv54qA9+rLtnRTvpbeDMDljq89qQDA/PoCclurjJTlQsQ3R9jBixMMPZtxpBWhx0LuL7kW6QpnmQgbua5Al3fWw7Y8ZZ2BBXDLI4QnLUT5vJ8FyzNmdq3DPJstrOaVxZzX8M/DpNWjYgeInvjpOpmyWvAYAsPiZq61g3P6J63bsoG1/Axi+d5p3uhhsohFC+aA0IanQbSDJrf8imvrPGSbZyP7+74yMQAaKb8tXA5TZxYdbiiumapzAQAIx8WuYiDqBlpqb8vRAoClFwYApSg256BYHwCZUOSkAJC/DAAFzcPO4u6Go5BtKRQ/BwPIYADQ8qyZXTMZZCcW+4UXF6OsyZDWFQ+8DqKKWTgAMhcI4wHAKLatE+wuCoC6LK5cDwCoACbKdxd9FgrGncUrnNtHv9M7h1I6l/8FAVO2ym5DPSIAAAAASUVORK5CYII=";
    exports.metaId = "d_2hxd99brRo";
  }
});

// ../../node_modules/.pnpm/@keplr-wallet+provider-extension@0.12.252_starknet@7.6.4/node_modules/@keplr-wallet/provider-extension/build/keplr.js
var require_keplr2 = __commonJS({
  "../../node_modules/.pnpm/@keplr-wallet+provider-extension@0.12.252_starknet@7.6.4/node_modules/@keplr-wallet/provider-extension/build/keplr.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P3, generator) {
      function adopt(value) {
        return value instanceof P3 ? value : new P3(function(resolve) {
          resolve(value);
        });
      }
      return new (P3 || (P3 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e2) {
            reject(e2);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e2) {
            reject(e2);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BitcoinProvider = exports.Keplr = exports.EthereumProviderRpcError = void 0;
    var types_1 = require_build();
    var uint8_array_1 = require_uint8_array();
    var deepmerge_1 = __importDefault(require_cjs());
    var long_1 = __importDefault(require_long());
    var cosmjs_1 = require_cosmjs2();
    var enigma_1 = require_enigma();
    var version_1 = require_version();
    var events_1 = __importDefault(require_events());
    var constants_1 = require_constants();
    var EthereumProviderRpcError = class _EthereumProviderRpcError extends Error {
      constructor(code, message, data) {
        super(message);
        this.code = code;
        this.data = data;
        Object.setPrototypeOf(this, _EthereumProviderRpcError.prototype);
      }
    };
    exports.EthereumProviderRpcError = EthereumProviderRpcError;
    var Keplr3 = class _Keplr {
      constructor() {
        this.enigmaUtils = /* @__PURE__ */ new Map();
        this.version = version_1.BUILD_VERSION;
        this.mode = "extension";
        this.defaultOptions = {};
        this.ethereum = new EthereumProvider(this);
        this.starknet = void 0;
        this.bitcoin = new BitcoinProvider(this);
      }
      static staticRequestMethod(method, args) {
        const isMobile = "ReactNativeWebView" in window;
        const postMessage = isMobile ? (message) => {
          window.ReactNativeWebView.postMessage(JSON.stringify(message));
        } : (message) => {
          window.postMessage(message, window.location.origin);
        };
        const parseMessage = isMobile ? (message) => {
          if (message && typeof message === "string") {
            try {
              return JSON.parse(message);
            } catch (_a2) {
            }
          }
          return message;
        } : (message) => {
          return message;
        };
        const bytes = new Uint8Array(8);
        const id = Array.from(crypto.getRandomValues(bytes)).map((value) => {
          return value.toString(16);
        }).join("");
        const proxyRequestType = !window.keplrRequestMetaIdSupport ? "proxy-request" : `proxy-request${constants_1.metaId ? `-${constants_1.metaId}` : ""}`;
        const proxyMessage = {
          type: proxyRequestType,
          id,
          method,
          args: uint8_array_1.JSONUint8Array.wrap(args)
        };
        return new Promise((resolve, reject) => {
          const receiveResponse = (e2) => {
            const proxyResponse = parseMessage(e2.data);
            if (!proxyResponse || proxyResponse.type !== "proxy-request-response") {
              return;
            }
            if (proxyResponse.id !== id) {
              return;
            }
            window.removeEventListener("message", receiveResponse);
            const result = uint8_array_1.JSONUint8Array.unwrap(proxyResponse.result);
            if (!result) {
              reject(new Error("Result is null"));
              return;
            }
            if (result.error) {
              reject(new Error(result.error));
              return;
            }
            resolve(result.return);
          };
          window.addEventListener("message", receiveResponse);
          postMessage(proxyMessage);
        });
      }
      requestMethod(method, args) {
        return _Keplr.staticRequestMethod(method, args);
      }
      static getKeplr(pingTimeout = 1500) {
        return __awaiter(this, void 0, void 0, function* () {
          yield waitDocumentReady();
          const isMobile = "ReactNativeWebView" in window;
          const isFirefox = (() => {
            if (typeof navigator !== "undefined" && "userAgent" in navigator) {
              return navigator.userAgent.includes("Firefox");
            }
            return false;
          })();
          if (!isMobile && !isFirefox && window.keplrRequestMetaIdSupport == null) {
            return void 0;
          }
          return new Promise((resolve, reject) => {
            const timeout = setTimeout(() => {
              resolve(void 0);
            }, pingTimeout);
            _Keplr.staticRequestMethod("ping", []).then(() => {
              clearTimeout(timeout);
              resolve(new _Keplr());
            }).catch((e2) => {
              var _a2;
              if ((_a2 = e2 === null || e2 === void 0 ? void 0 : e2.message) === null || _a2 === void 0 ? void 0 : _a2.includes("Invalid method: ping")) {
                clearTimeout(timeout);
                resolve(new _Keplr());
              } else {
                reject(e2);
              }
            });
          });
        });
      }
      ping() {
        return __awaiter(this, void 0, void 0, function* () {
          yield this.requestMethod("ping", []);
        });
      }
      enable(chainIds) {
        return __awaiter(this, void 0, void 0, function* () {
          yield this.requestMethod("enable", [chainIds]);
        });
      }
      disable(chainIds) {
        return __awaiter(this, void 0, void 0, function* () {
          yield this.requestMethod("disable", [chainIds]);
        });
      }
      experimentalSuggestChain(chainInfo) {
        var _a2, _b;
        return __awaiter(this, void 0, void 0, function* () {
          if (chainInfo.hideInUI) {
            throw new Error("hideInUI is not allowed");
          }
          if (((_a2 = chainInfo.features) === null || _a2 === void 0 ? void 0 : _a2.includes("stargate")) || ((_b = chainInfo.features) === null || _b === void 0 ? void 0 : _b.includes("no-legacy-stdTx"))) {
            console.warn("stargate, no-legacy-stdTx feature has been deprecated. The launchpad is no longer supported, thus works without the two features. We would keep the aforementioned two feature for a while, but the upcoming update would potentially cause errors. Remove the two feature.");
          }
          yield this.requestMethod("experimentalSuggestChain", [chainInfo]);
        });
      }
      getKey(chainId) {
        return __awaiter(this, void 0, void 0, function* () {
          return yield this.requestMethod("getKey", [chainId]);
        });
      }
      getKeysSettled(chainIds) {
        return __awaiter(this, void 0, void 0, function* () {
          return yield this.requestMethod("getKeysSettled", [chainIds]);
        });
      }
      sendTx(chainId, tx, mode) {
        return __awaiter(this, void 0, void 0, function* () {
          if (!("length" in tx)) {
            console.warn("Do not send legacy std tx via `sendTx` API. We now only support protobuf tx. The usage of legeacy std tx would throw an error in the near future.");
          }
          return yield this.requestMethod("sendTx", [chainId, tx, mode]);
        });
      }
      signAmino(chainId, signer, signDoc, signOptions = {}) {
        var _a2;
        return __awaiter(this, void 0, void 0, function* () {
          return yield this.requestMethod("signAmino", [
            chainId,
            signer,
            signDoc,
            (0, deepmerge_1.default)((_a2 = this.defaultOptions.sign) !== null && _a2 !== void 0 ? _a2 : {}, signOptions)
          ]);
        });
      }
      signDirect(chainId, signer, signDoc, signOptions = {}) {
        var _a2;
        return __awaiter(this, void 0, void 0, function* () {
          const result = yield this.requestMethod("signDirect", [
            chainId,
            signer,
            // We can't send the `Long` with remaing the type.
            // Receiver should change the `string` to `Long`.
            {
              bodyBytes: signDoc.bodyBytes,
              authInfoBytes: signDoc.authInfoBytes,
              chainId: signDoc.chainId,
              accountNumber: signDoc.accountNumber ? signDoc.accountNumber.toString() : null
            },
            (0, deepmerge_1.default)((_a2 = this.defaultOptions.sign) !== null && _a2 !== void 0 ? _a2 : {}, signOptions)
          ]);
          const signed = result.signed;
          return {
            signed: {
              bodyBytes: signed.bodyBytes,
              authInfoBytes: signed.authInfoBytes,
              chainId: signed.chainId,
              // We can't send the `Long` with remaing the type.
              // Sender should change the `Long` to `string`.
              accountNumber: long_1.default.fromString(signed.accountNumber)
            },
            signature: result.signature
          };
        });
      }
      signDirectAux(chainId, signer, signDoc, signOptions = {}) {
        var _a2;
        return __awaiter(this, void 0, void 0, function* () {
          const result = yield this.requestMethod("signDirectAux", [
            chainId,
            signer,
            // We can't send the `Long` with remaing the type.
            // Receiver should change the `string` to `Long`.
            {
              bodyBytes: signDoc.bodyBytes,
              publicKey: signDoc.publicKey,
              chainId: signDoc.chainId,
              accountNumber: signDoc.accountNumber ? signDoc.accountNumber.toString() : null,
              sequence: signDoc.sequence ? signDoc.sequence.toString() : null
            },
            (0, deepmerge_1.default)({
              preferNoSetMemo: (_a2 = this.defaultOptions.sign) === null || _a2 === void 0 ? void 0 : _a2.preferNoSetMemo
            }, signOptions)
          ]);
          const signed = result.signed;
          return {
            signed: {
              bodyBytes: signed.bodyBytes,
              publicKey: signed.publicKey || void 0,
              chainId: signed.chainId,
              // We can't send the `Long` with remaing the type.
              // Sender should change the `Long` to `string`.
              accountNumber: long_1.default.fromString(signed.accountNumber),
              sequence: long_1.default.fromString(signed.sequence)
            },
            signature: result.signature
          };
        });
      }
      signArbitrary(chainId, signer, data) {
        return __awaiter(this, void 0, void 0, function* () {
          return yield this.requestMethod("signArbitrary", [chainId, signer, data]);
        });
      }
      signICNSAdr36(chainId, contractAddress, owner, username, addressChainIds) {
        return this.requestMethod("signICNSAdr36", [
          chainId,
          contractAddress,
          owner,
          username,
          addressChainIds
        ]);
      }
      verifyArbitrary(chainId, signer, data, signature) {
        return __awaiter(this, void 0, void 0, function* () {
          return yield this.requestMethod("verifyArbitrary", [
            chainId,
            signer,
            data,
            signature
          ]);
        });
      }
      signEthereum(chainId, signer, data, type) {
        return __awaiter(this, void 0, void 0, function* () {
          return yield this.requestMethod("signEthereum", [
            chainId,
            signer,
            data,
            type
          ]);
        });
      }
      getOfflineSigner(chainId, signOptions) {
        return new cosmjs_1.CosmJSOfflineSigner(chainId, this, signOptions);
      }
      getOfflineSignerOnlyAmino(chainId, signOptions) {
        return new cosmjs_1.CosmJSOfflineSignerOnlyAmino(chainId, this, signOptions);
      }
      getOfflineSignerAuto(chainId, signOptions) {
        return __awaiter(this, void 0, void 0, function* () {
          const key = yield this.getKey(chainId);
          if (key.isNanoLedger) {
            return new cosmjs_1.CosmJSOfflineSignerOnlyAmino(chainId, this, signOptions);
          }
          return new cosmjs_1.CosmJSOfflineSigner(chainId, this, signOptions);
        });
      }
      suggestToken(chainId, contractAddress, viewingKey) {
        return __awaiter(this, void 0, void 0, function* () {
          return yield this.requestMethod("suggestToken", [
            chainId,
            contractAddress,
            viewingKey
          ]);
        });
      }
      getSecret20ViewingKey(chainId, contractAddress) {
        return __awaiter(this, void 0, void 0, function* () {
          return yield this.requestMethod("getSecret20ViewingKey", [
            chainId,
            contractAddress
          ]);
        });
      }
      getEnigmaPubKey(chainId) {
        return __awaiter(this, void 0, void 0, function* () {
          return yield this.requestMethod("getEnigmaPubKey", [chainId]);
        });
      }
      getEnigmaTxEncryptionKey(chainId, nonce) {
        return __awaiter(this, void 0, void 0, function* () {
          return yield this.requestMethod("getEnigmaTxEncryptionKey", [
            chainId,
            nonce
          ]);
        });
      }
      enigmaEncrypt(chainId, contractCodeHash, msg) {
        return __awaiter(this, void 0, void 0, function* () {
          return yield this.requestMethod("enigmaEncrypt", [
            chainId,
            contractCodeHash,
            msg
          ]);
        });
      }
      enigmaDecrypt(chainId, ciphertext, nonce) {
        return __awaiter(this, void 0, void 0, function* () {
          return yield this.requestMethod("enigmaDecrypt", [
            chainId,
            ciphertext,
            nonce
          ]);
        });
      }
      getEnigmaUtils(chainId) {
        if (this.enigmaUtils.has(chainId)) {
          return this.enigmaUtils.get(chainId);
        }
        const enigmaUtils = new enigma_1.KeplrEnigmaUtils(chainId, this);
        this.enigmaUtils.set(chainId, enigmaUtils);
        return enigmaUtils;
      }
      experimentalSignEIP712CosmosTx_v0(chainId, signer, eip712, signDoc, signOptions = {}) {
        var _a2;
        return __awaiter(this, void 0, void 0, function* () {
          return yield this.requestMethod("experimentalSignEIP712CosmosTx_v0", [
            chainId,
            signer,
            eip712,
            signDoc,
            (0, deepmerge_1.default)((_a2 = this.defaultOptions.sign) !== null && _a2 !== void 0 ? _a2 : {}, signOptions)
          ]);
        });
      }
      getChainInfosWithoutEndpoints() {
        return __awaiter(this, void 0, void 0, function* () {
          return yield this.requestMethod("getChainInfosWithoutEndpoints", []);
        });
      }
      changeKeyRingName({ defaultName, editable = true }) {
        return __awaiter(this, void 0, void 0, function* () {
          return yield this.requestMethod("changeKeyRingName", [
            { defaultName, editable }
          ]);
        });
      }
      sendEthereumTx(chainId, tx) {
        return __awaiter(this, void 0, void 0, function* () {
          return yield this.requestMethod("sendEthereumTx", [chainId, tx]);
        });
      }
      suggestERC20(chainId, contractAddress) {
        return __awaiter(this, void 0, void 0, function* () {
          return yield this.requestMethod("suggestERC20", [chainId, contractAddress]);
        });
      }
      getChainInfoWithoutEndpoints(chainId) {
        return __awaiter(this, void 0, void 0, function* () {
          return yield this.requestMethod("getChainInfoWithoutEndpoints", [chainId]);
        });
      }
      getStarknetKey(chainId) {
        return __awaiter(this, void 0, void 0, function* () {
          return yield this.requestMethod("getStarknetKey", [chainId]);
        });
      }
      getStarknetKeysSettled(chainIds) {
        return __awaiter(this, void 0, void 0, function* () {
          return yield this.requestMethod("getStarknetKeysSettled", [chainIds]);
        });
      }
      signStarknetTx(chainId, transactions, details) {
        return __awaiter(this, void 0, void 0, function* () {
          return yield this.requestMethod("signStarknetTx", [
            chainId,
            transactions,
            details
          ]);
        });
      }
      signStarknetDeployAccountTransaction(chainId, transaction2) {
        return __awaiter(this, void 0, void 0, function* () {
          return yield this.requestMethod("signStarknetDeployAccountTransaction", [
            chainId,
            transaction2
          ]);
        });
      }
      getBitcoinKey(chainId) {
        return __awaiter(this, void 0, void 0, function* () {
          return yield this.requestMethod("getBitcoinKey", [chainId]);
        });
      }
      getBitcoinKeysSettled(chainIds) {
        return __awaiter(this, void 0, void 0, function* () {
          return yield this.requestMethod("getBitcoinKeysSettled", [chainIds]);
        });
      }
      signPsbt(chainId, psbtHex, options) {
        return __awaiter(this, void 0, void 0, function* () {
          return yield this.requestMethod("signPsbt", [chainId, psbtHex, options]);
        });
      }
      signPsbts(chainId, psbtsHexes, options) {
        return __awaiter(this, void 0, void 0, function* () {
          return yield this.requestMethod("signPsbts", [
            chainId,
            psbtsHexes,
            options
          ]);
        });
      }
      __core__getAnalyticsId() {
        return __awaiter(this, void 0, void 0, function* () {
          return yield this.requestMethod("__core__getAnalyticsId", []);
        });
      }
      __core__privilageSignAminoWithdrawRewards(chainId, signer, signDoc) {
        return __awaiter(this, void 0, void 0, function* () {
          return yield this.requestMethod("__core__privilageSignAminoWithdrawRewards", [chainId, signer, signDoc]);
        });
      }
      __core__privilageSignAminoDelegate(chainId, signer, signDoc) {
        return __awaiter(this, void 0, void 0, function* () {
          return yield this.requestMethod("__core__privilageSignAminoDelegate", [chainId, signer, signDoc]);
        });
      }
      __core__privilageSignAminoExecuteCosmWasm(chainId, signer, signDoc) {
        return __awaiter(this, void 0, void 0, function* () {
          return yield this.requestMethod("__core__privilageSignAminoExecuteCosmWasm", [chainId, signer, signDoc]);
        });
      }
      __core__webpageClosed() {
        return __awaiter(this, void 0, void 0, function* () {
          return yield this.requestMethod("__core__webpageClosed", []);
        });
      }
    };
    exports.Keplr = Keplr3;
    var waitDocumentReady = () => {
      if (document.readyState === "complete") {
        return Promise.resolve();
      }
      return new Promise((resolve) => {
        const documentStateChange = (event) => {
          if (event.target && event.target.readyState === "complete") {
            resolve();
            document.removeEventListener("readystatechange", documentStateChange);
          }
        };
        document.addEventListener("readystatechange", documentStateChange);
      });
    };
    var EthereumProvider = class _EthereumProvider extends events_1.default {
      constructor(keplr) {
        super();
        this.keplr = keplr;
        this.eip6963ProviderInfo = {
          uuid: crypto.randomUUID(),
          name: "Keplr",
          rdns: "app.keplr",
          icon: `data:image/png;base64,${constants_1.KeplrLogoBase64}`
        };
        this.chainId = null;
        this.networkVersion = null;
        this.selectedAddress = null;
        this.isKeplr = true;
        this.isMetaMask = true;
        this._isConnected = false;
        this._currentChainId = null;
        window.addEventListener("keplr_keystorechange", () => __awaiter(this, void 0, void 0, function* () {
          if (this._currentChainId) {
            const chainInfo = yield keplr.getChainInfoWithoutEndpoints(this._currentChainId);
            if (chainInfo) {
              const selectedAddress = (yield keplr.getKey(this._currentChainId)).ethereumHexAddress;
              this.handleAccountsChanged(selectedAddress);
            }
          }
        }));
        window.addEventListener("keplr_chainChanged", (event) => {
          const origin = event.detail.origin;
          if (origin === window.location.origin) {
            const evmChainId = event.detail.evmChainId;
            this.handleChainChanged(evmChainId);
          }
        });
        window.addEventListener("keplr_ethSubscription", (event) => {
          var _a2;
          const origin = event.detail.origin;
          const providerId = event.detail.providerId;
          if (origin === window.location.origin && providerId === ((_a2 = this.eip6963ProviderInfo) === null || _a2 === void 0 ? void 0 : _a2.uuid)) {
            const data = event.detail.data;
            this.emit("message", {
              type: "eth_subscription",
              data
            });
          }
        });
        if (this.eip6963ProviderInfo) {
          const announceEvent = new CustomEvent(types_1.EIP6963EventNames.Announce, {
            detail: Object.freeze({
              info: this.eip6963ProviderInfo,
              provider: this
            })
          });
          window.addEventListener(types_1.EIP6963EventNames.Request, () => window.dispatchEvent(announceEvent));
          window.dispatchEvent(announceEvent);
        }
      }
      static requestMethod(method, args) {
        return __awaiter(this, void 0, void 0, function* () {
          const isMobile = "ReactNativeWebView" in window;
          const postMessage = isMobile ? (message) => {
            window.ReactNativeWebView.postMessage(JSON.stringify(message));
          } : (message) => {
            window.postMessage(message, window.location.origin);
          };
          const parseMessage = isMobile ? (message) => {
            if (message && typeof message === "string") {
              try {
                return JSON.parse(message);
              } catch (_a2) {
              }
            }
            return message;
          } : (message) => {
            return message;
          };
          const bytes = new Uint8Array(8);
          const id = Array.from(crypto.getRandomValues(bytes)).map((value) => {
            return value.toString(16);
          }).join("");
          const proxyRequestType = !window.keplrRequestMetaIdSupport ? "proxy-request" : `proxy-request${constants_1.metaId ? `-${constants_1.metaId}` : ""}`;
          const proxyMessage = {
            type: proxyRequestType,
            id,
            method: "ethereum",
            args: uint8_array_1.JSONUint8Array.wrap(args),
            ethereumProviderMethod: method
          };
          return new Promise((resolve, reject) => {
            const receiveResponse = (e2) => {
              const proxyResponse = parseMessage(e2.data);
              if (!proxyResponse || proxyResponse.type !== "proxy-request-response") {
                return;
              }
              if (proxyResponse.id !== id) {
                return;
              }
              window.removeEventListener("message", receiveResponse);
              const result = uint8_array_1.JSONUint8Array.unwrap(proxyResponse.result);
              if (!result) {
                reject(new Error("Result is null"));
                return;
              }
              if (result.error) {
                const error = result.error;
                reject(error.code && !error.module ? new EthereumProviderRpcError(error.code, error.message, error.data) : new Error(error));
                return;
              }
              resolve(result.return);
            };
            window.addEventListener("message", receiveResponse);
            postMessage(proxyMessage);
          });
        });
      }
      handleConnect(evmChainId) {
        return __awaiter(this, void 0, void 0, function* () {
          if (!this._isConnected) {
            const { currentEvmChainId, currentChainId, selectedAddress } = yield _EthereumProvider.requestMethod("request", Object.assign({ method: "keplr_connect" }, evmChainId && { params: [evmChainId] }));
            this._isConnected = true;
            this._currentChainId = currentChainId;
            this.chainId = `0x${currentEvmChainId.toString(16)}`;
            this.networkVersion = currentEvmChainId.toString(10);
            this.selectedAddress = selectedAddress;
            this.emit("connect", { chainId: this.chainId });
          }
        });
      }
      handleDisconnect() {
        return __awaiter(this, void 0, void 0, function* () {
          if (this._isConnected) {
            yield _EthereumProvider.requestMethod("request", {
              method: "keplr_disconnect"
            });
            this._isConnected = false;
            this.chainId = null;
            this.selectedAddress = null;
            this.networkVersion = null;
            this.emit("disconnect");
          }
        });
      }
      handleChainChanged(evmChainId) {
        return __awaiter(this, void 0, void 0, function* () {
          yield this.handleConnect(evmChainId);
          const evmChainIdHex = `0x${evmChainId.toString(16)}`;
          this.emit("chainChanged", evmChainIdHex);
        });
      }
      handleAccountsChanged(selectedAddress) {
        return __awaiter(this, void 0, void 0, function* () {
          if (this._isConnected) {
            this.selectedAddress = selectedAddress;
            this.emit("accountsChanged", [selectedAddress]);
          }
        });
      }
      isConnected() {
        return this._isConnected;
      }
      request({ method, params, chainId }) {
        var _a2;
        return __awaiter(this, void 0, void 0, function* () {
          if (!this._isConnected) {
            if (method === "eth_accounts") {
              return [];
            }
            yield this.handleConnect();
          }
          return yield _EthereumProvider.requestMethod("request", {
            method,
            params,
            providerId: (_a2 = this.eip6963ProviderInfo) === null || _a2 === void 0 ? void 0 : _a2.uuid,
            chainId
          });
        });
      }
      enable() {
        return __awaiter(this, void 0, void 0, function* () {
          return yield _EthereumProvider.requestMethod("request", {
            method: "eth_requestAccounts"
          });
        });
      }
      net_version() {
        return __awaiter(this, void 0, void 0, function* () {
          return yield _EthereumProvider.requestMethod("request", {
            method: "net_version"
          });
        });
      }
    };
    var BitcoinProvider = class _BitcoinProvider extends events_1.default {
      constructor(keplr) {
        super();
        this.keplr = keplr;
      }
      static _requestMethod(method, args) {
        return __awaiter(this, void 0, void 0, function* () {
          const isMobile = "ReactNativeWebView" in window;
          const postMessage = isMobile ? (message) => {
            window.ReactNativeWebView.postMessage(JSON.stringify(message));
          } : (message) => {
            window.postMessage(message, window.location.origin);
          };
          const parseMessage = isMobile ? (message) => {
            if (message && typeof message === "string") {
              try {
                return JSON.parse(message);
              } catch (_a2) {
              }
            }
            return message;
          } : (message) => {
            return message;
          };
          const bytes = new Uint8Array(8);
          const id = Array.from(crypto.getRandomValues(bytes)).map((value) => {
            return value.toString(16);
          }).join("");
          const proxyRequestType = !window.keplrRequestMetaIdSupport ? "proxy-request" : `proxy-request${constants_1.metaId ? `-${constants_1.metaId}` : ""}`;
          const proxyMessage = {
            type: proxyRequestType,
            id,
            method: "bitcoin",
            args: uint8_array_1.JSONUint8Array.wrap(args),
            bitcoinProviderMethod: method
          };
          return new Promise((resolve, reject) => {
            const receiveResponse = (e2) => {
              const proxyResponse = parseMessage(e2.data);
              if (!proxyResponse || proxyResponse.type !== "proxy-request-response") {
                return;
              }
              if (proxyResponse.id !== id) {
                return;
              }
              window.removeEventListener("message", receiveResponse);
              const result = uint8_array_1.JSONUint8Array.unwrap(proxyResponse.result);
              if (!result) {
                reject(new Error("Result is null"));
                return;
              }
              if (result.error) {
                reject(new Error(result.error));
                return;
              }
              resolve(result.return);
            };
            window.addEventListener("message", receiveResponse);
            postMessage(proxyMessage);
          });
        });
      }
      getAccounts() {
        return _BitcoinProvider._requestMethod("getAccounts", []);
      }
      requestAccounts() {
        return __awaiter(this, void 0, void 0, function* () {
          return _BitcoinProvider._requestMethod("requestAccounts", []);
        });
      }
      disconnect() {
        return __awaiter(this, void 0, void 0, function* () {
          return _BitcoinProvider._requestMethod("disconnect", []);
        });
      }
      getNetwork() {
        return __awaiter(this, void 0, void 0, function* () {
          return _BitcoinProvider._requestMethod("getNetwork", []);
        });
      }
      switchNetwork(network) {
        return __awaiter(this, void 0, void 0, function* () {
          return _BitcoinProvider._requestMethod("switchNetwork", [network]);
        });
      }
      getChain() {
        return __awaiter(this, void 0, void 0, function* () {
          return _BitcoinProvider._requestMethod("getChain", []);
        });
      }
      switchChain(chain) {
        return __awaiter(this, void 0, void 0, function* () {
          return _BitcoinProvider._requestMethod("switchChain", [chain]);
        });
      }
      getPublicKey() {
        return __awaiter(this, void 0, void 0, function* () {
          return _BitcoinProvider._requestMethod("getPublicKey", []);
        });
      }
      getBalance() {
        return __awaiter(this, void 0, void 0, function* () {
          return _BitcoinProvider._requestMethod("getBalance", []);
        });
      }
      getInscriptions(offset, limit) {
        return __awaiter(this, void 0, void 0, function* () {
          return _BitcoinProvider._requestMethod("getInscriptions", [offset, limit]);
        });
      }
      signMessage(message, type) {
        return __awaiter(this, void 0, void 0, function* () {
          return _BitcoinProvider._requestMethod("signMessage", [message, type]);
        });
      }
      sendBitcoin(to2, amount) {
        return __awaiter(this, void 0, void 0, function* () {
          return _BitcoinProvider._requestMethod("sendBitcoin", [to2, amount]);
        });
      }
      pushTx(rawTxHex) {
        return __awaiter(this, void 0, void 0, function* () {
          return _BitcoinProvider._requestMethod("pushTx", [rawTxHex]);
        });
      }
      pushPsbt(psbtHex) {
        return __awaiter(this, void 0, void 0, function* () {
          return _BitcoinProvider._requestMethod("pushPsbt", [psbtHex]);
        });
      }
      signPsbt(psbtHex, options) {
        return __awaiter(this, void 0, void 0, function* () {
          return _BitcoinProvider._requestMethod("signPsbt", [psbtHex, options]);
        });
      }
      signPsbts(psbtsHexes, options) {
        return __awaiter(this, void 0, void 0, function* () {
          return _BitcoinProvider._requestMethod("signPsbts", [psbtsHexes, options]);
        });
      }
      getAddress() {
        return __awaiter(this, void 0, void 0, function* () {
          const accounts = yield this.getAccounts();
          return accounts[0];
        });
      }
      connectWallet() {
        return __awaiter(this, void 0, void 0, function* () {
          return this.requestAccounts();
        });
      }
    };
    exports.BitcoinProvider = BitcoinProvider;
  }
});

// ../../node_modules/.pnpm/@keplr-wallet+provider-extension@0.12.252_starknet@7.6.4/node_modules/@keplr-wallet/provider-extension/build/keplr-fallback.js
var require_keplr_fallback = __commonJS({
  "../../node_modules/.pnpm/@keplr-wallet+provider-extension@0.12.252_starknet@7.6.4/node_modules/@keplr-wallet/provider-extension/build/keplr-fallback.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P3, generator) {
      function adopt(value) {
        return value instanceof P3 ? value : new P3(function(resolve) {
          resolve(value);
        });
      }
      return new (P3 || (P3 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e2) {
            reject(e2);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e2) {
            reject(e2);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.KeplrFallback = void 0;
    var keplr_1 = require_keplr2();
    var KeplrFallback = class extends keplr_1.Keplr {
      constructor(onKeplrNotDetected) {
        super();
        this.onKeplrNotDetected = onKeplrNotDetected;
        this.isKeplrDetected = null;
        if (this.onKeplrNotDetected) {
          keplr_1.Keplr.getKeplr(500).then((keplr) => {
            var _a2;
            if (!keplr) {
              (_a2 = this.onKeplrNotDetected) === null || _a2 === void 0 ? void 0 : _a2.call(this);
            }
          });
        }
      }
      requestMethod(method, args) {
        return __awaiter(this, void 0, void 0, function* () {
          if (this.isKeplrDetected == null) {
            const keplr = yield keplr_1.Keplr.getKeplr(500);
            if (keplr) {
              this.isKeplrDetected = true;
            } else {
              this.isKeplrDetected = false;
            }
          }
          if (this.isKeplrDetected) {
            return keplr_1.Keplr.staticRequestMethod(method, args);
          } else {
            const fallback = window.keplr;
            if (fallback) {
              return fallback[method](...args);
            } else {
              throw new Error("Can't detect keplr fallback");
            }
          }
        });
      }
    };
    exports.KeplrFallback = KeplrFallback;
  }
});

// ../../node_modules/.pnpm/@keplr-wallet+provider-extension@0.12.252_starknet@7.6.4/node_modules/@keplr-wallet/provider-extension/build/index.js
var require_build2 = __commonJS({
  "../../node_modules/.pnpm/@keplr-wallet+provider-extension@0.12.252_starknet@7.6.4/node_modules/@keplr-wallet/provider-extension/build/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o4, m3, k5, k22) {
      if (k22 === void 0)
        k22 = k5;
      var desc = Object.getOwnPropertyDescriptor(m3, k5);
      if (!desc || ("get" in desc ? !m3.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m3[k5];
        } };
      }
      Object.defineProperty(o4, k22, desc);
    } : function(o4, m3, k5, k22) {
      if (k22 === void 0)
        k22 = k5;
      o4[k22] = m3[k5];
    });
    var __exportStar = exports && exports.__exportStar || function(m3, exports2) {
      for (var p4 in m3)
        if (p4 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p4))
          __createBinding(exports2, m3, p4);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_keplr2(), exports);
    __exportStar(require_keplr_fallback(), exports);
  }
});

// ../../node_modules/.pnpm/big-integer@1.6.52/node_modules/big-integer/BigInteger.js
var require_BigInteger = __commonJS({
  "../../node_modules/.pnpm/big-integer@1.6.52/node_modules/big-integer/BigInteger.js"(exports, module) {
    var bigInt = function(undefined2) {
      "use strict";
      var BASE = 1e7, LOG_BASE = 7, MAX_INT = 9007199254740992, MAX_INT_ARR = smallToArray(MAX_INT), DEFAULT_ALPHABET = "0123456789abcdefghijklmnopqrstuvwxyz";
      var supportsNativeBigInt = typeof BigInt === "function";
      function Integer(v5, radix, alphabet, caseSensitive) {
        if (typeof v5 === "undefined")
          return Integer[0];
        if (typeof radix !== "undefined")
          return +radix === 10 && !alphabet ? parseValue(v5) : parseBase(v5, radix, alphabet, caseSensitive);
        return parseValue(v5);
      }
      function BigInteger(value, sign) {
        this.value = value;
        this.sign = sign;
        this.isSmall = false;
      }
      BigInteger.prototype = Object.create(Integer.prototype);
      function SmallInteger(value) {
        this.value = value;
        this.sign = value < 0;
        this.isSmall = true;
      }
      SmallInteger.prototype = Object.create(Integer.prototype);
      function NativeBigInt(value) {
        this.value = value;
      }
      NativeBigInt.prototype = Object.create(Integer.prototype);
      function isPrecise(n5) {
        return -MAX_INT < n5 && n5 < MAX_INT;
      }
      function smallToArray(n5) {
        if (n5 < 1e7)
          return [n5];
        if (n5 < 1e14)
          return [n5 % 1e7, Math.floor(n5 / 1e7)];
        return [n5 % 1e7, Math.floor(n5 / 1e7) % 1e7, Math.floor(n5 / 1e14)];
      }
      function arrayToSmall(arr) {
        trim(arr);
        var length = arr.length;
        if (length < 4 && compareAbs(arr, MAX_INT_ARR) < 0) {
          switch (length) {
            case 0:
              return 0;
            case 1:
              return arr[0];
            case 2:
              return arr[0] + arr[1] * BASE;
            default:
              return arr[0] + (arr[1] + arr[2] * BASE) * BASE;
          }
        }
        return arr;
      }
      function trim(v5) {
        var i5 = v5.length;
        while (v5[--i5] === 0)
          ;
        v5.length = i5 + 1;
      }
      function createArray(length) {
        var x4 = new Array(length);
        var i5 = -1;
        while (++i5 < length) {
          x4[i5] = 0;
        }
        return x4;
      }
      function truncate(n5) {
        if (n5 > 0)
          return Math.floor(n5);
        return Math.ceil(n5);
      }
      function add(a3, b4) {
        var l_a = a3.length, l_b = b4.length, r3 = new Array(l_a), carry = 0, base = BASE, sum, i5;
        for (i5 = 0; i5 < l_b; i5++) {
          sum = a3[i5] + b4[i5] + carry;
          carry = sum >= base ? 1 : 0;
          r3[i5] = sum - carry * base;
        }
        while (i5 < l_a) {
          sum = a3[i5] + carry;
          carry = sum === base ? 1 : 0;
          r3[i5++] = sum - carry * base;
        }
        if (carry > 0)
          r3.push(carry);
        return r3;
      }
      function addAny(a3, b4) {
        if (a3.length >= b4.length)
          return add(a3, b4);
        return add(b4, a3);
      }
      function addSmall(a3, carry) {
        var l6 = a3.length, r3 = new Array(l6), base = BASE, sum, i5;
        for (i5 = 0; i5 < l6; i5++) {
          sum = a3[i5] - base + carry;
          carry = Math.floor(sum / base);
          r3[i5] = sum - carry * base;
          carry += 1;
        }
        while (carry > 0) {
          r3[i5++] = carry % base;
          carry = Math.floor(carry / base);
        }
        return r3;
      }
      BigInteger.prototype.add = function(v5) {
        var n5 = parseValue(v5);
        if (this.sign !== n5.sign) {
          return this.subtract(n5.negate());
        }
        var a3 = this.value, b4 = n5.value;
        if (n5.isSmall) {
          return new BigInteger(addSmall(a3, Math.abs(b4)), this.sign);
        }
        return new BigInteger(addAny(a3, b4), this.sign);
      };
      BigInteger.prototype.plus = BigInteger.prototype.add;
      SmallInteger.prototype.add = function(v5) {
        var n5 = parseValue(v5);
        var a3 = this.value;
        if (a3 < 0 !== n5.sign) {
          return this.subtract(n5.negate());
        }
        var b4 = n5.value;
        if (n5.isSmall) {
          if (isPrecise(a3 + b4))
            return new SmallInteger(a3 + b4);
          b4 = smallToArray(Math.abs(b4));
        }
        return new BigInteger(addSmall(b4, Math.abs(a3)), a3 < 0);
      };
      SmallInteger.prototype.plus = SmallInteger.prototype.add;
      NativeBigInt.prototype.add = function(v5) {
        return new NativeBigInt(this.value + parseValue(v5).value);
      };
      NativeBigInt.prototype.plus = NativeBigInt.prototype.add;
      function subtract(a3, b4) {
        var a_l = a3.length, b_l = b4.length, r3 = new Array(a_l), borrow = 0, base = BASE, i5, difference;
        for (i5 = 0; i5 < b_l; i5++) {
          difference = a3[i5] - borrow - b4[i5];
          if (difference < 0) {
            difference += base;
            borrow = 1;
          } else
            borrow = 0;
          r3[i5] = difference;
        }
        for (i5 = b_l; i5 < a_l; i5++) {
          difference = a3[i5] - borrow;
          if (difference < 0)
            difference += base;
          else {
            r3[i5++] = difference;
            break;
          }
          r3[i5] = difference;
        }
        for (; i5 < a_l; i5++) {
          r3[i5] = a3[i5];
        }
        trim(r3);
        return r3;
      }
      function subtractAny(a3, b4, sign) {
        var value;
        if (compareAbs(a3, b4) >= 0) {
          value = subtract(a3, b4);
        } else {
          value = subtract(b4, a3);
          sign = !sign;
        }
        value = arrayToSmall(value);
        if (typeof value === "number") {
          if (sign)
            value = -value;
          return new SmallInteger(value);
        }
        return new BigInteger(value, sign);
      }
      function subtractSmall(a3, b4, sign) {
        var l6 = a3.length, r3 = new Array(l6), carry = -b4, base = BASE, i5, difference;
        for (i5 = 0; i5 < l6; i5++) {
          difference = a3[i5] + carry;
          carry = Math.floor(difference / base);
          difference %= base;
          r3[i5] = difference < 0 ? difference + base : difference;
        }
        r3 = arrayToSmall(r3);
        if (typeof r3 === "number") {
          if (sign)
            r3 = -r3;
          return new SmallInteger(r3);
        }
        return new BigInteger(r3, sign);
      }
      BigInteger.prototype.subtract = function(v5) {
        var n5 = parseValue(v5);
        if (this.sign !== n5.sign) {
          return this.add(n5.negate());
        }
        var a3 = this.value, b4 = n5.value;
        if (n5.isSmall)
          return subtractSmall(a3, Math.abs(b4), this.sign);
        return subtractAny(a3, b4, this.sign);
      };
      BigInteger.prototype.minus = BigInteger.prototype.subtract;
      SmallInteger.prototype.subtract = function(v5) {
        var n5 = parseValue(v5);
        var a3 = this.value;
        if (a3 < 0 !== n5.sign) {
          return this.add(n5.negate());
        }
        var b4 = n5.value;
        if (n5.isSmall) {
          return new SmallInteger(a3 - b4);
        }
        return subtractSmall(b4, Math.abs(a3), a3 >= 0);
      };
      SmallInteger.prototype.minus = SmallInteger.prototype.subtract;
      NativeBigInt.prototype.subtract = function(v5) {
        return new NativeBigInt(this.value - parseValue(v5).value);
      };
      NativeBigInt.prototype.minus = NativeBigInt.prototype.subtract;
      BigInteger.prototype.negate = function() {
        return new BigInteger(this.value, !this.sign);
      };
      SmallInteger.prototype.negate = function() {
        var sign = this.sign;
        var small = new SmallInteger(-this.value);
        small.sign = !sign;
        return small;
      };
      NativeBigInt.prototype.negate = function() {
        return new NativeBigInt(-this.value);
      };
      BigInteger.prototype.abs = function() {
        return new BigInteger(this.value, false);
      };
      SmallInteger.prototype.abs = function() {
        return new SmallInteger(Math.abs(this.value));
      };
      NativeBigInt.prototype.abs = function() {
        return new NativeBigInt(this.value >= 0 ? this.value : -this.value);
      };
      function multiplyLong(a3, b4) {
        var a_l = a3.length, b_l = b4.length, l6 = a_l + b_l, r3 = createArray(l6), base = BASE, product, carry, i5, a_i, b_j;
        for (i5 = 0; i5 < a_l; ++i5) {
          a_i = a3[i5];
          for (var j2 = 0; j2 < b_l; ++j2) {
            b_j = b4[j2];
            product = a_i * b_j + r3[i5 + j2];
            carry = Math.floor(product / base);
            r3[i5 + j2] = product - carry * base;
            r3[i5 + j2 + 1] += carry;
          }
        }
        trim(r3);
        return r3;
      }
      function multiplySmall(a3, b4) {
        var l6 = a3.length, r3 = new Array(l6), base = BASE, carry = 0, product, i5;
        for (i5 = 0; i5 < l6; i5++) {
          product = a3[i5] * b4 + carry;
          carry = Math.floor(product / base);
          r3[i5] = product - carry * base;
        }
        while (carry > 0) {
          r3[i5++] = carry % base;
          carry = Math.floor(carry / base);
        }
        return r3;
      }
      function shiftLeft(x4, n5) {
        var r3 = [];
        while (n5-- > 0)
          r3.push(0);
        return r3.concat(x4);
      }
      function multiplyKaratsuba(x4, y5) {
        var n5 = Math.max(x4.length, y5.length);
        if (n5 <= 30)
          return multiplyLong(x4, y5);
        n5 = Math.ceil(n5 / 2);
        var b4 = x4.slice(n5), a3 = x4.slice(0, n5), d4 = y5.slice(n5), c6 = y5.slice(0, n5);
        var ac = multiplyKaratsuba(a3, c6), bd = multiplyKaratsuba(b4, d4), abcd = multiplyKaratsuba(addAny(a3, b4), addAny(c6, d4));
        var product = addAny(addAny(ac, shiftLeft(subtract(subtract(abcd, ac), bd), n5)), shiftLeft(bd, 2 * n5));
        trim(product);
        return product;
      }
      function useKaratsuba(l1, l22) {
        return -0.012 * l1 - 0.012 * l22 + 15e-6 * l1 * l22 > 0;
      }
      BigInteger.prototype.multiply = function(v5) {
        var n5 = parseValue(v5), a3 = this.value, b4 = n5.value, sign = this.sign !== n5.sign, abs;
        if (n5.isSmall) {
          if (b4 === 0)
            return Integer[0];
          if (b4 === 1)
            return this;
          if (b4 === -1)
            return this.negate();
          abs = Math.abs(b4);
          if (abs < BASE) {
            return new BigInteger(multiplySmall(a3, abs), sign);
          }
          b4 = smallToArray(abs);
        }
        if (useKaratsuba(a3.length, b4.length))
          return new BigInteger(multiplyKaratsuba(a3, b4), sign);
        return new BigInteger(multiplyLong(a3, b4), sign);
      };
      BigInteger.prototype.times = BigInteger.prototype.multiply;
      function multiplySmallAndArray(a3, b4, sign) {
        if (a3 < BASE) {
          return new BigInteger(multiplySmall(b4, a3), sign);
        }
        return new BigInteger(multiplyLong(b4, smallToArray(a3)), sign);
      }
      SmallInteger.prototype._multiplyBySmall = function(a3) {
        if (isPrecise(a3.value * this.value)) {
          return new SmallInteger(a3.value * this.value);
        }
        return multiplySmallAndArray(Math.abs(a3.value), smallToArray(Math.abs(this.value)), this.sign !== a3.sign);
      };
      BigInteger.prototype._multiplyBySmall = function(a3) {
        if (a3.value === 0)
          return Integer[0];
        if (a3.value === 1)
          return this;
        if (a3.value === -1)
          return this.negate();
        return multiplySmallAndArray(Math.abs(a3.value), this.value, this.sign !== a3.sign);
      };
      SmallInteger.prototype.multiply = function(v5) {
        return parseValue(v5)._multiplyBySmall(this);
      };
      SmallInteger.prototype.times = SmallInteger.prototype.multiply;
      NativeBigInt.prototype.multiply = function(v5) {
        return new NativeBigInt(this.value * parseValue(v5).value);
      };
      NativeBigInt.prototype.times = NativeBigInt.prototype.multiply;
      function square(a3) {
        var l6 = a3.length, r3 = createArray(l6 + l6), base = BASE, product, carry, i5, a_i, a_j;
        for (i5 = 0; i5 < l6; i5++) {
          a_i = a3[i5];
          carry = 0 - a_i * a_i;
          for (var j2 = i5; j2 < l6; j2++) {
            a_j = a3[j2];
            product = 2 * (a_i * a_j) + r3[i5 + j2] + carry;
            carry = Math.floor(product / base);
            r3[i5 + j2] = product - carry * base;
          }
          r3[i5 + l6] = carry;
        }
        trim(r3);
        return r3;
      }
      BigInteger.prototype.square = function() {
        return new BigInteger(square(this.value), false);
      };
      SmallInteger.prototype.square = function() {
        var value = this.value * this.value;
        if (isPrecise(value))
          return new SmallInteger(value);
        return new BigInteger(square(smallToArray(Math.abs(this.value))), false);
      };
      NativeBigInt.prototype.square = function(v5) {
        return new NativeBigInt(this.value * this.value);
      };
      function divMod1(a3, b4) {
        var a_l = a3.length, b_l = b4.length, base = BASE, result = createArray(b4.length), divisorMostSignificantDigit = b4[b_l - 1], lambda = Math.ceil(base / (2 * divisorMostSignificantDigit)), remainder = multiplySmall(a3, lambda), divisor = multiplySmall(b4, lambda), quotientDigit, shift2, carry, borrow, i5, l6, q;
        if (remainder.length <= a_l)
          remainder.push(0);
        divisor.push(0);
        divisorMostSignificantDigit = divisor[b_l - 1];
        for (shift2 = a_l - b_l; shift2 >= 0; shift2--) {
          quotientDigit = base - 1;
          if (remainder[shift2 + b_l] !== divisorMostSignificantDigit) {
            quotientDigit = Math.floor((remainder[shift2 + b_l] * base + remainder[shift2 + b_l - 1]) / divisorMostSignificantDigit);
          }
          carry = 0;
          borrow = 0;
          l6 = divisor.length;
          for (i5 = 0; i5 < l6; i5++) {
            carry += quotientDigit * divisor[i5];
            q = Math.floor(carry / base);
            borrow += remainder[shift2 + i5] - (carry - q * base);
            carry = q;
            if (borrow < 0) {
              remainder[shift2 + i5] = borrow + base;
              borrow = -1;
            } else {
              remainder[shift2 + i5] = borrow;
              borrow = 0;
            }
          }
          while (borrow !== 0) {
            quotientDigit -= 1;
            carry = 0;
            for (i5 = 0; i5 < l6; i5++) {
              carry += remainder[shift2 + i5] - base + divisor[i5];
              if (carry < 0) {
                remainder[shift2 + i5] = carry + base;
                carry = 0;
              } else {
                remainder[shift2 + i5] = carry;
                carry = 1;
              }
            }
            borrow += carry;
          }
          result[shift2] = quotientDigit;
        }
        remainder = divModSmall(remainder, lambda)[0];
        return [arrayToSmall(result), arrayToSmall(remainder)];
      }
      function divMod2(a3, b4) {
        var a_l = a3.length, b_l = b4.length, result = [], part = [], base = BASE, guess, xlen, highx, highy, check;
        while (a_l) {
          part.unshift(a3[--a_l]);
          trim(part);
          if (compareAbs(part, b4) < 0) {
            result.push(0);
            continue;
          }
          xlen = part.length;
          highx = part[xlen - 1] * base + part[xlen - 2];
          highy = b4[b_l - 1] * base + b4[b_l - 2];
          if (xlen > b_l) {
            highx = (highx + 1) * base;
          }
          guess = Math.ceil(highx / highy);
          do {
            check = multiplySmall(b4, guess);
            if (compareAbs(check, part) <= 0)
              break;
            guess--;
          } while (guess);
          result.push(guess);
          part = subtract(part, check);
        }
        result.reverse();
        return [arrayToSmall(result), arrayToSmall(part)];
      }
      function divModSmall(value, lambda) {
        var length = value.length, quotient = createArray(length), base = BASE, i5, q, remainder, divisor;
        remainder = 0;
        for (i5 = length - 1; i5 >= 0; --i5) {
          divisor = remainder * base + value[i5];
          q = truncate(divisor / lambda);
          remainder = divisor - q * lambda;
          quotient[i5] = q | 0;
        }
        return [quotient, remainder | 0];
      }
      function divModAny(self2, v5) {
        var value, n5 = parseValue(v5);
        if (supportsNativeBigInt) {
          return [new NativeBigInt(self2.value / n5.value), new NativeBigInt(self2.value % n5.value)];
        }
        var a3 = self2.value, b4 = n5.value;
        var quotient;
        if (b4 === 0)
          throw new Error("Cannot divide by zero");
        if (self2.isSmall) {
          if (n5.isSmall) {
            return [new SmallInteger(truncate(a3 / b4)), new SmallInteger(a3 % b4)];
          }
          return [Integer[0], self2];
        }
        if (n5.isSmall) {
          if (b4 === 1)
            return [self2, Integer[0]];
          if (b4 == -1)
            return [self2.negate(), Integer[0]];
          var abs = Math.abs(b4);
          if (abs < BASE) {
            value = divModSmall(a3, abs);
            quotient = arrayToSmall(value[0]);
            var remainder = value[1];
            if (self2.sign)
              remainder = -remainder;
            if (typeof quotient === "number") {
              if (self2.sign !== n5.sign)
                quotient = -quotient;
              return [new SmallInteger(quotient), new SmallInteger(remainder)];
            }
            return [new BigInteger(quotient, self2.sign !== n5.sign), new SmallInteger(remainder)];
          }
          b4 = smallToArray(abs);
        }
        var comparison = compareAbs(a3, b4);
        if (comparison === -1)
          return [Integer[0], self2];
        if (comparison === 0)
          return [Integer[self2.sign === n5.sign ? 1 : -1], Integer[0]];
        if (a3.length + b4.length <= 200)
          value = divMod1(a3, b4);
        else
          value = divMod2(a3, b4);
        quotient = value[0];
        var qSign = self2.sign !== n5.sign, mod = value[1], mSign = self2.sign;
        if (typeof quotient === "number") {
          if (qSign)
            quotient = -quotient;
          quotient = new SmallInteger(quotient);
        } else
          quotient = new BigInteger(quotient, qSign);
        if (typeof mod === "number") {
          if (mSign)
            mod = -mod;
          mod = new SmallInteger(mod);
        } else
          mod = new BigInteger(mod, mSign);
        return [quotient, mod];
      }
      BigInteger.prototype.divmod = function(v5) {
        var result = divModAny(this, v5);
        return {
          quotient: result[0],
          remainder: result[1]
        };
      };
      NativeBigInt.prototype.divmod = SmallInteger.prototype.divmod = BigInteger.prototype.divmod;
      BigInteger.prototype.divide = function(v5) {
        return divModAny(this, v5)[0];
      };
      NativeBigInt.prototype.over = NativeBigInt.prototype.divide = function(v5) {
        return new NativeBigInt(this.value / parseValue(v5).value);
      };
      SmallInteger.prototype.over = SmallInteger.prototype.divide = BigInteger.prototype.over = BigInteger.prototype.divide;
      BigInteger.prototype.mod = function(v5) {
        return divModAny(this, v5)[1];
      };
      NativeBigInt.prototype.mod = NativeBigInt.prototype.remainder = function(v5) {
        return new NativeBigInt(this.value % parseValue(v5).value);
      };
      SmallInteger.prototype.remainder = SmallInteger.prototype.mod = BigInteger.prototype.remainder = BigInteger.prototype.mod;
      BigInteger.prototype.pow = function(v5) {
        var n5 = parseValue(v5), a3 = this.value, b4 = n5.value, value, x4, y5;
        if (b4 === 0)
          return Integer[1];
        if (a3 === 0)
          return Integer[0];
        if (a3 === 1)
          return Integer[1];
        if (a3 === -1)
          return n5.isEven() ? Integer[1] : Integer[-1];
        if (n5.sign) {
          return Integer[0];
        }
        if (!n5.isSmall)
          throw new Error("The exponent " + n5.toString() + " is too large.");
        if (this.isSmall) {
          if (isPrecise(value = Math.pow(a3, b4)))
            return new SmallInteger(truncate(value));
        }
        x4 = this;
        y5 = Integer[1];
        while (true) {
          if (b4 & true) {
            y5 = y5.times(x4);
            --b4;
          }
          if (b4 === 0)
            break;
          b4 /= 2;
          x4 = x4.square();
        }
        return y5;
      };
      SmallInteger.prototype.pow = BigInteger.prototype.pow;
      NativeBigInt.prototype.pow = function(v5) {
        var n5 = parseValue(v5);
        var a3 = this.value, b4 = n5.value;
        var _0 = BigInt(0), _1 = BigInt(1), _22 = BigInt(2);
        if (b4 === _0)
          return Integer[1];
        if (a3 === _0)
          return Integer[0];
        if (a3 === _1)
          return Integer[1];
        if (a3 === BigInt(-1))
          return n5.isEven() ? Integer[1] : Integer[-1];
        if (n5.isNegative())
          return new NativeBigInt(_0);
        var x4 = this;
        var y5 = Integer[1];
        while (true) {
          if ((b4 & _1) === _1) {
            y5 = y5.times(x4);
            --b4;
          }
          if (b4 === _0)
            break;
          b4 /= _22;
          x4 = x4.square();
        }
        return y5;
      };
      BigInteger.prototype.modPow = function(exp, mod) {
        exp = parseValue(exp);
        mod = parseValue(mod);
        if (mod.isZero())
          throw new Error("Cannot take modPow with modulus 0");
        var r3 = Integer[1], base = this.mod(mod);
        if (exp.isNegative()) {
          exp = exp.multiply(Integer[-1]);
          base = base.modInv(mod);
        }
        while (exp.isPositive()) {
          if (base.isZero())
            return Integer[0];
          if (exp.isOdd())
            r3 = r3.multiply(base).mod(mod);
          exp = exp.divide(2);
          base = base.square().mod(mod);
        }
        return r3;
      };
      NativeBigInt.prototype.modPow = SmallInteger.prototype.modPow = BigInteger.prototype.modPow;
      function compareAbs(a3, b4) {
        if (a3.length !== b4.length) {
          return a3.length > b4.length ? 1 : -1;
        }
        for (var i5 = a3.length - 1; i5 >= 0; i5--) {
          if (a3[i5] !== b4[i5])
            return a3[i5] > b4[i5] ? 1 : -1;
        }
        return 0;
      }
      BigInteger.prototype.compareAbs = function(v5) {
        var n5 = parseValue(v5), a3 = this.value, b4 = n5.value;
        if (n5.isSmall)
          return 1;
        return compareAbs(a3, b4);
      };
      SmallInteger.prototype.compareAbs = function(v5) {
        var n5 = parseValue(v5), a3 = Math.abs(this.value), b4 = n5.value;
        if (n5.isSmall) {
          b4 = Math.abs(b4);
          return a3 === b4 ? 0 : a3 > b4 ? 1 : -1;
        }
        return -1;
      };
      NativeBigInt.prototype.compareAbs = function(v5) {
        var a3 = this.value;
        var b4 = parseValue(v5).value;
        a3 = a3 >= 0 ? a3 : -a3;
        b4 = b4 >= 0 ? b4 : -b4;
        return a3 === b4 ? 0 : a3 > b4 ? 1 : -1;
      };
      BigInteger.prototype.compare = function(v5) {
        if (v5 === Infinity) {
          return -1;
        }
        if (v5 === -Infinity) {
          return 1;
        }
        var n5 = parseValue(v5), a3 = this.value, b4 = n5.value;
        if (this.sign !== n5.sign) {
          return n5.sign ? 1 : -1;
        }
        if (n5.isSmall) {
          return this.sign ? -1 : 1;
        }
        return compareAbs(a3, b4) * (this.sign ? -1 : 1);
      };
      BigInteger.prototype.compareTo = BigInteger.prototype.compare;
      SmallInteger.prototype.compare = function(v5) {
        if (v5 === Infinity) {
          return -1;
        }
        if (v5 === -Infinity) {
          return 1;
        }
        var n5 = parseValue(v5), a3 = this.value, b4 = n5.value;
        if (n5.isSmall) {
          return a3 == b4 ? 0 : a3 > b4 ? 1 : -1;
        }
        if (a3 < 0 !== n5.sign) {
          return a3 < 0 ? -1 : 1;
        }
        return a3 < 0 ? 1 : -1;
      };
      SmallInteger.prototype.compareTo = SmallInteger.prototype.compare;
      NativeBigInt.prototype.compare = function(v5) {
        if (v5 === Infinity) {
          return -1;
        }
        if (v5 === -Infinity) {
          return 1;
        }
        var a3 = this.value;
        var b4 = parseValue(v5).value;
        return a3 === b4 ? 0 : a3 > b4 ? 1 : -1;
      };
      NativeBigInt.prototype.compareTo = NativeBigInt.prototype.compare;
      BigInteger.prototype.equals = function(v5) {
        return this.compare(v5) === 0;
      };
      NativeBigInt.prototype.eq = NativeBigInt.prototype.equals = SmallInteger.prototype.eq = SmallInteger.prototype.equals = BigInteger.prototype.eq = BigInteger.prototype.equals;
      BigInteger.prototype.notEquals = function(v5) {
        return this.compare(v5) !== 0;
      };
      NativeBigInt.prototype.neq = NativeBigInt.prototype.notEquals = SmallInteger.prototype.neq = SmallInteger.prototype.notEquals = BigInteger.prototype.neq = BigInteger.prototype.notEquals;
      BigInteger.prototype.greater = function(v5) {
        return this.compare(v5) > 0;
      };
      NativeBigInt.prototype.gt = NativeBigInt.prototype.greater = SmallInteger.prototype.gt = SmallInteger.prototype.greater = BigInteger.prototype.gt = BigInteger.prototype.greater;
      BigInteger.prototype.lesser = function(v5) {
        return this.compare(v5) < 0;
      };
      NativeBigInt.prototype.lt = NativeBigInt.prototype.lesser = SmallInteger.prototype.lt = SmallInteger.prototype.lesser = BigInteger.prototype.lt = BigInteger.prototype.lesser;
      BigInteger.prototype.greaterOrEquals = function(v5) {
        return this.compare(v5) >= 0;
      };
      NativeBigInt.prototype.geq = NativeBigInt.prototype.greaterOrEquals = SmallInteger.prototype.geq = SmallInteger.prototype.greaterOrEquals = BigInteger.prototype.geq = BigInteger.prototype.greaterOrEquals;
      BigInteger.prototype.lesserOrEquals = function(v5) {
        return this.compare(v5) <= 0;
      };
      NativeBigInt.prototype.leq = NativeBigInt.prototype.lesserOrEquals = SmallInteger.prototype.leq = SmallInteger.prototype.lesserOrEquals = BigInteger.prototype.leq = BigInteger.prototype.lesserOrEquals;
      BigInteger.prototype.isEven = function() {
        return (this.value[0] & 1) === 0;
      };
      SmallInteger.prototype.isEven = function() {
        return (this.value & 1) === 0;
      };
      NativeBigInt.prototype.isEven = function() {
        return (this.value & BigInt(1)) === BigInt(0);
      };
      BigInteger.prototype.isOdd = function() {
        return (this.value[0] & 1) === 1;
      };
      SmallInteger.prototype.isOdd = function() {
        return (this.value & 1) === 1;
      };
      NativeBigInt.prototype.isOdd = function() {
        return (this.value & BigInt(1)) === BigInt(1);
      };
      BigInteger.prototype.isPositive = function() {
        return !this.sign;
      };
      SmallInteger.prototype.isPositive = function() {
        return this.value > 0;
      };
      NativeBigInt.prototype.isPositive = SmallInteger.prototype.isPositive;
      BigInteger.prototype.isNegative = function() {
        return this.sign;
      };
      SmallInteger.prototype.isNegative = function() {
        return this.value < 0;
      };
      NativeBigInt.prototype.isNegative = SmallInteger.prototype.isNegative;
      BigInteger.prototype.isUnit = function() {
        return false;
      };
      SmallInteger.prototype.isUnit = function() {
        return Math.abs(this.value) === 1;
      };
      NativeBigInt.prototype.isUnit = function() {
        return this.abs().value === BigInt(1);
      };
      BigInteger.prototype.isZero = function() {
        return false;
      };
      SmallInteger.prototype.isZero = function() {
        return this.value === 0;
      };
      NativeBigInt.prototype.isZero = function() {
        return this.value === BigInt(0);
      };
      BigInteger.prototype.isDivisibleBy = function(v5) {
        var n5 = parseValue(v5);
        if (n5.isZero())
          return false;
        if (n5.isUnit())
          return true;
        if (n5.compareAbs(2) === 0)
          return this.isEven();
        return this.mod(n5).isZero();
      };
      NativeBigInt.prototype.isDivisibleBy = SmallInteger.prototype.isDivisibleBy = BigInteger.prototype.isDivisibleBy;
      function isBasicPrime(v5) {
        var n5 = v5.abs();
        if (n5.isUnit())
          return false;
        if (n5.equals(2) || n5.equals(3) || n5.equals(5))
          return true;
        if (n5.isEven() || n5.isDivisibleBy(3) || n5.isDivisibleBy(5))
          return false;
        if (n5.lesser(49))
          return true;
      }
      function millerRabinTest(n5, a3) {
        var nPrev = n5.prev(), b4 = nPrev, r3 = 0, d4, t, i5, x4;
        while (b4.isEven())
          b4 = b4.divide(2), r3++;
        next:
          for (i5 = 0; i5 < a3.length; i5++) {
            if (n5.lesser(a3[i5]))
              continue;
            x4 = bigInt(a3[i5]).modPow(b4, n5);
            if (x4.isUnit() || x4.equals(nPrev))
              continue;
            for (d4 = r3 - 1; d4 != 0; d4--) {
              x4 = x4.square().mod(n5);
              if (x4.isUnit())
                return false;
              if (x4.equals(nPrev))
                continue next;
            }
            return false;
          }
        return true;
      }
      BigInteger.prototype.isPrime = function(strict) {
        var isPrime = isBasicPrime(this);
        if (isPrime !== undefined2)
          return isPrime;
        var n5 = this.abs();
        var bits = n5.bitLength();
        if (bits <= 64)
          return millerRabinTest(n5, [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]);
        var logN = Math.log(2) * bits.toJSNumber();
        var t = Math.ceil(strict === true ? 2 * Math.pow(logN, 2) : logN);
        for (var a3 = [], i5 = 0; i5 < t; i5++) {
          a3.push(bigInt(i5 + 2));
        }
        return millerRabinTest(n5, a3);
      };
      NativeBigInt.prototype.isPrime = SmallInteger.prototype.isPrime = BigInteger.prototype.isPrime;
      BigInteger.prototype.isProbablePrime = function(iterations, rng) {
        var isPrime = isBasicPrime(this);
        if (isPrime !== undefined2)
          return isPrime;
        var n5 = this.abs();
        var t = iterations === undefined2 ? 5 : iterations;
        for (var a3 = [], i5 = 0; i5 < t; i5++) {
          a3.push(bigInt.randBetween(2, n5.minus(2), rng));
        }
        return millerRabinTest(n5, a3);
      };
      NativeBigInt.prototype.isProbablePrime = SmallInteger.prototype.isProbablePrime = BigInteger.prototype.isProbablePrime;
      BigInteger.prototype.modInv = function(n5) {
        var t = bigInt.zero, newT = bigInt.one, r3 = parseValue(n5), newR = this.abs(), q, lastT, lastR;
        while (!newR.isZero()) {
          q = r3.divide(newR);
          lastT = t;
          lastR = r3;
          t = newT;
          r3 = newR;
          newT = lastT.subtract(q.multiply(newT));
          newR = lastR.subtract(q.multiply(newR));
        }
        if (!r3.isUnit())
          throw new Error(this.toString() + " and " + n5.toString() + " are not co-prime");
        if (t.compare(0) === -1) {
          t = t.add(n5);
        }
        if (this.isNegative()) {
          return t.negate();
        }
        return t;
      };
      NativeBigInt.prototype.modInv = SmallInteger.prototype.modInv = BigInteger.prototype.modInv;
      BigInteger.prototype.next = function() {
        var value = this.value;
        if (this.sign) {
          return subtractSmall(value, 1, this.sign);
        }
        return new BigInteger(addSmall(value, 1), this.sign);
      };
      SmallInteger.prototype.next = function() {
        var value = this.value;
        if (value + 1 < MAX_INT)
          return new SmallInteger(value + 1);
        return new BigInteger(MAX_INT_ARR, false);
      };
      NativeBigInt.prototype.next = function() {
        return new NativeBigInt(this.value + BigInt(1));
      };
      BigInteger.prototype.prev = function() {
        var value = this.value;
        if (this.sign) {
          return new BigInteger(addSmall(value, 1), true);
        }
        return subtractSmall(value, 1, this.sign);
      };
      SmallInteger.prototype.prev = function() {
        var value = this.value;
        if (value - 1 > -MAX_INT)
          return new SmallInteger(value - 1);
        return new BigInteger(MAX_INT_ARR, true);
      };
      NativeBigInt.prototype.prev = function() {
        return new NativeBigInt(this.value - BigInt(1));
      };
      var powersOfTwo = [1];
      while (2 * powersOfTwo[powersOfTwo.length - 1] <= BASE)
        powersOfTwo.push(2 * powersOfTwo[powersOfTwo.length - 1]);
      var powers2Length = powersOfTwo.length, highestPower2 = powersOfTwo[powers2Length - 1];
      function shift_isSmall(n5) {
        return Math.abs(n5) <= BASE;
      }
      BigInteger.prototype.shiftLeft = function(v5) {
        var n5 = parseValue(v5).toJSNumber();
        if (!shift_isSmall(n5)) {
          throw new Error(String(n5) + " is too large for shifting.");
        }
        if (n5 < 0)
          return this.shiftRight(-n5);
        var result = this;
        if (result.isZero())
          return result;
        while (n5 >= powers2Length) {
          result = result.multiply(highestPower2);
          n5 -= powers2Length - 1;
        }
        return result.multiply(powersOfTwo[n5]);
      };
      NativeBigInt.prototype.shiftLeft = SmallInteger.prototype.shiftLeft = BigInteger.prototype.shiftLeft;
      BigInteger.prototype.shiftRight = function(v5) {
        var remQuo;
        var n5 = parseValue(v5).toJSNumber();
        if (!shift_isSmall(n5)) {
          throw new Error(String(n5) + " is too large for shifting.");
        }
        if (n5 < 0)
          return this.shiftLeft(-n5);
        var result = this;
        while (n5 >= powers2Length) {
          if (result.isZero() || result.isNegative() && result.isUnit())
            return result;
          remQuo = divModAny(result, highestPower2);
          result = remQuo[1].isNegative() ? remQuo[0].prev() : remQuo[0];
          n5 -= powers2Length - 1;
        }
        remQuo = divModAny(result, powersOfTwo[n5]);
        return remQuo[1].isNegative() ? remQuo[0].prev() : remQuo[0];
      };
      NativeBigInt.prototype.shiftRight = SmallInteger.prototype.shiftRight = BigInteger.prototype.shiftRight;
      function bitwise(x4, y5, fn2) {
        y5 = parseValue(y5);
        var xSign = x4.isNegative(), ySign = y5.isNegative();
        var xRem = xSign ? x4.not() : x4, yRem = ySign ? y5.not() : y5;
        var xDigit = 0, yDigit = 0;
        var xDivMod = null, yDivMod = null;
        var result = [];
        while (!xRem.isZero() || !yRem.isZero()) {
          xDivMod = divModAny(xRem, highestPower2);
          xDigit = xDivMod[1].toJSNumber();
          if (xSign) {
            xDigit = highestPower2 - 1 - xDigit;
          }
          yDivMod = divModAny(yRem, highestPower2);
          yDigit = yDivMod[1].toJSNumber();
          if (ySign) {
            yDigit = highestPower2 - 1 - yDigit;
          }
          xRem = xDivMod[0];
          yRem = yDivMod[0];
          result.push(fn2(xDigit, yDigit));
        }
        var sum = fn2(xSign ? 1 : 0, ySign ? 1 : 0) !== 0 ? bigInt(-1) : bigInt(0);
        for (var i5 = result.length - 1; i5 >= 0; i5 -= 1) {
          sum = sum.multiply(highestPower2).add(bigInt(result[i5]));
        }
        return sum;
      }
      BigInteger.prototype.not = function() {
        return this.negate().prev();
      };
      NativeBigInt.prototype.not = SmallInteger.prototype.not = BigInteger.prototype.not;
      BigInteger.prototype.and = function(n5) {
        return bitwise(this, n5, function(a3, b4) {
          return a3 & b4;
        });
      };
      NativeBigInt.prototype.and = SmallInteger.prototype.and = BigInteger.prototype.and;
      BigInteger.prototype.or = function(n5) {
        return bitwise(this, n5, function(a3, b4) {
          return a3 | b4;
        });
      };
      NativeBigInt.prototype.or = SmallInteger.prototype.or = BigInteger.prototype.or;
      BigInteger.prototype.xor = function(n5) {
        return bitwise(this, n5, function(a3, b4) {
          return a3 ^ b4;
        });
      };
      NativeBigInt.prototype.xor = SmallInteger.prototype.xor = BigInteger.prototype.xor;
      var LOBMASK_I = 1 << 30, LOBMASK_BI = (BASE & -BASE) * (BASE & -BASE) | LOBMASK_I;
      function roughLOB(n5) {
        var v5 = n5.value, x4 = typeof v5 === "number" ? v5 | LOBMASK_I : typeof v5 === "bigint" ? v5 | BigInt(LOBMASK_I) : v5[0] + v5[1] * BASE | LOBMASK_BI;
        return x4 & -x4;
      }
      function integerLogarithm(value, base) {
        if (base.compareTo(value) <= 0) {
          var tmp = integerLogarithm(value, base.square(base));
          var p4 = tmp.p;
          var e2 = tmp.e;
          var t = p4.multiply(base);
          return t.compareTo(value) <= 0 ? { p: t, e: e2 * 2 + 1 } : { p: p4, e: e2 * 2 };
        }
        return { p: bigInt(1), e: 0 };
      }
      BigInteger.prototype.bitLength = function() {
        var n5 = this;
        if (n5.compareTo(bigInt(0)) < 0) {
          n5 = n5.negate().subtract(bigInt(1));
        }
        if (n5.compareTo(bigInt(0)) === 0) {
          return bigInt(0);
        }
        return bigInt(integerLogarithm(n5, bigInt(2)).e).add(bigInt(1));
      };
      NativeBigInt.prototype.bitLength = SmallInteger.prototype.bitLength = BigInteger.prototype.bitLength;
      function max(a3, b4) {
        a3 = parseValue(a3);
        b4 = parseValue(b4);
        return a3.greater(b4) ? a3 : b4;
      }
      function min(a3, b4) {
        a3 = parseValue(a3);
        b4 = parseValue(b4);
        return a3.lesser(b4) ? a3 : b4;
      }
      function gcd(a3, b4) {
        a3 = parseValue(a3).abs();
        b4 = parseValue(b4).abs();
        if (a3.equals(b4))
          return a3;
        if (a3.isZero())
          return b4;
        if (b4.isZero())
          return a3;
        var c6 = Integer[1], d4, t;
        while (a3.isEven() && b4.isEven()) {
          d4 = min(roughLOB(a3), roughLOB(b4));
          a3 = a3.divide(d4);
          b4 = b4.divide(d4);
          c6 = c6.multiply(d4);
        }
        while (a3.isEven()) {
          a3 = a3.divide(roughLOB(a3));
        }
        do {
          while (b4.isEven()) {
            b4 = b4.divide(roughLOB(b4));
          }
          if (a3.greater(b4)) {
            t = b4;
            b4 = a3;
            a3 = t;
          }
          b4 = b4.subtract(a3);
        } while (!b4.isZero());
        return c6.isUnit() ? a3 : a3.multiply(c6);
      }
      function lcm(a3, b4) {
        a3 = parseValue(a3).abs();
        b4 = parseValue(b4).abs();
        return a3.divide(gcd(a3, b4)).multiply(b4);
      }
      function randBetween(a3, b4, rng) {
        a3 = parseValue(a3);
        b4 = parseValue(b4);
        var usedRNG = rng || Math.random;
        var low = min(a3, b4), high = max(a3, b4);
        var range = high.subtract(low).add(1);
        if (range.isSmall)
          return low.add(Math.floor(usedRNG() * range));
        var digits = toBase(range, BASE).value;
        var result = [], restricted = true;
        for (var i5 = 0; i5 < digits.length; i5++) {
          var top = restricted ? digits[i5] + (i5 + 1 < digits.length ? digits[i5 + 1] / BASE : 0) : BASE;
          var digit = truncate(usedRNG() * top);
          result.push(digit);
          if (digit < digits[i5])
            restricted = false;
        }
        return low.add(Integer.fromArray(result, BASE, false));
      }
      var parseBase = function(text, base, alphabet, caseSensitive) {
        alphabet = alphabet || DEFAULT_ALPHABET;
        text = String(text);
        if (!caseSensitive) {
          text = text.toLowerCase();
          alphabet = alphabet.toLowerCase();
        }
        var length = text.length;
        var i5;
        var absBase = Math.abs(base);
        var alphabetValues = {};
        for (i5 = 0; i5 < alphabet.length; i5++) {
          alphabetValues[alphabet[i5]] = i5;
        }
        for (i5 = 0; i5 < length; i5++) {
          var c6 = text[i5];
          if (c6 === "-")
            continue;
          if (c6 in alphabetValues) {
            if (alphabetValues[c6] >= absBase) {
              if (c6 === "1" && absBase === 1)
                continue;
              throw new Error(c6 + " is not a valid digit in base " + base + ".");
            }
          }
        }
        base = parseValue(base);
        var digits = [];
        var isNegative = text[0] === "-";
        for (i5 = isNegative ? 1 : 0; i5 < text.length; i5++) {
          var c6 = text[i5];
          if (c6 in alphabetValues)
            digits.push(parseValue(alphabetValues[c6]));
          else if (c6 === "<") {
            var start = i5;
            do {
              i5++;
            } while (text[i5] !== ">" && i5 < text.length);
            digits.push(parseValue(text.slice(start + 1, i5)));
          } else
            throw new Error(c6 + " is not a valid character");
        }
        return parseBaseFromArray(digits, base, isNegative);
      };
      function parseBaseFromArray(digits, base, isNegative) {
        var val = Integer[0], pow = Integer[1], i5;
        for (i5 = digits.length - 1; i5 >= 0; i5--) {
          val = val.add(digits[i5].times(pow));
          pow = pow.times(base);
        }
        return isNegative ? val.negate() : val;
      }
      function stringify2(digit, alphabet) {
        alphabet = alphabet || DEFAULT_ALPHABET;
        if (digit < alphabet.length) {
          return alphabet[digit];
        }
        return "<" + digit + ">";
      }
      function toBase(n5, base) {
        base = bigInt(base);
        if (base.isZero()) {
          if (n5.isZero())
            return { value: [0], isNegative: false };
          throw new Error("Cannot convert nonzero numbers to base 0.");
        }
        if (base.equals(-1)) {
          if (n5.isZero())
            return { value: [0], isNegative: false };
          if (n5.isNegative())
            return {
              value: [].concat.apply(
                [],
                Array.apply(null, Array(-n5.toJSNumber())).map(Array.prototype.valueOf, [1, 0])
              ),
              isNegative: false
            };
          var arr = Array.apply(null, Array(n5.toJSNumber() - 1)).map(Array.prototype.valueOf, [0, 1]);
          arr.unshift([1]);
          return {
            value: [].concat.apply([], arr),
            isNegative: false
          };
        }
        var neg = false;
        if (n5.isNegative() && base.isPositive()) {
          neg = true;
          n5 = n5.abs();
        }
        if (base.isUnit()) {
          if (n5.isZero())
            return { value: [0], isNegative: false };
          return {
            value: Array.apply(null, Array(n5.toJSNumber())).map(Number.prototype.valueOf, 1),
            isNegative: neg
          };
        }
        var out = [];
        var left = n5, divmod;
        while (left.isNegative() || left.compareAbs(base) >= 0) {
          divmod = left.divmod(base);
          left = divmod.quotient;
          var digit = divmod.remainder;
          if (digit.isNegative()) {
            digit = base.minus(digit).abs();
            left = left.next();
          }
          out.push(digit.toJSNumber());
        }
        out.push(left.toJSNumber());
        return { value: out.reverse(), isNegative: neg };
      }
      function toBaseString(n5, base, alphabet) {
        var arr = toBase(n5, base);
        return (arr.isNegative ? "-" : "") + arr.value.map(function(x4) {
          return stringify2(x4, alphabet);
        }).join("");
      }
      BigInteger.prototype.toArray = function(radix) {
        return toBase(this, radix);
      };
      SmallInteger.prototype.toArray = function(radix) {
        return toBase(this, radix);
      };
      NativeBigInt.prototype.toArray = function(radix) {
        return toBase(this, radix);
      };
      BigInteger.prototype.toString = function(radix, alphabet) {
        if (radix === undefined2)
          radix = 10;
        if (radix !== 10 || alphabet)
          return toBaseString(this, radix, alphabet);
        var v5 = this.value, l6 = v5.length, str = String(v5[--l6]), zeros2 = "0000000", digit;
        while (--l6 >= 0) {
          digit = String(v5[l6]);
          str += zeros2.slice(digit.length) + digit;
        }
        var sign = this.sign ? "-" : "";
        return sign + str;
      };
      SmallInteger.prototype.toString = function(radix, alphabet) {
        if (radix === undefined2)
          radix = 10;
        if (radix != 10 || alphabet)
          return toBaseString(this, radix, alphabet);
        return String(this.value);
      };
      NativeBigInt.prototype.toString = SmallInteger.prototype.toString;
      NativeBigInt.prototype.toJSON = BigInteger.prototype.toJSON = SmallInteger.prototype.toJSON = function() {
        return this.toString();
      };
      BigInteger.prototype.valueOf = function() {
        return parseInt(this.toString(), 10);
      };
      BigInteger.prototype.toJSNumber = BigInteger.prototype.valueOf;
      SmallInteger.prototype.valueOf = function() {
        return this.value;
      };
      SmallInteger.prototype.toJSNumber = SmallInteger.prototype.valueOf;
      NativeBigInt.prototype.valueOf = NativeBigInt.prototype.toJSNumber = function() {
        return parseInt(this.toString(), 10);
      };
      function parseStringValue(v5) {
        if (isPrecise(+v5)) {
          var x4 = +v5;
          if (x4 === truncate(x4))
            return supportsNativeBigInt ? new NativeBigInt(BigInt(x4)) : new SmallInteger(x4);
          throw new Error("Invalid integer: " + v5);
        }
        var sign = v5[0] === "-";
        if (sign)
          v5 = v5.slice(1);
        var split = v5.split(/e/i);
        if (split.length > 2)
          throw new Error("Invalid integer: " + split.join("e"));
        if (split.length === 2) {
          var exp = split[1];
          if (exp[0] === "+")
            exp = exp.slice(1);
          exp = +exp;
          if (exp !== truncate(exp) || !isPrecise(exp))
            throw new Error("Invalid integer: " + exp + " is not a valid exponent.");
          var text = split[0];
          var decimalPlace = text.indexOf(".");
          if (decimalPlace >= 0) {
            exp -= text.length - decimalPlace - 1;
            text = text.slice(0, decimalPlace) + text.slice(decimalPlace + 1);
          }
          if (exp < 0)
            throw new Error("Cannot include negative exponent part for integers");
          text += new Array(exp + 1).join("0");
          v5 = text;
        }
        var isValid = /^([0-9][0-9]*)$/.test(v5);
        if (!isValid)
          throw new Error("Invalid integer: " + v5);
        if (supportsNativeBigInt) {
          return new NativeBigInt(BigInt(sign ? "-" + v5 : v5));
        }
        var r3 = [], max2 = v5.length, l6 = LOG_BASE, min2 = max2 - l6;
        while (max2 > 0) {
          r3.push(+v5.slice(min2, max2));
          min2 -= l6;
          if (min2 < 0)
            min2 = 0;
          max2 -= l6;
        }
        trim(r3);
        return new BigInteger(r3, sign);
      }
      function parseNumberValue(v5) {
        if (supportsNativeBigInt) {
          return new NativeBigInt(BigInt(v5));
        }
        if (isPrecise(v5)) {
          if (v5 !== truncate(v5))
            throw new Error(v5 + " is not an integer.");
          return new SmallInteger(v5);
        }
        return parseStringValue(v5.toString());
      }
      function parseValue(v5) {
        if (typeof v5 === "number") {
          return parseNumberValue(v5);
        }
        if (typeof v5 === "string") {
          return parseStringValue(v5);
        }
        if (typeof v5 === "bigint") {
          return new NativeBigInt(v5);
        }
        return v5;
      }
      for (var i4 = 0; i4 < 1e3; i4++) {
        Integer[i4] = parseValue(i4);
        if (i4 > 0)
          Integer[-i4] = parseValue(-i4);
      }
      Integer.one = Integer[1];
      Integer.zero = Integer[0];
      Integer.minusOne = Integer[-1];
      Integer.max = max;
      Integer.min = min;
      Integer.gcd = gcd;
      Integer.lcm = lcm;
      Integer.isInstance = function(x4) {
        return x4 instanceof BigInteger || x4 instanceof SmallInteger || x4 instanceof NativeBigInt;
      };
      Integer.randBetween = randBetween;
      Integer.fromArray = function(digits, base, isNegative) {
        return parseBaseFromArray(digits.map(parseValue), parseValue(base || 10), isNegative);
      };
      return Integer;
    }();
    if (typeof module !== "undefined" && module.hasOwnProperty("exports")) {
      module.exports = bigInt;
    }
    if (typeof define === "function" && define.amd) {
      define(function() {
        return bigInt;
      });
    }
  }
});

// ../../node_modules/.pnpm/@keplr-wallet+unit@0.12.28/node_modules/@keplr-wallet/unit/build/etc.js
var require_etc = __commonJS({
  "../../node_modules/.pnpm/@keplr-wallet+unit@0.12.28/node_modules/@keplr-wallet/unit/build/etc.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.exponentDecStringToDecString = exports.isExponentDecString = exports.isValidDecimalString = exports.isValidIntegerString = void 0;
    var regexIntString = /^-?\d+$/;
    var regexDecString = /^-?\d+.?\d*$/;
    var regexExponentDecString = /^(-?)([\d.]+)e([-+])([\d]+)$/;
    function isValidIntegerString(str) {
      return regexIntString.test(str);
    }
    exports.isValidIntegerString = isValidIntegerString;
    function isValidDecimalString(str) {
      return regexDecString.test(str);
    }
    exports.isValidDecimalString = isValidDecimalString;
    function isExponentDecString(str) {
      return regexExponentDecString.test(str);
    }
    exports.isExponentDecString = isExponentDecString;
    function makeZerosStr(len) {
      let r3 = "";
      for (let i4 = 0; i4 < len; i4++) {
        r3 += "0";
      }
      return r3;
    }
    function removeHeadZeros(str) {
      while (str.length > 0 && str[0] === "0") {
        str = str.slice(1);
      }
      if (str.length === 0 || str[0] === ".") {
        return "0" + str;
      }
      return str;
    }
    function exponentDecStringToDecString(str) {
      const split = str.split(regexExponentDecString);
      if (split.length !== 6) {
        return str;
      }
      const isNeg = split[1] === "-";
      let numStr = split[2];
      const numStrFractionIndex = numStr.indexOf(".");
      const exponentStr = split[4];
      let exponent = parseInt(exponentStr) * (split[3] === "-" ? -1 : 1);
      if (numStrFractionIndex >= 0) {
        const fractionLen = numStr.length - numStrFractionIndex - 1;
        exponent = exponent - fractionLen;
        numStr = removeHeadZeros(numStr.replace(".", ""));
      }
      const prefix = isNeg ? "-" : "";
      if (exponent < 0) {
        if (numStr.length > -exponent) {
          const fractionPosition = numStr.length + exponent;
          return prefix + (numStr.slice(0, fractionPosition) + "." + numStr.slice(fractionPosition));
        }
        return prefix + "0." + makeZerosStr(-(numStr.length + exponent)) + numStr;
      } else {
        return prefix + numStr + makeZerosStr(exponent);
      }
    }
    exports.exponentDecStringToDecString = exponentDecStringToDecString;
  }
});

// ../../node_modules/.pnpm/@keplr-wallet+unit@0.12.28/node_modules/@keplr-wallet/unit/build/int.js
var require_int = __commonJS({
  "../../node_modules/.pnpm/@keplr-wallet+unit@0.12.28/node_modules/@keplr-wallet/unit/build/int.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Uint = exports.Int = void 0;
    var big_integer_1 = __importDefault(require_BigInteger());
    var etc_1 = require_etc();
    var Int = class _Int {
      /**
       * @param int - Parse a number | bigInteger | string into a bigInt.
       */
      constructor(int) {
        if (typeof int === "number") {
          int = int.toString();
        }
        if (typeof int === "string") {
          if (!(0, etc_1.isValidIntegerString)(int)) {
            if ((0, etc_1.isExponentDecString)(int)) {
              int = (0, etc_1.exponentDecStringToDecString)(int);
            } else {
              throw new Error(`invalid integer: ${int}`);
            }
          }
          this.int = (0, big_integer_1.default)(int);
        } else if (typeof int === "bigint") {
          this.int = (0, big_integer_1.default)(int);
        } else {
          this.int = (0, big_integer_1.default)(int);
        }
        this.checkBitLen();
      }
      checkBitLen() {
        if (this.int.abs().gt(_Int.maxInt)) {
          throw new Error(`Integer out of range ${this.int.toString()}`);
        }
      }
      toString() {
        return this.int.toString(10);
      }
      isNegative() {
        return this.int.isNegative();
      }
      isPositive() {
        return this.int.isPositive();
      }
      isZero() {
        return this.int.eq((0, big_integer_1.default)(0));
      }
      equals(i4) {
        return this.int.equals(i4.int);
      }
      gt(i4) {
        return this.int.gt(i4.int);
      }
      gte(i4) {
        return this.int.greaterOrEquals(i4.int);
      }
      lt(i4) {
        return this.int.lt(i4.int);
      }
      lte(i4) {
        return this.int.lesserOrEquals(i4.int);
      }
      abs() {
        return new _Int(this.int.abs());
      }
      absUInt() {
        return new Uint(this.int.abs());
      }
      add(i4) {
        return new _Int(this.int.add(i4.int));
      }
      sub(i4) {
        return new _Int(this.int.subtract(i4.int));
      }
      mul(i4) {
        return new _Int(this.int.multiply(i4.int));
      }
      div(i4) {
        return new _Int(this.int.divide(i4.int));
      }
      mod(i4) {
        return new _Int(this.int.mod(i4.int));
      }
      neg() {
        return new _Int(this.int.negate());
      }
      pow(i4) {
        return new _Int(this.int.pow(i4.toBigNumber()));
      }
      toBigNumber() {
        return this.int;
      }
    };
    exports.Int = Int;
    Int.maxInt = (0, big_integer_1.default)("115792089237316195423570985008687907853269984665640564039457584007913129639935");
    var Uint = class _Uint {
      /**
       * @param uint - Parse a number | bigInteger | string into a bigUint.
       */
      constructor(uint) {
        if (typeof uint === "number") {
          uint = uint.toString();
        }
        if (typeof uint === "string") {
          if (!(0, etc_1.isValidIntegerString)(uint)) {
            if ((0, etc_1.isExponentDecString)(uint)) {
              uint = (0, etc_1.exponentDecStringToDecString)(uint);
            } else {
              throw new Error(`invalid integer: ${uint}`);
            }
          }
          this.uint = (0, big_integer_1.default)(uint);
        } else if (typeof uint === "bigint") {
          this.uint = (0, big_integer_1.default)(uint);
        } else {
          this.uint = (0, big_integer_1.default)(uint);
        }
        if (this.uint.isNegative()) {
          throw new TypeError("Uint should not be negative");
        }
        this.checkBitLen();
      }
      checkBitLen() {
        if (this.uint.abs().bitLength().gt(256)) {
          throw new Error(`Integer out of range ${this.uint.toString()}`);
        }
      }
      toString() {
        return this.uint.toString(10);
      }
      isZero() {
        return this.uint.eq((0, big_integer_1.default)(0));
      }
      equals(i4) {
        return this.uint.equals(i4.uint);
      }
      gt(i4) {
        return this.uint.gt(i4.uint);
      }
      gte(i4) {
        return this.uint.greaterOrEquals(i4.uint);
      }
      lt(i4) {
        return this.uint.lt(i4.uint);
      }
      lte(i4) {
        return this.uint.lesserOrEquals(i4.uint);
      }
      add(i4) {
        return new _Uint(this.uint.add(i4.uint));
      }
      sub(i4) {
        return new _Uint(this.uint.subtract(i4.uint));
      }
      mul(i4) {
        return new _Uint(this.uint.multiply(i4.uint));
      }
      div(i4) {
        return new _Uint(this.uint.divide(i4.uint));
      }
      mod(i4) {
        return new _Uint(this.uint.mod(i4.uint));
      }
      pow(i4) {
        return new _Uint(this.uint.pow(i4.toBigNumber()));
      }
      toBigNumber() {
        return this.uint;
      }
    };
    exports.Uint = Uint;
  }
});

// ../../node_modules/.pnpm/@keplr-wallet+unit@0.12.28/node_modules/@keplr-wallet/unit/build/utils.js
var require_utils2 = __commonJS({
  "../../node_modules/.pnpm/@keplr-wallet+unit@0.12.28/node_modules/@keplr-wallet/unit/build/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.integerStringToUSLocaleString = void 0;
    function integerStringToUSLocaleString(numberStr) {
      if (numberStr.indexOf(".") >= 0) {
        throw new Error(`${numberStr} is not integer`);
      }
      if (typeof BigInt !== "undefined") {
        return BigInt(numberStr).toLocaleString("en-US");
      }
      const integer = numberStr;
      const chunks = [];
      for (let i4 = integer.length; i4 > 0; i4 -= 3) {
        chunks.push(integer.slice(Math.max(0, i4 - 3), i4));
      }
      return chunks.reverse().join(",");
    }
    exports.integerStringToUSLocaleString = integerStringToUSLocaleString;
  }
});

// ../../node_modules/.pnpm/@keplr-wallet+unit@0.12.28/node_modules/@keplr-wallet/unit/build/decimal.js
var require_decimal = __commonJS({
  "../../node_modules/.pnpm/@keplr-wallet+unit@0.12.28/node_modules/@keplr-wallet/unit/build/decimal.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Dec = void 0;
    var big_integer_1 = __importDefault(require_BigInteger());
    var int_1 = require_int();
    var etc_1 = require_etc();
    var utils_1 = require_utils2();
    var Dec = class _Dec {
      static calcPrecisionMultiplier(prec) {
        if (prec < 0) {
          throw new Error("Invalid prec");
        }
        if (prec > _Dec.precision) {
          throw new Error("Too much precision");
        }
        const key = prec.toString();
        const cached = _Dec.precisionMultipliers.get(key);
        if (cached) {
          return cached;
        }
        const zerosToAdd = _Dec.precision - prec;
        const multiplier = (0, big_integer_1.default)(10).pow(zerosToAdd);
        _Dec.precisionMultipliers.set(key, multiplier);
        return multiplier;
      }
      static reduceDecimalsFromString(str) {
        const decimalPointIndex = str.indexOf(".");
        if (decimalPointIndex < 0) {
          return {
            res: str,
            isDownToZero: false
          };
        }
        const exceededDecimals = str.length - 1 - decimalPointIndex - _Dec.precision;
        if (exceededDecimals <= 0) {
          return {
            res: str,
            isDownToZero: false
          };
        }
        const res = str.slice(0, str.length - exceededDecimals);
        return {
          res,
          isDownToZero: /^[0.]*$/.test(res)
        };
      }
      /**
       * Create a new Dec from integer with decimal place at prec
       * @param int - Parse a number | bigInteger | string into a Dec.
       * If int is string and contains dot(.), prec is ignored and automatically calculated.
       * @param prec - Precision
       */
      constructor(int, prec = 0) {
        if (typeof int === "number") {
          int = int.toString();
        }
        if (typeof int === "string") {
          if (int.length === 0) {
            throw new Error("empty string");
          }
          if (!(0, etc_1.isValidDecimalString)(int)) {
            if ((0, etc_1.isExponentDecString)(int)) {
              int = (0, etc_1.exponentDecStringToDecString)(int);
            } else {
              throw new Error(`invalid decimal: ${int}`);
            }
          }
          const reduced = _Dec.reduceDecimalsFromString(int);
          if (reduced.isDownToZero) {
            console.log(`WARNING: Got ${int}. Dec can only handle up to 18 decimals. However, since the decimal point of the input exceeds 18 digits, the remainder is discarded. As a result, input becomes 0.`);
          }
          int = reduced.res;
          if (int.indexOf(".") >= 0) {
            prec = int.length - int.indexOf(".") - 1;
            int = int.replace(".", "");
          }
          this.int = (0, big_integer_1.default)(int);
        } else if (int instanceof int_1.Int) {
          this.int = (0, big_integer_1.default)(int.toString());
        } else if (int instanceof int_1.Uint) {
          this.int = (0, big_integer_1.default)(int.toString());
        } else if (typeof int === "bigint") {
          this.int = (0, big_integer_1.default)(int);
        } else {
          this.int = (0, big_integer_1.default)(int);
        }
        this.int = this.int.multiply(_Dec.calcPrecisionMultiplier(prec));
        this.checkBitLen();
      }
      checkBitLen() {
        if (this.int.abs().gt(_Dec.maxDec)) {
          throw new Error(`Integer out of range ${this.int.toString()}`);
        }
      }
      isZero() {
        return this.int.eq((0, big_integer_1.default)(0));
      }
      isNegative() {
        return this.int.isNegative();
      }
      isPositive() {
        return this.int.isPositive();
      }
      equals(d22) {
        return this.int.eq(d22.int);
      }
      /**
       * Alias for the greater method.
       */
      gt(d22) {
        return this.int.gt(d22.int);
      }
      /**
       * Alias for the greaterOrEquals method.
       */
      gte(d22) {
        return this.int.geq(d22.int);
      }
      /**
       * Alias for the lesser method.
       */
      lt(d22) {
        return this.int.lt(d22.int);
      }
      /**
       * Alias for the lesserOrEquals method.
       */
      lte(d22) {
        return this.int.leq(d22.int);
      }
      /**
       * reverse the decimal sign.
       */
      neg() {
        return new _Dec(this.int.negate(), _Dec.precision);
      }
      /**
       * Returns the absolute value of a decimals.
       */
      abs() {
        return new _Dec(this.int.abs(), _Dec.precision);
      }
      add(d22) {
        return new _Dec(this.int.add(d22.int), _Dec.precision);
      }
      sub(d22) {
        return new _Dec(this.int.subtract(d22.int), _Dec.precision);
      }
      pow(n5) {
        if (n5.isZero()) {
          return new _Dec(1);
        }
        if (n5.isNegative()) {
          return new _Dec(1).quo(this.pow(n5.abs()));
        }
        let base = new _Dec(this.int, _Dec.precision);
        let tmp = new _Dec(1);
        for (let i4 = n5; i4.gt(new int_1.Int(1)); i4 = i4.div(new int_1.Int(2))) {
          if (!i4.mod(new int_1.Int(2)).isZero()) {
            tmp = tmp.mul(base);
          }
          base = base.mul(base);
        }
        return base.mul(tmp);
      }
      approxSqrt() {
        return this.approxRoot(2);
      }
      approxRoot(root, maxIters = 300) {
        if (this.isNegative()) {
          return this.neg().approxRoot(root).neg();
        }
        if (root === 1 || this.isZero() || this.equals(_Dec.one)) {
          return this;
        }
        if (root === 0) {
          return _Dec.one;
        }
        let [guess, delta] = [_Dec.one, _Dec.one];
        for (let i4 = 0; delta.abs().gt(_Dec.smallestDec) && i4 < maxIters; i4++) {
          let prev = guess.pow(new int_1.Int(root - 1));
          if (prev.isZero()) {
            prev = _Dec.smallestDec;
          }
          delta = this.quo(prev);
          delta = delta.sub(guess);
          delta = delta.quoTruncate(new _Dec(root));
          guess = guess.add(delta);
        }
        return guess;
      }
      mul(d22) {
        return new _Dec(this.mulRaw(d22).chopPrecisionAndRound(), _Dec.precision);
      }
      mulTruncate(d22) {
        return new _Dec(this.mulRaw(d22).chopPrecisionAndTruncate(), _Dec.precision);
      }
      mulRoundUp(d22) {
        return new _Dec(this.mulRaw(d22).chopPrecisionAndRoundUp(), _Dec.precision);
      }
      mulRaw(d22) {
        return new _Dec(this.int.multiply(d22.int), _Dec.precision);
      }
      quo(d22) {
        return new _Dec(this.quoRaw(d22).chopPrecisionAndRound(), _Dec.precision);
      }
      quoTruncate(d22) {
        return new _Dec(this.quoRaw(d22).chopPrecisionAndTruncate(), _Dec.precision);
      }
      quoRoundUp(d22) {
        return new _Dec(this.quoRaw(d22).chopPrecisionAndRoundUp(), _Dec.precision);
      }
      quoRaw(d22) {
        const precision = _Dec.calcPrecisionMultiplier(0);
        const mul = this.int.multiply(precision).multiply(precision);
        return new _Dec(mul.divide(d22.int), _Dec.precision);
      }
      isInteger() {
        const precision = _Dec.calcPrecisionMultiplier(0);
        return this.int.remainder(precision).equals((0, big_integer_1.default)(0));
      }
      /**
       * Remove a Precision amount of rightmost digits and perform bankers rounding
       * on the remainder (gaussian rounding) on the digits which have been removed.
       */
      chopPrecisionAndRound() {
        if (this.isNegative()) {
          const absoulteDec = this.abs();
          const choped = absoulteDec.chopPrecisionAndRound();
          return choped.negate();
        }
        const precision = _Dec.calcPrecisionMultiplier(0);
        const fivePrecision = precision.divide((0, big_integer_1.default)(2));
        const { quotient, remainder } = this.int.divmod(precision);
        if (remainder.equals((0, big_integer_1.default)(0))) {
          return quotient;
        }
        if (remainder.lt(fivePrecision)) {
          return quotient;
        } else if (remainder.gt(fivePrecision)) {
          return quotient.add((0, big_integer_1.default)(1));
        } else {
          if (quotient.divide((0, big_integer_1.default)(2)).equals((0, big_integer_1.default)(0))) {
            return quotient;
          } else {
            return quotient.add((0, big_integer_1.default)(1));
          }
        }
      }
      chopPrecisionAndRoundUp() {
        if (this.isNegative()) {
          const absoulteDec = this.abs();
          const choped = absoulteDec.chopPrecisionAndTruncate();
          return choped.negate();
        }
        const precision = _Dec.calcPrecisionMultiplier(0);
        const { quotient, remainder } = this.int.divmod(precision);
        if (remainder.equals((0, big_integer_1.default)(0))) {
          return quotient;
        }
        return quotient.add((0, big_integer_1.default)(1));
      }
      /**
       * Similar to chopPrecisionAndRound, but always rounds down
       */
      chopPrecisionAndTruncate() {
        const precision = _Dec.calcPrecisionMultiplier(0);
        return this.int.divide(precision);
      }
      toString(prec = _Dec.precision, locale = false) {
        const precision = _Dec.calcPrecisionMultiplier(0);
        const int = this.int.abs();
        const { quotient: integer, remainder: fraction } = int.divmod(precision);
        let fractionStr = fraction.toString(10);
        for (let i4 = 0, l6 = fractionStr.length; i4 < _Dec.precision - l6; i4++) {
          fractionStr = "0" + fractionStr;
        }
        fractionStr = fractionStr.substring(0, prec);
        const isNegative = this.isNegative() && !(integer.eq((0, big_integer_1.default)(0)) && fractionStr.length === 0);
        const integerStr = locale ? (0, utils_1.integerStringToUSLocaleString)(integer.toString()) : integer.toString();
        return `${isNegative ? "-" : ""}${integerStr}${fractionStr.length > 0 ? "." + fractionStr : ""}`;
      }
      round() {
        return new int_1.Int(this.chopPrecisionAndRound());
      }
      roundUp() {
        return new int_1.Int(this.chopPrecisionAndRoundUp());
      }
      truncate() {
        return new int_1.Int(this.chopPrecisionAndTruncate());
      }
      roundDec() {
        return new _Dec(this.chopPrecisionAndRound(), 0);
      }
      roundUpDec() {
        return new _Dec(this.chopPrecisionAndRoundUp(), 0);
      }
      truncateDec() {
        return new _Dec(this.chopPrecisionAndTruncate(), 0);
      }
    };
    exports.Dec = Dec;
    Dec.precision = 18;
    Dec.decimalPrecisionBits = 60;
    Dec.maxDec = (0, big_integer_1.default)("133499189745056880149688856635597007162669032647290798121690100488888732861290034376435130433535");
    Dec.precisionMultipliers = /* @__PURE__ */ new Map();
    Dec.zero = new Dec(0);
    Dec.smallestDec = new Dec("1", Dec.precision);
    Dec.one = new Dec(1);
    int_1.Int.prototype.toDec = function() {
      return new Dec(this);
    };
    int_1.Uint.prototype.toDec = function() {
      return new Dec(this);
    };
  }
});

// ../../node_modules/.pnpm/@keplr-wallet+unit@0.12.28/node_modules/@keplr-wallet/unit/build/dec-utils.js
var require_dec_utils = __commonJS({
  "../../node_modules/.pnpm/@keplr-wallet+unit@0.12.28/node_modules/@keplr-wallet/unit/build/dec-utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DecUtils = void 0;
    var decimal_1 = require_decimal();
    var int_1 = require_int();
    var DecUtils = class _DecUtils {
      static trim(dec) {
        let decStr = typeof dec === "string" ? dec : dec.toString();
        if (decStr.indexOf(".") < 0) {
          return decStr;
        }
        for (let i4 = decStr.length - 1; i4 >= 0; i4--) {
          if (decStr[i4] === "0") {
            decStr = decStr.slice(0, i4);
          } else {
            break;
          }
        }
        if (decStr.length > 0) {
          if (decStr[decStr.length - 1] === ".") {
            decStr = decStr.slice(0, decStr.length - 1);
          }
        }
        return decStr;
      }
      static getTenExponentN(n5) {
        if (n5 < -decimal_1.Dec.precision) {
          throw new Error("Too little precision");
        }
        if (_DecUtils.tenExponentNs[n5.toString()]) {
          return _DecUtils.tenExponentNs[n5.toString()];
        }
        const dec = new decimal_1.Dec(10).pow(new int_1.Int(n5));
        _DecUtils.tenExponentNs[n5.toString()] = dec;
        return dec;
      }
      static getTenExponentNInPrecisionRange(n5) {
        if (n5 > decimal_1.Dec.precision) {
          throw new Error("Too much precision");
        }
        return _DecUtils.getTenExponentN(n5);
      }
      /**
       * @deprecated Use`getTenExponentNInPrecisionRange`
       */
      static getPrecisionDec(precision) {
        return _DecUtils.getTenExponentNInPrecisionRange(precision);
      }
    };
    exports.DecUtils = DecUtils;
    DecUtils.tenExponentNs = {};
  }
});

// ../../node_modules/.pnpm/@keplr-wallet+unit@0.12.28/node_modules/@keplr-wallet/unit/build/coin.js
var require_coin = __commonJS({
  "../../node_modules/.pnpm/@keplr-wallet+unit@0.12.28/node_modules/@keplr-wallet/unit/build/coin.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Coin = void 0;
    var int_1 = require_int();
    var Coin = class _Coin {
      static parse(str) {
        const re2 = new RegExp("([0-9]+)[ ]*([a-zA-Z]+)$");
        const execed = re2.exec(str);
        if (!execed || execed.length !== 3) {
          throw new Error("Invalid coin str");
        }
        const denom = execed[2];
        const amount = execed[1];
        return new _Coin(denom, amount);
      }
      constructor(denom, amount) {
        this.denom = denom;
        this.amount = amount instanceof int_1.Int ? amount : new int_1.Int(amount);
      }
      toString() {
        return `${this.amount.toString()}${this.denom}`;
      }
    };
    exports.Coin = Coin;
  }
});

// ../../node_modules/.pnpm/@keplr-wallet+unit@0.12.28/node_modules/@keplr-wallet/unit/build/coin-utils.js
var require_coin_utils = __commonJS({
  "../../node_modules/.pnpm/@keplr-wallet+unit@0.12.28/node_modules/@keplr-wallet/unit/build/coin-utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CoinUtils = void 0;
    var coin_1 = require_coin();
    var int_1 = require_int();
    var decimal_1 = require_decimal();
    var dec_utils_1 = require_dec_utils();
    var utils_1 = require_utils2();
    var CoinUtils = class _CoinUtils {
      static createCoinsFromPrimitives(coinPrimitives) {
        return coinPrimitives.map((primitive) => {
          return new coin_1.Coin(primitive.denom, primitive.amount);
        });
      }
      static amountOf(coins, denom) {
        const coin = coins.find((coin2) => {
          return coin2.denom === denom;
        });
        if (!coin) {
          return new int_1.Int(0);
        } else {
          return coin.amount;
        }
      }
      static exclude(coins, demons) {
        return coins.filter((coin) => {
          return demons.indexOf(coin.denom) === 0;
        });
      }
      static concat(...coins) {
        if (coins.length === 0) {
          return [];
        }
        const arr = coins.slice();
        const reducer = (accumulator, coin) => {
          const find = accumulator.find((c6) => c6.denom === coin.denom);
          if (find) {
            const newCoin = new coin_1.Coin(find.denom, find.amount.add(coin.amount));
            accumulator.push(newCoin);
          } else {
            const newCoin = new coin_1.Coin(coin.denom, coin.amount);
            accumulator.push(newCoin);
          }
          return accumulator;
        };
        return arr.reduce(reducer, []);
      }
      static getCoinFromDecimals(currencies, decAmountStr, denom) {
        const currency = currencies.find((currency2) => {
          return currency2.coinDenom === denom;
        });
        if (!currency) {
          throw new Error("Invalid currency");
        }
        let precision = new decimal_1.Dec(1);
        for (let i4 = 0; i4 < currency.coinDecimals; i4++) {
          precision = precision.mul(new decimal_1.Dec(10));
        }
        let decAmount = new decimal_1.Dec(decAmountStr);
        decAmount = decAmount.mul(precision);
        if (!new decimal_1.Dec(decAmount.truncate()).equals(decAmount)) {
          throw new Error("Can't divide anymore");
        }
        return new coin_1.Coin(currency.coinMinimalDenom, decAmount.truncate());
      }
      static parseDecAndDenomFromCoin(currencies, coin) {
        let currency = currencies.find((currency2) => {
          return currency2.coinMinimalDenom === coin.denom;
        });
        if (!currency) {
          currency = {
            coinDecimals: 0,
            coinDenom: coin.denom,
            coinMinimalDenom: coin.denom
          };
        }
        let precision = new decimal_1.Dec(1);
        for (let i4 = 0; i4 < currency.coinDecimals; i4++) {
          precision = precision.mul(new decimal_1.Dec(10));
        }
        const decAmount = new decimal_1.Dec(coin.amount).quoTruncate(precision);
        return {
          amount: decAmount.toString(currency.coinDecimals),
          denom: currency.coinDenom
        };
      }
      static shrinkDecimals(dec, minDecimals, maxDecimals, locale = false) {
        if (dec.equals(new decimal_1.Dec(0))) {
          return "0";
        }
        const isNeg = dec.isNegative();
        const integer = dec.abs().truncate();
        const fraction = dec.abs().sub(new decimal_1.Dec(integer));
        const decimals = Math.max(maxDecimals - integer.toString().length + 1, minDecimals);
        const fractionStr = decimals === 0 ? "" : fraction.toString(decimals).replace("0.", "");
        const integerStr = locale ? _CoinUtils.integerStringToUSLocaleString(integer.toString()) : integer.toString();
        return (isNeg ? "-" : "") + integerStr + (fractionStr.length > 0 ? "." : "") + fractionStr;
      }
      static coinToTrimmedString(coin, currency, separator = " ") {
        const dec = new decimal_1.Dec(coin.amount).quoTruncate(dec_utils_1.DecUtils.getPrecisionDec(currency.coinDecimals));
        return `${dec_utils_1.DecUtils.trim(dec)}${separator}${currency.coinDenom}`;
      }
    };
    exports.CoinUtils = CoinUtils;
    CoinUtils.integerStringToUSLocaleString = utils_1.integerStringToUSLocaleString;
  }
});

// ../../node_modules/.pnpm/@keplr-wallet+unit@0.12.28/node_modules/@keplr-wallet/unit/build/int-pretty.js
var require_int_pretty = __commonJS({
  "../../node_modules/.pnpm/@keplr-wallet+unit@0.12.28/node_modules/@keplr-wallet/unit/build/int-pretty.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IntPretty = void 0;
    var int_1 = require_int();
    var decimal_1 = require_decimal();
    var dec_utils_1 = require_dec_utils();
    var coin_utils_1 = require_coin_utils();
    var IntPretty = class _IntPretty {
      constructor(num) {
        this.floatingDecimalPointRight = 0;
        this._options = {
          maxDecimals: 0,
          trim: false,
          shrink: false,
          ready: true,
          locale: true,
          inequalitySymbol: false,
          inequalitySymbolSeparator: " "
        };
        if (typeof num === "object" && "toDec" in num) {
          num = num.toDec();
        } else if (!(num instanceof decimal_1.Dec)) {
          num = new decimal_1.Dec(num);
        }
        if (num.isZero()) {
          this.dec = num;
          return;
        }
        let dec = num;
        let decPrecision = 0;
        for (let i4 = 0; i4 < 18; i4++) {
          if (!dec.truncate().equals(new int_1.Int(0)) && dec.equals(new decimal_1.Dec(dec.truncate()))) {
            break;
          }
          dec = dec.mul(new decimal_1.Dec(10));
          decPrecision++;
        }
        this.dec = num;
        this._options.maxDecimals = decPrecision;
      }
      get options() {
        return this._options;
      }
      moveDecimalPointLeft(delta) {
        const pretty = this.clone();
        pretty.floatingDecimalPointRight += -delta;
        return pretty;
      }
      moveDecimalPointRight(delta) {
        const pretty = this.clone();
        pretty.floatingDecimalPointRight += delta;
        return pretty;
      }
      /**
       * @deprecated Use`moveDecimalPointLeft`
       */
      increasePrecision(delta) {
        return this.moveDecimalPointLeft(delta);
      }
      /**
       * @deprecated Use`moveDecimalPointRight`
       */
      decreasePrecision(delta) {
        return this.moveDecimalPointRight(delta);
      }
      maxDecimals(max) {
        const pretty = this.clone();
        pretty._options.maxDecimals = max;
        return pretty;
      }
      inequalitySymbol(bool) {
        const pretty = this.clone();
        pretty._options.inequalitySymbol = bool;
        return pretty;
      }
      inequalitySymbolSeparator(str) {
        const pretty = this.clone();
        pretty._options.inequalitySymbolSeparator = str;
        return pretty;
      }
      trim(bool) {
        const pretty = this.clone();
        pretty._options.trim = bool;
        return pretty;
      }
      shrink(bool) {
        const pretty = this.clone();
        pretty._options.shrink = bool;
        return pretty;
      }
      locale(locale) {
        const pretty = this.clone();
        pretty._options.locale = locale;
        return pretty;
      }
      /**
       * Ready indicates the actual value is ready to show the users.
       * Even if the ready option is false, it expects that the value can be shown to users (probably as 0).
       * The method that returns prettied value may return `undefined` or `null` if the value is not ready.
       * But, alternatively, it can return the 0 value that can be shown the users anyway, but indicates that the value is not ready.
       * @param bool
       */
      ready(bool) {
        const pretty = this.clone();
        pretty._options.ready = bool;
        return pretty;
      }
      get isReady() {
        return this._options.ready;
      }
      add(target) {
        if (!(target instanceof decimal_1.Dec)) {
          target = target.toDec();
        }
        const pretty = new _IntPretty(this.toDec().add(target));
        pretty._options = Object.assign({}, this._options);
        return pretty;
      }
      sub(target) {
        if (!(target instanceof decimal_1.Dec)) {
          target = target.toDec();
        }
        const pretty = new _IntPretty(this.toDec().sub(target));
        pretty._options = Object.assign({}, this._options);
        return pretty;
      }
      mul(target) {
        if (!(target instanceof decimal_1.Dec)) {
          target = target.toDec();
        }
        const pretty = new _IntPretty(this.toDec().mul(target));
        pretty._options = Object.assign({}, this._options);
        return pretty;
      }
      quo(target) {
        if (!(target instanceof decimal_1.Dec)) {
          target = target.toDec();
        }
        const pretty = new _IntPretty(this.toDec().quo(target));
        pretty._options = Object.assign({}, this._options);
        return pretty;
      }
      toDec() {
        if (this.floatingDecimalPointRight === 0) {
          return this.dec;
        } else if (this.floatingDecimalPointRight > 0) {
          return this.dec.mulTruncate(dec_utils_1.DecUtils.getTenExponentN(this.floatingDecimalPointRight));
        } else {
          let i4 = -this.floatingDecimalPointRight;
          let dec = this.dec;
          while (i4 > 0) {
            if (i4 >= decimal_1.Dec.precision) {
              dec = dec.mulTruncate(dec_utils_1.DecUtils.getTenExponentN(-decimal_1.Dec.precision));
              i4 -= decimal_1.Dec.precision;
            } else {
              dec = dec.mulTruncate(dec_utils_1.DecUtils.getTenExponentN(-(i4 % decimal_1.Dec.precision)));
              break;
            }
          }
          return dec;
        }
      }
      toString() {
        return this.toStringWithSymbols("", "");
      }
      toStringWithSymbols(prefix, suffix) {
        const dec = this.toDec();
        if (this._options.inequalitySymbol && !dec.isZero() && dec.abs().lt(dec_utils_1.DecUtils.getTenExponentN(-this._options.maxDecimals))) {
          const isNeg2 = dec.isNegative();
          return `${isNeg2 ? ">" : "<"}${this._options.inequalitySymbolSeparator}${isNeg2 ? "-" : ""}${prefix}${dec_utils_1.DecUtils.getTenExponentN(-this._options.maxDecimals).toString(this._options.maxDecimals, this._options.locale)}${suffix}`;
        }
        let result;
        if (!this._options.shrink) {
          result = dec.toString(this._options.maxDecimals, this._options.locale);
        } else {
          result = coin_utils_1.CoinUtils.shrinkDecimals(dec, 0, this._options.maxDecimals, this._options.locale);
        }
        if (this._options.trim) {
          result = dec_utils_1.DecUtils.trim(result);
        }
        const isNeg = result.charAt(0) === "-";
        if (isNeg) {
          result = result.slice(1);
        }
        return `${isNeg ? "-" : ""}${prefix}${result}${suffix}`;
      }
      clone() {
        const pretty = new _IntPretty(this.dec);
        pretty.dec = this.dec;
        pretty.floatingDecimalPointRight = this.floatingDecimalPointRight;
        pretty._options = Object.assign({}, this._options);
        return pretty;
      }
    };
    exports.IntPretty = IntPretty;
  }
});

// ../../node_modules/.pnpm/@keplr-wallet+unit@0.12.28/node_modules/@keplr-wallet/unit/build/coin-pretty.js
var require_coin_pretty = __commonJS({
  "../../node_modules/.pnpm/@keplr-wallet+unit@0.12.28/node_modules/@keplr-wallet/unit/build/coin-pretty.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CoinPretty = void 0;
    var int_pretty_1 = require_int_pretty();
    var decimal_1 = require_decimal();
    var dec_utils_1 = require_dec_utils();
    var CoinPretty = class _CoinPretty {
      constructor(_currency, amount) {
        this._currency = _currency;
        this._options = {
          separator: " ",
          upperCase: false,
          lowerCase: false,
          hideDenom: false,
          hideIBCMetadata: false
        };
        if (typeof amount === "object" && "toDec" in amount) {
          amount = amount.toDec();
        } else if (!(amount instanceof decimal_1.Dec)) {
          amount = new decimal_1.Dec(amount);
        }
        this.intPretty = new int_pretty_1.IntPretty(amount.quoTruncate(dec_utils_1.DecUtils.getTenExponentNInPrecisionRange(_currency.coinDecimals))).maxDecimals(_currency.coinDecimals);
      }
      get options() {
        return Object.assign(Object.assign({}, this._options), this.intPretty.options);
      }
      get denom() {
        return this.currency.coinDenom;
      }
      get currency() {
        return this._currency;
      }
      setCurrency(currency) {
        const pretty = this.clone();
        pretty.intPretty = this.intPretty.moveDecimalPointRight(this._currency.coinDecimals - currency.coinDecimals);
        pretty._currency = currency;
        return pretty;
      }
      separator(str) {
        const pretty = this.clone();
        pretty._options.separator = str;
        return pretty;
      }
      upperCase(bool) {
        const pretty = this.clone();
        pretty._options.upperCase = bool;
        pretty._options.lowerCase = !bool;
        return pretty;
      }
      lowerCase(bool) {
        const pretty = this.clone();
        pretty._options.lowerCase = bool;
        pretty._options.upperCase = !bool;
        return pretty;
      }
      hideDenom(bool) {
        const pretty = this.clone();
        pretty._options.hideDenom = bool;
        return pretty;
      }
      hideIBCMetadata(bool) {
        const pretty = this.clone();
        pretty._options.hideIBCMetadata = bool;
        return pretty;
      }
      moveDecimalPointLeft(delta) {
        const pretty = this.clone();
        pretty.intPretty = pretty.intPretty.moveDecimalPointLeft(delta);
        return pretty;
      }
      moveDecimalPointRight(delta) {
        const pretty = this.clone();
        pretty.intPretty = pretty.intPretty.moveDecimalPointRight(delta);
        return pretty;
      }
      /**
       * @deprecated Use`moveDecimalPointLeft`
       */
      increasePrecision(delta) {
        return this.moveDecimalPointLeft(delta);
      }
      /**
       * @deprecated Use`moveDecimalPointRight`
       */
      decreasePrecision(delta) {
        return this.moveDecimalPointRight(delta);
      }
      maxDecimals(max) {
        const pretty = this.clone();
        pretty.intPretty = pretty.intPretty.maxDecimals(max);
        return pretty;
      }
      inequalitySymbol(bool) {
        const pretty = this.clone();
        pretty.intPretty = pretty.intPretty.inequalitySymbol(bool);
        return pretty;
      }
      inequalitySymbolSeparator(str) {
        const pretty = this.clone();
        pretty.intPretty = pretty.intPretty.inequalitySymbolSeparator(str);
        return pretty;
      }
      trim(bool) {
        const pretty = this.clone();
        pretty.intPretty = pretty.intPretty.trim(bool);
        return pretty;
      }
      shrink(bool) {
        const pretty = this.clone();
        pretty.intPretty = pretty.intPretty.shrink(bool);
        return pretty;
      }
      locale(locale) {
        const pretty = this.clone();
        pretty.intPretty = pretty.intPretty.locale(locale);
        return pretty;
      }
      /**
       * Ready indicates the actual value is ready to show the users.
       * Even if the ready option is false, it expects that the value can be shown to users (probably as 0).
       * The method that returns prettied value may return `undefined` or `null` if the value is not ready.
       * But, alternatively, it can return the 0 value that can be shown the users anyway, but indicates that the value is not ready.
       * @param bool
       */
      ready(bool) {
        const pretty = this.clone();
        pretty.intPretty = pretty.intPretty.ready(bool);
        return pretty;
      }
      get isReady() {
        return this.intPretty.isReady;
      }
      add(target) {
        const isCoinPretty = target instanceof _CoinPretty;
        if (isCoinPretty) {
          if ("currency" in target && this.currency.coinMinimalDenom !== target.currency.coinMinimalDenom) {
            return this.clone();
          }
        }
        if ("toDec" in target) {
          target = target.toDec();
        }
        const pretty = this.clone();
        pretty.intPretty = pretty.intPretty.add(isCoinPretty ? target : target.mul(dec_utils_1.DecUtils.getTenExponentNInPrecisionRange(-this._currency.coinDecimals)));
        return pretty;
      }
      sub(target) {
        const isCoinPretty = target instanceof _CoinPretty;
        if (isCoinPretty) {
          if ("currency" in target && this.currency.coinMinimalDenom !== target.currency.coinMinimalDenom) {
            return this.clone();
          }
        }
        if ("toDec" in target) {
          target = target.toDec();
        }
        const pretty = this.clone();
        pretty.intPretty = pretty.intPretty.sub(isCoinPretty ? target : target.mul(dec_utils_1.DecUtils.getTenExponentNInPrecisionRange(-this._currency.coinDecimals)));
        return pretty;
      }
      mul(target) {
        const pretty = this.clone();
        pretty.intPretty = pretty.intPretty.mul(target);
        return pretty;
      }
      quo(target) {
        const pretty = this.clone();
        pretty.intPretty = pretty.intPretty.quo(target);
        return pretty;
      }
      toDec() {
        return this.intPretty.toDec();
      }
      toCoin() {
        const amount = this.toDec().mulTruncate(dec_utils_1.DecUtils.getTenExponentNInPrecisionRange(this.currency.coinDecimals)).truncate();
        return {
          denom: this.currency.coinMinimalDenom,
          amount: amount.toString()
        };
      }
      toString() {
        let denom = this.denom;
        if (this._options.hideIBCMetadata && "originCurrency" in this.currency && this.currency.originCurrency) {
          denom = this.currency.originCurrency.coinDenom;
        }
        if (this._options.upperCase) {
          denom = denom.toUpperCase();
        }
        if (this._options.lowerCase) {
          denom = denom.toLowerCase();
        }
        let separator = this._options.separator;
        if (this._options.hideDenom) {
          denom = "";
          separator = "";
        }
        return this.intPretty.toStringWithSymbols("", `${separator}${denom}`);
      }
      clone() {
        const pretty = new _CoinPretty(this._currency, 0);
        pretty._options = Object.assign({}, this._options);
        pretty.intPretty = this.intPretty.clone();
        return pretty;
      }
    };
    exports.CoinPretty = CoinPretty;
  }
});

// ../../node_modules/.pnpm/@keplr-wallet+unit@0.12.28/node_modules/@keplr-wallet/unit/build/price-pretty.js
var require_price_pretty = __commonJS({
  "../../node_modules/.pnpm/@keplr-wallet+unit@0.12.28/node_modules/@keplr-wallet/unit/build/price-pretty.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PricePretty = void 0;
    var int_pretty_1 = require_int_pretty();
    var dec_utils_1 = require_dec_utils();
    var PricePretty = class _PricePretty {
      constructor(_fiatCurrency, amount) {
        this._fiatCurrency = _fiatCurrency;
        this._options = {
          separator: "",
          upperCase: false,
          lowerCase: false,
          locale: "en-US"
        };
        this.intPretty = new int_pretty_1.IntPretty(amount).maxDecimals(_fiatCurrency.maxDecimals).shrink(true).trim(true).locale(false).inequalitySymbol(true);
        this._options.locale = _fiatCurrency.locale;
      }
      get options() {
        return Object.assign(Object.assign({}, this.intPretty.options), this._options);
      }
      get symbol() {
        return this._fiatCurrency.symbol;
      }
      get fiatCurrency() {
        return this._fiatCurrency;
      }
      separator(str) {
        const pretty = this.clone();
        pretty._options.separator = str;
        return pretty;
      }
      upperCase(bool) {
        const pretty = this.clone();
        pretty._options.upperCase = bool;
        pretty._options.lowerCase = !bool;
        return pretty;
      }
      lowerCase(bool) {
        const pretty = this.clone();
        pretty._options.lowerCase = bool;
        pretty._options.upperCase = !bool;
        return pretty;
      }
      moveDecimalPointLeft(delta) {
        const pretty = this.clone();
        pretty.intPretty = pretty.intPretty.moveDecimalPointLeft(delta);
        return pretty;
      }
      moveDecimalPointRight(delta) {
        const pretty = this.clone();
        pretty.intPretty = pretty.intPretty.moveDecimalPointRight(delta);
        return pretty;
      }
      /**
       * @deprecated Use`moveDecimalPointLeft`
       */
      increasePrecision(delta) {
        return this.moveDecimalPointLeft(delta);
      }
      /**
       * @deprecated Use`moveDecimalPointRight`
       */
      decreasePrecision(delta) {
        return this.moveDecimalPointRight(delta);
      }
      maxDecimals(max) {
        const pretty = this.clone();
        pretty.intPretty = pretty.intPretty.maxDecimals(max);
        return pretty;
      }
      inequalitySymbol(bool) {
        const pretty = this.clone();
        pretty.intPretty = pretty.intPretty.inequalitySymbol(bool);
        return pretty;
      }
      inequalitySymbolSeparator(str) {
        const pretty = this.clone();
        pretty.intPretty = pretty.intPretty.inequalitySymbolSeparator(str);
        return pretty;
      }
      trim(bool) {
        const pretty = this.clone();
        pretty.intPretty = pretty.intPretty.trim(bool);
        return pretty;
      }
      shrink(bool) {
        const pretty = this.clone();
        pretty.intPretty = pretty.intPretty.shrink(bool);
        return pretty;
      }
      locale(locale) {
        const pretty = this.clone();
        pretty._options.locale = locale;
        return pretty;
      }
      /**
       * Ready indicates the actual value is ready to show the users.
       * Even if the ready option is false, it expects that the value can be shown to users (probably as 0).
       * The method that returns prettied value may return `undefined` or `null` if the value is not ready.
       * But, alternatively, it can return the 0 value that can be shown the users anyway, but indicates that the value is not ready.
       * @param bool
       */
      ready(bool) {
        const pretty = this.clone();
        pretty.intPretty = pretty.intPretty.ready(bool);
        return pretty;
      }
      get isReady() {
        return this.intPretty.isReady;
      }
      add(target) {
        const pretty = this.clone();
        pretty.intPretty = pretty.intPretty.add(target);
        return pretty;
      }
      sub(target) {
        const pretty = this.clone();
        pretty.intPretty = pretty.intPretty.sub(target);
        return pretty;
      }
      mul(target) {
        const pretty = this.clone();
        pretty.intPretty = pretty.intPretty.mul(target);
        return pretty;
      }
      quo(target) {
        const pretty = this.clone();
        pretty.intPretty = pretty.intPretty.quo(target);
        return pretty;
      }
      toDec() {
        return this.intPretty.toDec();
      }
      toString() {
        let symbol = this.symbol;
        if (this._options.upperCase) {
          symbol = symbol.toUpperCase();
        }
        if (this._options.lowerCase) {
          symbol = symbol.toLowerCase();
        }
        const dec = this.toDec();
        const options = this.options;
        if (options.inequalitySymbol && !dec.isZero() && dec.abs().lt(dec_utils_1.DecUtils.getTenExponentN(-options.maxDecimals))) {
          return this.intPretty.toStringWithSymbols(`${symbol}${this._options.separator}`, "");
        }
        let localeString = parseFloat(this.intPretty.toString()).toLocaleString(options.locale, {
          maximumFractionDigits: options.maxDecimals
        });
        const isNeg = localeString.charAt(0) === "-";
        if (isNeg) {
          localeString = localeString.slice(1);
        }
        return `${isNeg ? "-" : ""}${symbol}${this._options.separator}${localeString}`;
      }
      clone() {
        const pretty = new _PricePretty(this._fiatCurrency, 0);
        pretty._options = Object.assign({}, this._options);
        pretty.intPretty = this.intPretty.clone();
        return pretty;
      }
    };
    exports.PricePretty = PricePretty;
  }
});

// ../../node_modules/.pnpm/@keplr-wallet+unit@0.12.28/node_modules/@keplr-wallet/unit/build/rate-pretty.js
var require_rate_pretty = __commonJS({
  "../../node_modules/.pnpm/@keplr-wallet+unit@0.12.28/node_modules/@keplr-wallet/unit/build/rate-pretty.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RatePretty = void 0;
    var int_pretty_1 = require_int_pretty();
    var RatePretty = class _RatePretty {
      constructor(amount) {
        this._options = {
          separator: "",
          symbol: "%"
        };
        this.intPretty = new int_pretty_1.IntPretty(amount);
        this.intPretty = this.intPretty.maxDecimals(3).shrink(false).trim(true).locale(true).inequalitySymbol(true);
      }
      get options() {
        return Object.assign(Object.assign({}, this.intPretty.options), this._options);
      }
      separator(str) {
        const pretty = this.clone();
        pretty._options.separator = str;
        return pretty;
      }
      symbol(str) {
        const pretty = this.clone();
        pretty._options.symbol = str;
        return pretty;
      }
      moveDecimalPointLeft(delta) {
        const pretty = this.clone();
        pretty.intPretty = pretty.intPretty.moveDecimalPointLeft(delta);
        return pretty;
      }
      moveDecimalPointRight(delta) {
        const pretty = this.clone();
        pretty.intPretty = pretty.intPretty.moveDecimalPointRight(delta);
        return pretty;
      }
      maxDecimals(max) {
        const pretty = this.clone();
        pretty.intPretty = pretty.intPretty.maxDecimals(max);
        return pretty;
      }
      inequalitySymbol(bool) {
        const pretty = this.clone();
        pretty.intPretty = pretty.intPretty.inequalitySymbol(bool);
        return pretty;
      }
      inequalitySymbolSeparator(str) {
        const pretty = this.clone();
        pretty.intPretty = pretty.intPretty.inequalitySymbolSeparator(str);
        return pretty;
      }
      trim(bool) {
        const pretty = this.clone();
        pretty.intPretty = pretty.intPretty.trim(bool);
        return pretty;
      }
      shrink(bool) {
        const pretty = this.clone();
        pretty.intPretty = pretty.intPretty.shrink(bool);
        return pretty;
      }
      locale(locale) {
        const pretty = this.clone();
        pretty.intPretty = pretty.intPretty.locale(locale);
        return pretty;
      }
      /**
       * Ready indicates the actual value is ready to show the users.
       * Even if the ready option is false, it expects that the value can be shown to users (probably as 0).
       * The method that returns prettied value may return `undefined` or `null` if the value is not ready.
       * But, alternatively, it can return the 0 value that can be shown the users anyway, but indicates that the value is not ready.
       * @param bool
       */
      ready(bool) {
        const pretty = this.clone();
        pretty.intPretty = pretty.intPretty.ready(bool);
        return pretty;
      }
      get isReady() {
        return this.intPretty.isReady;
      }
      add(target) {
        const pretty = this.clone();
        pretty.intPretty = pretty.intPretty.add(target);
        return pretty;
      }
      sub(target) {
        const pretty = this.clone();
        pretty.intPretty = pretty.intPretty.sub(target);
        return pretty;
      }
      mul(target) {
        const pretty = this.clone();
        pretty.intPretty = pretty.intPretty.mul(target);
        return pretty;
      }
      quo(target) {
        const pretty = this.clone();
        pretty.intPretty = pretty.intPretty.quo(target);
        return pretty;
      }
      toDec() {
        return this.intPretty.toDec();
      }
      toString() {
        return this.intPretty.moveDecimalPointRight(2).toStringWithSymbols("", `${this._options.separator}${this._options.symbol}`);
      }
      clone() {
        const pretty = new _RatePretty(0);
        pretty._options = Object.assign({}, this._options);
        pretty.intPretty = this.intPretty.clone();
        return pretty;
      }
    };
    exports.RatePretty = RatePretty;
  }
});

// ../../node_modules/.pnpm/@keplr-wallet+unit@0.12.28/node_modules/@keplr-wallet/unit/build/index.js
var require_build3 = __commonJS({
  "../../node_modules/.pnpm/@keplr-wallet+unit@0.12.28/node_modules/@keplr-wallet/unit/build/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o4, m3, k5, k22) {
      if (k22 === void 0)
        k22 = k5;
      var desc = Object.getOwnPropertyDescriptor(m3, k5);
      if (!desc || ("get" in desc ? !m3.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m3[k5];
        } };
      }
      Object.defineProperty(o4, k22, desc);
    } : function(o4, m3, k5, k22) {
      if (k22 === void 0)
        k22 = k5;
      o4[k22] = m3[k5];
    });
    var __exportStar = exports && exports.__exportStar || function(m3, exports2) {
      for (var p4 in m3)
        if (p4 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p4))
          __createBinding(exports2, m3, p4);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_int_pretty(), exports);
    __exportStar(require_coin_pretty(), exports);
    __exportStar(require_coin(), exports);
    __exportStar(require_int(), exports);
    __exportStar(require_decimal(), exports);
    __exportStar(require_coin_utils(), exports);
    __exportStar(require_dec_utils(), exports);
    __exportStar(require_price_pretty(), exports);
    __exportStar(require_rate_pretty(), exports);
  }
});

// ../../node_modules/.pnpm/@keplr-wallet+simple-fetch@0.12.28/node_modules/@keplr-wallet/simple-fetch/build/error.js
var require_error = __commonJS({
  "../../node_modules/.pnpm/@keplr-wallet+simple-fetch@0.12.28/node_modules/@keplr-wallet/simple-fetch/build/error.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isSimpleFetchError = exports.SimpleFetchError = void 0;
    var SimpleFetchError = class _SimpleFetchError extends Error {
      constructor(baseURL, url, response) {
        super(`Failed to get response from ${new URL(url, baseURL).toString()}`);
        this.baseURL = baseURL;
        this.url = url;
        this.response = response;
        Object.setPrototypeOf(this, _SimpleFetchError.prototype);
      }
    };
    exports.SimpleFetchError = SimpleFetchError;
    function isSimpleFetchError(payload) {
      return payload instanceof SimpleFetchError;
    }
    exports.isSimpleFetchError = isSimpleFetchError;
  }
});

// ../../node_modules/.pnpm/@keplr-wallet+simple-fetch@0.12.28/node_modules/@keplr-wallet/simple-fetch/build/fetch.js
var require_fetch = __commonJS({
  "../../node_modules/.pnpm/@keplr-wallet+simple-fetch@0.12.28/node_modules/@keplr-wallet/simple-fetch/build/fetch.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P3, generator) {
      function adopt(value) {
        return value instanceof P3 ? value : new P3(function(resolve) {
          resolve(value);
        });
      }
      return new (P3 || (P3 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e2) {
            reject(e2);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e2) {
            reject(e2);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __rest = exports && exports.__rest || function(s3, e2) {
      var t = {};
      for (var p4 in s3)
        if (Object.prototype.hasOwnProperty.call(s3, p4) && e2.indexOf(p4) < 0)
          t[p4] = s3[p4];
      if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i4 = 0, p4 = Object.getOwnPropertySymbols(s3); i4 < p4.length; i4++) {
          if (e2.indexOf(p4[i4]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p4[i4]))
            t[p4[i4]] = s3[p4[i4]];
        }
      return t;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.simpleFetch = exports.makeURL = void 0;
    var error_1 = require_error();
    function makeURL(baseURL, url) {
      const baseURLInstance = new URL(baseURL);
      baseURL = removeLastSlashIfIs(baseURLInstance.origin);
      url = removeLastSlashIfIs(baseURLInstance.pathname) + "/" + removeFirstSlashIfIs(url);
      return removeLastSlashIfIs(baseURL + "/" + removeFirstSlashIfIs(url));
    }
    exports.makeURL = makeURL;
    function removeFirstSlashIfIs(str) {
      if (str.length > 0 && str[0] === "/") {
        return str.slice(1);
      }
      return str;
    }
    function removeLastSlashIfIs(str) {
      if (str.length > 0 && str[str.length - 1] === "/") {
        return str.slice(0, str.length - 1);
      }
      return str;
    }
    function simpleFetch(baseURL, url, options) {
      return __awaiter(this, void 0, void 0, function* () {
        if (typeof url !== "string") {
          if (url) {
            options = url;
          }
          url = "";
        }
        if (url === "/") {
          url = "";
        }
        const actualURL = makeURL(baseURL, url);
        const _a2 = options || {}, { headers: optionHeaders } = _a2, otherOptions = __rest(_a2, ["headers"]);
        const fetched = yield fetch(actualURL, Object.assign({ headers: Object.assign({ accept: "application/json, text/plain, */*" }, optionHeaders) }, otherOptions));
        let data;
        const contentType = fetched.headers.get("content-type") || "";
        if (contentType.startsWith("application/json")) {
          data = yield fetched.json();
        } else {
          const r3 = yield fetched.text();
          const trim = r3.trim();
          if (trim.startsWith("{") && trim.endsWith("}")) {
            data = JSON.parse(trim);
          } else {
            data = r3;
          }
        }
        const res = {
          url: actualURL,
          data,
          headers: fetched.headers,
          status: fetched.status,
          statusText: fetched.statusText
        };
        const validateStatusFn = (options === null || options === void 0 ? void 0 : options.validateStatus) || defaultValidateStatusFn;
        if (!validateStatusFn(fetched.status)) {
          throw new error_1.SimpleFetchError(baseURL, url, res);
        }
        return res;
      });
    }
    exports.simpleFetch = simpleFetch;
    function defaultValidateStatusFn(status) {
      return status === 200;
    }
  }
});

// ../../node_modules/.pnpm/@keplr-wallet+simple-fetch@0.12.28/node_modules/@keplr-wallet/simple-fetch/build/types.js
var require_types = __commonJS({
  "../../node_modules/.pnpm/@keplr-wallet+simple-fetch@0.12.28/node_modules/@keplr-wallet/simple-fetch/build/types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// ../../node_modules/.pnpm/@keplr-wallet+simple-fetch@0.12.28/node_modules/@keplr-wallet/simple-fetch/build/index.js
var require_build4 = __commonJS({
  "../../node_modules/.pnpm/@keplr-wallet+simple-fetch@0.12.28/node_modules/@keplr-wallet/simple-fetch/build/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o4, m3, k5, k22) {
      if (k22 === void 0)
        k22 = k5;
      var desc = Object.getOwnPropertyDescriptor(m3, k5);
      if (!desc || ("get" in desc ? !m3.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m3[k5];
        } };
      }
      Object.defineProperty(o4, k22, desc);
    } : function(o4, m3, k5, k22) {
      if (k22 === void 0)
        k22 = k5;
      o4[k22] = m3[k5];
    });
    var __exportStar = exports && exports.__exportStar || function(m3, exports2) {
      for (var p4 in m3)
        if (p4 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p4))
          __createBinding(exports2, m3, p4);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_fetch(), exports);
    __exportStar(require_error(), exports);
    __exportStar(require_types(), exports);
  }
});

// ../../node_modules/.pnpm/@keplr-wallet+cosmos@0.12.28/node_modules/@keplr-wallet/cosmos/build/account/index.js
var require_account = __commonJS({
  "../../node_modules/.pnpm/@keplr-wallet+cosmos@0.12.28/node_modules/@keplr-wallet/cosmos/build/account/index.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P3, generator) {
      function adopt(value) {
        return value instanceof P3 ? value : new P3(function(resolve) {
          resolve(value);
        });
      }
      return new (P3 || (P3 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e2) {
            reject(e2);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e2) {
            reject(e2);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BaseAccount = void 0;
    var unit_1 = require_build3();
    var simple_fetch_1 = require_build4();
    var BaseAccount = class _BaseAccount {
      static fetchFromRest(rest, address, defaultBech32Address = false) {
        return __awaiter(this, void 0, void 0, function* () {
          const result = yield (0, simple_fetch_1.simpleFetch)(rest, `/cosmos/auth/v1beta1/accounts/${address}`, {
            validateStatus: function(status) {
              return status >= 200 && status < 300 || status === 404;
            }
          });
          return _BaseAccount.fromProtoJSON(result.data, defaultBech32Address ? address : "");
        });
      }
      static fromProtoJSON(obj, defaultBech32Address = "") {
        if (!obj.account) {
          if (!defaultBech32Address) {
            throw new Error(`Account's address is unknown: ${JSON.stringify(obj)}`);
          }
          return new _BaseAccount("", defaultBech32Address, new unit_1.Int(0), new unit_1.Int(0));
        }
        let value = obj.account;
        const type = value["@type"] || "";
        const baseAccount = value.BaseAccount || value.baseAccount || value.base_account;
        if (baseAccount) {
          value = baseAccount;
        }
        const embedAccount = value.account;
        if (embedAccount) {
          value = embedAccount;
        }
        const baseVestingAccount = value.BaseVestingAccount || value.baseVestingAccount || value.base_vesting_account;
        if (baseVestingAccount) {
          value = baseVestingAccount;
          const baseAccount2 = value.BaseAccount || value.baseAccount || value.base_account;
          if (baseAccount2) {
            value = baseAccount2;
          }
        }
        let address = value.address;
        if (!address) {
          if (!defaultBech32Address) {
            throw new Error(`Account's address is unknown: ${JSON.stringify(obj)}`);
          }
          address = defaultBech32Address;
        }
        const accountNumber = value.account_number;
        const sequence = value.sequence;
        return new _BaseAccount(type, address, new unit_1.Int(accountNumber || "0"), new unit_1.Int(sequence || "0"));
      }
      constructor(type, address, accountNumber, sequence) {
        this.type = type;
        this.address = address;
        this.accountNumber = accountNumber;
        this.sequence = sequence;
      }
      getType() {
        return this.type;
      }
      getAddress() {
        return this.address;
      }
      getAccountNumber() {
        return this.accountNumber;
      }
      getSequence() {
        return this.sequence;
      }
    };
    exports.BaseAccount = BaseAccount;
  }
});

// ../../node_modules/.pnpm/@ethersproject+logger@5.8.0/node_modules/@ethersproject/logger/lib.esm/_version.js
var version;
var init_version = __esm({
  "../../node_modules/.pnpm/@ethersproject+logger@5.8.0/node_modules/@ethersproject/logger/lib.esm/_version.js"() {
    version = "logger/5.8.0";
  }
});

// ../../node_modules/.pnpm/@ethersproject+logger@5.8.0/node_modules/@ethersproject/logger/lib.esm/index.js
function _checkNormalize() {
  try {
    const missing = [];
    ["NFD", "NFC", "NFKD", "NFKC"].forEach((form) => {
      try {
        if ("test".normalize(form) !== "test") {
          throw new Error("bad normalize");
        }
        ;
      } catch (error) {
        missing.push(form);
      }
    });
    if (missing.length) {
      throw new Error("missing " + missing.join(", "));
    }
    if (String.fromCharCode(233).normalize("NFD") !== String.fromCharCode(101, 769)) {
      throw new Error("broken implementation");
    }
  } catch (error) {
    return error.message;
  }
  return null;
}
var _permanentCensorErrors, _censorErrors, LogLevels, _logLevel, _globalLogger, _normalizeError, LogLevel, ErrorCode, HEX, Logger;
var init_lib = __esm({
  "../../node_modules/.pnpm/@ethersproject+logger@5.8.0/node_modules/@ethersproject/logger/lib.esm/index.js"() {
    "use strict";
    init_version();
    _permanentCensorErrors = false;
    _censorErrors = false;
    LogLevels = { debug: 1, "default": 2, info: 2, warning: 3, error: 4, off: 5 };
    _logLevel = LogLevels["default"];
    _globalLogger = null;
    _normalizeError = _checkNormalize();
    (function(LogLevel2) {
      LogLevel2["DEBUG"] = "DEBUG";
      LogLevel2["INFO"] = "INFO";
      LogLevel2["WARNING"] = "WARNING";
      LogLevel2["ERROR"] = "ERROR";
      LogLevel2["OFF"] = "OFF";
    })(LogLevel || (LogLevel = {}));
    (function(ErrorCode2) {
      ErrorCode2["UNKNOWN_ERROR"] = "UNKNOWN_ERROR";
      ErrorCode2["NOT_IMPLEMENTED"] = "NOT_IMPLEMENTED";
      ErrorCode2["UNSUPPORTED_OPERATION"] = "UNSUPPORTED_OPERATION";
      ErrorCode2["NETWORK_ERROR"] = "NETWORK_ERROR";
      ErrorCode2["SERVER_ERROR"] = "SERVER_ERROR";
      ErrorCode2["TIMEOUT"] = "TIMEOUT";
      ErrorCode2["BUFFER_OVERRUN"] = "BUFFER_OVERRUN";
      ErrorCode2["NUMERIC_FAULT"] = "NUMERIC_FAULT";
      ErrorCode2["MISSING_NEW"] = "MISSING_NEW";
      ErrorCode2["INVALID_ARGUMENT"] = "INVALID_ARGUMENT";
      ErrorCode2["MISSING_ARGUMENT"] = "MISSING_ARGUMENT";
      ErrorCode2["UNEXPECTED_ARGUMENT"] = "UNEXPECTED_ARGUMENT";
      ErrorCode2["CALL_EXCEPTION"] = "CALL_EXCEPTION";
      ErrorCode2["INSUFFICIENT_FUNDS"] = "INSUFFICIENT_FUNDS";
      ErrorCode2["NONCE_EXPIRED"] = "NONCE_EXPIRED";
      ErrorCode2["REPLACEMENT_UNDERPRICED"] = "REPLACEMENT_UNDERPRICED";
      ErrorCode2["UNPREDICTABLE_GAS_LIMIT"] = "UNPREDICTABLE_GAS_LIMIT";
      ErrorCode2["TRANSACTION_REPLACED"] = "TRANSACTION_REPLACED";
      ErrorCode2["ACTION_REJECTED"] = "ACTION_REJECTED";
    })(ErrorCode || (ErrorCode = {}));
    HEX = "0123456789abcdef";
    Logger = class _Logger {
      constructor(version6) {
        Object.defineProperty(this, "version", {
          enumerable: true,
          value: version6,
          writable: false
        });
      }
      _log(logLevel, args) {
        const level = logLevel.toLowerCase();
        if (LogLevels[level] == null) {
          this.throwArgumentError("invalid log level name", "logLevel", logLevel);
        }
        if (_logLevel > LogLevels[level]) {
          return;
        }
        console.log.apply(console, args);
      }
      debug(...args) {
        this._log(_Logger.levels.DEBUG, args);
      }
      info(...args) {
        this._log(_Logger.levels.INFO, args);
      }
      warn(...args) {
        this._log(_Logger.levels.WARNING, args);
      }
      makeError(message, code, params) {
        if (_censorErrors) {
          return this.makeError("censored error", code, {});
        }
        if (!code) {
          code = _Logger.errors.UNKNOWN_ERROR;
        }
        if (!params) {
          params = {};
        }
        const messageDetails = [];
        Object.keys(params).forEach((key) => {
          const value = params[key];
          try {
            if (value instanceof Uint8Array) {
              let hex = "";
              for (let i4 = 0; i4 < value.length; i4++) {
                hex += HEX[value[i4] >> 4];
                hex += HEX[value[i4] & 15];
              }
              messageDetails.push(key + "=Uint8Array(0x" + hex + ")");
            } else {
              messageDetails.push(key + "=" + JSON.stringify(value));
            }
          } catch (error2) {
            messageDetails.push(key + "=" + JSON.stringify(params[key].toString()));
          }
        });
        messageDetails.push(`code=${code}`);
        messageDetails.push(`version=${this.version}`);
        const reason = message;
        let url = "";
        switch (code) {
          case ErrorCode.NUMERIC_FAULT: {
            url = "NUMERIC_FAULT";
            const fault = message;
            switch (fault) {
              case "overflow":
              case "underflow":
              case "division-by-zero":
                url += "-" + fault;
                break;
              case "negative-power":
              case "negative-width":
                url += "-unsupported";
                break;
              case "unbound-bitwise-result":
                url += "-unbound-result";
                break;
            }
            break;
          }
          case ErrorCode.CALL_EXCEPTION:
          case ErrorCode.INSUFFICIENT_FUNDS:
          case ErrorCode.MISSING_NEW:
          case ErrorCode.NONCE_EXPIRED:
          case ErrorCode.REPLACEMENT_UNDERPRICED:
          case ErrorCode.TRANSACTION_REPLACED:
          case ErrorCode.UNPREDICTABLE_GAS_LIMIT:
            url = code;
            break;
        }
        if (url) {
          message += " [ See: https://links.ethers.org/v5-errors-" + url + " ]";
        }
        if (messageDetails.length) {
          message += " (" + messageDetails.join(", ") + ")";
        }
        const error = new Error(message);
        error.reason = reason;
        error.code = code;
        Object.keys(params).forEach(function(key) {
          error[key] = params[key];
        });
        return error;
      }
      throwError(message, code, params) {
        throw this.makeError(message, code, params);
      }
      throwArgumentError(message, name, value) {
        return this.throwError(message, _Logger.errors.INVALID_ARGUMENT, {
          argument: name,
          value
        });
      }
      assert(condition, message, code, params) {
        if (!!condition) {
          return;
        }
        this.throwError(message, code, params);
      }
      assertArgument(condition, message, name, value) {
        if (!!condition) {
          return;
        }
        this.throwArgumentError(message, name, value);
      }
      checkNormalize(message) {
        if (message == null) {
          message = "platform missing String.prototype.normalize";
        }
        if (_normalizeError) {
          this.throwError("platform missing String.prototype.normalize", _Logger.errors.UNSUPPORTED_OPERATION, {
            operation: "String.prototype.normalize",
            form: _normalizeError
          });
        }
      }
      checkSafeUint53(value, message) {
        if (typeof value !== "number") {
          return;
        }
        if (message == null) {
          message = "value not safe";
        }
        if (value < 0 || value >= 9007199254740991) {
          this.throwError(message, _Logger.errors.NUMERIC_FAULT, {
            operation: "checkSafeInteger",
            fault: "out-of-safe-range",
            value
          });
        }
        if (value % 1) {
          this.throwError(message, _Logger.errors.NUMERIC_FAULT, {
            operation: "checkSafeInteger",
            fault: "non-integer",
            value
          });
        }
      }
      checkArgumentCount(count, expectedCount, message) {
        if (message) {
          message = ": " + message;
        } else {
          message = "";
        }
        if (count < expectedCount) {
          this.throwError("missing argument" + message, _Logger.errors.MISSING_ARGUMENT, {
            count,
            expectedCount
          });
        }
        if (count > expectedCount) {
          this.throwError("too many arguments" + message, _Logger.errors.UNEXPECTED_ARGUMENT, {
            count,
            expectedCount
          });
        }
      }
      checkNew(target, kind) {
        if (target === Object || target == null) {
          this.throwError("missing new", _Logger.errors.MISSING_NEW, { name: kind.name });
        }
      }
      checkAbstract(target, kind) {
        if (target === kind) {
          this.throwError("cannot instantiate abstract class " + JSON.stringify(kind.name) + " directly; use a sub-class", _Logger.errors.UNSUPPORTED_OPERATION, { name: target.name, operation: "new" });
        } else if (target === Object || target == null) {
          this.throwError("missing new", _Logger.errors.MISSING_NEW, { name: kind.name });
        }
      }
      static globalLogger() {
        if (!_globalLogger) {
          _globalLogger = new _Logger(version);
        }
        return _globalLogger;
      }
      static setCensorship(censorship, permanent) {
        if (!censorship && permanent) {
          this.globalLogger().throwError("cannot permanently disable censorship", _Logger.errors.UNSUPPORTED_OPERATION, {
            operation: "setCensorship"
          });
        }
        if (_permanentCensorErrors) {
          if (!censorship) {
            return;
          }
          this.globalLogger().throwError("error censorship permanent", _Logger.errors.UNSUPPORTED_OPERATION, {
            operation: "setCensorship"
          });
        }
        _censorErrors = !!censorship;
        _permanentCensorErrors = !!permanent;
      }
      static setLogLevel(logLevel) {
        const level = LogLevels[logLevel.toLowerCase()];
        if (level == null) {
          _Logger.globalLogger().warn("invalid log level - " + logLevel);
          return;
        }
        _logLevel = level;
      }
      static from(version6) {
        return new _Logger(version6);
      }
    };
    Logger.errors = ErrorCode;
    Logger.levels = LogLevel;
  }
});

// ../../node_modules/.pnpm/@ethersproject+bytes@5.8.0/node_modules/@ethersproject/bytes/lib.esm/_version.js
var version2;
var init_version2 = __esm({
  "../../node_modules/.pnpm/@ethersproject+bytes@5.8.0/node_modules/@ethersproject/bytes/lib.esm/_version.js"() {
    version2 = "bytes/5.8.0";
  }
});

// ../../node_modules/.pnpm/@ethersproject+bytes@5.8.0/node_modules/@ethersproject/bytes/lib.esm/index.js
function isHexable(value) {
  return !!value.toHexString;
}
function addSlice(array2) {
  if (array2.slice) {
    return array2;
  }
  array2.slice = function() {
    const args = Array.prototype.slice.call(arguments);
    return addSlice(new Uint8Array(Array.prototype.slice.apply(array2, args)));
  };
  return array2;
}
function isBytesLike(value) {
  return isHexString(value) && !(value.length % 2) || isBytes(value);
}
function isInteger(value) {
  return typeof value === "number" && value == value && value % 1 === 0;
}
function isBytes(value) {
  if (value == null) {
    return false;
  }
  if (value.constructor === Uint8Array) {
    return true;
  }
  if (typeof value === "string") {
    return false;
  }
  if (!isInteger(value.length) || value.length < 0) {
    return false;
  }
  for (let i4 = 0; i4 < value.length; i4++) {
    const v5 = value[i4];
    if (!isInteger(v5) || v5 < 0 || v5 >= 256) {
      return false;
    }
  }
  return true;
}
function arrayify(value, options) {
  if (!options) {
    options = {};
  }
  if (typeof value === "number") {
    logger.checkSafeUint53(value, "invalid arrayify value");
    const result = [];
    while (value) {
      result.unshift(value & 255);
      value = parseInt(String(value / 256));
    }
    if (result.length === 0) {
      result.push(0);
    }
    return addSlice(new Uint8Array(result));
  }
  if (options.allowMissingPrefix && typeof value === "string" && value.substring(0, 2) !== "0x") {
    value = "0x" + value;
  }
  if (isHexable(value)) {
    value = value.toHexString();
  }
  if (isHexString(value)) {
    let hex = value.substring(2);
    if (hex.length % 2) {
      if (options.hexPad === "left") {
        hex = "0" + hex;
      } else if (options.hexPad === "right") {
        hex += "0";
      } else {
        logger.throwArgumentError("hex data is odd-length", "value", value);
      }
    }
    const result = [];
    for (let i4 = 0; i4 < hex.length; i4 += 2) {
      result.push(parseInt(hex.substring(i4, i4 + 2), 16));
    }
    return addSlice(new Uint8Array(result));
  }
  if (isBytes(value)) {
    return addSlice(new Uint8Array(value));
  }
  return logger.throwArgumentError("invalid arrayify value", "value", value);
}
function concat(items) {
  const objects = items.map((item) => arrayify(item));
  const length = objects.reduce((accum, item) => accum + item.length, 0);
  const result = new Uint8Array(length);
  objects.reduce((offset, object2) => {
    result.set(object2, offset);
    return offset + object2.length;
  }, 0);
  return addSlice(result);
}
function stripZeros(value) {
  let result = arrayify(value);
  if (result.length === 0) {
    return result;
  }
  let start = 0;
  while (start < result.length && result[start] === 0) {
    start++;
  }
  if (start) {
    result = result.slice(start);
  }
  return result;
}
function isHexString(value, length) {
  if (typeof value !== "string" || !value.match(/^0x[0-9A-Fa-f]*$/)) {
    return false;
  }
  if (length && value.length !== 2 + 2 * length) {
    return false;
  }
  return true;
}
function hexlify(value, options) {
  if (!options) {
    options = {};
  }
  if (typeof value === "number") {
    logger.checkSafeUint53(value, "invalid hexlify value");
    let hex = "";
    while (value) {
      hex = HexCharacters[value & 15] + hex;
      value = Math.floor(value / 16);
    }
    if (hex.length) {
      if (hex.length % 2) {
        hex = "0" + hex;
      }
      return "0x" + hex;
    }
    return "0x00";
  }
  if (typeof value === "bigint") {
    value = value.toString(16);
    if (value.length % 2) {
      return "0x0" + value;
    }
    return "0x" + value;
  }
  if (options.allowMissingPrefix && typeof value === "string" && value.substring(0, 2) !== "0x") {
    value = "0x" + value;
  }
  if (isHexable(value)) {
    return value.toHexString();
  }
  if (isHexString(value)) {
    if (value.length % 2) {
      if (options.hexPad === "left") {
        value = "0x0" + value.substring(2);
      } else if (options.hexPad === "right") {
        value += "0";
      } else {
        logger.throwArgumentError("hex data is odd-length", "value", value);
      }
    }
    return value.toLowerCase();
  }
  if (isBytes(value)) {
    let result = "0x";
    for (let i4 = 0; i4 < value.length; i4++) {
      let v5 = value[i4];
      result += HexCharacters[(v5 & 240) >> 4] + HexCharacters[v5 & 15];
    }
    return result;
  }
  return logger.throwArgumentError("invalid hexlify value", "value", value);
}
function hexDataLength(data) {
  if (typeof data !== "string") {
    data = hexlify(data);
  } else if (!isHexString(data) || data.length % 2) {
    return null;
  }
  return (data.length - 2) / 2;
}
function hexDataSlice(data, offset, endOffset) {
  if (typeof data !== "string") {
    data = hexlify(data);
  } else if (!isHexString(data) || data.length % 2) {
    logger.throwArgumentError("invalid hexData", "value", data);
  }
  offset = 2 + 2 * offset;
  if (endOffset != null) {
    return "0x" + data.substring(offset, 2 + 2 * endOffset);
  }
  return "0x" + data.substring(offset);
}
function hexZeroPad(value, length) {
  if (typeof value !== "string") {
    value = hexlify(value);
  } else if (!isHexString(value)) {
    logger.throwArgumentError("invalid hex string", "value", value);
  }
  if (value.length > 2 * length + 2) {
    logger.throwArgumentError("value out of range", "value", arguments[1]);
  }
  while (value.length < 2 * length + 2) {
    value = "0x0" + value.substring(2);
  }
  return value;
}
var logger, HexCharacters;
var init_lib2 = __esm({
  "../../node_modules/.pnpm/@ethersproject+bytes@5.8.0/node_modules/@ethersproject/bytes/lib.esm/index.js"() {
    "use strict";
    init_lib();
    init_version2();
    logger = new Logger(version2);
    HexCharacters = "0123456789abcdef";
  }
});

// ../../node_modules/.pnpm/@ethersproject+bignumber@5.8.0/node_modules/@ethersproject/bignumber/lib.esm/_version.js
var version3;
var init_version3 = __esm({
  "../../node_modules/.pnpm/@ethersproject+bignumber@5.8.0/node_modules/@ethersproject/bignumber/lib.esm/_version.js"() {
    version3 = "bignumber/5.8.0";
  }
});

// ../../node_modules/.pnpm/@ethersproject+bignumber@5.8.0/node_modules/@ethersproject/bignumber/lib.esm/bignumber.js
function isBigNumberish(value) {
  return value != null && (BigNumber.isBigNumber(value) || typeof value === "number" && value % 1 === 0 || typeof value === "string" && !!value.match(/^-?[0-9]+$/) || isHexString(value) || typeof value === "bigint" || isBytes(value));
}
function toHex(value) {
  if (typeof value !== "string") {
    return toHex(value.toString(16));
  }
  if (value[0] === "-") {
    value = value.substring(1);
    if (value[0] === "-") {
      logger2.throwArgumentError("invalid hex", "value", value);
    }
    value = toHex(value);
    if (value === "0x00") {
      return value;
    }
    return "-" + value;
  }
  if (value.substring(0, 2) !== "0x") {
    value = "0x" + value;
  }
  if (value === "0x") {
    return "0x00";
  }
  if (value.length % 2) {
    value = "0x0" + value.substring(2);
  }
  while (value.length > 4 && value.substring(0, 4) === "0x00") {
    value = "0x" + value.substring(4);
  }
  return value;
}
function toBigNumber(value) {
  return BigNumber.from(toHex(value));
}
function toBN(value) {
  const hex = BigNumber.from(value).toHexString();
  if (hex[0] === "-") {
    return new BN("-" + hex.substring(3), 16);
  }
  return new BN(hex.substring(2), 16);
}
function throwFault(fault, operation, value) {
  const params = { fault, operation };
  if (value != null) {
    params.value = value;
  }
  return logger2.throwError(fault, Logger.errors.NUMERIC_FAULT, params);
}
function _base36To16(value) {
  return new BN(value, 36).toString(16);
}
function _base16To36(value) {
  return new BN(value, 16).toString(36);
}
var import_bn, BN, logger2, _constructorGuard, MAX_SAFE, _warnedToStringRadix, BigNumber;
var init_bignumber = __esm({
  "../../node_modules/.pnpm/@ethersproject+bignumber@5.8.0/node_modules/@ethersproject/bignumber/lib.esm/bignumber.js"() {
    "use strict";
    import_bn = __toESM(require_bn());
    init_lib2();
    init_lib();
    init_version3();
    BN = import_bn.default.BN;
    logger2 = new Logger(version3);
    _constructorGuard = {};
    MAX_SAFE = 9007199254740991;
    _warnedToStringRadix = false;
    BigNumber = class _BigNumber {
      constructor(constructorGuard, hex) {
        if (constructorGuard !== _constructorGuard) {
          logger2.throwError("cannot call constructor directly; use BigNumber.from", Logger.errors.UNSUPPORTED_OPERATION, {
            operation: "new (BigNumber)"
          });
        }
        this._hex = hex;
        this._isBigNumber = true;
        Object.freeze(this);
      }
      fromTwos(value) {
        return toBigNumber(toBN(this).fromTwos(value));
      }
      toTwos(value) {
        return toBigNumber(toBN(this).toTwos(value));
      }
      abs() {
        if (this._hex[0] === "-") {
          return _BigNumber.from(this._hex.substring(1));
        }
        return this;
      }
      add(other) {
        return toBigNumber(toBN(this).add(toBN(other)));
      }
      sub(other) {
        return toBigNumber(toBN(this).sub(toBN(other)));
      }
      div(other) {
        const o4 = _BigNumber.from(other);
        if (o4.isZero()) {
          throwFault("division-by-zero", "div");
        }
        return toBigNumber(toBN(this).div(toBN(other)));
      }
      mul(other) {
        return toBigNumber(toBN(this).mul(toBN(other)));
      }
      mod(other) {
        const value = toBN(other);
        if (value.isNeg()) {
          throwFault("division-by-zero", "mod");
        }
        return toBigNumber(toBN(this).umod(value));
      }
      pow(other) {
        const value = toBN(other);
        if (value.isNeg()) {
          throwFault("negative-power", "pow");
        }
        return toBigNumber(toBN(this).pow(value));
      }
      and(other) {
        const value = toBN(other);
        if (this.isNegative() || value.isNeg()) {
          throwFault("unbound-bitwise-result", "and");
        }
        return toBigNumber(toBN(this).and(value));
      }
      or(other) {
        const value = toBN(other);
        if (this.isNegative() || value.isNeg()) {
          throwFault("unbound-bitwise-result", "or");
        }
        return toBigNumber(toBN(this).or(value));
      }
      xor(other) {
        const value = toBN(other);
        if (this.isNegative() || value.isNeg()) {
          throwFault("unbound-bitwise-result", "xor");
        }
        return toBigNumber(toBN(this).xor(value));
      }
      mask(value) {
        if (this.isNegative() || value < 0) {
          throwFault("negative-width", "mask");
        }
        return toBigNumber(toBN(this).maskn(value));
      }
      shl(value) {
        if (this.isNegative() || value < 0) {
          throwFault("negative-width", "shl");
        }
        return toBigNumber(toBN(this).shln(value));
      }
      shr(value) {
        if (this.isNegative() || value < 0) {
          throwFault("negative-width", "shr");
        }
        return toBigNumber(toBN(this).shrn(value));
      }
      eq(other) {
        return toBN(this).eq(toBN(other));
      }
      lt(other) {
        return toBN(this).lt(toBN(other));
      }
      lte(other) {
        return toBN(this).lte(toBN(other));
      }
      gt(other) {
        return toBN(this).gt(toBN(other));
      }
      gte(other) {
        return toBN(this).gte(toBN(other));
      }
      isNegative() {
        return this._hex[0] === "-";
      }
      isZero() {
        return toBN(this).isZero();
      }
      toNumber() {
        try {
          return toBN(this).toNumber();
        } catch (error) {
          throwFault("overflow", "toNumber", this.toString());
        }
        return null;
      }
      toBigInt() {
        try {
          return BigInt(this.toString());
        } catch (e2) {
        }
        return logger2.throwError("this platform does not support BigInt", Logger.errors.UNSUPPORTED_OPERATION, {
          value: this.toString()
        });
      }
      toString() {
        if (arguments.length > 0) {
          if (arguments[0] === 10) {
            if (!_warnedToStringRadix) {
              _warnedToStringRadix = true;
              logger2.warn("BigNumber.toString does not accept any parameters; base-10 is assumed");
            }
          } else if (arguments[0] === 16) {
            logger2.throwError("BigNumber.toString does not accept any parameters; use bigNumber.toHexString()", Logger.errors.UNEXPECTED_ARGUMENT, {});
          } else {
            logger2.throwError("BigNumber.toString does not accept parameters", Logger.errors.UNEXPECTED_ARGUMENT, {});
          }
        }
        return toBN(this).toString(10);
      }
      toHexString() {
        return this._hex;
      }
      toJSON(key) {
        return { type: "BigNumber", hex: this.toHexString() };
      }
      static from(value) {
        if (value instanceof _BigNumber) {
          return value;
        }
        if (typeof value === "string") {
          if (value.match(/^-?0x[0-9a-f]+$/i)) {
            return new _BigNumber(_constructorGuard, toHex(value));
          }
          if (value.match(/^-?[0-9]+$/)) {
            return new _BigNumber(_constructorGuard, toHex(new BN(value)));
          }
          return logger2.throwArgumentError("invalid BigNumber string", "value", value);
        }
        if (typeof value === "number") {
          if (value % 1) {
            throwFault("underflow", "BigNumber.from", value);
          }
          if (value >= MAX_SAFE || value <= -MAX_SAFE) {
            throwFault("overflow", "BigNumber.from", value);
          }
          return _BigNumber.from(String(value));
        }
        const anyValue = value;
        if (typeof anyValue === "bigint") {
          return _BigNumber.from(anyValue.toString());
        }
        if (isBytes(anyValue)) {
          return _BigNumber.from(hexlify(anyValue));
        }
        if (anyValue) {
          if (anyValue.toHexString) {
            const hex = anyValue.toHexString();
            if (typeof hex === "string") {
              return _BigNumber.from(hex);
            }
          } else {
            let hex = anyValue._hex;
            if (hex == null && anyValue.type === "BigNumber") {
              hex = anyValue.hex;
            }
            if (typeof hex === "string") {
              if (isHexString(hex) || hex[0] === "-" && isHexString(hex.substring(1))) {
                return _BigNumber.from(hex);
              }
            }
          }
        }
        return logger2.throwArgumentError("invalid BigNumber value", "value", value);
      }
      static isBigNumber(value) {
        return !!(value && value._isBigNumber);
      }
    };
  }
});

// ../../node_modules/.pnpm/@ethersproject+bignumber@5.8.0/node_modules/@ethersproject/bignumber/lib.esm/fixednumber.js
function throwFault2(message, fault, operation, value) {
  const params = { fault, operation };
  if (value !== void 0) {
    params.value = value;
  }
  return logger3.throwError(message, Logger.errors.NUMERIC_FAULT, params);
}
function getMultiplier(decimals) {
  if (typeof decimals !== "number") {
    try {
      decimals = BigNumber.from(decimals).toNumber();
    } catch (e2) {
    }
  }
  if (typeof decimals === "number" && decimals >= 0 && decimals <= 256 && !(decimals % 1)) {
    return "1" + zeros.substring(0, decimals);
  }
  return logger3.throwArgumentError("invalid decimal size", "decimals", decimals);
}
function formatFixed(value, decimals) {
  if (decimals == null) {
    decimals = 0;
  }
  const multiplier = getMultiplier(decimals);
  value = BigNumber.from(value);
  const negative = value.lt(Zero);
  if (negative) {
    value = value.mul(NegativeOne);
  }
  let fraction = value.mod(multiplier).toString();
  while (fraction.length < multiplier.length - 1) {
    fraction = "0" + fraction;
  }
  fraction = fraction.match(/^([0-9]*[1-9]|0)(0*)/)[1];
  const whole = value.div(multiplier).toString();
  if (multiplier.length === 1) {
    value = whole;
  } else {
    value = whole + "." + fraction;
  }
  if (negative) {
    value = "-" + value;
  }
  return value;
}
function parseFixed(value, decimals) {
  if (decimals == null) {
    decimals = 0;
  }
  const multiplier = getMultiplier(decimals);
  if (typeof value !== "string" || !value.match(/^-?[0-9.]+$/)) {
    logger3.throwArgumentError("invalid decimal value", "value", value);
  }
  const negative = value.substring(0, 1) === "-";
  if (negative) {
    value = value.substring(1);
  }
  if (value === ".") {
    logger3.throwArgumentError("missing value", "value", value);
  }
  const comps = value.split(".");
  if (comps.length > 2) {
    logger3.throwArgumentError("too many decimal points", "value", value);
  }
  let whole = comps[0], fraction = comps[1];
  if (!whole) {
    whole = "0";
  }
  if (!fraction) {
    fraction = "0";
  }
  while (fraction[fraction.length - 1] === "0") {
    fraction = fraction.substring(0, fraction.length - 1);
  }
  if (fraction.length > multiplier.length - 1) {
    throwFault2("fractional component exceeds decimals", "underflow", "parseFixed");
  }
  if (fraction === "") {
    fraction = "0";
  }
  while (fraction.length < multiplier.length - 1) {
    fraction += "0";
  }
  const wholeValue = BigNumber.from(whole);
  const fractionValue = BigNumber.from(fraction);
  let wei = wholeValue.mul(multiplier).add(fractionValue);
  if (negative) {
    wei = wei.mul(NegativeOne);
  }
  return wei;
}
var logger3, _constructorGuard2, Zero, NegativeOne, zeros, FixedFormat, FixedNumber, ONE, BUMP;
var init_fixednumber = __esm({
  "../../node_modules/.pnpm/@ethersproject+bignumber@5.8.0/node_modules/@ethersproject/bignumber/lib.esm/fixednumber.js"() {
    "use strict";
    init_lib2();
    init_lib();
    init_version3();
    init_bignumber();
    logger3 = new Logger(version3);
    _constructorGuard2 = {};
    Zero = BigNumber.from(0);
    NegativeOne = BigNumber.from(-1);
    zeros = "0";
    while (zeros.length < 256) {
      zeros += zeros;
    }
    FixedFormat = class _FixedFormat {
      constructor(constructorGuard, signed, width, decimals) {
        if (constructorGuard !== _constructorGuard2) {
          logger3.throwError("cannot use FixedFormat constructor; use FixedFormat.from", Logger.errors.UNSUPPORTED_OPERATION, {
            operation: "new FixedFormat"
          });
        }
        this.signed = signed;
        this.width = width;
        this.decimals = decimals;
        this.name = (signed ? "" : "u") + "fixed" + String(width) + "x" + String(decimals);
        this._multiplier = getMultiplier(decimals);
        Object.freeze(this);
      }
      static from(value) {
        if (value instanceof _FixedFormat) {
          return value;
        }
        if (typeof value === "number") {
          value = `fixed128x${value}`;
        }
        let signed = true;
        let width = 128;
        let decimals = 18;
        if (typeof value === "string") {
          if (value === "fixed") {
          } else if (value === "ufixed") {
            signed = false;
          } else {
            const match = value.match(/^(u?)fixed([0-9]+)x([0-9]+)$/);
            if (!match) {
              logger3.throwArgumentError("invalid fixed format", "format", value);
            }
            signed = match[1] !== "u";
            width = parseInt(match[2]);
            decimals = parseInt(match[3]);
          }
        } else if (value) {
          const check = (key, type, defaultValue) => {
            if (value[key] == null) {
              return defaultValue;
            }
            if (typeof value[key] !== type) {
              logger3.throwArgumentError("invalid fixed format (" + key + " not " + type + ")", "format." + key, value[key]);
            }
            return value[key];
          };
          signed = check("signed", "boolean", signed);
          width = check("width", "number", width);
          decimals = check("decimals", "number", decimals);
        }
        if (width % 8) {
          logger3.throwArgumentError("invalid fixed format width (not byte aligned)", "format.width", width);
        }
        if (decimals > 80) {
          logger3.throwArgumentError("invalid fixed format (decimals too large)", "format.decimals", decimals);
        }
        return new _FixedFormat(_constructorGuard2, signed, width, decimals);
      }
    };
    FixedNumber = class _FixedNumber {
      constructor(constructorGuard, hex, value, format) {
        if (constructorGuard !== _constructorGuard2) {
          logger3.throwError("cannot use FixedNumber constructor; use FixedNumber.from", Logger.errors.UNSUPPORTED_OPERATION, {
            operation: "new FixedFormat"
          });
        }
        this.format = format;
        this._hex = hex;
        this._value = value;
        this._isFixedNumber = true;
        Object.freeze(this);
      }
      _checkFormat(other) {
        if (this.format.name !== other.format.name) {
          logger3.throwArgumentError("incompatible format; use fixedNumber.toFormat", "other", other);
        }
      }
      addUnsafe(other) {
        this._checkFormat(other);
        const a3 = parseFixed(this._value, this.format.decimals);
        const b4 = parseFixed(other._value, other.format.decimals);
        return _FixedNumber.fromValue(a3.add(b4), this.format.decimals, this.format);
      }
      subUnsafe(other) {
        this._checkFormat(other);
        const a3 = parseFixed(this._value, this.format.decimals);
        const b4 = parseFixed(other._value, other.format.decimals);
        return _FixedNumber.fromValue(a3.sub(b4), this.format.decimals, this.format);
      }
      mulUnsafe(other) {
        this._checkFormat(other);
        const a3 = parseFixed(this._value, this.format.decimals);
        const b4 = parseFixed(other._value, other.format.decimals);
        return _FixedNumber.fromValue(a3.mul(b4).div(this.format._multiplier), this.format.decimals, this.format);
      }
      divUnsafe(other) {
        this._checkFormat(other);
        const a3 = parseFixed(this._value, this.format.decimals);
        const b4 = parseFixed(other._value, other.format.decimals);
        return _FixedNumber.fromValue(a3.mul(this.format._multiplier).div(b4), this.format.decimals, this.format);
      }
      floor() {
        const comps = this.toString().split(".");
        if (comps.length === 1) {
          comps.push("0");
        }
        let result = _FixedNumber.from(comps[0], this.format);
        const hasFraction = !comps[1].match(/^(0*)$/);
        if (this.isNegative() && hasFraction) {
          result = result.subUnsafe(ONE.toFormat(result.format));
        }
        return result;
      }
      ceiling() {
        const comps = this.toString().split(".");
        if (comps.length === 1) {
          comps.push("0");
        }
        let result = _FixedNumber.from(comps[0], this.format);
        const hasFraction = !comps[1].match(/^(0*)$/);
        if (!this.isNegative() && hasFraction) {
          result = result.addUnsafe(ONE.toFormat(result.format));
        }
        return result;
      }
      // @TODO: Support other rounding algorithms
      round(decimals) {
        if (decimals == null) {
          decimals = 0;
        }
        const comps = this.toString().split(".");
        if (comps.length === 1) {
          comps.push("0");
        }
        if (decimals < 0 || decimals > 80 || decimals % 1) {
          logger3.throwArgumentError("invalid decimal count", "decimals", decimals);
        }
        if (comps[1].length <= decimals) {
          return this;
        }
        const factor = _FixedNumber.from("1" + zeros.substring(0, decimals), this.format);
        const bump = BUMP.toFormat(this.format);
        return this.mulUnsafe(factor).addUnsafe(bump).floor().divUnsafe(factor);
      }
      isZero() {
        return this._value === "0.0" || this._value === "0";
      }
      isNegative() {
        return this._value[0] === "-";
      }
      toString() {
        return this._value;
      }
      toHexString(width) {
        if (width == null) {
          return this._hex;
        }
        if (width % 8) {
          logger3.throwArgumentError("invalid byte width", "width", width);
        }
        const hex = BigNumber.from(this._hex).fromTwos(this.format.width).toTwos(width).toHexString();
        return hexZeroPad(hex, width / 8);
      }
      toUnsafeFloat() {
        return parseFloat(this.toString());
      }
      toFormat(format) {
        return _FixedNumber.fromString(this._value, format);
      }
      static fromValue(value, decimals, format) {
        if (format == null && decimals != null && !isBigNumberish(decimals)) {
          format = decimals;
          decimals = null;
        }
        if (decimals == null) {
          decimals = 0;
        }
        if (format == null) {
          format = "fixed";
        }
        return _FixedNumber.fromString(formatFixed(value, decimals), FixedFormat.from(format));
      }
      static fromString(value, format) {
        if (format == null) {
          format = "fixed";
        }
        const fixedFormat = FixedFormat.from(format);
        const numeric = parseFixed(value, fixedFormat.decimals);
        if (!fixedFormat.signed && numeric.lt(Zero)) {
          throwFault2("unsigned value cannot be negative", "overflow", "value", value);
        }
        let hex = null;
        if (fixedFormat.signed) {
          hex = numeric.toTwos(fixedFormat.width).toHexString();
        } else {
          hex = numeric.toHexString();
          hex = hexZeroPad(hex, fixedFormat.width / 8);
        }
        const decimal = formatFixed(numeric, fixedFormat.decimals);
        return new _FixedNumber(_constructorGuard2, hex, decimal, fixedFormat);
      }
      static fromBytes(value, format) {
        if (format == null) {
          format = "fixed";
        }
        const fixedFormat = FixedFormat.from(format);
        if (arrayify(value).length > fixedFormat.width / 8) {
          throw new Error("overflow");
        }
        let numeric = BigNumber.from(value);
        if (fixedFormat.signed) {
          numeric = numeric.fromTwos(fixedFormat.width);
        }
        const hex = numeric.toTwos((fixedFormat.signed ? 0 : 1) + fixedFormat.width).toHexString();
        const decimal = formatFixed(numeric, fixedFormat.decimals);
        return new _FixedNumber(_constructorGuard2, hex, decimal, fixedFormat);
      }
      static from(value, format) {
        if (typeof value === "string") {
          return _FixedNumber.fromString(value, format);
        }
        if (isBytes(value)) {
          return _FixedNumber.fromBytes(value, format);
        }
        try {
          return _FixedNumber.fromValue(value, 0, format);
        } catch (error) {
          if (error.code !== Logger.errors.INVALID_ARGUMENT) {
            throw error;
          }
        }
        return logger3.throwArgumentError("invalid FixedNumber value", "value", value);
      }
      static isFixedNumber(value) {
        return !!(value && value._isFixedNumber);
      }
    };
    ONE = FixedNumber.from(1);
    BUMP = FixedNumber.from("0.5");
  }
});

// ../../node_modules/.pnpm/@ethersproject+bignumber@5.8.0/node_modules/@ethersproject/bignumber/lib.esm/index.js
var init_lib3 = __esm({
  "../../node_modules/.pnpm/@ethersproject+bignumber@5.8.0/node_modules/@ethersproject/bignumber/lib.esm/index.js"() {
    init_bignumber();
    init_fixednumber();
    init_bignumber();
  }
});

// ../../node_modules/.pnpm/js-sha3@0.8.0/node_modules/js-sha3/src/sha3.js
var require_sha3 = __commonJS({
  "../../node_modules/.pnpm/js-sha3@0.8.0/node_modules/js-sha3/src/sha3.js"(exports, module) {
    (function() {
      "use strict";
      var INPUT_ERROR = "input is invalid type";
      var FINALIZE_ERROR = "finalize already called";
      var WINDOW = typeof window === "object";
      var root = WINDOW ? window : {};
      if (root.JS_SHA3_NO_WINDOW) {
        WINDOW = false;
      }
      var WEB_WORKER = !WINDOW && typeof self === "object";
      var NODE_JS = !root.JS_SHA3_NO_NODE_JS && typeof process === "object" && process.versions && process.versions.node;
      if (NODE_JS) {
        root = global;
      } else if (WEB_WORKER) {
        root = self;
      }
      var COMMON_JS = !root.JS_SHA3_NO_COMMON_JS && typeof module === "object" && module.exports;
      var AMD = typeof define === "function" && define.amd;
      var ARRAY_BUFFER = !root.JS_SHA3_NO_ARRAY_BUFFER && typeof ArrayBuffer !== "undefined";
      var HEX_CHARS = "0123456789abcdef".split("");
      var SHAKE_PADDING = [31, 7936, 2031616, 520093696];
      var CSHAKE_PADDING = [4, 1024, 262144, 67108864];
      var KECCAK_PADDING = [1, 256, 65536, 16777216];
      var PADDING = [6, 1536, 393216, 100663296];
      var SHIFT = [0, 8, 16, 24];
      var RC = [
        1,
        0,
        32898,
        0,
        32906,
        2147483648,
        2147516416,
        2147483648,
        32907,
        0,
        2147483649,
        0,
        2147516545,
        2147483648,
        32777,
        2147483648,
        138,
        0,
        136,
        0,
        2147516425,
        0,
        2147483658,
        0,
        2147516555,
        0,
        139,
        2147483648,
        32905,
        2147483648,
        32771,
        2147483648,
        32770,
        2147483648,
        128,
        2147483648,
        32778,
        0,
        2147483658,
        2147483648,
        2147516545,
        2147483648,
        32896,
        2147483648,
        2147483649,
        0,
        2147516424,
        2147483648
      ];
      var BITS = [224, 256, 384, 512];
      var SHAKE_BITS = [128, 256];
      var OUTPUT_TYPES = ["hex", "buffer", "arrayBuffer", "array", "digest"];
      var CSHAKE_BYTEPAD = {
        "128": 168,
        "256": 136
      };
      if (root.JS_SHA3_NO_NODE_JS || !Array.isArray) {
        Array.isArray = function(obj) {
          return Object.prototype.toString.call(obj) === "[object Array]";
        };
      }
      if (ARRAY_BUFFER && (root.JS_SHA3_NO_ARRAY_BUFFER_IS_VIEW || !ArrayBuffer.isView)) {
        ArrayBuffer.isView = function(obj) {
          return typeof obj === "object" && obj.buffer && obj.buffer.constructor === ArrayBuffer;
        };
      }
      var createOutputMethod = function(bits2, padding, outputType) {
        return function(message) {
          return new Keccak(bits2, padding, bits2).update(message)[outputType]();
        };
      };
      var createShakeOutputMethod = function(bits2, padding, outputType) {
        return function(message, outputBits) {
          return new Keccak(bits2, padding, outputBits).update(message)[outputType]();
        };
      };
      var createCshakeOutputMethod = function(bits2, padding, outputType) {
        return function(message, outputBits, n5, s3) {
          return methods["cshake" + bits2].update(message, outputBits, n5, s3)[outputType]();
        };
      };
      var createKmacOutputMethod = function(bits2, padding, outputType) {
        return function(key, message, outputBits, s3) {
          return methods["kmac" + bits2].update(key, message, outputBits, s3)[outputType]();
        };
      };
      var createOutputMethods = function(method, createMethod2, bits2, padding) {
        for (var i5 = 0; i5 < OUTPUT_TYPES.length; ++i5) {
          var type = OUTPUT_TYPES[i5];
          method[type] = createMethod2(bits2, padding, type);
        }
        return method;
      };
      var createMethod = function(bits2, padding) {
        var method = createOutputMethod(bits2, padding, "hex");
        method.create = function() {
          return new Keccak(bits2, padding, bits2);
        };
        method.update = function(message) {
          return method.create().update(message);
        };
        return createOutputMethods(method, createOutputMethod, bits2, padding);
      };
      var createShakeMethod = function(bits2, padding) {
        var method = createShakeOutputMethod(bits2, padding, "hex");
        method.create = function(outputBits) {
          return new Keccak(bits2, padding, outputBits);
        };
        method.update = function(message, outputBits) {
          return method.create(outputBits).update(message);
        };
        return createOutputMethods(method, createShakeOutputMethod, bits2, padding);
      };
      var createCshakeMethod = function(bits2, padding) {
        var w4 = CSHAKE_BYTEPAD[bits2];
        var method = createCshakeOutputMethod(bits2, padding, "hex");
        method.create = function(outputBits, n5, s3) {
          if (!n5 && !s3) {
            return methods["shake" + bits2].create(outputBits);
          } else {
            return new Keccak(bits2, padding, outputBits).bytepad([n5, s3], w4);
          }
        };
        method.update = function(message, outputBits, n5, s3) {
          return method.create(outputBits, n5, s3).update(message);
        };
        return createOutputMethods(method, createCshakeOutputMethod, bits2, padding);
      };
      var createKmacMethod = function(bits2, padding) {
        var w4 = CSHAKE_BYTEPAD[bits2];
        var method = createKmacOutputMethod(bits2, padding, "hex");
        method.create = function(key, outputBits, s3) {
          return new Kmac(bits2, padding, outputBits).bytepad(["KMAC", s3], w4).bytepad([key], w4);
        };
        method.update = function(key, message, outputBits, s3) {
          return method.create(key, outputBits, s3).update(message);
        };
        return createOutputMethods(method, createKmacOutputMethod, bits2, padding);
      };
      var algorithms = [
        { name: "keccak", padding: KECCAK_PADDING, bits: BITS, createMethod },
        { name: "sha3", padding: PADDING, bits: BITS, createMethod },
        { name: "shake", padding: SHAKE_PADDING, bits: SHAKE_BITS, createMethod: createShakeMethod },
        { name: "cshake", padding: CSHAKE_PADDING, bits: SHAKE_BITS, createMethod: createCshakeMethod },
        { name: "kmac", padding: CSHAKE_PADDING, bits: SHAKE_BITS, createMethod: createKmacMethod }
      ];
      var methods = {}, methodNames = [];
      for (var i4 = 0; i4 < algorithms.length; ++i4) {
        var algorithm = algorithms[i4];
        var bits = algorithm.bits;
        for (var j2 = 0; j2 < bits.length; ++j2) {
          var methodName = algorithm.name + "_" + bits[j2];
          methodNames.push(methodName);
          methods[methodName] = algorithm.createMethod(bits[j2], algorithm.padding);
          if (algorithm.name !== "sha3") {
            var newMethodName = algorithm.name + bits[j2];
            methodNames.push(newMethodName);
            methods[newMethodName] = methods[methodName];
          }
        }
      }
      function Keccak(bits2, padding, outputBits) {
        this.blocks = [];
        this.s = [];
        this.padding = padding;
        this.outputBits = outputBits;
        this.reset = true;
        this.finalized = false;
        this.block = 0;
        this.start = 0;
        this.blockCount = 1600 - (bits2 << 1) >> 5;
        this.byteCount = this.blockCount << 2;
        this.outputBlocks = outputBits >> 5;
        this.extraBytes = (outputBits & 31) >> 3;
        for (var i5 = 0; i5 < 50; ++i5) {
          this.s[i5] = 0;
        }
      }
      Keccak.prototype.update = function(message) {
        if (this.finalized) {
          throw new Error(FINALIZE_ERROR);
        }
        var notString, type = typeof message;
        if (type !== "string") {
          if (type === "object") {
            if (message === null) {
              throw new Error(INPUT_ERROR);
            } else if (ARRAY_BUFFER && message.constructor === ArrayBuffer) {
              message = new Uint8Array(message);
            } else if (!Array.isArray(message)) {
              if (!ARRAY_BUFFER || !ArrayBuffer.isView(message)) {
                throw new Error(INPUT_ERROR);
              }
            }
          } else {
            throw new Error(INPUT_ERROR);
          }
          notString = true;
        }
        var blocks = this.blocks, byteCount = this.byteCount, length = message.length, blockCount = this.blockCount, index = 0, s3 = this.s, i5, code;
        while (index < length) {
          if (this.reset) {
            this.reset = false;
            blocks[0] = this.block;
            for (i5 = 1; i5 < blockCount + 1; ++i5) {
              blocks[i5] = 0;
            }
          }
          if (notString) {
            for (i5 = this.start; index < length && i5 < byteCount; ++index) {
              blocks[i5 >> 2] |= message[index] << SHIFT[i5++ & 3];
            }
          } else {
            for (i5 = this.start; index < length && i5 < byteCount; ++index) {
              code = message.charCodeAt(index);
              if (code < 128) {
                blocks[i5 >> 2] |= code << SHIFT[i5++ & 3];
              } else if (code < 2048) {
                blocks[i5 >> 2] |= (192 | code >> 6) << SHIFT[i5++ & 3];
                blocks[i5 >> 2] |= (128 | code & 63) << SHIFT[i5++ & 3];
              } else if (code < 55296 || code >= 57344) {
                blocks[i5 >> 2] |= (224 | code >> 12) << SHIFT[i5++ & 3];
                blocks[i5 >> 2] |= (128 | code >> 6 & 63) << SHIFT[i5++ & 3];
                blocks[i5 >> 2] |= (128 | code & 63) << SHIFT[i5++ & 3];
              } else {
                code = 65536 + ((code & 1023) << 10 | message.charCodeAt(++index) & 1023);
                blocks[i5 >> 2] |= (240 | code >> 18) << SHIFT[i5++ & 3];
                blocks[i5 >> 2] |= (128 | code >> 12 & 63) << SHIFT[i5++ & 3];
                blocks[i5 >> 2] |= (128 | code >> 6 & 63) << SHIFT[i5++ & 3];
                blocks[i5 >> 2] |= (128 | code & 63) << SHIFT[i5++ & 3];
              }
            }
          }
          this.lastByteIndex = i5;
          if (i5 >= byteCount) {
            this.start = i5 - byteCount;
            this.block = blocks[blockCount];
            for (i5 = 0; i5 < blockCount; ++i5) {
              s3[i5] ^= blocks[i5];
            }
            f6(s3);
            this.reset = true;
          } else {
            this.start = i5;
          }
        }
        return this;
      };
      Keccak.prototype.encode = function(x4, right) {
        var o4 = x4 & 255, n5 = 1;
        var bytes = [o4];
        x4 = x4 >> 8;
        o4 = x4 & 255;
        while (o4 > 0) {
          bytes.unshift(o4);
          x4 = x4 >> 8;
          o4 = x4 & 255;
          ++n5;
        }
        if (right) {
          bytes.push(n5);
        } else {
          bytes.unshift(n5);
        }
        this.update(bytes);
        return bytes.length;
      };
      Keccak.prototype.encodeString = function(str) {
        var notString, type = typeof str;
        if (type !== "string") {
          if (type === "object") {
            if (str === null) {
              throw new Error(INPUT_ERROR);
            } else if (ARRAY_BUFFER && str.constructor === ArrayBuffer) {
              str = new Uint8Array(str);
            } else if (!Array.isArray(str)) {
              if (!ARRAY_BUFFER || !ArrayBuffer.isView(str)) {
                throw new Error(INPUT_ERROR);
              }
            }
          } else {
            throw new Error(INPUT_ERROR);
          }
          notString = true;
        }
        var bytes = 0, length = str.length;
        if (notString) {
          bytes = length;
        } else {
          for (var i5 = 0; i5 < str.length; ++i5) {
            var code = str.charCodeAt(i5);
            if (code < 128) {
              bytes += 1;
            } else if (code < 2048) {
              bytes += 2;
            } else if (code < 55296 || code >= 57344) {
              bytes += 3;
            } else {
              code = 65536 + ((code & 1023) << 10 | str.charCodeAt(++i5) & 1023);
              bytes += 4;
            }
          }
        }
        bytes += this.encode(bytes * 8);
        this.update(str);
        return bytes;
      };
      Keccak.prototype.bytepad = function(strs, w4) {
        var bytes = this.encode(w4);
        for (var i5 = 0; i5 < strs.length; ++i5) {
          bytes += this.encodeString(strs[i5]);
        }
        var paddingBytes = w4 - bytes % w4;
        var zeros2 = [];
        zeros2.length = paddingBytes;
        this.update(zeros2);
        return this;
      };
      Keccak.prototype.finalize = function() {
        if (this.finalized) {
          return;
        }
        this.finalized = true;
        var blocks = this.blocks, i5 = this.lastByteIndex, blockCount = this.blockCount, s3 = this.s;
        blocks[i5 >> 2] |= this.padding[i5 & 3];
        if (this.lastByteIndex === this.byteCount) {
          blocks[0] = blocks[blockCount];
          for (i5 = 1; i5 < blockCount + 1; ++i5) {
            blocks[i5] = 0;
          }
        }
        blocks[blockCount - 1] |= 2147483648;
        for (i5 = 0; i5 < blockCount; ++i5) {
          s3[i5] ^= blocks[i5];
        }
        f6(s3);
      };
      Keccak.prototype.toString = Keccak.prototype.hex = function() {
        this.finalize();
        var blockCount = this.blockCount, s3 = this.s, outputBlocks = this.outputBlocks, extraBytes = this.extraBytes, i5 = 0, j3 = 0;
        var hex = "", block;
        while (j3 < outputBlocks) {
          for (i5 = 0; i5 < blockCount && j3 < outputBlocks; ++i5, ++j3) {
            block = s3[i5];
            hex += HEX_CHARS[block >> 4 & 15] + HEX_CHARS[block & 15] + HEX_CHARS[block >> 12 & 15] + HEX_CHARS[block >> 8 & 15] + HEX_CHARS[block >> 20 & 15] + HEX_CHARS[block >> 16 & 15] + HEX_CHARS[block >> 28 & 15] + HEX_CHARS[block >> 24 & 15];
          }
          if (j3 % blockCount === 0) {
            f6(s3);
            i5 = 0;
          }
        }
        if (extraBytes) {
          block = s3[i5];
          hex += HEX_CHARS[block >> 4 & 15] + HEX_CHARS[block & 15];
          if (extraBytes > 1) {
            hex += HEX_CHARS[block >> 12 & 15] + HEX_CHARS[block >> 8 & 15];
          }
          if (extraBytes > 2) {
            hex += HEX_CHARS[block >> 20 & 15] + HEX_CHARS[block >> 16 & 15];
          }
        }
        return hex;
      };
      Keccak.prototype.arrayBuffer = function() {
        this.finalize();
        var blockCount = this.blockCount, s3 = this.s, outputBlocks = this.outputBlocks, extraBytes = this.extraBytes, i5 = 0, j3 = 0;
        var bytes = this.outputBits >> 3;
        var buffer;
        if (extraBytes) {
          buffer = new ArrayBuffer(outputBlocks + 1 << 2);
        } else {
          buffer = new ArrayBuffer(bytes);
        }
        var array2 = new Uint32Array(buffer);
        while (j3 < outputBlocks) {
          for (i5 = 0; i5 < blockCount && j3 < outputBlocks; ++i5, ++j3) {
            array2[j3] = s3[i5];
          }
          if (j3 % blockCount === 0) {
            f6(s3);
          }
        }
        if (extraBytes) {
          array2[i5] = s3[i5];
          buffer = buffer.slice(0, bytes);
        }
        return buffer;
      };
      Keccak.prototype.buffer = Keccak.prototype.arrayBuffer;
      Keccak.prototype.digest = Keccak.prototype.array = function() {
        this.finalize();
        var blockCount = this.blockCount, s3 = this.s, outputBlocks = this.outputBlocks, extraBytes = this.extraBytes, i5 = 0, j3 = 0;
        var array2 = [], offset, block;
        while (j3 < outputBlocks) {
          for (i5 = 0; i5 < blockCount && j3 < outputBlocks; ++i5, ++j3) {
            offset = j3 << 2;
            block = s3[i5];
            array2[offset] = block & 255;
            array2[offset + 1] = block >> 8 & 255;
            array2[offset + 2] = block >> 16 & 255;
            array2[offset + 3] = block >> 24 & 255;
          }
          if (j3 % blockCount === 0) {
            f6(s3);
          }
        }
        if (extraBytes) {
          offset = j3 << 2;
          block = s3[i5];
          array2[offset] = block & 255;
          if (extraBytes > 1) {
            array2[offset + 1] = block >> 8 & 255;
          }
          if (extraBytes > 2) {
            array2[offset + 2] = block >> 16 & 255;
          }
        }
        return array2;
      };
      function Kmac(bits2, padding, outputBits) {
        Keccak.call(this, bits2, padding, outputBits);
      }
      Kmac.prototype = new Keccak();
      Kmac.prototype.finalize = function() {
        this.encode(this.outputBits, true);
        return Keccak.prototype.finalize.call(this);
      };
      var f6 = function(s3) {
        var h5, l6, n5, c0, c1, c22, c32, c42, c52, c6, c7, c8, c9, b0, b1, b22, b32, b4, b5, b6, b7, b8, b9, b10, b11, b12, b13, b14, b15, b16, b17, b18, b19, b20, b21, b222, b23, b24, b25, b26, b27, b28, b29, b30, b31, b322, b33, b34, b35, b36, b37, b38, b39, b40, b41, b42, b43, b44, b45, b46, b47, b48, b49;
        for (n5 = 0; n5 < 48; n5 += 2) {
          c0 = s3[0] ^ s3[10] ^ s3[20] ^ s3[30] ^ s3[40];
          c1 = s3[1] ^ s3[11] ^ s3[21] ^ s3[31] ^ s3[41];
          c22 = s3[2] ^ s3[12] ^ s3[22] ^ s3[32] ^ s3[42];
          c32 = s3[3] ^ s3[13] ^ s3[23] ^ s3[33] ^ s3[43];
          c42 = s3[4] ^ s3[14] ^ s3[24] ^ s3[34] ^ s3[44];
          c52 = s3[5] ^ s3[15] ^ s3[25] ^ s3[35] ^ s3[45];
          c6 = s3[6] ^ s3[16] ^ s3[26] ^ s3[36] ^ s3[46];
          c7 = s3[7] ^ s3[17] ^ s3[27] ^ s3[37] ^ s3[47];
          c8 = s3[8] ^ s3[18] ^ s3[28] ^ s3[38] ^ s3[48];
          c9 = s3[9] ^ s3[19] ^ s3[29] ^ s3[39] ^ s3[49];
          h5 = c8 ^ (c22 << 1 | c32 >>> 31);
          l6 = c9 ^ (c32 << 1 | c22 >>> 31);
          s3[0] ^= h5;
          s3[1] ^= l6;
          s3[10] ^= h5;
          s3[11] ^= l6;
          s3[20] ^= h5;
          s3[21] ^= l6;
          s3[30] ^= h5;
          s3[31] ^= l6;
          s3[40] ^= h5;
          s3[41] ^= l6;
          h5 = c0 ^ (c42 << 1 | c52 >>> 31);
          l6 = c1 ^ (c52 << 1 | c42 >>> 31);
          s3[2] ^= h5;
          s3[3] ^= l6;
          s3[12] ^= h5;
          s3[13] ^= l6;
          s3[22] ^= h5;
          s3[23] ^= l6;
          s3[32] ^= h5;
          s3[33] ^= l6;
          s3[42] ^= h5;
          s3[43] ^= l6;
          h5 = c22 ^ (c6 << 1 | c7 >>> 31);
          l6 = c32 ^ (c7 << 1 | c6 >>> 31);
          s3[4] ^= h5;
          s3[5] ^= l6;
          s3[14] ^= h5;
          s3[15] ^= l6;
          s3[24] ^= h5;
          s3[25] ^= l6;
          s3[34] ^= h5;
          s3[35] ^= l6;
          s3[44] ^= h5;
          s3[45] ^= l6;
          h5 = c42 ^ (c8 << 1 | c9 >>> 31);
          l6 = c52 ^ (c9 << 1 | c8 >>> 31);
          s3[6] ^= h5;
          s3[7] ^= l6;
          s3[16] ^= h5;
          s3[17] ^= l6;
          s3[26] ^= h5;
          s3[27] ^= l6;
          s3[36] ^= h5;
          s3[37] ^= l6;
          s3[46] ^= h5;
          s3[47] ^= l6;
          h5 = c6 ^ (c0 << 1 | c1 >>> 31);
          l6 = c7 ^ (c1 << 1 | c0 >>> 31);
          s3[8] ^= h5;
          s3[9] ^= l6;
          s3[18] ^= h5;
          s3[19] ^= l6;
          s3[28] ^= h5;
          s3[29] ^= l6;
          s3[38] ^= h5;
          s3[39] ^= l6;
          s3[48] ^= h5;
          s3[49] ^= l6;
          b0 = s3[0];
          b1 = s3[1];
          b322 = s3[11] << 4 | s3[10] >>> 28;
          b33 = s3[10] << 4 | s3[11] >>> 28;
          b14 = s3[20] << 3 | s3[21] >>> 29;
          b15 = s3[21] << 3 | s3[20] >>> 29;
          b46 = s3[31] << 9 | s3[30] >>> 23;
          b47 = s3[30] << 9 | s3[31] >>> 23;
          b28 = s3[40] << 18 | s3[41] >>> 14;
          b29 = s3[41] << 18 | s3[40] >>> 14;
          b20 = s3[2] << 1 | s3[3] >>> 31;
          b21 = s3[3] << 1 | s3[2] >>> 31;
          b22 = s3[13] << 12 | s3[12] >>> 20;
          b32 = s3[12] << 12 | s3[13] >>> 20;
          b34 = s3[22] << 10 | s3[23] >>> 22;
          b35 = s3[23] << 10 | s3[22] >>> 22;
          b16 = s3[33] << 13 | s3[32] >>> 19;
          b17 = s3[32] << 13 | s3[33] >>> 19;
          b48 = s3[42] << 2 | s3[43] >>> 30;
          b49 = s3[43] << 2 | s3[42] >>> 30;
          b40 = s3[5] << 30 | s3[4] >>> 2;
          b41 = s3[4] << 30 | s3[5] >>> 2;
          b222 = s3[14] << 6 | s3[15] >>> 26;
          b23 = s3[15] << 6 | s3[14] >>> 26;
          b4 = s3[25] << 11 | s3[24] >>> 21;
          b5 = s3[24] << 11 | s3[25] >>> 21;
          b36 = s3[34] << 15 | s3[35] >>> 17;
          b37 = s3[35] << 15 | s3[34] >>> 17;
          b18 = s3[45] << 29 | s3[44] >>> 3;
          b19 = s3[44] << 29 | s3[45] >>> 3;
          b10 = s3[6] << 28 | s3[7] >>> 4;
          b11 = s3[7] << 28 | s3[6] >>> 4;
          b42 = s3[17] << 23 | s3[16] >>> 9;
          b43 = s3[16] << 23 | s3[17] >>> 9;
          b24 = s3[26] << 25 | s3[27] >>> 7;
          b25 = s3[27] << 25 | s3[26] >>> 7;
          b6 = s3[36] << 21 | s3[37] >>> 11;
          b7 = s3[37] << 21 | s3[36] >>> 11;
          b38 = s3[47] << 24 | s3[46] >>> 8;
          b39 = s3[46] << 24 | s3[47] >>> 8;
          b30 = s3[8] << 27 | s3[9] >>> 5;
          b31 = s3[9] << 27 | s3[8] >>> 5;
          b12 = s3[18] << 20 | s3[19] >>> 12;
          b13 = s3[19] << 20 | s3[18] >>> 12;
          b44 = s3[29] << 7 | s3[28] >>> 25;
          b45 = s3[28] << 7 | s3[29] >>> 25;
          b26 = s3[38] << 8 | s3[39] >>> 24;
          b27 = s3[39] << 8 | s3[38] >>> 24;
          b8 = s3[48] << 14 | s3[49] >>> 18;
          b9 = s3[49] << 14 | s3[48] >>> 18;
          s3[0] = b0 ^ ~b22 & b4;
          s3[1] = b1 ^ ~b32 & b5;
          s3[10] = b10 ^ ~b12 & b14;
          s3[11] = b11 ^ ~b13 & b15;
          s3[20] = b20 ^ ~b222 & b24;
          s3[21] = b21 ^ ~b23 & b25;
          s3[30] = b30 ^ ~b322 & b34;
          s3[31] = b31 ^ ~b33 & b35;
          s3[40] = b40 ^ ~b42 & b44;
          s3[41] = b41 ^ ~b43 & b45;
          s3[2] = b22 ^ ~b4 & b6;
          s3[3] = b32 ^ ~b5 & b7;
          s3[12] = b12 ^ ~b14 & b16;
          s3[13] = b13 ^ ~b15 & b17;
          s3[22] = b222 ^ ~b24 & b26;
          s3[23] = b23 ^ ~b25 & b27;
          s3[32] = b322 ^ ~b34 & b36;
          s3[33] = b33 ^ ~b35 & b37;
          s3[42] = b42 ^ ~b44 & b46;
          s3[43] = b43 ^ ~b45 & b47;
          s3[4] = b4 ^ ~b6 & b8;
          s3[5] = b5 ^ ~b7 & b9;
          s3[14] = b14 ^ ~b16 & b18;
          s3[15] = b15 ^ ~b17 & b19;
          s3[24] = b24 ^ ~b26 & b28;
          s3[25] = b25 ^ ~b27 & b29;
          s3[34] = b34 ^ ~b36 & b38;
          s3[35] = b35 ^ ~b37 & b39;
          s3[44] = b44 ^ ~b46 & b48;
          s3[45] = b45 ^ ~b47 & b49;
          s3[6] = b6 ^ ~b8 & b0;
          s3[7] = b7 ^ ~b9 & b1;
          s3[16] = b16 ^ ~b18 & b10;
          s3[17] = b17 ^ ~b19 & b11;
          s3[26] = b26 ^ ~b28 & b20;
          s3[27] = b27 ^ ~b29 & b21;
          s3[36] = b36 ^ ~b38 & b30;
          s3[37] = b37 ^ ~b39 & b31;
          s3[46] = b46 ^ ~b48 & b40;
          s3[47] = b47 ^ ~b49 & b41;
          s3[8] = b8 ^ ~b0 & b22;
          s3[9] = b9 ^ ~b1 & b32;
          s3[18] = b18 ^ ~b10 & b12;
          s3[19] = b19 ^ ~b11 & b13;
          s3[28] = b28 ^ ~b20 & b222;
          s3[29] = b29 ^ ~b21 & b23;
          s3[38] = b38 ^ ~b30 & b322;
          s3[39] = b39 ^ ~b31 & b33;
          s3[48] = b48 ^ ~b40 & b42;
          s3[49] = b49 ^ ~b41 & b43;
          s3[0] ^= RC[n5];
          s3[1] ^= RC[n5 + 1];
        }
      };
      if (COMMON_JS) {
        module.exports = methods;
      } else {
        for (i4 = 0; i4 < methodNames.length; ++i4) {
          root[methodNames[i4]] = methods[methodNames[i4]];
        }
        if (AMD) {
          define(function() {
            return methods;
          });
        }
      }
    })();
  }
});

// ../../node_modules/.pnpm/@ethersproject+keccak256@5.8.0/node_modules/@ethersproject/keccak256/lib.esm/index.js
var lib_exports = {};
__export(lib_exports, {
  keccak256: () => keccak256
});
function keccak256(data) {
  return "0x" + import_js_sha3.default.keccak_256(arrayify(data));
}
var import_js_sha3;
var init_lib4 = __esm({
  "../../node_modules/.pnpm/@ethersproject+keccak256@5.8.0/node_modules/@ethersproject/keccak256/lib.esm/index.js"() {
    "use strict";
    import_js_sha3 = __toESM(require_sha3());
    init_lib2();
  }
});

// ../../node_modules/.pnpm/@ethersproject+rlp@5.8.0/node_modules/@ethersproject/rlp/lib.esm/_version.js
var version4;
var init_version4 = __esm({
  "../../node_modules/.pnpm/@ethersproject+rlp@5.8.0/node_modules/@ethersproject/rlp/lib.esm/_version.js"() {
    version4 = "rlp/5.8.0";
  }
});

// ../../node_modules/.pnpm/@ethersproject+rlp@5.8.0/node_modules/@ethersproject/rlp/lib.esm/index.js
function arrayifyInteger(value) {
  const result = [];
  while (value) {
    result.unshift(value & 255);
    value >>= 8;
  }
  return result;
}
function _encode(object2) {
  if (Array.isArray(object2)) {
    let payload = [];
    object2.forEach(function(child) {
      payload = payload.concat(_encode(child));
    });
    if (payload.length <= 55) {
      payload.unshift(192 + payload.length);
      return payload;
    }
    const length2 = arrayifyInteger(payload.length);
    length2.unshift(247 + length2.length);
    return length2.concat(payload);
  }
  if (!isBytesLike(object2)) {
    logger4.throwArgumentError("RLP object must be BytesLike", "object", object2);
  }
  const data = Array.prototype.slice.call(arrayify(object2));
  if (data.length === 1 && data[0] <= 127) {
    return data;
  } else if (data.length <= 55) {
    data.unshift(128 + data.length);
    return data;
  }
  const length = arrayifyInteger(data.length);
  length.unshift(183 + length.length);
  return length.concat(data);
}
function encode(object2) {
  return hexlify(_encode(object2));
}
var logger4;
var init_lib5 = __esm({
  "../../node_modules/.pnpm/@ethersproject+rlp@5.8.0/node_modules/@ethersproject/rlp/lib.esm/index.js"() {
    "use strict";
    init_lib2();
    init_lib();
    init_version4();
    logger4 = new Logger(version4);
  }
});

// ../../node_modules/.pnpm/@ethersproject+address@5.8.0/node_modules/@ethersproject/address/lib.esm/_version.js
var version5;
var init_version5 = __esm({
  "../../node_modules/.pnpm/@ethersproject+address@5.8.0/node_modules/@ethersproject/address/lib.esm/_version.js"() {
    version5 = "address/5.8.0";
  }
});

// ../../node_modules/.pnpm/@ethersproject+address@5.8.0/node_modules/@ethersproject/address/lib.esm/index.js
var lib_exports2 = {};
__export(lib_exports2, {
  getAddress: () => getAddress,
  getContractAddress: () => getContractAddress,
  getCreate2Address: () => getCreate2Address,
  getIcapAddress: () => getIcapAddress,
  isAddress: () => isAddress
});
function getChecksumAddress(address) {
  if (!isHexString(address, 20)) {
    logger5.throwArgumentError("invalid address", "address", address);
  }
  address = address.toLowerCase();
  const chars = address.substring(2).split("");
  const expanded = new Uint8Array(40);
  for (let i4 = 0; i4 < 40; i4++) {
    expanded[i4] = chars[i4].charCodeAt(0);
  }
  const hashed = arrayify(keccak256(expanded));
  for (let i4 = 0; i4 < 40; i4 += 2) {
    if (hashed[i4 >> 1] >> 4 >= 8) {
      chars[i4] = chars[i4].toUpperCase();
    }
    if ((hashed[i4 >> 1] & 15) >= 8) {
      chars[i4 + 1] = chars[i4 + 1].toUpperCase();
    }
  }
  return "0x" + chars.join("");
}
function log10(x4) {
  if (Math.log10) {
    return Math.log10(x4);
  }
  return Math.log(x4) / Math.LN10;
}
function ibanChecksum(address) {
  address = address.toUpperCase();
  address = address.substring(4) + address.substring(0, 2) + "00";
  let expanded = address.split("").map((c6) => {
    return ibanLookup[c6];
  }).join("");
  while (expanded.length >= safeDigits) {
    let block = expanded.substring(0, safeDigits);
    expanded = parseInt(block, 10) % 97 + expanded.substring(block.length);
  }
  let checksum = String(98 - parseInt(expanded, 10) % 97);
  while (checksum.length < 2) {
    checksum = "0" + checksum;
  }
  return checksum;
}
function getAddress(address) {
  let result = null;
  if (typeof address !== "string") {
    logger5.throwArgumentError("invalid address", "address", address);
  }
  if (address.match(/^(0x)?[0-9a-fA-F]{40}$/)) {
    if (address.substring(0, 2) !== "0x") {
      address = "0x" + address;
    }
    result = getChecksumAddress(address);
    if (address.match(/([A-F].*[a-f])|([a-f].*[A-F])/) && result !== address) {
      logger5.throwArgumentError("bad address checksum", "address", address);
    }
  } else if (address.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {
    if (address.substring(2, 4) !== ibanChecksum(address)) {
      logger5.throwArgumentError("bad icap checksum", "address", address);
    }
    result = _base36To16(address.substring(4));
    while (result.length < 40) {
      result = "0" + result;
    }
    result = getChecksumAddress("0x" + result);
  } else {
    logger5.throwArgumentError("invalid address", "address", address);
  }
  return result;
}
function isAddress(address) {
  try {
    getAddress(address);
    return true;
  } catch (error) {
  }
  return false;
}
function getIcapAddress(address) {
  let base36 = _base16To36(getAddress(address).substring(2)).toUpperCase();
  while (base36.length < 30) {
    base36 = "0" + base36;
  }
  return "XE" + ibanChecksum("XE00" + base36) + base36;
}
function getContractAddress(transaction2) {
  let from = null;
  try {
    from = getAddress(transaction2.from);
  } catch (error) {
    logger5.throwArgumentError("missing from address", "transaction", transaction2);
  }
  const nonce = stripZeros(arrayify(BigNumber.from(transaction2.nonce).toHexString()));
  return getAddress(hexDataSlice(keccak256(encode([from, nonce])), 12));
}
function getCreate2Address(from, salt, initCodeHash) {
  if (hexDataLength(salt) !== 32) {
    logger5.throwArgumentError("salt must be 32 bytes", "salt", salt);
  }
  if (hexDataLength(initCodeHash) !== 32) {
    logger5.throwArgumentError("initCodeHash must be 32 bytes", "initCodeHash", initCodeHash);
  }
  return getAddress(hexDataSlice(keccak256(concat(["0xff", getAddress(from), salt, initCodeHash])), 12));
}
var logger5, MAX_SAFE_INTEGER, ibanLookup, safeDigits;
var init_lib6 = __esm({
  "../../node_modules/.pnpm/@ethersproject+address@5.8.0/node_modules/@ethersproject/address/lib.esm/index.js"() {
    "use strict";
    init_lib2();
    init_lib3();
    init_lib4();
    init_lib5();
    init_lib();
    init_version5();
    logger5 = new Logger(version5);
    MAX_SAFE_INTEGER = 9007199254740991;
    ibanLookup = {};
    for (let i4 = 0; i4 < 10; i4++) {
      ibanLookup[String(i4)] = String(i4);
    }
    for (let i4 = 0; i4 < 26; i4++) {
      ibanLookup[String.fromCharCode(65 + i4)] = String(10 + i4);
    }
    safeDigits = Math.floor(log10(MAX_SAFE_INTEGER));
  }
});

// ../../node_modules/.pnpm/@keplr-wallet+cosmos@0.12.28/node_modules/@keplr-wallet/cosmos/build/bech32/index.js
var require_bech323 = __commonJS({
  "../../node_modules/.pnpm/@keplr-wallet+cosmos@0.12.28/node_modules/@keplr-wallet/cosmos/build/bech32/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o4, m3, k5, k22) {
      if (k22 === void 0)
        k22 = k5;
      var desc = Object.getOwnPropertyDescriptor(m3, k5);
      if (!desc || ("get" in desc ? !m3.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m3[k5];
        } };
      }
      Object.defineProperty(o4, k22, desc);
    } : function(o4, m3, k5, k22) {
      if (k22 === void 0)
        k22 = k5;
      o4[k22] = m3[k5];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o4, v5) {
      Object.defineProperty(o4, "default", { enumerable: true, value: v5 });
    } : function(o4, v5) {
      o4["default"] = v5;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k5 in mod)
          if (k5 !== "default" && Object.prototype.hasOwnProperty.call(mod, k5))
            __createBinding(result, mod, k5);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Bech32Address = void 0;
    var bech32_1 = __importStar(require_bech32());
    var buffer_1 = require_buffer();
    var address_1 = (init_lib6(), __toCommonJS(lib_exports2));
    var Bech32Address2 = class _Bech32Address {
      static shortenAddress(bech32, maxCharacters) {
        if (maxCharacters >= bech32.length) {
          return bech32;
        }
        const i4 = bech32.indexOf("1");
        const prefix = bech32.slice(0, i4);
        const address = bech32.slice(i4 + 1);
        maxCharacters -= prefix.length;
        maxCharacters -= 3;
        maxCharacters -= 1;
        if (maxCharacters <= 0) {
          return "";
        }
        const mid = Math.floor(address.length / 2);
        let former = address.slice(0, mid);
        let latter = address.slice(mid);
        while (maxCharacters < former.length + latter.length) {
          if ((former.length + latter.length) % 2 === 1 && former.length > 0) {
            former = former.slice(0, former.length - 1);
          } else {
            latter = latter.slice(1);
          }
        }
        return prefix + "1" + former + "..." + latter;
      }
      static fromBech32(bech32Address, prefix) {
        const decoded = bech32_1.default.decode(bech32Address);
        if (prefix && decoded.prefix !== prefix) {
          throw new Error("Unmatched prefix");
        }
        return new _Bech32Address(new Uint8Array((0, bech32_1.fromWords)(decoded.words)));
      }
      static validate(bech32Address, prefix) {
        const { prefix: decodedPrefix } = bech32_1.default.decode(bech32Address);
        if (prefix && prefix !== decodedPrefix) {
          throw new Error(`Unexpected prefix (expected: ${prefix}, actual: ${decodedPrefix})`);
        }
      }
      static defaultBech32Config(mainPrefix, validatorPrefix = "val", consensusPrefix = "cons", publicPrefix = "pub", operatorPrefix = "oper") {
        return {
          bech32PrefixAccAddr: mainPrefix,
          bech32PrefixAccPub: mainPrefix + publicPrefix,
          bech32PrefixValAddr: mainPrefix + validatorPrefix + operatorPrefix,
          bech32PrefixValPub: mainPrefix + validatorPrefix + operatorPrefix + publicPrefix,
          bech32PrefixConsAddr: mainPrefix + validatorPrefix + consensusPrefix,
          bech32PrefixConsPub: mainPrefix + validatorPrefix + consensusPrefix + publicPrefix
        };
      }
      constructor(address) {
        this.address = address;
      }
      toBech32(prefix) {
        const words = bech32_1.default.toWords(this.address);
        return bech32_1.default.encode(prefix, words);
      }
      toHex(mixedCaseChecksum = true) {
        const hex = buffer_1.Buffer.from(this.address).toString("hex");
        if (hex.length === 0) {
          throw new Error("Empty address");
        }
        if (mixedCaseChecksum) {
          return (0, address_1.getAddress)("0x" + hex);
        } else {
          return "0x" + hex;
        }
      }
    };
    exports.Bech32Address = Bech32Address2;
  }
});

// ../../node_modules/.pnpm/@keplr-wallet+cosmos@0.12.28/node_modules/@keplr-wallet/cosmos/build/chain-id/cosmos.js
var require_cosmos = __commonJS({
  "../../node_modules/.pnpm/@keplr-wallet+cosmos@0.12.28/node_modules/@keplr-wallet/cosmos/build/chain-id/cosmos.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ChainIdHelper = void 0;
    var ChainIdHelper = class _ChainIdHelper {
      static parse(chainId) {
        if (chainId === "injective-777" || chainId === "injective-888") {
          return {
            identifier: chainId,
            version: 0
          };
        }
        const split = chainId.split(_ChainIdHelper.VersionFormatRegExp).filter(Boolean);
        if (split.length !== 2) {
          return {
            identifier: chainId,
            version: 0
          };
        } else {
          return { identifier: split[0], version: parseInt(split[1]) };
        }
      }
      static hasChainVersion(chainId) {
        const version6 = _ChainIdHelper.parse(chainId);
        return version6.identifier !== chainId;
      }
    };
    exports.ChainIdHelper = ChainIdHelper;
    ChainIdHelper.VersionFormatRegExp = /(.+)-([\d]+)/;
  }
});

// ../../node_modules/.pnpm/@keplr-wallet+cosmos@0.12.28/node_modules/@keplr-wallet/cosmos/build/chain-id/ethermint.js
var require_ethermint = __commonJS({
  "../../node_modules/.pnpm/@keplr-wallet+cosmos@0.12.28/node_modules/@keplr-wallet/cosmos/build/chain-id/ethermint.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.EthermintChainIdHelper = void 0;
    var cosmos_1 = require_cosmos();
    var EthermintChainIdHelper = class {
      static parse(chainId) {
        const cosmosChainId = cosmos_1.ChainIdHelper.parse(chainId);
        if (chainId.startsWith("injective")) {
          const injectiveTestnetChainIds = ["injective-777", "injective-888"];
          if (injectiveTestnetChainIds.includes(chainId)) {
            return Object.assign({ ethChainId: 5 }, cosmosChainId);
          }
          return Object.assign({ ethChainId: 1 }, cosmosChainId);
        }
        const matches = chainId.match("^([a-z]{1,})_{1}([1-9][0-9]*)-{1}([1-9][0-9]*)$");
        if (!matches || matches.length !== 4 || matches[1] === "" || Number.isNaN(parseFloat(matches[2])) || !Number.isInteger(parseFloat(matches[2]))) {
          throw new Error(`Invalid chainId for ethermint: ${chainId}`);
        }
        return Object.assign(Object.assign({}, cosmosChainId), { ethChainId: parseFloat(matches[2]) });
      }
    };
    exports.EthermintChainIdHelper = EthermintChainIdHelper;
  }
});

// ../../node_modules/.pnpm/@keplr-wallet+cosmos@0.12.28/node_modules/@keplr-wallet/cosmos/build/chain-id/index.js
var require_chain_id = __commonJS({
  "../../node_modules/.pnpm/@keplr-wallet+cosmos@0.12.28/node_modules/@keplr-wallet/cosmos/build/chain-id/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o4, m3, k5, k22) {
      if (k22 === void 0)
        k22 = k5;
      var desc = Object.getOwnPropertyDescriptor(m3, k5);
      if (!desc || ("get" in desc ? !m3.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m3[k5];
        } };
      }
      Object.defineProperty(o4, k22, desc);
    } : function(o4, m3, k5, k22) {
      if (k22 === void 0)
        k22 = k5;
      o4[k22] = m3[k5];
    });
    var __exportStar = exports && exports.__exportStar || function(m3, exports2) {
      for (var p4 in m3)
        if (p4 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p4))
          __createBinding(exports2, m3, p4);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_cosmos(), exports);
    __exportStar(require_ethermint(), exports);
  }
});

// ../../node_modules/.pnpm/@keplr-wallet+cosmos@0.12.28/node_modules/@keplr-wallet/cosmos/build/tx-tracer/types.js
var require_types2 = __commonJS({
  "../../node_modules/.pnpm/@keplr-wallet+cosmos@0.12.28/node_modules/@keplr-wallet/cosmos/build/tx-tracer/types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WsReadyState = void 0;
    var WsReadyState;
    (function(WsReadyState2) {
      WsReadyState2[WsReadyState2["CONNECTING"] = 0] = "CONNECTING";
      WsReadyState2[WsReadyState2["OPEN"] = 1] = "OPEN";
      WsReadyState2[WsReadyState2["CLOSING"] = 2] = "CLOSING";
      WsReadyState2[WsReadyState2["CLOSED"] = 3] = "CLOSED";
      WsReadyState2[WsReadyState2["NONE"] = 4] = "NONE";
    })(WsReadyState = exports.WsReadyState || (exports.WsReadyState = {}));
  }
});

// ../../node_modules/.pnpm/@keplr-wallet+cosmos@0.12.28/node_modules/@keplr-wallet/cosmos/build/tx-tracer/index.js
var require_tx_tracer = __commonJS({
  "../../node_modules/.pnpm/@keplr-wallet+cosmos@0.12.28/node_modules/@keplr-wallet/cosmos/build/tx-tracer/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TendermintTxTracer = void 0;
    var types_1 = require_types2();
    var buffer_1 = require_buffer();
    var TendermintTxTracer = class {
      constructor(url, wsEndpoint, options = {}) {
        this.url = url;
        this.wsEndpoint = wsEndpoint;
        this.options = options;
        this.newBlockSubscribes = [];
        this.txSubscribes = /* @__PURE__ */ new Map();
        this.pendingQueries = /* @__PURE__ */ new Map();
        this.listeners = {};
        this.onOpen = (e2) => {
          var _a2;
          if (this.newBlockSubscribes.length > 0) {
            this.sendSubscribeBlockRpc();
          }
          for (const [id, tx] of this.txSubscribes) {
            this.sendSubscribeTxRpc(id, tx.params);
          }
          for (const [id, query] of this.pendingQueries) {
            this.sendQueryRpc(id, query.method, query.params);
          }
          for (const listener of (_a2 = this.listeners.open) !== null && _a2 !== void 0 ? _a2 : []) {
            listener(e2);
          }
        };
        this.onMessage = (e2) => {
          var _a2, _b, _c, _d, _e3, _f;
          for (const listener of (_a2 = this.listeners.message) !== null && _a2 !== void 0 ? _a2 : []) {
            listener(e2);
          }
          if (e2.data) {
            try {
              const obj = JSON.parse(e2.data);
              if (obj === null || obj === void 0 ? void 0 : obj.id) {
                if (this.pendingQueries.has(obj.id)) {
                  if (obj.error) {
                    this.pendingQueries.get(obj.id).rejector(new Error(obj.error.data || obj.error.message));
                  } else {
                    if ((_b = obj.result) === null || _b === void 0 ? void 0 : _b.tx_result) {
                      this.pendingQueries.get(obj.id).resolver(obj.result.tx_result);
                    } else {
                      this.pendingQueries.get(obj.id).resolver(obj.result);
                    }
                  }
                  this.pendingQueries.delete(obj.id);
                }
              }
              if (((_d = (_c = obj === null || obj === void 0 ? void 0 : obj.result) === null || _c === void 0 ? void 0 : _c.data) === null || _d === void 0 ? void 0 : _d.type) === "tendermint/event/NewBlock") {
                for (const handler of this.newBlockSubscribes) {
                  handler.handler(obj.result.data.value);
                }
              }
              if (((_f = (_e3 = obj === null || obj === void 0 ? void 0 : obj.result) === null || _e3 === void 0 ? void 0 : _e3.data) === null || _f === void 0 ? void 0 : _f.type) === "tendermint/event/Tx") {
                if (obj === null || obj === void 0 ? void 0 : obj.id) {
                  if (this.txSubscribes.has(obj.id)) {
                    if (obj.error) {
                      this.txSubscribes.get(obj.id).rejector(new Error(obj.error.data || obj.error.message));
                    } else {
                      this.txSubscribes.get(obj.id).resolver(obj.result.data.value.TxResult.result);
                    }
                    this.txSubscribes.delete(obj.id);
                  }
                }
              }
            } catch (e3) {
              console.log(`Tendermint websocket jsonrpc response is not JSON: ${e3.message || e3.toString()}`);
            }
          }
        };
        this.onClose = (e2) => {
          var _a2;
          for (const listener of (_a2 = this.listeners.close) !== null && _a2 !== void 0 ? _a2 : []) {
            listener(e2);
          }
        };
        this.ws = this.options.wsObject ? new this.options.wsObject(this.getWsEndpoint()) : new WebSocket(this.getWsEndpoint());
        this.ws.onopen = this.onOpen;
        this.ws.onmessage = this.onMessage;
        this.ws.onclose = this.onClose;
      }
      getWsEndpoint() {
        let url = this.url;
        if (url.startsWith("http")) {
          url = url.replace("http", "ws");
        }
        if (!url.endsWith(this.wsEndpoint)) {
          const wsEndpoint = this.wsEndpoint.startsWith("/") ? this.wsEndpoint : "/" + this.wsEndpoint;
          url = url.endsWith("/") ? url + wsEndpoint.slice(1) : url + wsEndpoint;
        }
        return url;
      }
      close() {
        this.ws.close();
      }
      get readyState() {
        switch (this.ws.readyState) {
          case 0:
            return types_1.WsReadyState.CONNECTING;
          case 1:
            return types_1.WsReadyState.OPEN;
          case 2:
            return types_1.WsReadyState.CLOSING;
          case 3:
            return types_1.WsReadyState.CLOSED;
          default:
            return types_1.WsReadyState.NONE;
        }
      }
      addEventListener(type, listener) {
        if (!this.listeners[type]) {
          this.listeners[type] = [];
        }
        this.listeners[type].push(listener);
      }
      /**
       * SubscribeBlock receives the handler for the block.
       * The handelrs shares the subscription of block.
       * @param handler
       * @return unsubscriber
       */
      subscribeBlock(handler) {
        this.newBlockSubscribes.push({
          handler
        });
        if (this.newBlockSubscribes.length === 1) {
          this.sendSubscribeBlockRpc();
        }
        return () => {
          this.newBlockSubscribes = this.newBlockSubscribes.filter((s3) => s3.handler !== handler);
        };
      }
      sendSubscribeBlockRpc() {
        if (this.readyState === types_1.WsReadyState.OPEN) {
          this.ws.send(JSON.stringify({
            jsonrpc: "2.0",
            method: "subscribe",
            params: ["tm.event='NewBlock'"],
            id: 1
          }));
        }
      }
      // Query the tx and subscribe the tx.
      traceTx(query) {
        return new Promise((resolve) => {
          this.queryTx(query).then((result) => {
            if (query instanceof Uint8Array) {
              resolve(result);
              return;
            }
            if ((result === null || result === void 0 ? void 0 : result.total_count) !== "0") {
              resolve(result);
              return;
            }
          }).catch(() => {
          });
          this.subscribeTx(query).then(resolve);
        }).then((tx) => {
          return new Promise((resolve) => {
            setTimeout(() => resolve(tx), 100);
          });
        });
      }
      subscribeTx(query) {
        if (query instanceof Uint8Array) {
          const id = this.createRandomId();
          const params = {
            query: `tm.event='Tx' AND tx.hash='${buffer_1.Buffer.from(query).toString("hex").toUpperCase()}'`
          };
          return new Promise((resolve, reject) => {
            this.txSubscribes.set(id, {
              params,
              resolver: resolve,
              rejector: reject
            });
            this.sendSubscribeTxRpc(id, params);
          });
        } else {
          const id = this.createRandomId();
          const params = {
            query: `tm.event='Tx' and ` + Object.keys(query).map((key) => {
              return {
                key,
                value: query[key]
              };
            }).map((obj) => {
              return `${obj.key}=${typeof obj.value === "string" ? `'${obj.value}'` : obj.value}`;
            }).join(" and "),
            page: "1",
            per_page: "1",
            order_by: "desc"
          };
          return new Promise((resolve, reject) => {
            this.txSubscribes.set(id, {
              params,
              resolver: resolve,
              rejector: reject
            });
            this.sendSubscribeTxRpc(id, params);
          });
        }
      }
      sendSubscribeTxRpc(id, params) {
        if (this.readyState === types_1.WsReadyState.OPEN) {
          this.ws.send(JSON.stringify({
            jsonrpc: "2.0",
            method: "subscribe",
            params,
            id
          }));
        }
      }
      queryTx(query) {
        if (query instanceof Uint8Array) {
          return this.query("tx", {
            hash: buffer_1.Buffer.from(query).toString("base64"),
            prove: false
          });
        } else {
          const params = {
            query: Object.keys(query).map((key) => {
              return {
                key,
                value: query[key]
              };
            }).map((obj) => {
              return `${obj.key}=${typeof obj.value === "string" ? `'${obj.value}'` : obj.value}`;
            }).join(" and "),
            page: "1",
            per_page: "1",
            order_by: "desc"
          };
          return this.query("tx_search", params);
        }
      }
      query(method, params) {
        const id = this.createRandomId();
        return new Promise((resolve, reject) => {
          this.pendingQueries.set(id, {
            method,
            params,
            resolver: resolve,
            rejector: reject
          });
          this.sendQueryRpc(id, method, params);
        });
      }
      sendQueryRpc(id, method, params) {
        if (this.readyState === types_1.WsReadyState.OPEN) {
          this.ws.send(JSON.stringify({
            jsonrpc: "2.0",
            method,
            params,
            id
          }));
        }
      }
      createRandomId() {
        return parseInt(Array.from({ length: 6 }).map(() => Math.floor(Math.random() * 100)).join(""));
      }
    };
    exports.TendermintTxTracer = TendermintTxTracer;
  }
});

// ../../node_modules/.pnpm/@keplr-wallet+proto-types@0.12.28/node_modules/@keplr-wallet/proto-types/agoric/swingset/msgs.js
var require_msgs = __commonJS({
  "../../node_modules/.pnpm/@keplr-wallet+proto-types@0.12.28/node_modules/@keplr-wallet/proto-types/agoric/swingset/msgs.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MsgInstallBundleResponse = exports.MsgInstallBundle = exports.MsgProvisionResponse = exports.MsgProvision = exports.MsgWalletSpendActionResponse = exports.MsgWalletSpendAction = exports.MsgWalletActionResponse = exports.MsgWalletAction = exports.MsgDeliverInboundResponse = exports.MsgDeliverInbound = exports.protobufPackage = void 0;
    var long_1 = __importDefault(require_long());
    var minimal_1 = __importDefault(require_minimal());
    exports.protobufPackage = "agoric.swingset";
    function createBaseMsgDeliverInbound() {
      return { messages: [], nums: [], ack: "0", submitter: new Uint8Array() };
    }
    exports.MsgDeliverInbound = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v5 of message.messages) {
          writer.uint32(10).string(v5);
        }
        writer.uint32(18).fork();
        for (const v5 of message.nums) {
          writer.uint64(v5);
        }
        writer.ldelim();
        if (message.ack !== "0") {
          writer.uint32(24).uint64(message.ack);
        }
        if (message.submitter.length !== 0) {
          writer.uint32(34).bytes(message.submitter);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgDeliverInbound();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.messages.push(reader.string());
              break;
            case 2:
              if ((tag & 7) === 2) {
                const end2 = reader.uint32() + reader.pos;
                while (reader.pos < end2) {
                  message.nums.push(longToString(reader.uint64()));
                }
              } else {
                message.nums.push(longToString(reader.uint64()));
              }
              break;
            case 3:
              message.ack = longToString(reader.uint64());
              break;
            case 4:
              message.submitter = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object2) {
        return {
          messages: Array.isArray(object2 === null || object2 === void 0 ? void 0 : object2.messages) ? object2.messages.map((e2) => String(e2)) : [],
          nums: Array.isArray(object2 === null || object2 === void 0 ? void 0 : object2.nums) ? object2.nums.map((e2) => String(e2)) : [],
          ack: isSet(object2.ack) ? String(object2.ack) : "0",
          submitter: isSet(object2.submitter) ? bytesFromBase64(object2.submitter) : new Uint8Array()
        };
      },
      toJSON(message) {
        const obj = {};
        if (message.messages) {
          obj.messages = message.messages.map((e2) => e2);
        } else {
          obj.messages = [];
        }
        if (message.nums) {
          obj.nums = message.nums.map((e2) => e2);
        } else {
          obj.nums = [];
        }
        message.ack !== void 0 && (obj.ack = message.ack);
        message.submitter !== void 0 && (obj.submitter = base64FromBytes(message.submitter !== void 0 ? message.submitter : new Uint8Array()));
        return obj;
      },
      fromPartial(object2) {
        var _a2, _b, _c, _d;
        const message = createBaseMsgDeliverInbound();
        message.messages = ((_a2 = object2.messages) === null || _a2 === void 0 ? void 0 : _a2.map((e2) => e2)) || [];
        message.nums = ((_b = object2.nums) === null || _b === void 0 ? void 0 : _b.map((e2) => e2)) || [];
        message.ack = (_c = object2.ack) !== null && _c !== void 0 ? _c : "0";
        message.submitter = (_d = object2.submitter) !== null && _d !== void 0 ? _d : new Uint8Array();
        return message;
      }
    };
    function createBaseMsgDeliverInboundResponse() {
      return {};
    }
    exports.MsgDeliverInboundResponse = {
      encode(_16, writer = minimal_1.default.Writer.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgDeliverInboundResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_16) {
        return {};
      },
      toJSON(_16) {
        const obj = {};
        return obj;
      },
      fromPartial(_16) {
        const message = createBaseMsgDeliverInboundResponse();
        return message;
      }
    };
    function createBaseMsgWalletAction() {
      return { owner: new Uint8Array(), action: "" };
    }
    exports.MsgWalletAction = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.owner.length !== 0) {
          writer.uint32(10).bytes(message.owner);
        }
        if (message.action !== "") {
          writer.uint32(18).string(message.action);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgWalletAction();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.owner = reader.bytes();
              break;
            case 2:
              message.action = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object2) {
        return {
          owner: isSet(object2.owner) ? bytesFromBase64(object2.owner) : new Uint8Array(),
          action: isSet(object2.action) ? String(object2.action) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        message.owner !== void 0 && (obj.owner = base64FromBytes(message.owner !== void 0 ? message.owner : new Uint8Array()));
        message.action !== void 0 && (obj.action = message.action);
        return obj;
      },
      fromPartial(object2) {
        var _a2, _b;
        const message = createBaseMsgWalletAction();
        message.owner = (_a2 = object2.owner) !== null && _a2 !== void 0 ? _a2 : new Uint8Array();
        message.action = (_b = object2.action) !== null && _b !== void 0 ? _b : "";
        return message;
      }
    };
    function createBaseMsgWalletActionResponse() {
      return {};
    }
    exports.MsgWalletActionResponse = {
      encode(_16, writer = minimal_1.default.Writer.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgWalletActionResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_16) {
        return {};
      },
      toJSON(_16) {
        const obj = {};
        return obj;
      },
      fromPartial(_16) {
        const message = createBaseMsgWalletActionResponse();
        return message;
      }
    };
    function createBaseMsgWalletSpendAction() {
      return { owner: new Uint8Array(), spendAction: "" };
    }
    exports.MsgWalletSpendAction = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.owner.length !== 0) {
          writer.uint32(10).bytes(message.owner);
        }
        if (message.spendAction !== "") {
          writer.uint32(18).string(message.spendAction);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgWalletSpendAction();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.owner = reader.bytes();
              break;
            case 2:
              message.spendAction = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object2) {
        return {
          owner: isSet(object2.owner) ? bytesFromBase64(object2.owner) : new Uint8Array(),
          spendAction: isSet(object2.spendAction) ? String(object2.spendAction) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        message.owner !== void 0 && (obj.owner = base64FromBytes(message.owner !== void 0 ? message.owner : new Uint8Array()));
        message.spendAction !== void 0 && (obj.spendAction = message.spendAction);
        return obj;
      },
      fromPartial(object2) {
        var _a2, _b;
        const message = createBaseMsgWalletSpendAction();
        message.owner = (_a2 = object2.owner) !== null && _a2 !== void 0 ? _a2 : new Uint8Array();
        message.spendAction = (_b = object2.spendAction) !== null && _b !== void 0 ? _b : "";
        return message;
      }
    };
    function createBaseMsgWalletSpendActionResponse() {
      return {};
    }
    exports.MsgWalletSpendActionResponse = {
      encode(_16, writer = minimal_1.default.Writer.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgWalletSpendActionResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_16) {
        return {};
      },
      toJSON(_16) {
        const obj = {};
        return obj;
      },
      fromPartial(_16) {
        const message = createBaseMsgWalletSpendActionResponse();
        return message;
      }
    };
    function createBaseMsgProvision() {
      return {
        nickname: "",
        address: new Uint8Array(),
        powerFlags: [],
        submitter: new Uint8Array()
      };
    }
    exports.MsgProvision = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.nickname !== "") {
          writer.uint32(10).string(message.nickname);
        }
        if (message.address.length !== 0) {
          writer.uint32(18).bytes(message.address);
        }
        for (const v5 of message.powerFlags) {
          writer.uint32(26).string(v5);
        }
        if (message.submitter.length !== 0) {
          writer.uint32(34).bytes(message.submitter);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgProvision();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.nickname = reader.string();
              break;
            case 2:
              message.address = reader.bytes();
              break;
            case 3:
              message.powerFlags.push(reader.string());
              break;
            case 4:
              message.submitter = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object2) {
        return {
          nickname: isSet(object2.nickname) ? String(object2.nickname) : "",
          address: isSet(object2.address) ? bytesFromBase64(object2.address) : new Uint8Array(),
          powerFlags: Array.isArray(object2 === null || object2 === void 0 ? void 0 : object2.powerFlags) ? object2.powerFlags.map((e2) => String(e2)) : [],
          submitter: isSet(object2.submitter) ? bytesFromBase64(object2.submitter) : new Uint8Array()
        };
      },
      toJSON(message) {
        const obj = {};
        message.nickname !== void 0 && (obj.nickname = message.nickname);
        message.address !== void 0 && (obj.address = base64FromBytes(message.address !== void 0 ? message.address : new Uint8Array()));
        if (message.powerFlags) {
          obj.powerFlags = message.powerFlags.map((e2) => e2);
        } else {
          obj.powerFlags = [];
        }
        message.submitter !== void 0 && (obj.submitter = base64FromBytes(message.submitter !== void 0 ? message.submitter : new Uint8Array()));
        return obj;
      },
      fromPartial(object2) {
        var _a2, _b, _c, _d;
        const message = createBaseMsgProvision();
        message.nickname = (_a2 = object2.nickname) !== null && _a2 !== void 0 ? _a2 : "";
        message.address = (_b = object2.address) !== null && _b !== void 0 ? _b : new Uint8Array();
        message.powerFlags = ((_c = object2.powerFlags) === null || _c === void 0 ? void 0 : _c.map((e2) => e2)) || [];
        message.submitter = (_d = object2.submitter) !== null && _d !== void 0 ? _d : new Uint8Array();
        return message;
      }
    };
    function createBaseMsgProvisionResponse() {
      return {};
    }
    exports.MsgProvisionResponse = {
      encode(_16, writer = minimal_1.default.Writer.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgProvisionResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_16) {
        return {};
      },
      toJSON(_16) {
        const obj = {};
        return obj;
      },
      fromPartial(_16) {
        const message = createBaseMsgProvisionResponse();
        return message;
      }
    };
    function createBaseMsgInstallBundle() {
      return {
        bundle: "",
        submitter: new Uint8Array(),
        compressedBundle: new Uint8Array(),
        uncompressedSize: "0"
      };
    }
    exports.MsgInstallBundle = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.bundle !== "") {
          writer.uint32(10).string(message.bundle);
        }
        if (message.submitter.length !== 0) {
          writer.uint32(18).bytes(message.submitter);
        }
        if (message.compressedBundle.length !== 0) {
          writer.uint32(26).bytes(message.compressedBundle);
        }
        if (message.uncompressedSize !== "0") {
          writer.uint32(32).int64(message.uncompressedSize);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgInstallBundle();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.bundle = reader.string();
              break;
            case 2:
              message.submitter = reader.bytes();
              break;
            case 3:
              message.compressedBundle = reader.bytes();
              break;
            case 4:
              message.uncompressedSize = longToString(reader.int64());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object2) {
        return {
          bundle: isSet(object2.bundle) ? String(object2.bundle) : "",
          submitter: isSet(object2.submitter) ? bytesFromBase64(object2.submitter) : new Uint8Array(),
          compressedBundle: isSet(object2.compressedBundle) ? bytesFromBase64(object2.compressedBundle) : new Uint8Array(),
          uncompressedSize: isSet(object2.uncompressedSize) ? String(object2.uncompressedSize) : "0"
        };
      },
      toJSON(message) {
        const obj = {};
        message.bundle !== void 0 && (obj.bundle = message.bundle);
        message.submitter !== void 0 && (obj.submitter = base64FromBytes(message.submitter !== void 0 ? message.submitter : new Uint8Array()));
        message.compressedBundle !== void 0 && (obj.compressedBundle = base64FromBytes(message.compressedBundle !== void 0 ? message.compressedBundle : new Uint8Array()));
        message.uncompressedSize !== void 0 && (obj.uncompressedSize = message.uncompressedSize);
        return obj;
      },
      fromPartial(object2) {
        var _a2, _b, _c, _d;
        const message = createBaseMsgInstallBundle();
        message.bundle = (_a2 = object2.bundle) !== null && _a2 !== void 0 ? _a2 : "";
        message.submitter = (_b = object2.submitter) !== null && _b !== void 0 ? _b : new Uint8Array();
        message.compressedBundle = (_c = object2.compressedBundle) !== null && _c !== void 0 ? _c : new Uint8Array();
        message.uncompressedSize = (_d = object2.uncompressedSize) !== null && _d !== void 0 ? _d : "0";
        return message;
      }
    };
    function createBaseMsgInstallBundleResponse() {
      return {};
    }
    exports.MsgInstallBundleResponse = {
      encode(_16, writer = minimal_1.default.Writer.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgInstallBundleResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_16) {
        return {};
      },
      toJSON(_16) {
        const obj = {};
        return obj;
      },
      fromPartial(_16) {
        const message = createBaseMsgInstallBundleResponse();
        return message;
      }
    };
    var globalThis2 = (() => {
      if (typeof globalThis2 !== "undefined")
        return globalThis2;
      if (typeof self !== "undefined")
        return self;
      if (typeof window !== "undefined")
        return window;
      if (typeof global !== "undefined")
        return global;
      throw "Unable to locate global object";
    })();
    var atob = globalThis2.atob || ((b64) => globalThis2.Buffer.from(b64, "base64").toString("binary"));
    function bytesFromBase64(b64) {
      const bin = atob(b64);
      const arr = new Uint8Array(bin.length);
      for (let i4 = 0; i4 < bin.length; ++i4) {
        arr[i4] = bin.charCodeAt(i4);
      }
      return arr;
    }
    var btoa = globalThis2.btoa || ((bin) => globalThis2.Buffer.from(bin, "binary").toString("base64"));
    function base64FromBytes(arr) {
      const bin = [];
      for (const byte of arr) {
        bin.push(String.fromCharCode(byte));
      }
      return btoa(bin.join(""));
    }
    function longToString(long) {
      return long.toString();
    }
    if (minimal_1.default.util.Long !== long_1.default) {
      minimal_1.default.util.Long = long_1.default;
      minimal_1.default.configure();
    }
    function isSet(value) {
      return value !== null && value !== void 0;
    }
  }
});

// ../../node_modules/.pnpm/@keplr-wallet+proto-types@0.12.28/node_modules/@keplr-wallet/proto-types/cosmos/base/v1beta1/coin.js
var require_coin2 = __commonJS({
  "../../node_modules/.pnpm/@keplr-wallet+proto-types@0.12.28/node_modules/@keplr-wallet/proto-types/cosmos/base/v1beta1/coin.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DecProto = exports.IntProto = exports.DecCoin = exports.Coin = exports.protobufPackage = void 0;
    var long_1 = __importDefault(require_long());
    var minimal_1 = __importDefault(require_minimal());
    exports.protobufPackage = "cosmos.base.v1beta1";
    function createBaseCoin() {
      return { denom: "", amount: "" };
    }
    exports.Coin = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.denom !== "") {
          writer.uint32(10).string(message.denom);
        }
        if (message.amount !== "") {
          writer.uint32(18).string(message.amount);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseCoin();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.denom = reader.string();
              break;
            case 2:
              message.amount = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object2) {
        return {
          denom: isSet(object2.denom) ? String(object2.denom) : "",
          amount: isSet(object2.amount) ? String(object2.amount) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        message.denom !== void 0 && (obj.denom = message.denom);
        message.amount !== void 0 && (obj.amount = message.amount);
        return obj;
      },
      fromPartial(object2) {
        var _a2, _b;
        const message = createBaseCoin();
        message.denom = (_a2 = object2.denom) !== null && _a2 !== void 0 ? _a2 : "";
        message.amount = (_b = object2.amount) !== null && _b !== void 0 ? _b : "";
        return message;
      }
    };
    function createBaseDecCoin() {
      return { denom: "", amount: "" };
    }
    exports.DecCoin = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.denom !== "") {
          writer.uint32(10).string(message.denom);
        }
        if (message.amount !== "") {
          writer.uint32(18).string(message.amount);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseDecCoin();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.denom = reader.string();
              break;
            case 2:
              message.amount = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object2) {
        return {
          denom: isSet(object2.denom) ? String(object2.denom) : "",
          amount: isSet(object2.amount) ? String(object2.amount) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        message.denom !== void 0 && (obj.denom = message.denom);
        message.amount !== void 0 && (obj.amount = message.amount);
        return obj;
      },
      fromPartial(object2) {
        var _a2, _b;
        const message = createBaseDecCoin();
        message.denom = (_a2 = object2.denom) !== null && _a2 !== void 0 ? _a2 : "";
        message.amount = (_b = object2.amount) !== null && _b !== void 0 ? _b : "";
        return message;
      }
    };
    function createBaseIntProto() {
      return { int: "" };
    }
    exports.IntProto = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.int !== "") {
          writer.uint32(10).string(message.int);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseIntProto();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.int = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object2) {
        return {
          int: isSet(object2.int) ? String(object2.int) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        message.int !== void 0 && (obj.int = message.int);
        return obj;
      },
      fromPartial(object2) {
        var _a2;
        const message = createBaseIntProto();
        message.int = (_a2 = object2.int) !== null && _a2 !== void 0 ? _a2 : "";
        return message;
      }
    };
    function createBaseDecProto() {
      return { dec: "" };
    }
    exports.DecProto = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.dec !== "") {
          writer.uint32(10).string(message.dec);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseDecProto();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.dec = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object2) {
        return {
          dec: isSet(object2.dec) ? String(object2.dec) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        message.dec !== void 0 && (obj.dec = message.dec);
        return obj;
      },
      fromPartial(object2) {
        var _a2;
        const message = createBaseDecProto();
        message.dec = (_a2 = object2.dec) !== null && _a2 !== void 0 ? _a2 : "";
        return message;
      }
    };
    if (minimal_1.default.util.Long !== long_1.default) {
      minimal_1.default.util.Long = long_1.default;
      minimal_1.default.configure();
    }
    function isSet(value) {
      return value !== null && value !== void 0;
    }
  }
});

// ../../node_modules/.pnpm/@keplr-wallet+proto-types@0.12.28/node_modules/@keplr-wallet/proto-types/cosmos/bank/v1beta1/bank.js
var require_bank = __commonJS({
  "../../node_modules/.pnpm/@keplr-wallet+proto-types@0.12.28/node_modules/@keplr-wallet/proto-types/cosmos/bank/v1beta1/bank.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Metadata = exports.DenomUnit = exports.Supply = exports.Output = exports.Input = exports.SendEnabled = exports.Params = exports.protobufPackage = void 0;
    var long_1 = __importDefault(require_long());
    var minimal_1 = __importDefault(require_minimal());
    var coin_1 = require_coin2();
    exports.protobufPackage = "cosmos.bank.v1beta1";
    function createBaseParams() {
      return { sendEnabled: [], defaultSendEnabled: false };
    }
    exports.Params = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v5 of message.sendEnabled) {
          exports.SendEnabled.encode(v5, writer.uint32(10).fork()).ldelim();
        }
        if (message.defaultSendEnabled === true) {
          writer.uint32(16).bool(message.defaultSendEnabled);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseParams();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.sendEnabled.push(exports.SendEnabled.decode(reader, reader.uint32()));
              break;
            case 2:
              message.defaultSendEnabled = reader.bool();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object2) {
        return {
          sendEnabled: Array.isArray(object2 === null || object2 === void 0 ? void 0 : object2.sendEnabled) ? object2.sendEnabled.map((e2) => exports.SendEnabled.fromJSON(e2)) : [],
          defaultSendEnabled: isSet(object2.defaultSendEnabled) ? Boolean(object2.defaultSendEnabled) : false
        };
      },
      toJSON(message) {
        const obj = {};
        if (message.sendEnabled) {
          obj.sendEnabled = message.sendEnabled.map((e2) => e2 ? exports.SendEnabled.toJSON(e2) : void 0);
        } else {
          obj.sendEnabled = [];
        }
        message.defaultSendEnabled !== void 0 && (obj.defaultSendEnabled = message.defaultSendEnabled);
        return obj;
      },
      fromPartial(object2) {
        var _a2, _b;
        const message = createBaseParams();
        message.sendEnabled = ((_a2 = object2.sendEnabled) === null || _a2 === void 0 ? void 0 : _a2.map((e2) => exports.SendEnabled.fromPartial(e2))) || [];
        message.defaultSendEnabled = (_b = object2.defaultSendEnabled) !== null && _b !== void 0 ? _b : false;
        return message;
      }
    };
    function createBaseSendEnabled() {
      return { denom: "", enabled: false };
    }
    exports.SendEnabled = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.denom !== "") {
          writer.uint32(10).string(message.denom);
        }
        if (message.enabled === true) {
          writer.uint32(16).bool(message.enabled);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseSendEnabled();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.denom = reader.string();
              break;
            case 2:
              message.enabled = reader.bool();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object2) {
        return {
          denom: isSet(object2.denom) ? String(object2.denom) : "",
          enabled: isSet(object2.enabled) ? Boolean(object2.enabled) : false
        };
      },
      toJSON(message) {
        const obj = {};
        message.denom !== void 0 && (obj.denom = message.denom);
        message.enabled !== void 0 && (obj.enabled = message.enabled);
        return obj;
      },
      fromPartial(object2) {
        var _a2, _b;
        const message = createBaseSendEnabled();
        message.denom = (_a2 = object2.denom) !== null && _a2 !== void 0 ? _a2 : "";
        message.enabled = (_b = object2.enabled) !== null && _b !== void 0 ? _b : false;
        return message;
      }
    };
    function createBaseInput() {
      return { address: "", coins: [] };
    }
    exports.Input = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.address !== "") {
          writer.uint32(10).string(message.address);
        }
        for (const v5 of message.coins) {
          coin_1.Coin.encode(v5, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseInput();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.address = reader.string();
              break;
            case 2:
              message.coins.push(coin_1.Coin.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object2) {
        return {
          address: isSet(object2.address) ? String(object2.address) : "",
          coins: Array.isArray(object2 === null || object2 === void 0 ? void 0 : object2.coins) ? object2.coins.map((e2) => coin_1.Coin.fromJSON(e2)) : []
        };
      },
      toJSON(message) {
        const obj = {};
        message.address !== void 0 && (obj.address = message.address);
        if (message.coins) {
          obj.coins = message.coins.map((e2) => e2 ? coin_1.Coin.toJSON(e2) : void 0);
        } else {
          obj.coins = [];
        }
        return obj;
      },
      fromPartial(object2) {
        var _a2, _b;
        const message = createBaseInput();
        message.address = (_a2 = object2.address) !== null && _a2 !== void 0 ? _a2 : "";
        message.coins = ((_b = object2.coins) === null || _b === void 0 ? void 0 : _b.map((e2) => coin_1.Coin.fromPartial(e2))) || [];
        return message;
      }
    };
    function createBaseOutput() {
      return { address: "", coins: [] };
    }
    exports.Output = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.address !== "") {
          writer.uint32(10).string(message.address);
        }
        for (const v5 of message.coins) {
          coin_1.Coin.encode(v5, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseOutput();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.address = reader.string();
              break;
            case 2:
              message.coins.push(coin_1.Coin.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object2) {
        return {
          address: isSet(object2.address) ? String(object2.address) : "",
          coins: Array.isArray(object2 === null || object2 === void 0 ? void 0 : object2.coins) ? object2.coins.map((e2) => coin_1.Coin.fromJSON(e2)) : []
        };
      },
      toJSON(message) {
        const obj = {};
        message.address !== void 0 && (obj.address = message.address);
        if (message.coins) {
          obj.coins = message.coins.map((e2) => e2 ? coin_1.Coin.toJSON(e2) : void 0);
        } else {
          obj.coins = [];
        }
        return obj;
      },
      fromPartial(object2) {
        var _a2, _b;
        const message = createBaseOutput();
        message.address = (_a2 = object2.address) !== null && _a2 !== void 0 ? _a2 : "";
        message.coins = ((_b = object2.coins) === null || _b === void 0 ? void 0 : _b.map((e2) => coin_1.Coin.fromPartial(e2))) || [];
        return message;
      }
    };
    function createBaseSupply() {
      return { total: [] };
    }
    exports.Supply = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v5 of message.total) {
          coin_1.Coin.encode(v5, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseSupply();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.total.push(coin_1.Coin.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object2) {
        return {
          total: Array.isArray(object2 === null || object2 === void 0 ? void 0 : object2.total) ? object2.total.map((e2) => coin_1.Coin.fromJSON(e2)) : []
        };
      },
      toJSON(message) {
        const obj = {};
        if (message.total) {
          obj.total = message.total.map((e2) => e2 ? coin_1.Coin.toJSON(e2) : void 0);
        } else {
          obj.total = [];
        }
        return obj;
      },
      fromPartial(object2) {
        var _a2;
        const message = createBaseSupply();
        message.total = ((_a2 = object2.total) === null || _a2 === void 0 ? void 0 : _a2.map((e2) => coin_1.Coin.fromPartial(e2))) || [];
        return message;
      }
    };
    function createBaseDenomUnit() {
      return { denom: "", exponent: 0, aliases: [] };
    }
    exports.DenomUnit = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.denom !== "") {
          writer.uint32(10).string(message.denom);
        }
        if (message.exponent !== 0) {
          writer.uint32(16).uint32(message.exponent);
        }
        for (const v5 of message.aliases) {
          writer.uint32(26).string(v5);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseDenomUnit();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.denom = reader.string();
              break;
            case 2:
              message.exponent = reader.uint32();
              break;
            case 3:
              message.aliases.push(reader.string());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object2) {
        return {
          denom: isSet(object2.denom) ? String(object2.denom) : "",
          exponent: isSet(object2.exponent) ? Number(object2.exponent) : 0,
          aliases: Array.isArray(object2 === null || object2 === void 0 ? void 0 : object2.aliases) ? object2.aliases.map((e2) => String(e2)) : []
        };
      },
      toJSON(message) {
        const obj = {};
        message.denom !== void 0 && (obj.denom = message.denom);
        message.exponent !== void 0 && (obj.exponent = Math.round(message.exponent));
        if (message.aliases) {
          obj.aliases = message.aliases.map((e2) => e2);
        } else {
          obj.aliases = [];
        }
        return obj;
      },
      fromPartial(object2) {
        var _a2, _b, _c;
        const message = createBaseDenomUnit();
        message.denom = (_a2 = object2.denom) !== null && _a2 !== void 0 ? _a2 : "";
        message.exponent = (_b = object2.exponent) !== null && _b !== void 0 ? _b : 0;
        message.aliases = ((_c = object2.aliases) === null || _c === void 0 ? void 0 : _c.map((e2) => e2)) || [];
        return message;
      }
    };
    function createBaseMetadata() {
      return {
        description: "",
        denomUnits: [],
        base: "",
        display: "",
        name: "",
        symbol: ""
      };
    }
    exports.Metadata = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.description !== "") {
          writer.uint32(10).string(message.description);
        }
        for (const v5 of message.denomUnits) {
          exports.DenomUnit.encode(v5, writer.uint32(18).fork()).ldelim();
        }
        if (message.base !== "") {
          writer.uint32(26).string(message.base);
        }
        if (message.display !== "") {
          writer.uint32(34).string(message.display);
        }
        if (message.name !== "") {
          writer.uint32(42).string(message.name);
        }
        if (message.symbol !== "") {
          writer.uint32(50).string(message.symbol);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMetadata();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.description = reader.string();
              break;
            case 2:
              message.denomUnits.push(exports.DenomUnit.decode(reader, reader.uint32()));
              break;
            case 3:
              message.base = reader.string();
              break;
            case 4:
              message.display = reader.string();
              break;
            case 5:
              message.name = reader.string();
              break;
            case 6:
              message.symbol = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object2) {
        return {
          description: isSet(object2.description) ? String(object2.description) : "",
          denomUnits: Array.isArray(object2 === null || object2 === void 0 ? void 0 : object2.denomUnits) ? object2.denomUnits.map((e2) => exports.DenomUnit.fromJSON(e2)) : [],
          base: isSet(object2.base) ? String(object2.base) : "",
          display: isSet(object2.display) ? String(object2.display) : "",
          name: isSet(object2.name) ? String(object2.name) : "",
          symbol: isSet(object2.symbol) ? String(object2.symbol) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        message.description !== void 0 && (obj.description = message.description);
        if (message.denomUnits) {
          obj.denomUnits = message.denomUnits.map((e2) => e2 ? exports.DenomUnit.toJSON(e2) : void 0);
        } else {
          obj.denomUnits = [];
        }
        message.base !== void 0 && (obj.base = message.base);
        message.display !== void 0 && (obj.display = message.display);
        message.name !== void 0 && (obj.name = message.name);
        message.symbol !== void 0 && (obj.symbol = message.symbol);
        return obj;
      },
      fromPartial(object2) {
        var _a2, _b, _c, _d, _e3, _f;
        const message = createBaseMetadata();
        message.description = (_a2 = object2.description) !== null && _a2 !== void 0 ? _a2 : "";
        message.denomUnits = ((_b = object2.denomUnits) === null || _b === void 0 ? void 0 : _b.map((e2) => exports.DenomUnit.fromPartial(e2))) || [];
        message.base = (_c = object2.base) !== null && _c !== void 0 ? _c : "";
        message.display = (_d = object2.display) !== null && _d !== void 0 ? _d : "";
        message.name = (_e3 = object2.name) !== null && _e3 !== void 0 ? _e3 : "";
        message.symbol = (_f = object2.symbol) !== null && _f !== void 0 ? _f : "";
        return message;
      }
    };
    if (minimal_1.default.util.Long !== long_1.default) {
      minimal_1.default.util.Long = long_1.default;
      minimal_1.default.configure();
    }
    function isSet(value) {
      return value !== null && value !== void 0;
    }
  }
});

// ../../node_modules/.pnpm/@keplr-wallet+proto-types@0.12.28/node_modules/@keplr-wallet/proto-types/cosmos/bank/v1beta1/tx.js
var require_tx = __commonJS({
  "../../node_modules/.pnpm/@keplr-wallet+proto-types@0.12.28/node_modules/@keplr-wallet/proto-types/cosmos/bank/v1beta1/tx.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MsgMultiSendResponse = exports.MsgMultiSend = exports.MsgSendResponse = exports.MsgSend = exports.protobufPackage = void 0;
    var long_1 = __importDefault(require_long());
    var minimal_1 = __importDefault(require_minimal());
    var coin_1 = require_coin2();
    var bank_1 = require_bank();
    exports.protobufPackage = "cosmos.bank.v1beta1";
    function createBaseMsgSend() {
      return { fromAddress: "", toAddress: "", amount: [] };
    }
    exports.MsgSend = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.fromAddress !== "") {
          writer.uint32(10).string(message.fromAddress);
        }
        if (message.toAddress !== "") {
          writer.uint32(18).string(message.toAddress);
        }
        for (const v5 of message.amount) {
          coin_1.Coin.encode(v5, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgSend();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.fromAddress = reader.string();
              break;
            case 2:
              message.toAddress = reader.string();
              break;
            case 3:
              message.amount.push(coin_1.Coin.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object2) {
        return {
          fromAddress: isSet(object2.fromAddress) ? String(object2.fromAddress) : "",
          toAddress: isSet(object2.toAddress) ? String(object2.toAddress) : "",
          amount: Array.isArray(object2 === null || object2 === void 0 ? void 0 : object2.amount) ? object2.amount.map((e2) => coin_1.Coin.fromJSON(e2)) : []
        };
      },
      toJSON(message) {
        const obj = {};
        message.fromAddress !== void 0 && (obj.fromAddress = message.fromAddress);
        message.toAddress !== void 0 && (obj.toAddress = message.toAddress);
        if (message.amount) {
          obj.amount = message.amount.map((e2) => e2 ? coin_1.Coin.toJSON(e2) : void 0);
        } else {
          obj.amount = [];
        }
        return obj;
      },
      fromPartial(object2) {
        var _a2, _b, _c;
        const message = createBaseMsgSend();
        message.fromAddress = (_a2 = object2.fromAddress) !== null && _a2 !== void 0 ? _a2 : "";
        message.toAddress = (_b = object2.toAddress) !== null && _b !== void 0 ? _b : "";
        message.amount = ((_c = object2.amount) === null || _c === void 0 ? void 0 : _c.map((e2) => coin_1.Coin.fromPartial(e2))) || [];
        return message;
      }
    };
    function createBaseMsgSendResponse() {
      return {};
    }
    exports.MsgSendResponse = {
      encode(_16, writer = minimal_1.default.Writer.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgSendResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_16) {
        return {};
      },
      toJSON(_16) {
        const obj = {};
        return obj;
      },
      fromPartial(_16) {
        const message = createBaseMsgSendResponse();
        return message;
      }
    };
    function createBaseMsgMultiSend() {
      return { inputs: [], outputs: [] };
    }
    exports.MsgMultiSend = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v5 of message.inputs) {
          bank_1.Input.encode(v5, writer.uint32(10).fork()).ldelim();
        }
        for (const v5 of message.outputs) {
          bank_1.Output.encode(v5, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgMultiSend();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.inputs.push(bank_1.Input.decode(reader, reader.uint32()));
              break;
            case 2:
              message.outputs.push(bank_1.Output.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object2) {
        return {
          inputs: Array.isArray(object2 === null || object2 === void 0 ? void 0 : object2.inputs) ? object2.inputs.map((e2) => bank_1.Input.fromJSON(e2)) : [],
          outputs: Array.isArray(object2 === null || object2 === void 0 ? void 0 : object2.outputs) ? object2.outputs.map((e2) => bank_1.Output.fromJSON(e2)) : []
        };
      },
      toJSON(message) {
        const obj = {};
        if (message.inputs) {
          obj.inputs = message.inputs.map((e2) => e2 ? bank_1.Input.toJSON(e2) : void 0);
        } else {
          obj.inputs = [];
        }
        if (message.outputs) {
          obj.outputs = message.outputs.map((e2) => e2 ? bank_1.Output.toJSON(e2) : void 0);
        } else {
          obj.outputs = [];
        }
        return obj;
      },
      fromPartial(object2) {
        var _a2, _b;
        const message = createBaseMsgMultiSend();
        message.inputs = ((_a2 = object2.inputs) === null || _a2 === void 0 ? void 0 : _a2.map((e2) => bank_1.Input.fromPartial(e2))) || [];
        message.outputs = ((_b = object2.outputs) === null || _b === void 0 ? void 0 : _b.map((e2) => bank_1.Output.fromPartial(e2))) || [];
        return message;
      }
    };
    function createBaseMsgMultiSendResponse() {
      return {};
    }
    exports.MsgMultiSendResponse = {
      encode(_16, writer = minimal_1.default.Writer.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgMultiSendResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_16) {
        return {};
      },
      toJSON(_16) {
        const obj = {};
        return obj;
      },
      fromPartial(_16) {
        const message = createBaseMsgMultiSendResponse();
        return message;
      }
    };
    if (minimal_1.default.util.Long !== long_1.default) {
      minimal_1.default.util.Long = long_1.default;
      minimal_1.default.configure();
    }
    function isSet(value) {
      return value !== null && value !== void 0;
    }
  }
});

// ../../node_modules/.pnpm/@keplr-wallet+proto-types@0.12.28/node_modules/@keplr-wallet/proto-types/google/protobuf/timestamp.js
var require_timestamp = __commonJS({
  "../../node_modules/.pnpm/@keplr-wallet+proto-types@0.12.28/node_modules/@keplr-wallet/proto-types/google/protobuf/timestamp.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Timestamp = exports.protobufPackage = void 0;
    var long_1 = __importDefault(require_long());
    var minimal_1 = __importDefault(require_minimal());
    exports.protobufPackage = "google.protobuf";
    function createBaseTimestamp() {
      return { seconds: "0", nanos: 0 };
    }
    exports.Timestamp = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.seconds !== "0") {
          writer.uint32(8).int64(message.seconds);
        }
        if (message.nanos !== 0) {
          writer.uint32(16).int32(message.nanos);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseTimestamp();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.seconds = longToString(reader.int64());
              break;
            case 2:
              message.nanos = reader.int32();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object2) {
        return {
          seconds: isSet(object2.seconds) ? String(object2.seconds) : "0",
          nanos: isSet(object2.nanos) ? Number(object2.nanos) : 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.seconds !== void 0 && (obj.seconds = message.seconds);
        message.nanos !== void 0 && (obj.nanos = Math.round(message.nanos));
        return obj;
      },
      fromPartial(object2) {
        var _a2, _b;
        const message = createBaseTimestamp();
        message.seconds = (_a2 = object2.seconds) !== null && _a2 !== void 0 ? _a2 : "0";
        message.nanos = (_b = object2.nanos) !== null && _b !== void 0 ? _b : 0;
        return message;
      }
    };
    function longToString(long) {
      return long.toString();
    }
    if (minimal_1.default.util.Long !== long_1.default) {
      minimal_1.default.util.Long = long_1.default;
      minimal_1.default.configure();
    }
    function isSet(value) {
      return value !== null && value !== void 0;
    }
  }
});

// ../../node_modules/.pnpm/@keplr-wallet+proto-types@0.12.28/node_modules/@keplr-wallet/proto-types/tendermint/crypto/proof.js
var require_proof = __commonJS({
  "../../node_modules/.pnpm/@keplr-wallet+proto-types@0.12.28/node_modules/@keplr-wallet/proto-types/tendermint/crypto/proof.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ProofOps = exports.ProofOp = exports.DominoOp = exports.ValueOp = exports.Proof = exports.protobufPackage = void 0;
    var long_1 = __importDefault(require_long());
    var minimal_1 = __importDefault(require_minimal());
    exports.protobufPackage = "tendermint.crypto";
    function createBaseProof() {
      return { total: "0", index: "0", leafHash: new Uint8Array(), aunts: [] };
    }
    exports.Proof = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.total !== "0") {
          writer.uint32(8).int64(message.total);
        }
        if (message.index !== "0") {
          writer.uint32(16).int64(message.index);
        }
        if (message.leafHash.length !== 0) {
          writer.uint32(26).bytes(message.leafHash);
        }
        for (const v5 of message.aunts) {
          writer.uint32(34).bytes(v5);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseProof();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.total = longToString(reader.int64());
              break;
            case 2:
              message.index = longToString(reader.int64());
              break;
            case 3:
              message.leafHash = reader.bytes();
              break;
            case 4:
              message.aunts.push(reader.bytes());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object2) {
        return {
          total: isSet(object2.total) ? String(object2.total) : "0",
          index: isSet(object2.index) ? String(object2.index) : "0",
          leafHash: isSet(object2.leafHash) ? bytesFromBase64(object2.leafHash) : new Uint8Array(),
          aunts: Array.isArray(object2 === null || object2 === void 0 ? void 0 : object2.aunts) ? object2.aunts.map((e2) => bytesFromBase64(e2)) : []
        };
      },
      toJSON(message) {
        const obj = {};
        message.total !== void 0 && (obj.total = message.total);
        message.index !== void 0 && (obj.index = message.index);
        message.leafHash !== void 0 && (obj.leafHash = base64FromBytes(message.leafHash !== void 0 ? message.leafHash : new Uint8Array()));
        if (message.aunts) {
          obj.aunts = message.aunts.map((e2) => base64FromBytes(e2 !== void 0 ? e2 : new Uint8Array()));
        } else {
          obj.aunts = [];
        }
        return obj;
      },
      fromPartial(object2) {
        var _a2, _b, _c, _d;
        const message = createBaseProof();
        message.total = (_a2 = object2.total) !== null && _a2 !== void 0 ? _a2 : "0";
        message.index = (_b = object2.index) !== null && _b !== void 0 ? _b : "0";
        message.leafHash = (_c = object2.leafHash) !== null && _c !== void 0 ? _c : new Uint8Array();
        message.aunts = ((_d = object2.aunts) === null || _d === void 0 ? void 0 : _d.map((e2) => e2)) || [];
        return message;
      }
    };
    function createBaseValueOp() {
      return { key: new Uint8Array(), proof: void 0 };
    }
    exports.ValueOp = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.key.length !== 0) {
          writer.uint32(10).bytes(message.key);
        }
        if (message.proof !== void 0) {
          exports.Proof.encode(message.proof, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseValueOp();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.key = reader.bytes();
              break;
            case 2:
              message.proof = exports.Proof.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object2) {
        return {
          key: isSet(object2.key) ? bytesFromBase64(object2.key) : new Uint8Array(),
          proof: isSet(object2.proof) ? exports.Proof.fromJSON(object2.proof) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.key !== void 0 && (obj.key = base64FromBytes(message.key !== void 0 ? message.key : new Uint8Array()));
        message.proof !== void 0 && (obj.proof = message.proof ? exports.Proof.toJSON(message.proof) : void 0);
        return obj;
      },
      fromPartial(object2) {
        var _a2;
        const message = createBaseValueOp();
        message.key = (_a2 = object2.key) !== null && _a2 !== void 0 ? _a2 : new Uint8Array();
        message.proof = object2.proof !== void 0 && object2.proof !== null ? exports.Proof.fromPartial(object2.proof) : void 0;
        return message;
      }
    };
    function createBaseDominoOp() {
      return { key: "", input: "", output: "" };
    }
    exports.DominoOp = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.key !== "") {
          writer.uint32(10).string(message.key);
        }
        if (message.input !== "") {
          writer.uint32(18).string(message.input);
        }
        if (message.output !== "") {
          writer.uint32(26).string(message.output);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseDominoOp();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.key = reader.string();
              break;
            case 2:
              message.input = reader.string();
              break;
            case 3:
              message.output = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object2) {
        return {
          key: isSet(object2.key) ? String(object2.key) : "",
          input: isSet(object2.input) ? String(object2.input) : "",
          output: isSet(object2.output) ? String(object2.output) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        message.key !== void 0 && (obj.key = message.key);
        message.input !== void 0 && (obj.input = message.input);
        message.output !== void 0 && (obj.output = message.output);
        return obj;
      },
      fromPartial(object2) {
        var _a2, _b, _c;
        const message = createBaseDominoOp();
        message.key = (_a2 = object2.key) !== null && _a2 !== void 0 ? _a2 : "";
        message.input = (_b = object2.input) !== null && _b !== void 0 ? _b : "";
        message.output = (_c = object2.output) !== null && _c !== void 0 ? _c : "";
        return message;
      }
    };
    function createBaseProofOp() {
      return { type: "", key: new Uint8Array(), data: new Uint8Array() };
    }
    exports.ProofOp = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.type !== "") {
          writer.uint32(10).string(message.type);
        }
        if (message.key.length !== 0) {
          writer.uint32(18).bytes(message.key);
        }
        if (message.data.length !== 0) {
          writer.uint32(26).bytes(message.data);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseProofOp();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.type = reader.string();
              break;
            case 2:
              message.key = reader.bytes();
              break;
            case 3:
              message.data = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object2) {
        return {
          type: isSet(object2.type) ? String(object2.type) : "",
          key: isSet(object2.key) ? bytesFromBase64(object2.key) : new Uint8Array(),
          data: isSet(object2.data) ? bytesFromBase64(object2.data) : new Uint8Array()
        };
      },
      toJSON(message) {
        const obj = {};
        message.type !== void 0 && (obj.type = message.type);
        message.key !== void 0 && (obj.key = base64FromBytes(message.key !== void 0 ? message.key : new Uint8Array()));
        message.data !== void 0 && (obj.data = base64FromBytes(message.data !== void 0 ? message.data : new Uint8Array()));
        return obj;
      },
      fromPartial(object2) {
        var _a2, _b, _c;
        const message = createBaseProofOp();
        message.type = (_a2 = object2.type) !== null && _a2 !== void 0 ? _a2 : "";
        message.key = (_b = object2.key) !== null && _b !== void 0 ? _b : new Uint8Array();
        message.data = (_c = object2.data) !== null && _c !== void 0 ? _c : new Uint8Array();
        return message;
      }
    };
    function createBaseProofOps() {
      return { ops: [] };
    }
    exports.ProofOps = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v5 of message.ops) {
          exports.ProofOp.encode(v5, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseProofOps();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.ops.push(exports.ProofOp.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object2) {
        return {
          ops: Array.isArray(object2 === null || object2 === void 0 ? void 0 : object2.ops) ? object2.ops.map((e2) => exports.ProofOp.fromJSON(e2)) : []
        };
      },
      toJSON(message) {
        const obj = {};
        if (message.ops) {
          obj.ops = message.ops.map((e2) => e2 ? exports.ProofOp.toJSON(e2) : void 0);
        } else {
          obj.ops = [];
        }
        return obj;
      },
      fromPartial(object2) {
        var _a2;
        const message = createBaseProofOps();
        message.ops = ((_a2 = object2.ops) === null || _a2 === void 0 ? void 0 : _a2.map((e2) => exports.ProofOp.fromPartial(e2))) || [];
        return message;
      }
    };
    var globalThis2 = (() => {
      if (typeof globalThis2 !== "undefined")
        return globalThis2;
      if (typeof self !== "undefined")
        return self;
      if (typeof window !== "undefined")
        return window;
      if (typeof global !== "undefined")
        return global;
      throw "Unable to locate global object";
    })();
    var atob = globalThis2.atob || ((b64) => globalThis2.Buffer.from(b64, "base64").toString("binary"));
    function bytesFromBase64(b64) {
      const bin = atob(b64);
      const arr = new Uint8Array(bin.length);
      for (let i4 = 0; i4 < bin.length; ++i4) {
        arr[i4] = bin.charCodeAt(i4);
      }
      return arr;
    }
    var btoa = globalThis2.btoa || ((bin) => globalThis2.Buffer.from(bin, "binary").toString("base64"));
    function base64FromBytes(arr) {
      const bin = [];
      for (const byte of arr) {
        bin.push(String.fromCharCode(byte));
      }
      return btoa(bin.join(""));
    }
    function longToString(long) {
      return long.toString();
    }
    if (minimal_1.default.util.Long !== long_1.default) {
      minimal_1.default.util.Long = long_1.default;
      minimal_1.default.configure();
    }
    function isSet(value) {
      return value !== null && value !== void 0;
    }
  }
});

// ../../node_modules/.pnpm/@keplr-wallet+proto-types@0.12.28/node_modules/@keplr-wallet/proto-types/tendermint/version/types.js
var require_types3 = __commonJS({
  "../../node_modules/.pnpm/@keplr-wallet+proto-types@0.12.28/node_modules/@keplr-wallet/proto-types/tendermint/version/types.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Consensus = exports.App = exports.protobufPackage = void 0;
    var long_1 = __importDefault(require_long());
    var minimal_1 = __importDefault(require_minimal());
    exports.protobufPackage = "tendermint.version";
    function createBaseApp() {
      return { protocol: "0", software: "" };
    }
    exports.App = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.protocol !== "0") {
          writer.uint32(8).uint64(message.protocol);
        }
        if (message.software !== "") {
          writer.uint32(18).string(message.software);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseApp();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.protocol = longToString(reader.uint64());
              break;
            case 2:
              message.software = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object2) {
        return {
          protocol: isSet(object2.protocol) ? String(object2.protocol) : "0",
          software: isSet(object2.software) ? String(object2.software) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        message.protocol !== void 0 && (obj.protocol = message.protocol);
        message.software !== void 0 && (obj.software = message.software);
        return obj;
      },
      fromPartial(object2) {
        var _a2, _b;
        const message = createBaseApp();
        message.protocol = (_a2 = object2.protocol) !== null && _a2 !== void 0 ? _a2 : "0";
        message.software = (_b = object2.software) !== null && _b !== void 0 ? _b : "";
        return message;
      }
    };
    function createBaseConsensus() {
      return { block: "0", app: "0" };
    }
    exports.Consensus = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.block !== "0") {
          writer.uint32(8).uint64(message.block);
        }
        if (message.app !== "0") {
          writer.uint32(16).uint64(message.app);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseConsensus();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.block = longToString(reader.uint64());
              break;
            case 2:
              message.app = longToString(reader.uint64());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object2) {
        return {
          block: isSet(object2.block) ? String(object2.block) : "0",
          app: isSet(object2.app) ? String(object2.app) : "0"
        };
      },
      toJSON(message) {
        const obj = {};
        message.block !== void 0 && (obj.block = message.block);
        message.app !== void 0 && (obj.app = message.app);
        return obj;
      },
      fromPartial(object2) {
        var _a2, _b;
        const message = createBaseConsensus();
        message.block = (_a2 = object2.block) !== null && _a2 !== void 0 ? _a2 : "0";
        message.app = (_b = object2.app) !== null && _b !== void 0 ? _b : "0";
        return message;
      }
    };
    function longToString(long) {
      return long.toString();
    }
    if (minimal_1.default.util.Long !== long_1.default) {
      minimal_1.default.util.Long = long_1.default;
      minimal_1.default.configure();
    }
    function isSet(value) {
      return value !== null && value !== void 0;
    }
  }
});

// ../../node_modules/.pnpm/@keplr-wallet+proto-types@0.12.28/node_modules/@keplr-wallet/proto-types/tendermint/crypto/keys.js
var require_keys = __commonJS({
  "../../node_modules/.pnpm/@keplr-wallet+proto-types@0.12.28/node_modules/@keplr-wallet/proto-types/tendermint/crypto/keys.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PublicKey = exports.protobufPackage = void 0;
    var long_1 = __importDefault(require_long());
    var minimal_1 = __importDefault(require_minimal());
    exports.protobufPackage = "tendermint.crypto";
    function createBasePublicKey() {
      return { ed25519: void 0, secp256k1: void 0 };
    }
    exports.PublicKey = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.ed25519 !== void 0) {
          writer.uint32(10).bytes(message.ed25519);
        }
        if (message.secp256k1 !== void 0) {
          writer.uint32(18).bytes(message.secp256k1);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBasePublicKey();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.ed25519 = reader.bytes();
              break;
            case 2:
              message.secp256k1 = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object2) {
        return {
          ed25519: isSet(object2.ed25519) ? bytesFromBase64(object2.ed25519) : void 0,
          secp256k1: isSet(object2.secp256k1) ? bytesFromBase64(object2.secp256k1) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.ed25519 !== void 0 && (obj.ed25519 = message.ed25519 !== void 0 ? base64FromBytes(message.ed25519) : void 0);
        message.secp256k1 !== void 0 && (obj.secp256k1 = message.secp256k1 !== void 0 ? base64FromBytes(message.secp256k1) : void 0);
        return obj;
      },
      fromPartial(object2) {
        var _a2, _b;
        const message = createBasePublicKey();
        message.ed25519 = (_a2 = object2.ed25519) !== null && _a2 !== void 0 ? _a2 : void 0;
        message.secp256k1 = (_b = object2.secp256k1) !== null && _b !== void 0 ? _b : void 0;
        return message;
      }
    };
    var globalThis2 = (() => {
      if (typeof globalThis2 !== "undefined")
        return globalThis2;
      if (typeof self !== "undefined")
        return self;
      if (typeof window !== "undefined")
        return window;
      if (typeof global !== "undefined")
        return global;
      throw "Unable to locate global object";
    })();
    var atob = globalThis2.atob || ((b64) => globalThis2.Buffer.from(b64, "base64").toString("binary"));
    function bytesFromBase64(b64) {
      const bin = atob(b64);
      const arr = new Uint8Array(bin.length);
      for (let i4 = 0; i4 < bin.length; ++i4) {
        arr[i4] = bin.charCodeAt(i4);
      }
      return arr;
    }
    var btoa = globalThis2.btoa || ((bin) => globalThis2.Buffer.from(bin, "binary").toString("base64"));
    function base64FromBytes(arr) {
      const bin = [];
      for (const byte of arr) {
        bin.push(String.fromCharCode(byte));
      }
      return btoa(bin.join(""));
    }
    if (minimal_1.default.util.Long !== long_1.default) {
      minimal_1.default.util.Long = long_1.default;
      minimal_1.default.configure();
    }
    function isSet(value) {
      return value !== null && value !== void 0;
    }
  }
});

// ../../node_modules/.pnpm/@keplr-wallet+proto-types@0.12.28/node_modules/@keplr-wallet/proto-types/tendermint/types/validator.js
var require_validator = __commonJS({
  "../../node_modules/.pnpm/@keplr-wallet+proto-types@0.12.28/node_modules/@keplr-wallet/proto-types/tendermint/types/validator.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SimpleValidator = exports.Validator = exports.ValidatorSet = exports.protobufPackage = void 0;
    var long_1 = __importDefault(require_long());
    var minimal_1 = __importDefault(require_minimal());
    var keys_1 = require_keys();
    exports.protobufPackage = "tendermint.types";
    function createBaseValidatorSet() {
      return { validators: [], proposer: void 0, totalVotingPower: "0" };
    }
    exports.ValidatorSet = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v5 of message.validators) {
          exports.Validator.encode(v5, writer.uint32(10).fork()).ldelim();
        }
        if (message.proposer !== void 0) {
          exports.Validator.encode(message.proposer, writer.uint32(18).fork()).ldelim();
        }
        if (message.totalVotingPower !== "0") {
          writer.uint32(24).int64(message.totalVotingPower);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseValidatorSet();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.validators.push(exports.Validator.decode(reader, reader.uint32()));
              break;
            case 2:
              message.proposer = exports.Validator.decode(reader, reader.uint32());
              break;
            case 3:
              message.totalVotingPower = longToString(reader.int64());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object2) {
        return {
          validators: Array.isArray(object2 === null || object2 === void 0 ? void 0 : object2.validators) ? object2.validators.map((e2) => exports.Validator.fromJSON(e2)) : [],
          proposer: isSet(object2.proposer) ? exports.Validator.fromJSON(object2.proposer) : void 0,
          totalVotingPower: isSet(object2.totalVotingPower) ? String(object2.totalVotingPower) : "0"
        };
      },
      toJSON(message) {
        const obj = {};
        if (message.validators) {
          obj.validators = message.validators.map((e2) => e2 ? exports.Validator.toJSON(e2) : void 0);
        } else {
          obj.validators = [];
        }
        message.proposer !== void 0 && (obj.proposer = message.proposer ? exports.Validator.toJSON(message.proposer) : void 0);
        message.totalVotingPower !== void 0 && (obj.totalVotingPower = message.totalVotingPower);
        return obj;
      },
      fromPartial(object2) {
        var _a2, _b;
        const message = createBaseValidatorSet();
        message.validators = ((_a2 = object2.validators) === null || _a2 === void 0 ? void 0 : _a2.map((e2) => exports.Validator.fromPartial(e2))) || [];
        message.proposer = object2.proposer !== void 0 && object2.proposer !== null ? exports.Validator.fromPartial(object2.proposer) : void 0;
        message.totalVotingPower = (_b = object2.totalVotingPower) !== null && _b !== void 0 ? _b : "0";
        return message;
      }
    };
    function createBaseValidator() {
      return {
        address: new Uint8Array(),
        pubKey: void 0,
        votingPower: "0",
        proposerPriority: "0"
      };
    }
    exports.Validator = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.address.length !== 0) {
          writer.uint32(10).bytes(message.address);
        }
        if (message.pubKey !== void 0) {
          keys_1.PublicKey.encode(message.pubKey, writer.uint32(18).fork()).ldelim();
        }
        if (message.votingPower !== "0") {
          writer.uint32(24).int64(message.votingPower);
        }
        if (message.proposerPriority !== "0") {
          writer.uint32(32).int64(message.proposerPriority);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseValidator();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.address = reader.bytes();
              break;
            case 2:
              message.pubKey = keys_1.PublicKey.decode(reader, reader.uint32());
              break;
            case 3:
              message.votingPower = longToString(reader.int64());
              break;
            case 4:
              message.proposerPriority = longToString(reader.int64());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object2) {
        return {
          address: isSet(object2.address) ? bytesFromBase64(object2.address) : new Uint8Array(),
          pubKey: isSet(object2.pubKey) ? keys_1.PublicKey.fromJSON(object2.pubKey) : void 0,
          votingPower: isSet(object2.votingPower) ? String(object2.votingPower) : "0",
          proposerPriority: isSet(object2.proposerPriority) ? String(object2.proposerPriority) : "0"
        };
      },
      toJSON(message) {
        const obj = {};
        message.address !== void 0 && (obj.address = base64FromBytes(message.address !== void 0 ? message.address : new Uint8Array()));
        message.pubKey !== void 0 && (obj.pubKey = message.pubKey ? keys_1.PublicKey.toJSON(message.pubKey) : void 0);
        message.votingPower !== void 0 && (obj.votingPower = message.votingPower);
        message.proposerPriority !== void 0 && (obj.proposerPriority = message.proposerPriority);
        return obj;
      },
      fromPartial(object2) {
        var _a2, _b, _c;
        const message = createBaseValidator();
        message.address = (_a2 = object2.address) !== null && _a2 !== void 0 ? _a2 : new Uint8Array();
        message.pubKey = object2.pubKey !== void 0 && object2.pubKey !== null ? keys_1.PublicKey.fromPartial(object2.pubKey) : void 0;
        message.votingPower = (_b = object2.votingPower) !== null && _b !== void 0 ? _b : "0";
        message.proposerPriority = (_c = object2.proposerPriority) !== null && _c !== void 0 ? _c : "0";
        return message;
      }
    };
    function createBaseSimpleValidator() {
      return { pubKey: void 0, votingPower: "0" };
    }
    exports.SimpleValidator = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.pubKey !== void 0) {
          keys_1.PublicKey.encode(message.pubKey, writer.uint32(10).fork()).ldelim();
        }
        if (message.votingPower !== "0") {
          writer.uint32(16).int64(message.votingPower);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseSimpleValidator();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.pubKey = keys_1.PublicKey.decode(reader, reader.uint32());
              break;
            case 2:
              message.votingPower = longToString(reader.int64());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object2) {
        return {
          pubKey: isSet(object2.pubKey) ? keys_1.PublicKey.fromJSON(object2.pubKey) : void 0,
          votingPower: isSet(object2.votingPower) ? String(object2.votingPower) : "0"
        };
      },
      toJSON(message) {
        const obj = {};
        message.pubKey !== void 0 && (obj.pubKey = message.pubKey ? keys_1.PublicKey.toJSON(message.pubKey) : void 0);
        message.votingPower !== void 0 && (obj.votingPower = message.votingPower);
        return obj;
      },
      fromPartial(object2) {
        var _a2;
        const message = createBaseSimpleValidator();
        message.pubKey = object2.pubKey !== void 0 && object2.pubKey !== null ? keys_1.PublicKey.fromPartial(object2.pubKey) : void 0;
        message.votingPower = (_a2 = object2.votingPower) !== null && _a2 !== void 0 ? _a2 : "0";
        return message;
      }
    };
    var globalThis2 = (() => {
      if (typeof globalThis2 !== "undefined")
        return globalThis2;
      if (typeof self !== "undefined")
        return self;
      if (typeof window !== "undefined")
        return window;
      if (typeof global !== "undefined")
        return global;
      throw "Unable to locate global object";
    })();
    var atob = globalThis2.atob || ((b64) => globalThis2.Buffer.from(b64, "base64").toString("binary"));
    function bytesFromBase64(b64) {
      const bin = atob(b64);
      const arr = new Uint8Array(bin.length);
      for (let i4 = 0; i4 < bin.length; ++i4) {
        arr[i4] = bin.charCodeAt(i4);
      }
      return arr;
    }
    var btoa = globalThis2.btoa || ((bin) => globalThis2.Buffer.from(bin, "binary").toString("base64"));
    function base64FromBytes(arr) {
      const bin = [];
      for (const byte of arr) {
        bin.push(String.fromCharCode(byte));
      }
      return btoa(bin.join(""));
    }
    function longToString(long) {
      return long.toString();
    }
    if (minimal_1.default.util.Long !== long_1.default) {
      minimal_1.default.util.Long = long_1.default;
      minimal_1.default.configure();
    }
    function isSet(value) {
      return value !== null && value !== void 0;
    }
  }
});

// ../../node_modules/.pnpm/@keplr-wallet+proto-types@0.12.28/node_modules/@keplr-wallet/proto-types/tendermint/types/types.js
var require_types4 = __commonJS({
  "../../node_modules/.pnpm/@keplr-wallet+proto-types@0.12.28/node_modules/@keplr-wallet/proto-types/tendermint/types/types.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TxProof = exports.BlockMeta = exports.LightBlock = exports.SignedHeader = exports.Proposal = exports.CommitSig = exports.Commit = exports.Vote = exports.Data = exports.Header = exports.BlockID = exports.Part = exports.PartSetHeader = exports.signedMsgTypeToJSON = exports.signedMsgTypeFromJSON = exports.SignedMsgType = exports.blockIDFlagToJSON = exports.blockIDFlagFromJSON = exports.BlockIDFlag = exports.protobufPackage = void 0;
    var long_1 = __importDefault(require_long());
    var minimal_1 = __importDefault(require_minimal());
    var timestamp_1 = require_timestamp();
    var proof_1 = require_proof();
    var types_1 = require_types3();
    var validator_1 = require_validator();
    exports.protobufPackage = "tendermint.types";
    var BlockIDFlag;
    (function(BlockIDFlag2) {
      BlockIDFlag2[BlockIDFlag2["BLOCK_ID_FLAG_UNKNOWN"] = 0] = "BLOCK_ID_FLAG_UNKNOWN";
      BlockIDFlag2[BlockIDFlag2["BLOCK_ID_FLAG_ABSENT"] = 1] = "BLOCK_ID_FLAG_ABSENT";
      BlockIDFlag2[BlockIDFlag2["BLOCK_ID_FLAG_COMMIT"] = 2] = "BLOCK_ID_FLAG_COMMIT";
      BlockIDFlag2[BlockIDFlag2["BLOCK_ID_FLAG_NIL"] = 3] = "BLOCK_ID_FLAG_NIL";
      BlockIDFlag2[BlockIDFlag2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(BlockIDFlag = exports.BlockIDFlag || (exports.BlockIDFlag = {}));
    function blockIDFlagFromJSON(object2) {
      switch (object2) {
        case 0:
        case "BLOCK_ID_FLAG_UNKNOWN":
          return BlockIDFlag.BLOCK_ID_FLAG_UNKNOWN;
        case 1:
        case "BLOCK_ID_FLAG_ABSENT":
          return BlockIDFlag.BLOCK_ID_FLAG_ABSENT;
        case 2:
        case "BLOCK_ID_FLAG_COMMIT":
          return BlockIDFlag.BLOCK_ID_FLAG_COMMIT;
        case 3:
        case "BLOCK_ID_FLAG_NIL":
          return BlockIDFlag.BLOCK_ID_FLAG_NIL;
        case -1:
        case "UNRECOGNIZED":
        default:
          return BlockIDFlag.UNRECOGNIZED;
      }
    }
    exports.blockIDFlagFromJSON = blockIDFlagFromJSON;
    function blockIDFlagToJSON(object2) {
      switch (object2) {
        case BlockIDFlag.BLOCK_ID_FLAG_UNKNOWN:
          return "BLOCK_ID_FLAG_UNKNOWN";
        case BlockIDFlag.BLOCK_ID_FLAG_ABSENT:
          return "BLOCK_ID_FLAG_ABSENT";
        case BlockIDFlag.BLOCK_ID_FLAG_COMMIT:
          return "BLOCK_ID_FLAG_COMMIT";
        case BlockIDFlag.BLOCK_ID_FLAG_NIL:
          return "BLOCK_ID_FLAG_NIL";
        default:
          return "UNKNOWN";
      }
    }
    exports.blockIDFlagToJSON = blockIDFlagToJSON;
    var SignedMsgType;
    (function(SignedMsgType2) {
      SignedMsgType2[SignedMsgType2["SIGNED_MSG_TYPE_UNKNOWN"] = 0] = "SIGNED_MSG_TYPE_UNKNOWN";
      SignedMsgType2[SignedMsgType2["SIGNED_MSG_TYPE_PREVOTE"] = 1] = "SIGNED_MSG_TYPE_PREVOTE";
      SignedMsgType2[SignedMsgType2["SIGNED_MSG_TYPE_PRECOMMIT"] = 2] = "SIGNED_MSG_TYPE_PRECOMMIT";
      SignedMsgType2[SignedMsgType2["SIGNED_MSG_TYPE_PROPOSAL"] = 32] = "SIGNED_MSG_TYPE_PROPOSAL";
      SignedMsgType2[SignedMsgType2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(SignedMsgType = exports.SignedMsgType || (exports.SignedMsgType = {}));
    function signedMsgTypeFromJSON(object2) {
      switch (object2) {
        case 0:
        case "SIGNED_MSG_TYPE_UNKNOWN":
          return SignedMsgType.SIGNED_MSG_TYPE_UNKNOWN;
        case 1:
        case "SIGNED_MSG_TYPE_PREVOTE":
          return SignedMsgType.SIGNED_MSG_TYPE_PREVOTE;
        case 2:
        case "SIGNED_MSG_TYPE_PRECOMMIT":
          return SignedMsgType.SIGNED_MSG_TYPE_PRECOMMIT;
        case 32:
        case "SIGNED_MSG_TYPE_PROPOSAL":
          return SignedMsgType.SIGNED_MSG_TYPE_PROPOSAL;
        case -1:
        case "UNRECOGNIZED":
        default:
          return SignedMsgType.UNRECOGNIZED;
      }
    }
    exports.signedMsgTypeFromJSON = signedMsgTypeFromJSON;
    function signedMsgTypeToJSON(object2) {
      switch (object2) {
        case SignedMsgType.SIGNED_MSG_TYPE_UNKNOWN:
          return "SIGNED_MSG_TYPE_UNKNOWN";
        case SignedMsgType.SIGNED_MSG_TYPE_PREVOTE:
          return "SIGNED_MSG_TYPE_PREVOTE";
        case SignedMsgType.SIGNED_MSG_TYPE_PRECOMMIT:
          return "SIGNED_MSG_TYPE_PRECOMMIT";
        case SignedMsgType.SIGNED_MSG_TYPE_PROPOSAL:
          return "SIGNED_MSG_TYPE_PROPOSAL";
        default:
          return "UNKNOWN";
      }
    }
    exports.signedMsgTypeToJSON = signedMsgTypeToJSON;
    function createBasePartSetHeader() {
      return { total: 0, hash: new Uint8Array() };
    }
    exports.PartSetHeader = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.total !== 0) {
          writer.uint32(8).uint32(message.total);
        }
        if (message.hash.length !== 0) {
          writer.uint32(18).bytes(message.hash);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBasePartSetHeader();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.total = reader.uint32();
              break;
            case 2:
              message.hash = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object2) {
        return {
          total: isSet(object2.total) ? Number(object2.total) : 0,
          hash: isSet(object2.hash) ? bytesFromBase64(object2.hash) : new Uint8Array()
        };
      },
      toJSON(message) {
        const obj = {};
        message.total !== void 0 && (obj.total = Math.round(message.total));
        message.hash !== void 0 && (obj.hash = base64FromBytes(message.hash !== void 0 ? message.hash : new Uint8Array()));
        return obj;
      },
      fromPartial(object2) {
        var _a2, _b;
        const message = createBasePartSetHeader();
        message.total = (_a2 = object2.total) !== null && _a2 !== void 0 ? _a2 : 0;
        message.hash = (_b = object2.hash) !== null && _b !== void 0 ? _b : new Uint8Array();
        return message;
      }
    };
    function createBasePart() {
      return { index: 0, bytes: new Uint8Array(), proof: void 0 };
    }
    exports.Part = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.index !== 0) {
          writer.uint32(8).uint32(message.index);
        }
        if (message.bytes.length !== 0) {
          writer.uint32(18).bytes(message.bytes);
        }
        if (message.proof !== void 0) {
          proof_1.Proof.encode(message.proof, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBasePart();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.index = reader.uint32();
              break;
            case 2:
              message.bytes = reader.bytes();
              break;
            case 3:
              message.proof = proof_1.Proof.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object2) {
        return {
          index: isSet(object2.index) ? Number(object2.index) : 0,
          bytes: isSet(object2.bytes) ? bytesFromBase64(object2.bytes) : new Uint8Array(),
          proof: isSet(object2.proof) ? proof_1.Proof.fromJSON(object2.proof) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.index !== void 0 && (obj.index = Math.round(message.index));
        message.bytes !== void 0 && (obj.bytes = base64FromBytes(message.bytes !== void 0 ? message.bytes : new Uint8Array()));
        message.proof !== void 0 && (obj.proof = message.proof ? proof_1.Proof.toJSON(message.proof) : void 0);
        return obj;
      },
      fromPartial(object2) {
        var _a2, _b;
        const message = createBasePart();
        message.index = (_a2 = object2.index) !== null && _a2 !== void 0 ? _a2 : 0;
        message.bytes = (_b = object2.bytes) !== null && _b !== void 0 ? _b : new Uint8Array();
        message.proof = object2.proof !== void 0 && object2.proof !== null ? proof_1.Proof.fromPartial(object2.proof) : void 0;
        return message;
      }
    };
    function createBaseBlockID() {
      return { hash: new Uint8Array(), partSetHeader: void 0 };
    }
    exports.BlockID = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.hash.length !== 0) {
          writer.uint32(10).bytes(message.hash);
        }
        if (message.partSetHeader !== void 0) {
          exports.PartSetHeader.encode(message.partSetHeader, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseBlockID();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.hash = reader.bytes();
              break;
            case 2:
              message.partSetHeader = exports.PartSetHeader.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object2) {
        return {
          hash: isSet(object2.hash) ? bytesFromBase64(object2.hash) : new Uint8Array(),
          partSetHeader: isSet(object2.partSetHeader) ? exports.PartSetHeader.fromJSON(object2.partSetHeader) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.hash !== void 0 && (obj.hash = base64FromBytes(message.hash !== void 0 ? message.hash : new Uint8Array()));
        message.partSetHeader !== void 0 && (obj.partSetHeader = message.partSetHeader ? exports.PartSetHeader.toJSON(message.partSetHeader) : void 0);
        return obj;
      },
      fromPartial(object2) {
        var _a2;
        const message = createBaseBlockID();
        message.hash = (_a2 = object2.hash) !== null && _a2 !== void 0 ? _a2 : new Uint8Array();
        message.partSetHeader = object2.partSetHeader !== void 0 && object2.partSetHeader !== null ? exports.PartSetHeader.fromPartial(object2.partSetHeader) : void 0;
        return message;
      }
    };
    function createBaseHeader() {
      return {
        version: void 0,
        chainId: "",
        height: "0",
        time: void 0,
        lastBlockId: void 0,
        lastCommitHash: new Uint8Array(),
        dataHash: new Uint8Array(),
        validatorsHash: new Uint8Array(),
        nextValidatorsHash: new Uint8Array(),
        consensusHash: new Uint8Array(),
        appHash: new Uint8Array(),
        lastResultsHash: new Uint8Array(),
        evidenceHash: new Uint8Array(),
        proposerAddress: new Uint8Array()
      };
    }
    exports.Header = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.version !== void 0) {
          types_1.Consensus.encode(message.version, writer.uint32(10).fork()).ldelim();
        }
        if (message.chainId !== "") {
          writer.uint32(18).string(message.chainId);
        }
        if (message.height !== "0") {
          writer.uint32(24).int64(message.height);
        }
        if (message.time !== void 0) {
          timestamp_1.Timestamp.encode(toTimestamp(message.time), writer.uint32(34).fork()).ldelim();
        }
        if (message.lastBlockId !== void 0) {
          exports.BlockID.encode(message.lastBlockId, writer.uint32(42).fork()).ldelim();
        }
        if (message.lastCommitHash.length !== 0) {
          writer.uint32(50).bytes(message.lastCommitHash);
        }
        if (message.dataHash.length !== 0) {
          writer.uint32(58).bytes(message.dataHash);
        }
        if (message.validatorsHash.length !== 0) {
          writer.uint32(66).bytes(message.validatorsHash);
        }
        if (message.nextValidatorsHash.length !== 0) {
          writer.uint32(74).bytes(message.nextValidatorsHash);
        }
        if (message.consensusHash.length !== 0) {
          writer.uint32(82).bytes(message.consensusHash);
        }
        if (message.appHash.length !== 0) {
          writer.uint32(90).bytes(message.appHash);
        }
        if (message.lastResultsHash.length !== 0) {
          writer.uint32(98).bytes(message.lastResultsHash);
        }
        if (message.evidenceHash.length !== 0) {
          writer.uint32(106).bytes(message.evidenceHash);
        }
        if (message.proposerAddress.length !== 0) {
          writer.uint32(114).bytes(message.proposerAddress);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseHeader();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.version = types_1.Consensus.decode(reader, reader.uint32());
              break;
            case 2:
              message.chainId = reader.string();
              break;
            case 3:
              message.height = longToString(reader.int64());
              break;
            case 4:
              message.time = fromTimestamp(timestamp_1.Timestamp.decode(reader, reader.uint32()));
              break;
            case 5:
              message.lastBlockId = exports.BlockID.decode(reader, reader.uint32());
              break;
            case 6:
              message.lastCommitHash = reader.bytes();
              break;
            case 7:
              message.dataHash = reader.bytes();
              break;
            case 8:
              message.validatorsHash = reader.bytes();
              break;
            case 9:
              message.nextValidatorsHash = reader.bytes();
              break;
            case 10:
              message.consensusHash = reader.bytes();
              break;
            case 11:
              message.appHash = reader.bytes();
              break;
            case 12:
              message.lastResultsHash = reader.bytes();
              break;
            case 13:
              message.evidenceHash = reader.bytes();
              break;
            case 14:
              message.proposerAddress = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object2) {
        return {
          version: isSet(object2.version) ? types_1.Consensus.fromJSON(object2.version) : void 0,
          chainId: isSet(object2.chainId) ? String(object2.chainId) : "",
          height: isSet(object2.height) ? String(object2.height) : "0",
          time: isSet(object2.time) ? fromJsonTimestamp(object2.time) : void 0,
          lastBlockId: isSet(object2.lastBlockId) ? exports.BlockID.fromJSON(object2.lastBlockId) : void 0,
          lastCommitHash: isSet(object2.lastCommitHash) ? bytesFromBase64(object2.lastCommitHash) : new Uint8Array(),
          dataHash: isSet(object2.dataHash) ? bytesFromBase64(object2.dataHash) : new Uint8Array(),
          validatorsHash: isSet(object2.validatorsHash) ? bytesFromBase64(object2.validatorsHash) : new Uint8Array(),
          nextValidatorsHash: isSet(object2.nextValidatorsHash) ? bytesFromBase64(object2.nextValidatorsHash) : new Uint8Array(),
          consensusHash: isSet(object2.consensusHash) ? bytesFromBase64(object2.consensusHash) : new Uint8Array(),
          appHash: isSet(object2.appHash) ? bytesFromBase64(object2.appHash) : new Uint8Array(),
          lastResultsHash: isSet(object2.lastResultsHash) ? bytesFromBase64(object2.lastResultsHash) : new Uint8Array(),
          evidenceHash: isSet(object2.evidenceHash) ? bytesFromBase64(object2.evidenceHash) : new Uint8Array(),
          proposerAddress: isSet(object2.proposerAddress) ? bytesFromBase64(object2.proposerAddress) : new Uint8Array()
        };
      },
      toJSON(message) {
        const obj = {};
        message.version !== void 0 && (obj.version = message.version ? types_1.Consensus.toJSON(message.version) : void 0);
        message.chainId !== void 0 && (obj.chainId = message.chainId);
        message.height !== void 0 && (obj.height = message.height);
        message.time !== void 0 && (obj.time = message.time.toISOString());
        message.lastBlockId !== void 0 && (obj.lastBlockId = message.lastBlockId ? exports.BlockID.toJSON(message.lastBlockId) : void 0);
        message.lastCommitHash !== void 0 && (obj.lastCommitHash = base64FromBytes(message.lastCommitHash !== void 0 ? message.lastCommitHash : new Uint8Array()));
        message.dataHash !== void 0 && (obj.dataHash = base64FromBytes(message.dataHash !== void 0 ? message.dataHash : new Uint8Array()));
        message.validatorsHash !== void 0 && (obj.validatorsHash = base64FromBytes(message.validatorsHash !== void 0 ? message.validatorsHash : new Uint8Array()));
        message.nextValidatorsHash !== void 0 && (obj.nextValidatorsHash = base64FromBytes(message.nextValidatorsHash !== void 0 ? message.nextValidatorsHash : new Uint8Array()));
        message.consensusHash !== void 0 && (obj.consensusHash = base64FromBytes(message.consensusHash !== void 0 ? message.consensusHash : new Uint8Array()));
        message.appHash !== void 0 && (obj.appHash = base64FromBytes(message.appHash !== void 0 ? message.appHash : new Uint8Array()));
        message.lastResultsHash !== void 0 && (obj.lastResultsHash = base64FromBytes(message.lastResultsHash !== void 0 ? message.lastResultsHash : new Uint8Array()));
        message.evidenceHash !== void 0 && (obj.evidenceHash = base64FromBytes(message.evidenceHash !== void 0 ? message.evidenceHash : new Uint8Array()));
        message.proposerAddress !== void 0 && (obj.proposerAddress = base64FromBytes(message.proposerAddress !== void 0 ? message.proposerAddress : new Uint8Array()));
        return obj;
      },
      fromPartial(object2) {
        var _a2, _b, _c, _d, _e3, _f, _g, _h, _j, _k, _l, _m;
        const message = createBaseHeader();
        message.version = object2.version !== void 0 && object2.version !== null ? types_1.Consensus.fromPartial(object2.version) : void 0;
        message.chainId = (_a2 = object2.chainId) !== null && _a2 !== void 0 ? _a2 : "";
        message.height = (_b = object2.height) !== null && _b !== void 0 ? _b : "0";
        message.time = (_c = object2.time) !== null && _c !== void 0 ? _c : void 0;
        message.lastBlockId = object2.lastBlockId !== void 0 && object2.lastBlockId !== null ? exports.BlockID.fromPartial(object2.lastBlockId) : void 0;
        message.lastCommitHash = (_d = object2.lastCommitHash) !== null && _d !== void 0 ? _d : new Uint8Array();
        message.dataHash = (_e3 = object2.dataHash) !== null && _e3 !== void 0 ? _e3 : new Uint8Array();
        message.validatorsHash = (_f = object2.validatorsHash) !== null && _f !== void 0 ? _f : new Uint8Array();
        message.nextValidatorsHash = (_g = object2.nextValidatorsHash) !== null && _g !== void 0 ? _g : new Uint8Array();
        message.consensusHash = (_h = object2.consensusHash) !== null && _h !== void 0 ? _h : new Uint8Array();
        message.appHash = (_j = object2.appHash) !== null && _j !== void 0 ? _j : new Uint8Array();
        message.lastResultsHash = (_k = object2.lastResultsHash) !== null && _k !== void 0 ? _k : new Uint8Array();
        message.evidenceHash = (_l = object2.evidenceHash) !== null && _l !== void 0 ? _l : new Uint8Array();
        message.proposerAddress = (_m = object2.proposerAddress) !== null && _m !== void 0 ? _m : new Uint8Array();
        return message;
      }
    };
    function createBaseData() {
      return { txs: [] };
    }
    exports.Data = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v5 of message.txs) {
          writer.uint32(10).bytes(v5);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseData();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.txs.push(reader.bytes());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object2) {
        return {
          txs: Array.isArray(object2 === null || object2 === void 0 ? void 0 : object2.txs) ? object2.txs.map((e2) => bytesFromBase64(e2)) : []
        };
      },
      toJSON(message) {
        const obj = {};
        if (message.txs) {
          obj.txs = message.txs.map((e2) => base64FromBytes(e2 !== void 0 ? e2 : new Uint8Array()));
        } else {
          obj.txs = [];
        }
        return obj;
      },
      fromPartial(object2) {
        var _a2;
        const message = createBaseData();
        message.txs = ((_a2 = object2.txs) === null || _a2 === void 0 ? void 0 : _a2.map((e2) => e2)) || [];
        return message;
      }
    };
    function createBaseVote() {
      return {
        type: 0,
        height: "0",
        round: 0,
        blockId: void 0,
        timestamp: void 0,
        validatorAddress: new Uint8Array(),
        validatorIndex: 0,
        signature: new Uint8Array()
      };
    }
    exports.Vote = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.type !== 0) {
          writer.uint32(8).int32(message.type);
        }
        if (message.height !== "0") {
          writer.uint32(16).int64(message.height);
        }
        if (message.round !== 0) {
          writer.uint32(24).int32(message.round);
        }
        if (message.blockId !== void 0) {
          exports.BlockID.encode(message.blockId, writer.uint32(34).fork()).ldelim();
        }
        if (message.timestamp !== void 0) {
          timestamp_1.Timestamp.encode(toTimestamp(message.timestamp), writer.uint32(42).fork()).ldelim();
        }
        if (message.validatorAddress.length !== 0) {
          writer.uint32(50).bytes(message.validatorAddress);
        }
        if (message.validatorIndex !== 0) {
          writer.uint32(56).int32(message.validatorIndex);
        }
        if (message.signature.length !== 0) {
          writer.uint32(66).bytes(message.signature);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseVote();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.type = reader.int32();
              break;
            case 2:
              message.height = longToString(reader.int64());
              break;
            case 3:
              message.round = reader.int32();
              break;
            case 4:
              message.blockId = exports.BlockID.decode(reader, reader.uint32());
              break;
            case 5:
              message.timestamp = fromTimestamp(timestamp_1.Timestamp.decode(reader, reader.uint32()));
              break;
            case 6:
              message.validatorAddress = reader.bytes();
              break;
            case 7:
              message.validatorIndex = reader.int32();
              break;
            case 8:
              message.signature = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object2) {
        return {
          type: isSet(object2.type) ? signedMsgTypeFromJSON(object2.type) : 0,
          height: isSet(object2.height) ? String(object2.height) : "0",
          round: isSet(object2.round) ? Number(object2.round) : 0,
          blockId: isSet(object2.blockId) ? exports.BlockID.fromJSON(object2.blockId) : void 0,
          timestamp: isSet(object2.timestamp) ? fromJsonTimestamp(object2.timestamp) : void 0,
          validatorAddress: isSet(object2.validatorAddress) ? bytesFromBase64(object2.validatorAddress) : new Uint8Array(),
          validatorIndex: isSet(object2.validatorIndex) ? Number(object2.validatorIndex) : 0,
          signature: isSet(object2.signature) ? bytesFromBase64(object2.signature) : new Uint8Array()
        };
      },
      toJSON(message) {
        const obj = {};
        message.type !== void 0 && (obj.type = signedMsgTypeToJSON(message.type));
        message.height !== void 0 && (obj.height = message.height);
        message.round !== void 0 && (obj.round = Math.round(message.round));
        message.blockId !== void 0 && (obj.blockId = message.blockId ? exports.BlockID.toJSON(message.blockId) : void 0);
        message.timestamp !== void 0 && (obj.timestamp = message.timestamp.toISOString());
        message.validatorAddress !== void 0 && (obj.validatorAddress = base64FromBytes(message.validatorAddress !== void 0 ? message.validatorAddress : new Uint8Array()));
        message.validatorIndex !== void 0 && (obj.validatorIndex = Math.round(message.validatorIndex));
        message.signature !== void 0 && (obj.signature = base64FromBytes(message.signature !== void 0 ? message.signature : new Uint8Array()));
        return obj;
      },
      fromPartial(object2) {
        var _a2, _b, _c, _d, _e3, _f, _g;
        const message = createBaseVote();
        message.type = (_a2 = object2.type) !== null && _a2 !== void 0 ? _a2 : 0;
        message.height = (_b = object2.height) !== null && _b !== void 0 ? _b : "0";
        message.round = (_c = object2.round) !== null && _c !== void 0 ? _c : 0;
        message.blockId = object2.blockId !== void 0 && object2.blockId !== null ? exports.BlockID.fromPartial(object2.blockId) : void 0;
        message.timestamp = (_d = object2.timestamp) !== null && _d !== void 0 ? _d : void 0;
        message.validatorAddress = (_e3 = object2.validatorAddress) !== null && _e3 !== void 0 ? _e3 : new Uint8Array();
        message.validatorIndex = (_f = object2.validatorIndex) !== null && _f !== void 0 ? _f : 0;
        message.signature = (_g = object2.signature) !== null && _g !== void 0 ? _g : new Uint8Array();
        return message;
      }
    };
    function createBaseCommit() {
      return { height: "0", round: 0, blockId: void 0, signatures: [] };
    }
    exports.Commit = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.height !== "0") {
          writer.uint32(8).int64(message.height);
        }
        if (message.round !== 0) {
          writer.uint32(16).int32(message.round);
        }
        if (message.blockId !== void 0) {
          exports.BlockID.encode(message.blockId, writer.uint32(26).fork()).ldelim();
        }
        for (const v5 of message.signatures) {
          exports.CommitSig.encode(v5, writer.uint32(34).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseCommit();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.height = longToString(reader.int64());
              break;
            case 2:
              message.round = reader.int32();
              break;
            case 3:
              message.blockId = exports.BlockID.decode(reader, reader.uint32());
              break;
            case 4:
              message.signatures.push(exports.CommitSig.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object2) {
        return {
          height: isSet(object2.height) ? String(object2.height) : "0",
          round: isSet(object2.round) ? Number(object2.round) : 0,
          blockId: isSet(object2.blockId) ? exports.BlockID.fromJSON(object2.blockId) : void 0,
          signatures: Array.isArray(object2 === null || object2 === void 0 ? void 0 : object2.signatures) ? object2.signatures.map((e2) => exports.CommitSig.fromJSON(e2)) : []
        };
      },
      toJSON(message) {
        const obj = {};
        message.height !== void 0 && (obj.height = message.height);
        message.round !== void 0 && (obj.round = Math.round(message.round));
        message.blockId !== void 0 && (obj.blockId = message.blockId ? exports.BlockID.toJSON(message.blockId) : void 0);
        if (message.signatures) {
          obj.signatures = message.signatures.map((e2) => e2 ? exports.CommitSig.toJSON(e2) : void 0);
        } else {
          obj.signatures = [];
        }
        return obj;
      },
      fromPartial(object2) {
        var _a2, _b, _c;
        const message = createBaseCommit();
        message.height = (_a2 = object2.height) !== null && _a2 !== void 0 ? _a2 : "0";
        message.round = (_b = object2.round) !== null && _b !== void 0 ? _b : 0;
        message.blockId = object2.blockId !== void 0 && object2.blockId !== null ? exports.BlockID.fromPartial(object2.blockId) : void 0;
        message.signatures = ((_c = object2.signatures) === null || _c === void 0 ? void 0 : _c.map((e2) => exports.CommitSig.fromPartial(e2))) || [];
        return message;
      }
    };
    function createBaseCommitSig() {
      return {
        blockIdFlag: 0,
        validatorAddress: new Uint8Array(),
        timestamp: void 0,
        signature: new Uint8Array()
      };
    }
    exports.CommitSig = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.blockIdFlag !== 0) {
          writer.uint32(8).int32(message.blockIdFlag);
        }
        if (message.validatorAddress.length !== 0) {
          writer.uint32(18).bytes(message.validatorAddress);
        }
        if (message.timestamp !== void 0) {
          timestamp_1.Timestamp.encode(toTimestamp(message.timestamp), writer.uint32(26).fork()).ldelim();
        }
        if (message.signature.length !== 0) {
          writer.uint32(34).bytes(message.signature);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseCommitSig();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.blockIdFlag = reader.int32();
              break;
            case 2:
              message.validatorAddress = reader.bytes();
              break;
            case 3:
              message.timestamp = fromTimestamp(timestamp_1.Timestamp.decode(reader, reader.uint32()));
              break;
            case 4:
              message.signature = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object2) {
        return {
          blockIdFlag: isSet(object2.blockIdFlag) ? blockIDFlagFromJSON(object2.blockIdFlag) : 0,
          validatorAddress: isSet(object2.validatorAddress) ? bytesFromBase64(object2.validatorAddress) : new Uint8Array(),
          timestamp: isSet(object2.timestamp) ? fromJsonTimestamp(object2.timestamp) : void 0,
          signature: isSet(object2.signature) ? bytesFromBase64(object2.signature) : new Uint8Array()
        };
      },
      toJSON(message) {
        const obj = {};
        message.blockIdFlag !== void 0 && (obj.blockIdFlag = blockIDFlagToJSON(message.blockIdFlag));
        message.validatorAddress !== void 0 && (obj.validatorAddress = base64FromBytes(message.validatorAddress !== void 0 ? message.validatorAddress : new Uint8Array()));
        message.timestamp !== void 0 && (obj.timestamp = message.timestamp.toISOString());
        message.signature !== void 0 && (obj.signature = base64FromBytes(message.signature !== void 0 ? message.signature : new Uint8Array()));
        return obj;
      },
      fromPartial(object2) {
        var _a2, _b, _c, _d;
        const message = createBaseCommitSig();
        message.blockIdFlag = (_a2 = object2.blockIdFlag) !== null && _a2 !== void 0 ? _a2 : 0;
        message.validatorAddress = (_b = object2.validatorAddress) !== null && _b !== void 0 ? _b : new Uint8Array();
        message.timestamp = (_c = object2.timestamp) !== null && _c !== void 0 ? _c : void 0;
        message.signature = (_d = object2.signature) !== null && _d !== void 0 ? _d : new Uint8Array();
        return message;
      }
    };
    function createBaseProposal() {
      return {
        type: 0,
        height: "0",
        round: 0,
        polRound: 0,
        blockId: void 0,
        timestamp: void 0,
        signature: new Uint8Array()
      };
    }
    exports.Proposal = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.type !== 0) {
          writer.uint32(8).int32(message.type);
        }
        if (message.height !== "0") {
          writer.uint32(16).int64(message.height);
        }
        if (message.round !== 0) {
          writer.uint32(24).int32(message.round);
        }
        if (message.polRound !== 0) {
          writer.uint32(32).int32(message.polRound);
        }
        if (message.blockId !== void 0) {
          exports.BlockID.encode(message.blockId, writer.uint32(42).fork()).ldelim();
        }
        if (message.timestamp !== void 0) {
          timestamp_1.Timestamp.encode(toTimestamp(message.timestamp), writer.uint32(50).fork()).ldelim();
        }
        if (message.signature.length !== 0) {
          writer.uint32(58).bytes(message.signature);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseProposal();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.type = reader.int32();
              break;
            case 2:
              message.height = longToString(reader.int64());
              break;
            case 3:
              message.round = reader.int32();
              break;
            case 4:
              message.polRound = reader.int32();
              break;
            case 5:
              message.blockId = exports.BlockID.decode(reader, reader.uint32());
              break;
            case 6:
              message.timestamp = fromTimestamp(timestamp_1.Timestamp.decode(reader, reader.uint32()));
              break;
            case 7:
              message.signature = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object2) {
        return {
          type: isSet(object2.type) ? signedMsgTypeFromJSON(object2.type) : 0,
          height: isSet(object2.height) ? String(object2.height) : "0",
          round: isSet(object2.round) ? Number(object2.round) : 0,
          polRound: isSet(object2.polRound) ? Number(object2.polRound) : 0,
          blockId: isSet(object2.blockId) ? exports.BlockID.fromJSON(object2.blockId) : void 0,
          timestamp: isSet(object2.timestamp) ? fromJsonTimestamp(object2.timestamp) : void 0,
          signature: isSet(object2.signature) ? bytesFromBase64(object2.signature) : new Uint8Array()
        };
      },
      toJSON(message) {
        const obj = {};
        message.type !== void 0 && (obj.type = signedMsgTypeToJSON(message.type));
        message.height !== void 0 && (obj.height = message.height);
        message.round !== void 0 && (obj.round = Math.round(message.round));
        message.polRound !== void 0 && (obj.polRound = Math.round(message.polRound));
        message.blockId !== void 0 && (obj.blockId = message.blockId ? exports.BlockID.toJSON(message.blockId) : void 0);
        message.timestamp !== void 0 && (obj.timestamp = message.timestamp.toISOString());
        message.signature !== void 0 && (obj.signature = base64FromBytes(message.signature !== void 0 ? message.signature : new Uint8Array()));
        return obj;
      },
      fromPartial(object2) {
        var _a2, _b, _c, _d, _e3, _f;
        const message = createBaseProposal();
        message.type = (_a2 = object2.type) !== null && _a2 !== void 0 ? _a2 : 0;
        message.height = (_b = object2.height) !== null && _b !== void 0 ? _b : "0";
        message.round = (_c = object2.round) !== null && _c !== void 0 ? _c : 0;
        message.polRound = (_d = object2.polRound) !== null && _d !== void 0 ? _d : 0;
        message.blockId = object2.blockId !== void 0 && object2.blockId !== null ? exports.BlockID.fromPartial(object2.blockId) : void 0;
        message.timestamp = (_e3 = object2.timestamp) !== null && _e3 !== void 0 ? _e3 : void 0;
        message.signature = (_f = object2.signature) !== null && _f !== void 0 ? _f : new Uint8Array();
        return message;
      }
    };
    function createBaseSignedHeader() {
      return { header: void 0, commit: void 0 };
    }
    exports.SignedHeader = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.header !== void 0) {
          exports.Header.encode(message.header, writer.uint32(10).fork()).ldelim();
        }
        if (message.commit !== void 0) {
          exports.Commit.encode(message.commit, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseSignedHeader();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.header = exports.Header.decode(reader, reader.uint32());
              break;
            case 2:
              message.commit = exports.Commit.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object2) {
        return {
          header: isSet(object2.header) ? exports.Header.fromJSON(object2.header) : void 0,
          commit: isSet(object2.commit) ? exports.Commit.fromJSON(object2.commit) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.header !== void 0 && (obj.header = message.header ? exports.Header.toJSON(message.header) : void 0);
        message.commit !== void 0 && (obj.commit = message.commit ? exports.Commit.toJSON(message.commit) : void 0);
        return obj;
      },
      fromPartial(object2) {
        const message = createBaseSignedHeader();
        message.header = object2.header !== void 0 && object2.header !== null ? exports.Header.fromPartial(object2.header) : void 0;
        message.commit = object2.commit !== void 0 && object2.commit !== null ? exports.Commit.fromPartial(object2.commit) : void 0;
        return message;
      }
    };
    function createBaseLightBlock() {
      return { signedHeader: void 0, validatorSet: void 0 };
    }
    exports.LightBlock = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.signedHeader !== void 0) {
          exports.SignedHeader.encode(message.signedHeader, writer.uint32(10).fork()).ldelim();
        }
        if (message.validatorSet !== void 0) {
          validator_1.ValidatorSet.encode(message.validatorSet, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseLightBlock();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.signedHeader = exports.SignedHeader.decode(reader, reader.uint32());
              break;
            case 2:
              message.validatorSet = validator_1.ValidatorSet.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object2) {
        return {
          signedHeader: isSet(object2.signedHeader) ? exports.SignedHeader.fromJSON(object2.signedHeader) : void 0,
          validatorSet: isSet(object2.validatorSet) ? validator_1.ValidatorSet.fromJSON(object2.validatorSet) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.signedHeader !== void 0 && (obj.signedHeader = message.signedHeader ? exports.SignedHeader.toJSON(message.signedHeader) : void 0);
        message.validatorSet !== void 0 && (obj.validatorSet = message.validatorSet ? validator_1.ValidatorSet.toJSON(message.validatorSet) : void 0);
        return obj;
      },
      fromPartial(object2) {
        const message = createBaseLightBlock();
        message.signedHeader = object2.signedHeader !== void 0 && object2.signedHeader !== null ? exports.SignedHeader.fromPartial(object2.signedHeader) : void 0;
        message.validatorSet = object2.validatorSet !== void 0 && object2.validatorSet !== null ? validator_1.ValidatorSet.fromPartial(object2.validatorSet) : void 0;
        return message;
      }
    };
    function createBaseBlockMeta() {
      return { blockId: void 0, blockSize: "0", header: void 0, numTxs: "0" };
    }
    exports.BlockMeta = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.blockId !== void 0) {
          exports.BlockID.encode(message.blockId, writer.uint32(10).fork()).ldelim();
        }
        if (message.blockSize !== "0") {
          writer.uint32(16).int64(message.blockSize);
        }
        if (message.header !== void 0) {
          exports.Header.encode(message.header, writer.uint32(26).fork()).ldelim();
        }
        if (message.numTxs !== "0") {
          writer.uint32(32).int64(message.numTxs);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseBlockMeta();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.blockId = exports.BlockID.decode(reader, reader.uint32());
              break;
            case 2:
              message.blockSize = longToString(reader.int64());
              break;
            case 3:
              message.header = exports.Header.decode(reader, reader.uint32());
              break;
            case 4:
              message.numTxs = longToString(reader.int64());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object2) {
        return {
          blockId: isSet(object2.blockId) ? exports.BlockID.fromJSON(object2.blockId) : void 0,
          blockSize: isSet(object2.blockSize) ? String(object2.blockSize) : "0",
          header: isSet(object2.header) ? exports.Header.fromJSON(object2.header) : void 0,
          numTxs: isSet(object2.numTxs) ? String(object2.numTxs) : "0"
        };
      },
      toJSON(message) {
        const obj = {};
        message.blockId !== void 0 && (obj.blockId = message.blockId ? exports.BlockID.toJSON(message.blockId) : void 0);
        message.blockSize !== void 0 && (obj.blockSize = message.blockSize);
        message.header !== void 0 && (obj.header = message.header ? exports.Header.toJSON(message.header) : void 0);
        message.numTxs !== void 0 && (obj.numTxs = message.numTxs);
        return obj;
      },
      fromPartial(object2) {
        var _a2, _b;
        const message = createBaseBlockMeta();
        message.blockId = object2.blockId !== void 0 && object2.blockId !== null ? exports.BlockID.fromPartial(object2.blockId) : void 0;
        message.blockSize = (_a2 = object2.blockSize) !== null && _a2 !== void 0 ? _a2 : "0";
        message.header = object2.header !== void 0 && object2.header !== null ? exports.Header.fromPartial(object2.header) : void 0;
        message.numTxs = (_b = object2.numTxs) !== null && _b !== void 0 ? _b : "0";
        return message;
      }
    };
    function createBaseTxProof() {
      return {
        rootHash: new Uint8Array(),
        data: new Uint8Array(),
        proof: void 0
      };
    }
    exports.TxProof = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.rootHash.length !== 0) {
          writer.uint32(10).bytes(message.rootHash);
        }
        if (message.data.length !== 0) {
          writer.uint32(18).bytes(message.data);
        }
        if (message.proof !== void 0) {
          proof_1.Proof.encode(message.proof, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseTxProof();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.rootHash = reader.bytes();
              break;
            case 2:
              message.data = reader.bytes();
              break;
            case 3:
              message.proof = proof_1.Proof.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object2) {
        return {
          rootHash: isSet(object2.rootHash) ? bytesFromBase64(object2.rootHash) : new Uint8Array(),
          data: isSet(object2.data) ? bytesFromBase64(object2.data) : new Uint8Array(),
          proof: isSet(object2.proof) ? proof_1.Proof.fromJSON(object2.proof) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.rootHash !== void 0 && (obj.rootHash = base64FromBytes(message.rootHash !== void 0 ? message.rootHash : new Uint8Array()));
        message.data !== void 0 && (obj.data = base64FromBytes(message.data !== void 0 ? message.data : new Uint8Array()));
        message.proof !== void 0 && (obj.proof = message.proof ? proof_1.Proof.toJSON(message.proof) : void 0);
        return obj;
      },
      fromPartial(object2) {
        var _a2, _b;
        const message = createBaseTxProof();
        message.rootHash = (_a2 = object2.rootHash) !== null && _a2 !== void 0 ? _a2 : new Uint8Array();
        message.data = (_b = object2.data) !== null && _b !== void 0 ? _b : new Uint8Array();
        message.proof = object2.proof !== void 0 && object2.proof !== null ? proof_1.Proof.fromPartial(object2.proof) : void 0;
        return message;
      }
    };
    var globalThis2 = (() => {
      if (typeof globalThis2 !== "undefined")
        return globalThis2;
      if (typeof self !== "undefined")
        return self;
      if (typeof window !== "undefined")
        return window;
      if (typeof global !== "undefined")
        return global;
      throw "Unable to locate global object";
    })();
    var atob = globalThis2.atob || ((b64) => globalThis2.Buffer.from(b64, "base64").toString("binary"));
    function bytesFromBase64(b64) {
      const bin = atob(b64);
      const arr = new Uint8Array(bin.length);
      for (let i4 = 0; i4 < bin.length; ++i4) {
        arr[i4] = bin.charCodeAt(i4);
      }
      return arr;
    }
    var btoa = globalThis2.btoa || ((bin) => globalThis2.Buffer.from(bin, "binary").toString("base64"));
    function base64FromBytes(arr) {
      const bin = [];
      for (const byte of arr) {
        bin.push(String.fromCharCode(byte));
      }
      return btoa(bin.join(""));
    }
    function toTimestamp(date) {
      const seconds = Math.trunc(date.getTime() / 1e3).toString();
      const nanos = date.getTime() % 1e3 * 1e6;
      return { seconds, nanos };
    }
    function fromTimestamp(t) {
      let millis = Number(t.seconds) * 1e3;
      millis += t.nanos / 1e6;
      return new Date(millis);
    }
    function fromJsonTimestamp(o4) {
      if (o4 instanceof Date) {
        return o4;
      } else if (typeof o4 === "string") {
        return new Date(o4);
      } else {
        return fromTimestamp(timestamp_1.Timestamp.fromJSON(o4));
      }
    }
    function longToString(long) {
      return long.toString();
    }
    if (minimal_1.default.util.Long !== long_1.default) {
      minimal_1.default.util.Long = long_1.default;
      minimal_1.default.configure();
    }
    function isSet(value) {
      return value !== null && value !== void 0;
    }
  }
});

// ../../node_modules/.pnpm/@keplr-wallet+proto-types@0.12.28/node_modules/@keplr-wallet/proto-types/google/protobuf/any.js
var require_any = __commonJS({
  "../../node_modules/.pnpm/@keplr-wallet+proto-types@0.12.28/node_modules/@keplr-wallet/proto-types/google/protobuf/any.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Any = exports.protobufPackage = void 0;
    var long_1 = __importDefault(require_long());
    var minimal_1 = __importDefault(require_minimal());
    exports.protobufPackage = "google.protobuf";
    function createBaseAny() {
      return { typeUrl: "", value: new Uint8Array() };
    }
    exports.Any = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.typeUrl !== "") {
          writer.uint32(10).string(message.typeUrl);
        }
        if (message.value.length !== 0) {
          writer.uint32(18).bytes(message.value);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseAny();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.typeUrl = reader.string();
              break;
            case 2:
              message.value = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object2) {
        return {
          typeUrl: isSet(object2.typeUrl) ? String(object2.typeUrl) : "",
          value: isSet(object2.value) ? bytesFromBase64(object2.value) : new Uint8Array()
        };
      },
      toJSON(message) {
        const obj = {};
        message.typeUrl !== void 0 && (obj.typeUrl = message.typeUrl);
        message.value !== void 0 && (obj.value = base64FromBytes(message.value !== void 0 ? message.value : new Uint8Array()));
        return obj;
      },
      fromPartial(object2) {
        var _a2, _b;
        const message = createBaseAny();
        message.typeUrl = (_a2 = object2.typeUrl) !== null && _a2 !== void 0 ? _a2 : "";
        message.value = (_b = object2.value) !== null && _b !== void 0 ? _b : new Uint8Array();
        return message;
      }
    };
    var globalThis2 = (() => {
      if (typeof globalThis2 !== "undefined")
        return globalThis2;
      if (typeof self !== "undefined")
        return self;
      if (typeof window !== "undefined")
        return window;
      if (typeof global !== "undefined")
        return global;
      throw "Unable to locate global object";
    })();
    var atob = globalThis2.atob || ((b64) => globalThis2.Buffer.from(b64, "base64").toString("binary"));
    function bytesFromBase64(b64) {
      const bin = atob(b64);
      const arr = new Uint8Array(bin.length);
      for (let i4 = 0; i4 < bin.length; ++i4) {
        arr[i4] = bin.charCodeAt(i4);
      }
      return arr;
    }
    var btoa = globalThis2.btoa || ((bin) => globalThis2.Buffer.from(bin, "binary").toString("base64"));
    function base64FromBytes(arr) {
      const bin = [];
      for (const byte of arr) {
        bin.push(String.fromCharCode(byte));
      }
      return btoa(bin.join(""));
    }
    if (minimal_1.default.util.Long !== long_1.default) {
      minimal_1.default.util.Long = long_1.default;
      minimal_1.default.configure();
    }
    function isSet(value) {
      return value !== null && value !== void 0;
    }
  }
});

// ../../node_modules/.pnpm/@keplr-wallet+proto-types@0.12.28/node_modules/@keplr-wallet/proto-types/google/protobuf/duration.js
var require_duration = __commonJS({
  "../../node_modules/.pnpm/@keplr-wallet+proto-types@0.12.28/node_modules/@keplr-wallet/proto-types/google/protobuf/duration.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Duration = exports.protobufPackage = void 0;
    var long_1 = __importDefault(require_long());
    var minimal_1 = __importDefault(require_minimal());
    exports.protobufPackage = "google.protobuf";
    function createBaseDuration() {
      return { seconds: "0", nanos: 0 };
    }
    exports.Duration = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.seconds !== "0") {
          writer.uint32(8).int64(message.seconds);
        }
        if (message.nanos !== 0) {
          writer.uint32(16).int32(message.nanos);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseDuration();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.seconds = longToString(reader.int64());
              break;
            case 2:
              message.nanos = reader.int32();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object2) {
        return {
          seconds: isSet(object2.seconds) ? String(object2.seconds) : "0",
          nanos: isSet(object2.nanos) ? Number(object2.nanos) : 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.seconds !== void 0 && (obj.seconds = message.seconds);
        message.nanos !== void 0 && (obj.nanos = Math.round(message.nanos));
        return obj;
      },
      fromPartial(object2) {
        var _a2, _b;
        const message = createBaseDuration();
        message.seconds = (_a2 = object2.seconds) !== null && _a2 !== void 0 ? _a2 : "0";
        message.nanos = (_b = object2.nanos) !== null && _b !== void 0 ? _b : 0;
        return message;
      }
    };
    function longToString(long) {
      return long.toString();
    }
    if (minimal_1.default.util.Long !== long_1.default) {
      minimal_1.default.util.Long = long_1.default;
      minimal_1.default.configure();
    }
    function isSet(value) {
      return value !== null && value !== void 0;
    }
  }
});

// ../../node_modules/.pnpm/@keplr-wallet+proto-types@0.12.28/node_modules/@keplr-wallet/proto-types/cosmos/staking/v1beta1/staking.js
var require_staking = __commonJS({
  "../../node_modules/.pnpm/@keplr-wallet+proto-types@0.12.28/node_modules/@keplr-wallet/proto-types/cosmos/staking/v1beta1/staking.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Pool = exports.RedelegationResponse = exports.RedelegationEntryResponse = exports.DelegationResponse = exports.Params = exports.Redelegation = exports.RedelegationEntry = exports.UnbondingDelegationEntry = exports.UnbondingDelegation = exports.Delegation = exports.DVVTriplets = exports.DVVTriplet = exports.DVPairs = exports.DVPair = exports.ValAddresses = exports.Validator = exports.Description = exports.Commission = exports.CommissionRates = exports.HistoricalInfo = exports.bondStatusToJSON = exports.bondStatusFromJSON = exports.BondStatus = exports.protobufPackage = void 0;
    var long_1 = __importDefault(require_long());
    var minimal_1 = __importDefault(require_minimal());
    var timestamp_1 = require_timestamp();
    var types_1 = require_types4();
    var any_1 = require_any();
    var duration_1 = require_duration();
    var coin_1 = require_coin2();
    exports.protobufPackage = "cosmos.staking.v1beta1";
    var BondStatus;
    (function(BondStatus2) {
      BondStatus2[BondStatus2["BOND_STATUS_UNSPECIFIED"] = 0] = "BOND_STATUS_UNSPECIFIED";
      BondStatus2[BondStatus2["BOND_STATUS_UNBONDED"] = 1] = "BOND_STATUS_UNBONDED";
      BondStatus2[BondStatus2["BOND_STATUS_UNBONDING"] = 2] = "BOND_STATUS_UNBONDING";
      BondStatus2[BondStatus2["BOND_STATUS_BONDED"] = 3] = "BOND_STATUS_BONDED";
      BondStatus2[BondStatus2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(BondStatus = exports.BondStatus || (exports.BondStatus = {}));
    function bondStatusFromJSON(object2) {
      switch (object2) {
        case 0:
        case "BOND_STATUS_UNSPECIFIED":
          return BondStatus.BOND_STATUS_UNSPECIFIED;
        case 1:
        case "BOND_STATUS_UNBONDED":
          return BondStatus.BOND_STATUS_UNBONDED;
        case 2:
        case "BOND_STATUS_UNBONDING":
          return BondStatus.BOND_STATUS_UNBONDING;
        case 3:
        case "BOND_STATUS_BONDED":
          return BondStatus.BOND_STATUS_BONDED;
        case -1:
        case "UNRECOGNIZED":
        default:
          return BondStatus.UNRECOGNIZED;
      }
    }
    exports.bondStatusFromJSON = bondStatusFromJSON;
    function bondStatusToJSON(object2) {
      switch (object2) {
        case BondStatus.BOND_STATUS_UNSPECIFIED:
          return "BOND_STATUS_UNSPECIFIED";
        case BondStatus.BOND_STATUS_UNBONDED:
          return "BOND_STATUS_UNBONDED";
        case BondStatus.BOND_STATUS_UNBONDING:
          return "BOND_STATUS_UNBONDING";
        case BondStatus.BOND_STATUS_BONDED:
          return "BOND_STATUS_BONDED";
        default:
          return "UNKNOWN";
      }
    }
    exports.bondStatusToJSON = bondStatusToJSON;
    function createBaseHistoricalInfo() {
      return { header: void 0, valset: [] };
    }
    exports.HistoricalInfo = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.header !== void 0) {
          types_1.Header.encode(message.header, writer.uint32(10).fork()).ldelim();
        }
        for (const v5 of message.valset) {
          exports.Validator.encode(v5, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseHistoricalInfo();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.header = types_1.Header.decode(reader, reader.uint32());
              break;
            case 2:
              message.valset.push(exports.Validator.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object2) {
        return {
          header: isSet(object2.header) ? types_1.Header.fromJSON(object2.header) : void 0,
          valset: Array.isArray(object2 === null || object2 === void 0 ? void 0 : object2.valset) ? object2.valset.map((e2) => exports.Validator.fromJSON(e2)) : []
        };
      },
      toJSON(message) {
        const obj = {};
        message.header !== void 0 && (obj.header = message.header ? types_1.Header.toJSON(message.header) : void 0);
        if (message.valset) {
          obj.valset = message.valset.map((e2) => e2 ? exports.Validator.toJSON(e2) : void 0);
        } else {
          obj.valset = [];
        }
        return obj;
      },
      fromPartial(object2) {
        var _a2;
        const message = createBaseHistoricalInfo();
        message.header = object2.header !== void 0 && object2.header !== null ? types_1.Header.fromPartial(object2.header) : void 0;
        message.valset = ((_a2 = object2.valset) === null || _a2 === void 0 ? void 0 : _a2.map((e2) => exports.Validator.fromPartial(e2))) || [];
        return message;
      }
    };
    function createBaseCommissionRates() {
      return { rate: "", maxRate: "", maxChangeRate: "" };
    }
    exports.CommissionRates = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.rate !== "") {
          writer.uint32(10).string(message.rate);
        }
        if (message.maxRate !== "") {
          writer.uint32(18).string(message.maxRate);
        }
        if (message.maxChangeRate !== "") {
          writer.uint32(26).string(message.maxChangeRate);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseCommissionRates();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.rate = reader.string();
              break;
            case 2:
              message.maxRate = reader.string();
              break;
            case 3:
              message.maxChangeRate = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object2) {
        return {
          rate: isSet(object2.rate) ? String(object2.rate) : "",
          maxRate: isSet(object2.maxRate) ? String(object2.maxRate) : "",
          maxChangeRate: isSet(object2.maxChangeRate) ? String(object2.maxChangeRate) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        message.rate !== void 0 && (obj.rate = message.rate);
        message.maxRate !== void 0 && (obj.maxRate = message.maxRate);
        message.maxChangeRate !== void 0 && (obj.maxChangeRate = message.maxChangeRate);
        return obj;
      },
      fromPartial(object2) {
        var _a2, _b, _c;
        const message = createBaseCommissionRates();
        message.rate = (_a2 = object2.rate) !== null && _a2 !== void 0 ? _a2 : "";
        message.maxRate = (_b = object2.maxRate) !== null && _b !== void 0 ? _b : "";
        message.maxChangeRate = (_c = object2.maxChangeRate) !== null && _c !== void 0 ? _c : "";
        return message;
      }
    };
    function createBaseCommission() {
      return { commissionRates: void 0, updateTime: void 0 };
    }
    exports.Commission = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.commissionRates !== void 0) {
          exports.CommissionRates.encode(message.commissionRates, writer.uint32(10).fork()).ldelim();
        }
        if (message.updateTime !== void 0) {
          timestamp_1.Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseCommission();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.commissionRates = exports.CommissionRates.decode(reader, reader.uint32());
              break;
            case 2:
              message.updateTime = fromTimestamp(timestamp_1.Timestamp.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object2) {
        return {
          commissionRates: isSet(object2.commissionRates) ? exports.CommissionRates.fromJSON(object2.commissionRates) : void 0,
          updateTime: isSet(object2.updateTime) ? fromJsonTimestamp(object2.updateTime) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.commissionRates !== void 0 && (obj.commissionRates = message.commissionRates ? exports.CommissionRates.toJSON(message.commissionRates) : void 0);
        message.updateTime !== void 0 && (obj.updateTime = message.updateTime.toISOString());
        return obj;
      },
      fromPartial(object2) {
        var _a2;
        const message = createBaseCommission();
        message.commissionRates = object2.commissionRates !== void 0 && object2.commissionRates !== null ? exports.CommissionRates.fromPartial(object2.commissionRates) : void 0;
        message.updateTime = (_a2 = object2.updateTime) !== null && _a2 !== void 0 ? _a2 : void 0;
        return message;
      }
    };
    function createBaseDescription() {
      return {
        moniker: "",
        identity: "",
        website: "",
        securityContact: "",
        details: ""
      };
    }
    exports.Description = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.moniker !== "") {
          writer.uint32(10).string(message.moniker);
        }
        if (message.identity !== "") {
          writer.uint32(18).string(message.identity);
        }
        if (message.website !== "") {
          writer.uint32(26).string(message.website);
        }
        if (message.securityContact !== "") {
          writer.uint32(34).string(message.securityContact);
        }
        if (message.details !== "") {
          writer.uint32(42).string(message.details);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseDescription();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.moniker = reader.string();
              break;
            case 2:
              message.identity = reader.string();
              break;
            case 3:
              message.website = reader.string();
              break;
            case 4:
              message.securityContact = reader.string();
              break;
            case 5:
              message.details = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object2) {
        return {
          moniker: isSet(object2.moniker) ? String(object2.moniker) : "",
          identity: isSet(object2.identity) ? String(object2.identity) : "",
          website: isSet(object2.website) ? String(object2.website) : "",
          securityContact: isSet(object2.securityContact) ? String(object2.securityContact) : "",
          details: isSet(object2.details) ? String(object2.details) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        message.moniker !== void 0 && (obj.moniker = message.moniker);
        message.identity !== void 0 && (obj.identity = message.identity);
        message.website !== void 0 && (obj.website = message.website);
        message.securityContact !== void 0 && (obj.securityContact = message.securityContact);
        message.details !== void 0 && (obj.details = message.details);
        return obj;
      },
      fromPartial(object2) {
        var _a2, _b, _c, _d, _e3;
        const message = createBaseDescription();
        message.moniker = (_a2 = object2.moniker) !== null && _a2 !== void 0 ? _a2 : "";
        message.identity = (_b = object2.identity) !== null && _b !== void 0 ? _b : "";
        message.website = (_c = object2.website) !== null && _c !== void 0 ? _c : "";
        message.securityContact = (_d = object2.securityContact) !== null && _d !== void 0 ? _d : "";
        message.details = (_e3 = object2.details) !== null && _e3 !== void 0 ? _e3 : "";
        return message;
      }
    };
    function createBaseValidator() {
      return {
        operatorAddress: "",
        consensusPubkey: void 0,
        jailed: false,
        status: 0,
        tokens: "",
        delegatorShares: "",
        description: void 0,
        unbondingHeight: "0",
        unbondingTime: void 0,
        commission: void 0,
        minSelfDelegation: ""
      };
    }
    exports.Validator = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.operatorAddress !== "") {
          writer.uint32(10).string(message.operatorAddress);
        }
        if (message.consensusPubkey !== void 0) {
          any_1.Any.encode(message.consensusPubkey, writer.uint32(18).fork()).ldelim();
        }
        if (message.jailed === true) {
          writer.uint32(24).bool(message.jailed);
        }
        if (message.status !== 0) {
          writer.uint32(32).int32(message.status);
        }
        if (message.tokens !== "") {
          writer.uint32(42).string(message.tokens);
        }
        if (message.delegatorShares !== "") {
          writer.uint32(50).string(message.delegatorShares);
        }
        if (message.description !== void 0) {
          exports.Description.encode(message.description, writer.uint32(58).fork()).ldelim();
        }
        if (message.unbondingHeight !== "0") {
          writer.uint32(64).int64(message.unbondingHeight);
        }
        if (message.unbondingTime !== void 0) {
          timestamp_1.Timestamp.encode(toTimestamp(message.unbondingTime), writer.uint32(74).fork()).ldelim();
        }
        if (message.commission !== void 0) {
          exports.Commission.encode(message.commission, writer.uint32(82).fork()).ldelim();
        }
        if (message.minSelfDelegation !== "") {
          writer.uint32(90).string(message.minSelfDelegation);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseValidator();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.operatorAddress = reader.string();
              break;
            case 2:
              message.consensusPubkey = any_1.Any.decode(reader, reader.uint32());
              break;
            case 3:
              message.jailed = reader.bool();
              break;
            case 4:
              message.status = reader.int32();
              break;
            case 5:
              message.tokens = reader.string();
              break;
            case 6:
              message.delegatorShares = reader.string();
              break;
            case 7:
              message.description = exports.Description.decode(reader, reader.uint32());
              break;
            case 8:
              message.unbondingHeight = longToString(reader.int64());
              break;
            case 9:
              message.unbondingTime = fromTimestamp(timestamp_1.Timestamp.decode(reader, reader.uint32()));
              break;
            case 10:
              message.commission = exports.Commission.decode(reader, reader.uint32());
              break;
            case 11:
              message.minSelfDelegation = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object2) {
        return {
          operatorAddress: isSet(object2.operatorAddress) ? String(object2.operatorAddress) : "",
          consensusPubkey: isSet(object2.consensusPubkey) ? any_1.Any.fromJSON(object2.consensusPubkey) : void 0,
          jailed: isSet(object2.jailed) ? Boolean(object2.jailed) : false,
          status: isSet(object2.status) ? bondStatusFromJSON(object2.status) : 0,
          tokens: isSet(object2.tokens) ? String(object2.tokens) : "",
          delegatorShares: isSet(object2.delegatorShares) ? String(object2.delegatorShares) : "",
          description: isSet(object2.description) ? exports.Description.fromJSON(object2.description) : void 0,
          unbondingHeight: isSet(object2.unbondingHeight) ? String(object2.unbondingHeight) : "0",
          unbondingTime: isSet(object2.unbondingTime) ? fromJsonTimestamp(object2.unbondingTime) : void 0,
          commission: isSet(object2.commission) ? exports.Commission.fromJSON(object2.commission) : void 0,
          minSelfDelegation: isSet(object2.minSelfDelegation) ? String(object2.minSelfDelegation) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        message.operatorAddress !== void 0 && (obj.operatorAddress = message.operatorAddress);
        message.consensusPubkey !== void 0 && (obj.consensusPubkey = message.consensusPubkey ? any_1.Any.toJSON(message.consensusPubkey) : void 0);
        message.jailed !== void 0 && (obj.jailed = message.jailed);
        message.status !== void 0 && (obj.status = bondStatusToJSON(message.status));
        message.tokens !== void 0 && (obj.tokens = message.tokens);
        message.delegatorShares !== void 0 && (obj.delegatorShares = message.delegatorShares);
        message.description !== void 0 && (obj.description = message.description ? exports.Description.toJSON(message.description) : void 0);
        message.unbondingHeight !== void 0 && (obj.unbondingHeight = message.unbondingHeight);
        message.unbondingTime !== void 0 && (obj.unbondingTime = message.unbondingTime.toISOString());
        message.commission !== void 0 && (obj.commission = message.commission ? exports.Commission.toJSON(message.commission) : void 0);
        message.minSelfDelegation !== void 0 && (obj.minSelfDelegation = message.minSelfDelegation);
        return obj;
      },
      fromPartial(object2) {
        var _a2, _b, _c, _d, _e3, _f, _g, _h;
        const message = createBaseValidator();
        message.operatorAddress = (_a2 = object2.operatorAddress) !== null && _a2 !== void 0 ? _a2 : "";
        message.consensusPubkey = object2.consensusPubkey !== void 0 && object2.consensusPubkey !== null ? any_1.Any.fromPartial(object2.consensusPubkey) : void 0;
        message.jailed = (_b = object2.jailed) !== null && _b !== void 0 ? _b : false;
        message.status = (_c = object2.status) !== null && _c !== void 0 ? _c : 0;
        message.tokens = (_d = object2.tokens) !== null && _d !== void 0 ? _d : "";
        message.delegatorShares = (_e3 = object2.delegatorShares) !== null && _e3 !== void 0 ? _e3 : "";
        message.description = object2.description !== void 0 && object2.description !== null ? exports.Description.fromPartial(object2.description) : void 0;
        message.unbondingHeight = (_f = object2.unbondingHeight) !== null && _f !== void 0 ? _f : "0";
        message.unbondingTime = (_g = object2.unbondingTime) !== null && _g !== void 0 ? _g : void 0;
        message.commission = object2.commission !== void 0 && object2.commission !== null ? exports.Commission.fromPartial(object2.commission) : void 0;
        message.minSelfDelegation = (_h = object2.minSelfDelegation) !== null && _h !== void 0 ? _h : "";
        return message;
      }
    };
    function createBaseValAddresses() {
      return { addresses: [] };
    }
    exports.ValAddresses = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v5 of message.addresses) {
          writer.uint32(10).string(v5);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseValAddresses();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.addresses.push(reader.string());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object2) {
        return {
          addresses: Array.isArray(object2 === null || object2 === void 0 ? void 0 : object2.addresses) ? object2.addresses.map((e2) => String(e2)) : []
        };
      },
      toJSON(message) {
        const obj = {};
        if (message.addresses) {
          obj.addresses = message.addresses.map((e2) => e2);
        } else {
          obj.addresses = [];
        }
        return obj;
      },
      fromPartial(object2) {
        var _a2;
        const message = createBaseValAddresses();
        message.addresses = ((_a2 = object2.addresses) === null || _a2 === void 0 ? void 0 : _a2.map((e2) => e2)) || [];
        return message;
      }
    };
    function createBaseDVPair() {
      return { delegatorAddress: "", validatorAddress: "" };
    }
    exports.DVPair = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.delegatorAddress !== "") {
          writer.uint32(10).string(message.delegatorAddress);
        }
        if (message.validatorAddress !== "") {
          writer.uint32(18).string(message.validatorAddress);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseDVPair();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.delegatorAddress = reader.string();
              break;
            case 2:
              message.validatorAddress = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object2) {
        return {
          delegatorAddress: isSet(object2.delegatorAddress) ? String(object2.delegatorAddress) : "",
          validatorAddress: isSet(object2.validatorAddress) ? String(object2.validatorAddress) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        message.delegatorAddress !== void 0 && (obj.delegatorAddress = message.delegatorAddress);
        message.validatorAddress !== void 0 && (obj.validatorAddress = message.validatorAddress);
        return obj;
      },
      fromPartial(object2) {
        var _a2, _b;
        const message = createBaseDVPair();
        message.delegatorAddress = (_a2 = object2.delegatorAddress) !== null && _a2 !== void 0 ? _a2 : "";
        message.validatorAddress = (_b = object2.validatorAddress) !== null && _b !== void 0 ? _b : "";
        return message;
      }
    };
    function createBaseDVPairs() {
      return { pairs: [] };
    }
    exports.DVPairs = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v5 of message.pairs) {
          exports.DVPair.encode(v5, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseDVPairs();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.pairs.push(exports.DVPair.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object2) {
        return {
          pairs: Array.isArray(object2 === null || object2 === void 0 ? void 0 : object2.pairs) ? object2.pairs.map((e2) => exports.DVPair.fromJSON(e2)) : []
        };
      },
      toJSON(message) {
        const obj = {};
        if (message.pairs) {
          obj.pairs = message.pairs.map((e2) => e2 ? exports.DVPair.toJSON(e2) : void 0);
        } else {
          obj.pairs = [];
        }
        return obj;
      },
      fromPartial(object2) {
        var _a2;
        const message = createBaseDVPairs();
        message.pairs = ((_a2 = object2.pairs) === null || _a2 === void 0 ? void 0 : _a2.map((e2) => exports.DVPair.fromPartial(e2))) || [];
        return message;
      }
    };
    function createBaseDVVTriplet() {
      return {
        delegatorAddress: "",
        validatorSrcAddress: "",
        validatorDstAddress: ""
      };
    }
    exports.DVVTriplet = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.delegatorAddress !== "") {
          writer.uint32(10).string(message.delegatorAddress);
        }
        if (message.validatorSrcAddress !== "") {
          writer.uint32(18).string(message.validatorSrcAddress);
        }
        if (message.validatorDstAddress !== "") {
          writer.uint32(26).string(message.validatorDstAddress);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseDVVTriplet();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.delegatorAddress = reader.string();
              break;
            case 2:
              message.validatorSrcAddress = reader.string();
              break;
            case 3:
              message.validatorDstAddress = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object2) {
        return {
          delegatorAddress: isSet(object2.delegatorAddress) ? String(object2.delegatorAddress) : "",
          validatorSrcAddress: isSet(object2.validatorSrcAddress) ? String(object2.validatorSrcAddress) : "",
          validatorDstAddress: isSet(object2.validatorDstAddress) ? String(object2.validatorDstAddress) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        message.delegatorAddress !== void 0 && (obj.delegatorAddress = message.delegatorAddress);
        message.validatorSrcAddress !== void 0 && (obj.validatorSrcAddress = message.validatorSrcAddress);
        message.validatorDstAddress !== void 0 && (obj.validatorDstAddress = message.validatorDstAddress);
        return obj;
      },
      fromPartial(object2) {
        var _a2, _b, _c;
        const message = createBaseDVVTriplet();
        message.delegatorAddress = (_a2 = object2.delegatorAddress) !== null && _a2 !== void 0 ? _a2 : "";
        message.validatorSrcAddress = (_b = object2.validatorSrcAddress) !== null && _b !== void 0 ? _b : "";
        message.validatorDstAddress = (_c = object2.validatorDstAddress) !== null && _c !== void 0 ? _c : "";
        return message;
      }
    };
    function createBaseDVVTriplets() {
      return { triplets: [] };
    }
    exports.DVVTriplets = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v5 of message.triplets) {
          exports.DVVTriplet.encode(v5, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseDVVTriplets();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.triplets.push(exports.DVVTriplet.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object2) {
        return {
          triplets: Array.isArray(object2 === null || object2 === void 0 ? void 0 : object2.triplets) ? object2.triplets.map((e2) => exports.DVVTriplet.fromJSON(e2)) : []
        };
      },
      toJSON(message) {
        const obj = {};
        if (message.triplets) {
          obj.triplets = message.triplets.map((e2) => e2 ? exports.DVVTriplet.toJSON(e2) : void 0);
        } else {
          obj.triplets = [];
        }
        return obj;
      },
      fromPartial(object2) {
        var _a2;
        const message = createBaseDVVTriplets();
        message.triplets = ((_a2 = object2.triplets) === null || _a2 === void 0 ? void 0 : _a2.map((e2) => exports.DVVTriplet.fromPartial(e2))) || [];
        return message;
      }
    };
    function createBaseDelegation() {
      return { delegatorAddress: "", validatorAddress: "", shares: "" };
    }
    exports.Delegation = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.delegatorAddress !== "") {
          writer.uint32(10).string(message.delegatorAddress);
        }
        if (message.validatorAddress !== "") {
          writer.uint32(18).string(message.validatorAddress);
        }
        if (message.shares !== "") {
          writer.uint32(26).string(message.shares);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseDelegation();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.delegatorAddress = reader.string();
              break;
            case 2:
              message.validatorAddress = reader.string();
              break;
            case 3:
              message.shares = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object2) {
        return {
          delegatorAddress: isSet(object2.delegatorAddress) ? String(object2.delegatorAddress) : "",
          validatorAddress: isSet(object2.validatorAddress) ? String(object2.validatorAddress) : "",
          shares: isSet(object2.shares) ? String(object2.shares) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        message.delegatorAddress !== void 0 && (obj.delegatorAddress = message.delegatorAddress);
        message.validatorAddress !== void 0 && (obj.validatorAddress = message.validatorAddress);
        message.shares !== void 0 && (obj.shares = message.shares);
        return obj;
      },
      fromPartial(object2) {
        var _a2, _b, _c;
        const message = createBaseDelegation();
        message.delegatorAddress = (_a2 = object2.delegatorAddress) !== null && _a2 !== void 0 ? _a2 : "";
        message.validatorAddress = (_b = object2.validatorAddress) !== null && _b !== void 0 ? _b : "";
        message.shares = (_c = object2.shares) !== null && _c !== void 0 ? _c : "";
        return message;
      }
    };
    function createBaseUnbondingDelegation() {
      return { delegatorAddress: "", validatorAddress: "", entries: [] };
    }
    exports.UnbondingDelegation = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.delegatorAddress !== "") {
          writer.uint32(10).string(message.delegatorAddress);
        }
        if (message.validatorAddress !== "") {
          writer.uint32(18).string(message.validatorAddress);
        }
        for (const v5 of message.entries) {
          exports.UnbondingDelegationEntry.encode(v5, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseUnbondingDelegation();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.delegatorAddress = reader.string();
              break;
            case 2:
              message.validatorAddress = reader.string();
              break;
            case 3:
              message.entries.push(exports.UnbondingDelegationEntry.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object2) {
        return {
          delegatorAddress: isSet(object2.delegatorAddress) ? String(object2.delegatorAddress) : "",
          validatorAddress: isSet(object2.validatorAddress) ? String(object2.validatorAddress) : "",
          entries: Array.isArray(object2 === null || object2 === void 0 ? void 0 : object2.entries) ? object2.entries.map((e2) => exports.UnbondingDelegationEntry.fromJSON(e2)) : []
        };
      },
      toJSON(message) {
        const obj = {};
        message.delegatorAddress !== void 0 && (obj.delegatorAddress = message.delegatorAddress);
        message.validatorAddress !== void 0 && (obj.validatorAddress = message.validatorAddress);
        if (message.entries) {
          obj.entries = message.entries.map((e2) => e2 ? exports.UnbondingDelegationEntry.toJSON(e2) : void 0);
        } else {
          obj.entries = [];
        }
        return obj;
      },
      fromPartial(object2) {
        var _a2, _b, _c;
        const message = createBaseUnbondingDelegation();
        message.delegatorAddress = (_a2 = object2.delegatorAddress) !== null && _a2 !== void 0 ? _a2 : "";
        message.validatorAddress = (_b = object2.validatorAddress) !== null && _b !== void 0 ? _b : "";
        message.entries = ((_c = object2.entries) === null || _c === void 0 ? void 0 : _c.map((e2) => exports.UnbondingDelegationEntry.fromPartial(e2))) || [];
        return message;
      }
    };
    function createBaseUnbondingDelegationEntry() {
      return {
        creationHeight: "0",
        completionTime: void 0,
        initialBalance: "",
        balance: ""
      };
    }
    exports.UnbondingDelegationEntry = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.creationHeight !== "0") {
          writer.uint32(8).int64(message.creationHeight);
        }
        if (message.completionTime !== void 0) {
          timestamp_1.Timestamp.encode(toTimestamp(message.completionTime), writer.uint32(18).fork()).ldelim();
        }
        if (message.initialBalance !== "") {
          writer.uint32(26).string(message.initialBalance);
        }
        if (message.balance !== "") {
          writer.uint32(34).string(message.balance);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseUnbondingDelegationEntry();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.creationHeight = longToString(reader.int64());
              break;
            case 2:
              message.completionTime = fromTimestamp(timestamp_1.Timestamp.decode(reader, reader.uint32()));
              break;
            case 3:
              message.initialBalance = reader.string();
              break;
            case 4:
              message.balance = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object2) {
        return {
          creationHeight: isSet(object2.creationHeight) ? String(object2.creationHeight) : "0",
          completionTime: isSet(object2.completionTime) ? fromJsonTimestamp(object2.completionTime) : void 0,
          initialBalance: isSet(object2.initialBalance) ? String(object2.initialBalance) : "",
          balance: isSet(object2.balance) ? String(object2.balance) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        message.creationHeight !== void 0 && (obj.creationHeight = message.creationHeight);
        message.completionTime !== void 0 && (obj.completionTime = message.completionTime.toISOString());
        message.initialBalance !== void 0 && (obj.initialBalance = message.initialBalance);
        message.balance !== void 0 && (obj.balance = message.balance);
        return obj;
      },
      fromPartial(object2) {
        var _a2, _b, _c, _d;
        const message = createBaseUnbondingDelegationEntry();
        message.creationHeight = (_a2 = object2.creationHeight) !== null && _a2 !== void 0 ? _a2 : "0";
        message.completionTime = (_b = object2.completionTime) !== null && _b !== void 0 ? _b : void 0;
        message.initialBalance = (_c = object2.initialBalance) !== null && _c !== void 0 ? _c : "";
        message.balance = (_d = object2.balance) !== null && _d !== void 0 ? _d : "";
        return message;
      }
    };
    function createBaseRedelegationEntry() {
      return {
        creationHeight: "0",
        completionTime: void 0,
        initialBalance: "",
        sharesDst: ""
      };
    }
    exports.RedelegationEntry = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.creationHeight !== "0") {
          writer.uint32(8).int64(message.creationHeight);
        }
        if (message.completionTime !== void 0) {
          timestamp_1.Timestamp.encode(toTimestamp(message.completionTime), writer.uint32(18).fork()).ldelim();
        }
        if (message.initialBalance !== "") {
          writer.uint32(26).string(message.initialBalance);
        }
        if (message.sharesDst !== "") {
          writer.uint32(34).string(message.sharesDst);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseRedelegationEntry();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.creationHeight = longToString(reader.int64());
              break;
            case 2:
              message.completionTime = fromTimestamp(timestamp_1.Timestamp.decode(reader, reader.uint32()));
              break;
            case 3:
              message.initialBalance = reader.string();
              break;
            case 4:
              message.sharesDst = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object2) {
        return {
          creationHeight: isSet(object2.creationHeight) ? String(object2.creationHeight) : "0",
          completionTime: isSet(object2.completionTime) ? fromJsonTimestamp(object2.completionTime) : void 0,
          initialBalance: isSet(object2.initialBalance) ? String(object2.initialBalance) : "",
          sharesDst: isSet(object2.sharesDst) ? String(object2.sharesDst) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        message.creationHeight !== void 0 && (obj.creationHeight = message.creationHeight);
        message.completionTime !== void 0 && (obj.completionTime = message.completionTime.toISOString());
        message.initialBalance !== void 0 && (obj.initialBalance = message.initialBalance);
        message.sharesDst !== void 0 && (obj.sharesDst = message.sharesDst);
        return obj;
      },
      fromPartial(object2) {
        var _a2, _b, _c, _d;
        const message = createBaseRedelegationEntry();
        message.creationHeight = (_a2 = object2.creationHeight) !== null && _a2 !== void 0 ? _a2 : "0";
        message.completionTime = (_b = object2.completionTime) !== null && _b !== void 0 ? _b : void 0;
        message.initialBalance = (_c = object2.initialBalance) !== null && _c !== void 0 ? _c : "";
        message.sharesDst = (_d = object2.sharesDst) !== null && _d !== void 0 ? _d : "";
        return message;
      }
    };
    function createBaseRedelegation() {
      return {
        delegatorAddress: "",
        validatorSrcAddress: "",
        validatorDstAddress: "",
        entries: []
      };
    }
    exports.Redelegation = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.delegatorAddress !== "") {
          writer.uint32(10).string(message.delegatorAddress);
        }
        if (message.validatorSrcAddress !== "") {
          writer.uint32(18).string(message.validatorSrcAddress);
        }
        if (message.validatorDstAddress !== "") {
          writer.uint32(26).string(message.validatorDstAddress);
        }
        for (const v5 of message.entries) {
          exports.RedelegationEntry.encode(v5, writer.uint32(34).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseRedelegation();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.delegatorAddress = reader.string();
              break;
            case 2:
              message.validatorSrcAddress = reader.string();
              break;
            case 3:
              message.validatorDstAddress = reader.string();
              break;
            case 4:
              message.entries.push(exports.RedelegationEntry.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object2) {
        return {
          delegatorAddress: isSet(object2.delegatorAddress) ? String(object2.delegatorAddress) : "",
          validatorSrcAddress: isSet(object2.validatorSrcAddress) ? String(object2.validatorSrcAddress) : "",
          validatorDstAddress: isSet(object2.validatorDstAddress) ? String(object2.validatorDstAddress) : "",
          entries: Array.isArray(object2 === null || object2 === void 0 ? void 0 : object2.entries) ? object2.entries.map((e2) => exports.RedelegationEntry.fromJSON(e2)) : []
        };
      },
      toJSON(message) {
        const obj = {};
        message.delegatorAddress !== void 0 && (obj.delegatorAddress = message.delegatorAddress);
        message.validatorSrcAddress !== void 0 && (obj.validatorSrcAddress = message.validatorSrcAddress);
        message.validatorDstAddress !== void 0 && (obj.validatorDstAddress = message.validatorDstAddress);
        if (message.entries) {
          obj.entries = message.entries.map((e2) => e2 ? exports.RedelegationEntry.toJSON(e2) : void 0);
        } else {
          obj.entries = [];
        }
        return obj;
      },
      fromPartial(object2) {
        var _a2, _b, _c, _d;
        const message = createBaseRedelegation();
        message.delegatorAddress = (_a2 = object2.delegatorAddress) !== null && _a2 !== void 0 ? _a2 : "";
        message.validatorSrcAddress = (_b = object2.validatorSrcAddress) !== null && _b !== void 0 ? _b : "";
        message.validatorDstAddress = (_c = object2.validatorDstAddress) !== null && _c !== void 0 ? _c : "";
        message.entries = ((_d = object2.entries) === null || _d === void 0 ? void 0 : _d.map((e2) => exports.RedelegationEntry.fromPartial(e2))) || [];
        return message;
      }
    };
    function createBaseParams() {
      return {
        unbondingTime: void 0,
        maxValidators: 0,
        maxEntries: 0,
        historicalEntries: 0,
        bondDenom: ""
      };
    }
    exports.Params = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.unbondingTime !== void 0) {
          duration_1.Duration.encode(message.unbondingTime, writer.uint32(10).fork()).ldelim();
        }
        if (message.maxValidators !== 0) {
          writer.uint32(16).uint32(message.maxValidators);
        }
        if (message.maxEntries !== 0) {
          writer.uint32(24).uint32(message.maxEntries);
        }
        if (message.historicalEntries !== 0) {
          writer.uint32(32).uint32(message.historicalEntries);
        }
        if (message.bondDenom !== "") {
          writer.uint32(42).string(message.bondDenom);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseParams();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.unbondingTime = duration_1.Duration.decode(reader, reader.uint32());
              break;
            case 2:
              message.maxValidators = reader.uint32();
              break;
            case 3:
              message.maxEntries = reader.uint32();
              break;
            case 4:
              message.historicalEntries = reader.uint32();
              break;
            case 5:
              message.bondDenom = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object2) {
        return {
          unbondingTime: isSet(object2.unbondingTime) ? duration_1.Duration.fromJSON(object2.unbondingTime) : void 0,
          maxValidators: isSet(object2.maxValidators) ? Number(object2.maxValidators) : 0,
          maxEntries: isSet(object2.maxEntries) ? Number(object2.maxEntries) : 0,
          historicalEntries: isSet(object2.historicalEntries) ? Number(object2.historicalEntries) : 0,
          bondDenom: isSet(object2.bondDenom) ? String(object2.bondDenom) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        message.unbondingTime !== void 0 && (obj.unbondingTime = message.unbondingTime ? duration_1.Duration.toJSON(message.unbondingTime) : void 0);
        message.maxValidators !== void 0 && (obj.maxValidators = Math.round(message.maxValidators));
        message.maxEntries !== void 0 && (obj.maxEntries = Math.round(message.maxEntries));
        message.historicalEntries !== void 0 && (obj.historicalEntries = Math.round(message.historicalEntries));
        message.bondDenom !== void 0 && (obj.bondDenom = message.bondDenom);
        return obj;
      },
      fromPartial(object2) {
        var _a2, _b, _c, _d;
        const message = createBaseParams();
        message.unbondingTime = object2.unbondingTime !== void 0 && object2.unbondingTime !== null ? duration_1.Duration.fromPartial(object2.unbondingTime) : void 0;
        message.maxValidators = (_a2 = object2.maxValidators) !== null && _a2 !== void 0 ? _a2 : 0;
        message.maxEntries = (_b = object2.maxEntries) !== null && _b !== void 0 ? _b : 0;
        message.historicalEntries = (_c = object2.historicalEntries) !== null && _c !== void 0 ? _c : 0;
        message.bondDenom = (_d = object2.bondDenom) !== null && _d !== void 0 ? _d : "";
        return message;
      }
    };
    function createBaseDelegationResponse() {
      return { delegation: void 0, balance: void 0 };
    }
    exports.DelegationResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.delegation !== void 0) {
          exports.Delegation.encode(message.delegation, writer.uint32(10).fork()).ldelim();
        }
        if (message.balance !== void 0) {
          coin_1.Coin.encode(message.balance, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseDelegationResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.delegation = exports.Delegation.decode(reader, reader.uint32());
              break;
            case 2:
              message.balance = coin_1.Coin.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object2) {
        return {
          delegation: isSet(object2.delegation) ? exports.Delegation.fromJSON(object2.delegation) : void 0,
          balance: isSet(object2.balance) ? coin_1.Coin.fromJSON(object2.balance) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.delegation !== void 0 && (obj.delegation = message.delegation ? exports.Delegation.toJSON(message.delegation) : void 0);
        message.balance !== void 0 && (obj.balance = message.balance ? coin_1.Coin.toJSON(message.balance) : void 0);
        return obj;
      },
      fromPartial(object2) {
        const message = createBaseDelegationResponse();
        message.delegation = object2.delegation !== void 0 && object2.delegation !== null ? exports.Delegation.fromPartial(object2.delegation) : void 0;
        message.balance = object2.balance !== void 0 && object2.balance !== null ? coin_1.Coin.fromPartial(object2.balance) : void 0;
        return message;
      }
    };
    function createBaseRedelegationEntryResponse() {
      return { redelegationEntry: void 0, balance: "" };
    }
    exports.RedelegationEntryResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.redelegationEntry !== void 0) {
          exports.RedelegationEntry.encode(message.redelegationEntry, writer.uint32(10).fork()).ldelim();
        }
        if (message.balance !== "") {
          writer.uint32(34).string(message.balance);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseRedelegationEntryResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.redelegationEntry = exports.RedelegationEntry.decode(reader, reader.uint32());
              break;
            case 4:
              message.balance = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object2) {
        return {
          redelegationEntry: isSet(object2.redelegationEntry) ? exports.RedelegationEntry.fromJSON(object2.redelegationEntry) : void 0,
          balance: isSet(object2.balance) ? String(object2.balance) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        message.redelegationEntry !== void 0 && (obj.redelegationEntry = message.redelegationEntry ? exports.RedelegationEntry.toJSON(message.redelegationEntry) : void 0);
        message.balance !== void 0 && (obj.balance = message.balance);
        return obj;
      },
      fromPartial(object2) {
        var _a2;
        const message = createBaseRedelegationEntryResponse();
        message.redelegationEntry = object2.redelegationEntry !== void 0 && object2.redelegationEntry !== null ? exports.RedelegationEntry.fromPartial(object2.redelegationEntry) : void 0;
        message.balance = (_a2 = object2.balance) !== null && _a2 !== void 0 ? _a2 : "";
        return message;
      }
    };
    function createBaseRedelegationResponse() {
      return { redelegation: void 0, entries: [] };
    }
    exports.RedelegationResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.redelegation !== void 0) {
          exports.Redelegation.encode(message.redelegation, writer.uint32(10).fork()).ldelim();
        }
        for (const v5 of message.entries) {
          exports.RedelegationEntryResponse.encode(v5, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseRedelegationResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.redelegation = exports.Redelegation.decode(reader, reader.uint32());
              break;
            case 2:
              message.entries.push(exports.RedelegationEntryResponse.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object2) {
        return {
          redelegation: isSet(object2.redelegation) ? exports.Redelegation.fromJSON(object2.redelegation) : void 0,
          entries: Array.isArray(object2 === null || object2 === void 0 ? void 0 : object2.entries) ? object2.entries.map((e2) => exports.RedelegationEntryResponse.fromJSON(e2)) : []
        };
      },
      toJSON(message) {
        const obj = {};
        message.redelegation !== void 0 && (obj.redelegation = message.redelegation ? exports.Redelegation.toJSON(message.redelegation) : void 0);
        if (message.entries) {
          obj.entries = message.entries.map((e2) => e2 ? exports.RedelegationEntryResponse.toJSON(e2) : void 0);
        } else {
          obj.entries = [];
        }
        return obj;
      },
      fromPartial(object2) {
        var _a2;
        const message = createBaseRedelegationResponse();
        message.redelegation = object2.redelegation !== void 0 && object2.redelegation !== null ? exports.Redelegation.fromPartial(object2.redelegation) : void 0;
        message.entries = ((_a2 = object2.entries) === null || _a2 === void 0 ? void 0 : _a2.map((e2) => exports.RedelegationEntryResponse.fromPartial(e2))) || [];
        return message;
      }
    };
    function createBasePool() {
      return { notBondedTokens: "", bondedTokens: "" };
    }
    exports.Pool = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.notBondedTokens !== "") {
          writer.uint32(10).string(message.notBondedTokens);
        }
        if (message.bondedTokens !== "") {
          writer.uint32(18).string(message.bondedTokens);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBasePool();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.notBondedTokens = reader.string();
              break;
            case 2:
              message.bondedTokens = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object2) {
        return {
          notBondedTokens: isSet(object2.notBondedTokens) ? String(object2.notBondedTokens) : "",
          bondedTokens: isSet(object2.bondedTokens) ? String(object2.bondedTokens) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        message.notBondedTokens !== void 0 && (obj.notBondedTokens = message.notBondedTokens);
        message.bondedTokens !== void 0 && (obj.bondedTokens = message.bondedTokens);
        return obj;
      },
      fromPartial(object2) {
        var _a2, _b;
        const message = createBasePool();
        message.notBondedTokens = (_a2 = object2.notBondedTokens) !== null && _a2 !== void 0 ? _a2 : "";
        message.bondedTokens = (_b = object2.bondedTokens) !== null && _b !== void 0 ? _b : "";
        return message;
      }
    };
    function toTimestamp(date) {
      const seconds = Math.trunc(date.getTime() / 1e3).toString();
      const nanos = date.getTime() % 1e3 * 1e6;
      return { seconds, nanos };
    }
    function fromTimestamp(t) {
      let millis = Number(t.seconds) * 1e3;
      millis += t.nanos / 1e6;
      return new Date(millis);
    }
    function fromJsonTimestamp(o4) {
      if (o4 instanceof Date) {
        return o4;
      } else if (typeof o4 === "string") {
        return new Date(o4);
      } else {
        return fromTimestamp(timestamp_1.Timestamp.fromJSON(o4));
      }
    }
    function longToString(long) {
      return long.toString();
    }
    if (minimal_1.default.util.Long !== long_1.default) {
      minimal_1.default.util.Long = long_1.default;
      minimal_1.default.configure();
    }
    function isSet(value) {
      return value !== null && value !== void 0;
    }
  }
});

// ../../node_modules/.pnpm/@keplr-wallet+proto-types@0.12.28/node_modules/@keplr-wallet/proto-types/cosmos/staking/v1beta1/tx.js
var require_tx2 = __commonJS({
  "../../node_modules/.pnpm/@keplr-wallet+proto-types@0.12.28/node_modules/@keplr-wallet/proto-types/cosmos/staking/v1beta1/tx.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MsgUndelegateResponse = exports.MsgUndelegate = exports.MsgBeginRedelegateResponse = exports.MsgBeginRedelegate = exports.MsgDelegateResponse = exports.MsgDelegate = exports.MsgEditValidatorResponse = exports.MsgEditValidator = exports.MsgCreateValidatorResponse = exports.MsgCreateValidator = exports.protobufPackage = void 0;
    var long_1 = __importDefault(require_long());
    var minimal_1 = __importDefault(require_minimal());
    var timestamp_1 = require_timestamp();
    var staking_1 = require_staking();
    var any_1 = require_any();
    var coin_1 = require_coin2();
    exports.protobufPackage = "cosmos.staking.v1beta1";
    function createBaseMsgCreateValidator() {
      return {
        description: void 0,
        commission: void 0,
        minSelfDelegation: "",
        delegatorAddress: "",
        validatorAddress: "",
        pubkey: void 0,
        value: void 0
      };
    }
    exports.MsgCreateValidator = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.description !== void 0) {
          staking_1.Description.encode(message.description, writer.uint32(10).fork()).ldelim();
        }
        if (message.commission !== void 0) {
          staking_1.CommissionRates.encode(message.commission, writer.uint32(18).fork()).ldelim();
        }
        if (message.minSelfDelegation !== "") {
          writer.uint32(26).string(message.minSelfDelegation);
        }
        if (message.delegatorAddress !== "") {
          writer.uint32(34).string(message.delegatorAddress);
        }
        if (message.validatorAddress !== "") {
          writer.uint32(42).string(message.validatorAddress);
        }
        if (message.pubkey !== void 0) {
          any_1.Any.encode(message.pubkey, writer.uint32(50).fork()).ldelim();
        }
        if (message.value !== void 0) {
          coin_1.Coin.encode(message.value, writer.uint32(58).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgCreateValidator();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.description = staking_1.Description.decode(reader, reader.uint32());
              break;
            case 2:
              message.commission = staking_1.CommissionRates.decode(reader, reader.uint32());
              break;
            case 3:
              message.minSelfDelegation = reader.string();
              break;
            case 4:
              message.delegatorAddress = reader.string();
              break;
            case 5:
              message.validatorAddress = reader.string();
              break;
            case 6:
              message.pubkey = any_1.Any.decode(reader, reader.uint32());
              break;
            case 7:
              message.value = coin_1.Coin.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object2) {
        return {
          description: isSet(object2.description) ? staking_1.Description.fromJSON(object2.description) : void 0,
          commission: isSet(object2.commission) ? staking_1.CommissionRates.fromJSON(object2.commission) : void 0,
          minSelfDelegation: isSet(object2.minSelfDelegation) ? String(object2.minSelfDelegation) : "",
          delegatorAddress: isSet(object2.delegatorAddress) ? String(object2.delegatorAddress) : "",
          validatorAddress: isSet(object2.validatorAddress) ? String(object2.validatorAddress) : "",
          pubkey: isSet(object2.pubkey) ? any_1.Any.fromJSON(object2.pubkey) : void 0,
          value: isSet(object2.value) ? coin_1.Coin.fromJSON(object2.value) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.description !== void 0 && (obj.description = message.description ? staking_1.Description.toJSON(message.description) : void 0);
        message.commission !== void 0 && (obj.commission = message.commission ? staking_1.CommissionRates.toJSON(message.commission) : void 0);
        message.minSelfDelegation !== void 0 && (obj.minSelfDelegation = message.minSelfDelegation);
        message.delegatorAddress !== void 0 && (obj.delegatorAddress = message.delegatorAddress);
        message.validatorAddress !== void 0 && (obj.validatorAddress = message.validatorAddress);
        message.pubkey !== void 0 && (obj.pubkey = message.pubkey ? any_1.Any.toJSON(message.pubkey) : void 0);
        message.value !== void 0 && (obj.value = message.value ? coin_1.Coin.toJSON(message.value) : void 0);
        return obj;
      },
      fromPartial(object2) {
        var _a2, _b, _c;
        const message = createBaseMsgCreateValidator();
        message.description = object2.description !== void 0 && object2.description !== null ? staking_1.Description.fromPartial(object2.description) : void 0;
        message.commission = object2.commission !== void 0 && object2.commission !== null ? staking_1.CommissionRates.fromPartial(object2.commission) : void 0;
        message.minSelfDelegation = (_a2 = object2.minSelfDelegation) !== null && _a2 !== void 0 ? _a2 : "";
        message.delegatorAddress = (_b = object2.delegatorAddress) !== null && _b !== void 0 ? _b : "";
        message.validatorAddress = (_c = object2.validatorAddress) !== null && _c !== void 0 ? _c : "";
        message.pubkey = object2.pubkey !== void 0 && object2.pubkey !== null ? any_1.Any.fromPartial(object2.pubkey) : void 0;
        message.value = object2.value !== void 0 && object2.value !== null ? coin_1.Coin.fromPartial(object2.value) : void 0;
        return message;
      }
    };
    function createBaseMsgCreateValidatorResponse() {
      return {};
    }
    exports.MsgCreateValidatorResponse = {
      encode(_16, writer = minimal_1.default.Writer.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgCreateValidatorResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_16) {
        return {};
      },
      toJSON(_16) {
        const obj = {};
        return obj;
      },
      fromPartial(_16) {
        const message = createBaseMsgCreateValidatorResponse();
        return message;
      }
    };
    function createBaseMsgEditValidator() {
      return {
        description: void 0,
        validatorAddress: "",
        commissionRate: "",
        minSelfDelegation: ""
      };
    }
    exports.MsgEditValidator = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.description !== void 0) {
          staking_1.Description.encode(message.description, writer.uint32(10).fork()).ldelim();
        }
        if (message.validatorAddress !== "") {
          writer.uint32(18).string(message.validatorAddress);
        }
        if (message.commissionRate !== "") {
          writer.uint32(26).string(message.commissionRate);
        }
        if (message.minSelfDelegation !== "") {
          writer.uint32(34).string(message.minSelfDelegation);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgEditValidator();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.description = staking_1.Description.decode(reader, reader.uint32());
              break;
            case 2:
              message.validatorAddress = reader.string();
              break;
            case 3:
              message.commissionRate = reader.string();
              break;
            case 4:
              message.minSelfDelegation = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object2) {
        return {
          description: isSet(object2.description) ? staking_1.Description.fromJSON(object2.description) : void 0,
          validatorAddress: isSet(object2.validatorAddress) ? String(object2.validatorAddress) : "",
          commissionRate: isSet(object2.commissionRate) ? String(object2.commissionRate) : "",
          minSelfDelegation: isSet(object2.minSelfDelegation) ? String(object2.minSelfDelegation) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        message.description !== void 0 && (obj.description = message.description ? staking_1.Description.toJSON(message.description) : void 0);
        message.validatorAddress !== void 0 && (obj.validatorAddress = message.validatorAddress);
        message.commissionRate !== void 0 && (obj.commissionRate = message.commissionRate);
        message.minSelfDelegation !== void 0 && (obj.minSelfDelegation = message.minSelfDelegation);
        return obj;
      },
      fromPartial(object2) {
        var _a2, _b, _c;
        const message = createBaseMsgEditValidator();
        message.description = object2.description !== void 0 && object2.description !== null ? staking_1.Description.fromPartial(object2.description) : void 0;
        message.validatorAddress = (_a2 = object2.validatorAddress) !== null && _a2 !== void 0 ? _a2 : "";
        message.commissionRate = (_b = object2.commissionRate) !== null && _b !== void 0 ? _b : "";
        message.minSelfDelegation = (_c = object2.minSelfDelegation) !== null && _c !== void 0 ? _c : "";
        return message;
      }
    };
    function createBaseMsgEditValidatorResponse() {
      return {};
    }
    exports.MsgEditValidatorResponse = {
      encode(_16, writer = minimal_1.default.Writer.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgEditValidatorResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_16) {
        return {};
      },
      toJSON(_16) {
        const obj = {};
        return obj;
      },
      fromPartial(_16) {
        const message = createBaseMsgEditValidatorResponse();
        return message;
      }
    };
    function createBaseMsgDelegate() {
      return { delegatorAddress: "", validatorAddress: "", amount: void 0 };
    }
    exports.MsgDelegate = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.delegatorAddress !== "") {
          writer.uint32(10).string(message.delegatorAddress);
        }
        if (message.validatorAddress !== "") {
          writer.uint32(18).string(message.validatorAddress);
        }
        if (message.amount !== void 0) {
          coin_1.Coin.encode(message.amount, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgDelegate();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.delegatorAddress = reader.string();
              break;
            case 2:
              message.validatorAddress = reader.string();
              break;
            case 3:
              message.amount = coin_1.Coin.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object2) {
        return {
          delegatorAddress: isSet(object2.delegatorAddress) ? String(object2.delegatorAddress) : "",
          validatorAddress: isSet(object2.validatorAddress) ? String(object2.validatorAddress) : "",
          amount: isSet(object2.amount) ? coin_1.Coin.fromJSON(object2.amount) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.delegatorAddress !== void 0 && (obj.delegatorAddress = message.delegatorAddress);
        message.validatorAddress !== void 0 && (obj.validatorAddress = message.validatorAddress);
        message.amount !== void 0 && (obj.amount = message.amount ? coin_1.Coin.toJSON(message.amount) : void 0);
        return obj;
      },
      fromPartial(object2) {
        var _a2, _b;
        const message = createBaseMsgDelegate();
        message.delegatorAddress = (_a2 = object2.delegatorAddress) !== null && _a2 !== void 0 ? _a2 : "";
        message.validatorAddress = (_b = object2.validatorAddress) !== null && _b !== void 0 ? _b : "";
        message.amount = object2.amount !== void 0 && object2.amount !== null ? coin_1.Coin.fromPartial(object2.amount) : void 0;
        return message;
      }
    };
    function createBaseMsgDelegateResponse() {
      return {};
    }
    exports.MsgDelegateResponse = {
      encode(_16, writer = minimal_1.default.Writer.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgDelegateResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_16) {
        return {};
      },
      toJSON(_16) {
        const obj = {};
        return obj;
      },
      fromPartial(_16) {
        const message = createBaseMsgDelegateResponse();
        return message;
      }
    };
    function createBaseMsgBeginRedelegate() {
      return {
        delegatorAddress: "",
        validatorSrcAddress: "",
        validatorDstAddress: "",
        amount: void 0
      };
    }
    exports.MsgBeginRedelegate = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.delegatorAddress !== "") {
          writer.uint32(10).string(message.delegatorAddress);
        }
        if (message.validatorSrcAddress !== "") {
          writer.uint32(18).string(message.validatorSrcAddress);
        }
        if (message.validatorDstAddress !== "") {
          writer.uint32(26).string(message.validatorDstAddress);
        }
        if (message.amount !== void 0) {
          coin_1.Coin.encode(message.amount, writer.uint32(34).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgBeginRedelegate();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.delegatorAddress = reader.string();
              break;
            case 2:
              message.validatorSrcAddress = reader.string();
              break;
            case 3:
              message.validatorDstAddress = reader.string();
              break;
            case 4:
              message.amount = coin_1.Coin.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object2) {
        return {
          delegatorAddress: isSet(object2.delegatorAddress) ? String(object2.delegatorAddress) : "",
          validatorSrcAddress: isSet(object2.validatorSrcAddress) ? String(object2.validatorSrcAddress) : "",
          validatorDstAddress: isSet(object2.validatorDstAddress) ? String(object2.validatorDstAddress) : "",
          amount: isSet(object2.amount) ? coin_1.Coin.fromJSON(object2.amount) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.delegatorAddress !== void 0 && (obj.delegatorAddress = message.delegatorAddress);
        message.validatorSrcAddress !== void 0 && (obj.validatorSrcAddress = message.validatorSrcAddress);
        message.validatorDstAddress !== void 0 && (obj.validatorDstAddress = message.validatorDstAddress);
        message.amount !== void 0 && (obj.amount = message.amount ? coin_1.Coin.toJSON(message.amount) : void 0);
        return obj;
      },
      fromPartial(object2) {
        var _a2, _b, _c;
        const message = createBaseMsgBeginRedelegate();
        message.delegatorAddress = (_a2 = object2.delegatorAddress) !== null && _a2 !== void 0 ? _a2 : "";
        message.validatorSrcAddress = (_b = object2.validatorSrcAddress) !== null && _b !== void 0 ? _b : "";
        message.validatorDstAddress = (_c = object2.validatorDstAddress) !== null && _c !== void 0 ? _c : "";
        message.amount = object2.amount !== void 0 && object2.amount !== null ? coin_1.Coin.fromPartial(object2.amount) : void 0;
        return message;
      }
    };
    function createBaseMsgBeginRedelegateResponse() {
      return { completionTime: void 0 };
    }
    exports.MsgBeginRedelegateResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.completionTime !== void 0) {
          timestamp_1.Timestamp.encode(toTimestamp(message.completionTime), writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgBeginRedelegateResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.completionTime = fromTimestamp(timestamp_1.Timestamp.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object2) {
        return {
          completionTime: isSet(object2.completionTime) ? fromJsonTimestamp(object2.completionTime) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.completionTime !== void 0 && (obj.completionTime = message.completionTime.toISOString());
        return obj;
      },
      fromPartial(object2) {
        var _a2;
        const message = createBaseMsgBeginRedelegateResponse();
        message.completionTime = (_a2 = object2.completionTime) !== null && _a2 !== void 0 ? _a2 : void 0;
        return message;
      }
    };
    function createBaseMsgUndelegate() {
      return { delegatorAddress: "", validatorAddress: "", amount: void 0 };
    }
    exports.MsgUndelegate = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.delegatorAddress !== "") {
          writer.uint32(10).string(message.delegatorAddress);
        }
        if (message.validatorAddress !== "") {
          writer.uint32(18).string(message.validatorAddress);
        }
        if (message.amount !== void 0) {
          coin_1.Coin.encode(message.amount, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgUndelegate();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.delegatorAddress = reader.string();
              break;
            case 2:
              message.validatorAddress = reader.string();
              break;
            case 3:
              message.amount = coin_1.Coin.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object2) {
        return {
          delegatorAddress: isSet(object2.delegatorAddress) ? String(object2.delegatorAddress) : "",
          validatorAddress: isSet(object2.validatorAddress) ? String(object2.validatorAddress) : "",
          amount: isSet(object2.amount) ? coin_1.Coin.fromJSON(object2.amount) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.delegatorAddress !== void 0 && (obj.delegatorAddress = message.delegatorAddress);
        message.validatorAddress !== void 0 && (obj.validatorAddress = message.validatorAddress);
        message.amount !== void 0 && (obj.amount = message.amount ? coin_1.Coin.toJSON(message.amount) : void 0);
        return obj;
      },
      fromPartial(object2) {
        var _a2, _b;
        const message = createBaseMsgUndelegate();
        message.delegatorAddress = (_a2 = object2.delegatorAddress) !== null && _a2 !== void 0 ? _a2 : "";
        message.validatorAddress = (_b = object2.validatorAddress) !== null && _b !== void 0 ? _b : "";
        message.amount = object2.amount !== void 0 && object2.amount !== null ? coin_1.Coin.fromPartial(object2.amount) : void 0;
        return message;
      }
    };
    function createBaseMsgUndelegateResponse() {
      return { completionTime: void 0 };
    }
    exports.MsgUndelegateResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.completionTime !== void 0) {
          timestamp_1.Timestamp.encode(toTimestamp(message.completionTime), writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgUndelegateResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.completionTime = fromTimestamp(timestamp_1.Timestamp.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object2) {
        return {
          completionTime: isSet(object2.completionTime) ? fromJsonTimestamp(object2.completionTime) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.completionTime !== void 0 && (obj.completionTime = message.completionTime.toISOString());
        return obj;
      },
      fromPartial(object2) {
        var _a2;
        const message = createBaseMsgUndelegateResponse();
        message.completionTime = (_a2 = object2.completionTime) !== null && _a2 !== void 0 ? _a2 : void 0;
        return message;
      }
    };
    function toTimestamp(date) {
      const seconds = Math.trunc(date.getTime() / 1e3).toString();
      const nanos = date.getTime() % 1e3 * 1e6;
      return { seconds, nanos };
    }
    function fromTimestamp(t) {
      let millis = Number(t.seconds) * 1e3;
      millis += t.nanos / 1e6;
      return new Date(millis);
    }
    function fromJsonTimestamp(o4) {
      if (o4 instanceof Date) {
        return o4;
      } else if (typeof o4 === "string") {
        return new Date(o4);
      } else {
        return fromTimestamp(timestamp_1.Timestamp.fromJSON(o4));
      }
    }
    if (minimal_1.default.util.Long !== long_1.default) {
      minimal_1.default.util.Long = long_1.default;
      minimal_1.default.configure();
    }
    function isSet(value) {
      return value !== null && value !== void 0;
    }
  }
});

// ../../node_modules/.pnpm/@keplr-wallet+proto-types@0.12.28/node_modules/@keplr-wallet/proto-types/cosmos/authz/v1beta1/authz.js
var require_authz = __commonJS({
  "../../node_modules/.pnpm/@keplr-wallet+proto-types@0.12.28/node_modules/@keplr-wallet/proto-types/cosmos/authz/v1beta1/authz.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Grant = exports.GenericAuthorization = exports.protobufPackage = void 0;
    var long_1 = __importDefault(require_long());
    var minimal_1 = __importDefault(require_minimal());
    var timestamp_1 = require_timestamp();
    var any_1 = require_any();
    exports.protobufPackage = "cosmos.authz.v1beta1";
    function createBaseGenericAuthorization() {
      return { msg: "" };
    }
    exports.GenericAuthorization = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.msg !== "") {
          writer.uint32(10).string(message.msg);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseGenericAuthorization();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.msg = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object2) {
        return {
          msg: isSet(object2.msg) ? String(object2.msg) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        message.msg !== void 0 && (obj.msg = message.msg);
        return obj;
      },
      fromPartial(object2) {
        var _a2;
        const message = createBaseGenericAuthorization();
        message.msg = (_a2 = object2.msg) !== null && _a2 !== void 0 ? _a2 : "";
        return message;
      }
    };
    function createBaseGrant() {
      return { authorization: void 0, expiration: void 0 };
    }
    exports.Grant = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.authorization !== void 0) {
          any_1.Any.encode(message.authorization, writer.uint32(10).fork()).ldelim();
        }
        if (message.expiration !== void 0) {
          timestamp_1.Timestamp.encode(toTimestamp(message.expiration), writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseGrant();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.authorization = any_1.Any.decode(reader, reader.uint32());
              break;
            case 2:
              message.expiration = fromTimestamp(timestamp_1.Timestamp.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object2) {
        return {
          authorization: isSet(object2.authorization) ? any_1.Any.fromJSON(object2.authorization) : void 0,
          expiration: isSet(object2.expiration) ? fromJsonTimestamp(object2.expiration) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.authorization !== void 0 && (obj.authorization = message.authorization ? any_1.Any.toJSON(message.authorization) : void 0);
        message.expiration !== void 0 && (obj.expiration = message.expiration.toISOString());
        return obj;
      },
      fromPartial(object2) {
        var _a2;
        const message = createBaseGrant();
        message.authorization = object2.authorization !== void 0 && object2.authorization !== null ? any_1.Any.fromPartial(object2.authorization) : void 0;
        message.expiration = (_a2 = object2.expiration) !== null && _a2 !== void 0 ? _a2 : void 0;
        return message;
      }
    };
    function toTimestamp(date) {
      const seconds = Math.trunc(date.getTime() / 1e3).toString();
      const nanos = date.getTime() % 1e3 * 1e6;
      return { seconds, nanos };
    }
    function fromTimestamp(t) {
      let millis = Number(t.seconds) * 1e3;
      millis += t.nanos / 1e6;
      return new Date(millis);
    }
    function fromJsonTimestamp(o4) {
      if (o4 instanceof Date) {
        return o4;
      } else if (typeof o4 === "string") {
        return new Date(o4);
      } else {
        return fromTimestamp(timestamp_1.Timestamp.fromJSON(o4));
      }
    }
    if (minimal_1.default.util.Long !== long_1.default) {
      minimal_1.default.util.Long = long_1.default;
      minimal_1.default.configure();
    }
    function isSet(value) {
      return value !== null && value !== void 0;
    }
  }
});

// ../../node_modules/.pnpm/@keplr-wallet+proto-types@0.12.28/node_modules/@keplr-wallet/proto-types/cosmos/authz/v1beta1/tx.js
var require_tx3 = __commonJS({
  "../../node_modules/.pnpm/@keplr-wallet+proto-types@0.12.28/node_modules/@keplr-wallet/proto-types/cosmos/authz/v1beta1/tx.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MsgRevokeResponse = exports.MsgRevoke = exports.MsgGrantResponse = exports.MsgExec = exports.MsgExecResponse = exports.MsgGrant = exports.protobufPackage = void 0;
    var long_1 = __importDefault(require_long());
    var minimal_1 = __importDefault(require_minimal());
    var authz_1 = require_authz();
    var any_1 = require_any();
    exports.protobufPackage = "cosmos.authz.v1beta1";
    function createBaseMsgGrant() {
      return { granter: "", grantee: "", grant: void 0 };
    }
    exports.MsgGrant = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.granter !== "") {
          writer.uint32(10).string(message.granter);
        }
        if (message.grantee !== "") {
          writer.uint32(18).string(message.grantee);
        }
        if (message.grant !== void 0) {
          authz_1.Grant.encode(message.grant, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgGrant();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.granter = reader.string();
              break;
            case 2:
              message.grantee = reader.string();
              break;
            case 3:
              message.grant = authz_1.Grant.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object2) {
        return {
          granter: isSet(object2.granter) ? String(object2.granter) : "",
          grantee: isSet(object2.grantee) ? String(object2.grantee) : "",
          grant: isSet(object2.grant) ? authz_1.Grant.fromJSON(object2.grant) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.granter !== void 0 && (obj.granter = message.granter);
        message.grantee !== void 0 && (obj.grantee = message.grantee);
        message.grant !== void 0 && (obj.grant = message.grant ? authz_1.Grant.toJSON(message.grant) : void 0);
        return obj;
      },
      fromPartial(object2) {
        var _a2, _b;
        const message = createBaseMsgGrant();
        message.granter = (_a2 = object2.granter) !== null && _a2 !== void 0 ? _a2 : "";
        message.grantee = (_b = object2.grantee) !== null && _b !== void 0 ? _b : "";
        message.grant = object2.grant !== void 0 && object2.grant !== null ? authz_1.Grant.fromPartial(object2.grant) : void 0;
        return message;
      }
    };
    function createBaseMsgExecResponse() {
      return { results: [] };
    }
    exports.MsgExecResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v5 of message.results) {
          writer.uint32(10).bytes(v5);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgExecResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.results.push(reader.bytes());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object2) {
        return {
          results: Array.isArray(object2 === null || object2 === void 0 ? void 0 : object2.results) ? object2.results.map((e2) => bytesFromBase64(e2)) : []
        };
      },
      toJSON(message) {
        const obj = {};
        if (message.results) {
          obj.results = message.results.map((e2) => base64FromBytes(e2 !== void 0 ? e2 : new Uint8Array()));
        } else {
          obj.results = [];
        }
        return obj;
      },
      fromPartial(object2) {
        var _a2;
        const message = createBaseMsgExecResponse();
        message.results = ((_a2 = object2.results) === null || _a2 === void 0 ? void 0 : _a2.map((e2) => e2)) || [];
        return message;
      }
    };
    function createBaseMsgExec() {
      return { grantee: "", msgs: [] };
    }
    exports.MsgExec = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.grantee !== "") {
          writer.uint32(10).string(message.grantee);
        }
        for (const v5 of message.msgs) {
          any_1.Any.encode(v5, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgExec();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.grantee = reader.string();
              break;
            case 2:
              message.msgs.push(any_1.Any.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object2) {
        return {
          grantee: isSet(object2.grantee) ? String(object2.grantee) : "",
          msgs: Array.isArray(object2 === null || object2 === void 0 ? void 0 : object2.msgs) ? object2.msgs.map((e2) => any_1.Any.fromJSON(e2)) : []
        };
      },
      toJSON(message) {
        const obj = {};
        message.grantee !== void 0 && (obj.grantee = message.grantee);
        if (message.msgs) {
          obj.msgs = message.msgs.map((e2) => e2 ? any_1.Any.toJSON(e2) : void 0);
        } else {
          obj.msgs = [];
        }
        return obj;
      },
      fromPartial(object2) {
        var _a2, _b;
        const message = createBaseMsgExec();
        message.grantee = (_a2 = object2.grantee) !== null && _a2 !== void 0 ? _a2 : "";
        message.msgs = ((_b = object2.msgs) === null || _b === void 0 ? void 0 : _b.map((e2) => any_1.Any.fromPartial(e2))) || [];
        return message;
      }
    };
    function createBaseMsgGrantResponse() {
      return {};
    }
    exports.MsgGrantResponse = {
      encode(_16, writer = minimal_1.default.Writer.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgGrantResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_16) {
        return {};
      },
      toJSON(_16) {
        const obj = {};
        return obj;
      },
      fromPartial(_16) {
        const message = createBaseMsgGrantResponse();
        return message;
      }
    };
    function createBaseMsgRevoke() {
      return { granter: "", grantee: "", msgTypeUrl: "" };
    }
    exports.MsgRevoke = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.granter !== "") {
          writer.uint32(10).string(message.granter);
        }
        if (message.grantee !== "") {
          writer.uint32(18).string(message.grantee);
        }
        if (message.msgTypeUrl !== "") {
          writer.uint32(26).string(message.msgTypeUrl);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgRevoke();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.granter = reader.string();
              break;
            case 2:
              message.grantee = reader.string();
              break;
            case 3:
              message.msgTypeUrl = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object2) {
        return {
          granter: isSet(object2.granter) ? String(object2.granter) : "",
          grantee: isSet(object2.grantee) ? String(object2.grantee) : "",
          msgTypeUrl: isSet(object2.msgTypeUrl) ? String(object2.msgTypeUrl) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        message.granter !== void 0 && (obj.granter = message.granter);
        message.grantee !== void 0 && (obj.grantee = message.grantee);
        message.msgTypeUrl !== void 0 && (obj.msgTypeUrl = message.msgTypeUrl);
        return obj;
      },
      fromPartial(object2) {
        var _a2, _b, _c;
        const message = createBaseMsgRevoke();
        message.granter = (_a2 = object2.granter) !== null && _a2 !== void 0 ? _a2 : "";
        message.grantee = (_b = object2.grantee) !== null && _b !== void 0 ? _b : "";
        message.msgTypeUrl = (_c = object2.msgTypeUrl) !== null && _c !== void 0 ? _c : "";
        return message;
      }
    };
    function createBaseMsgRevokeResponse() {
      return {};
    }
    exports.MsgRevokeResponse = {
      encode(_16, writer = minimal_1.default.Writer.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgRevokeResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_16) {
        return {};
      },
      toJSON(_16) {
        const obj = {};
        return obj;
      },
      fromPartial(_16) {
        const message = createBaseMsgRevokeResponse();
        return message;
      }
    };
    var globalThis2 = (() => {
      if (typeof globalThis2 !== "undefined")
        return globalThis2;
      if (typeof self !== "undefined")
        return self;
      if (typeof window !== "undefined")
        return window;
      if (typeof global !== "undefined")
        return global;
      throw "Unable to locate global object";
    })();
    var atob = globalThis2.atob || ((b64) => globalThis2.Buffer.from(b64, "base64").toString("binary"));
    function bytesFromBase64(b64) {
      const bin = atob(b64);
      const arr = new Uint8Array(bin.length);
      for (let i4 = 0; i4 < bin.length; ++i4) {
        arr[i4] = bin.charCodeAt(i4);
      }
      return arr;
    }
    var btoa = globalThis2.btoa || ((bin) => globalThis2.Buffer.from(bin, "binary").toString("base64"));
    function base64FromBytes(arr) {
      const bin = [];
      for (const byte of arr) {
        bin.push(String.fromCharCode(byte));
      }
      return btoa(bin.join(""));
    }
    if (minimal_1.default.util.Long !== long_1.default) {
      minimal_1.default.util.Long = long_1.default;
      minimal_1.default.configure();
    }
    function isSet(value) {
      return value !== null && value !== void 0;
    }
  }
});

// ../../node_modules/.pnpm/@keplr-wallet+proto-types@0.12.28/node_modules/@keplr-wallet/proto-types/cosmos/gov/v1beta1/gov.js
var require_gov = __commonJS({
  "../../node_modules/.pnpm/@keplr-wallet+proto-types@0.12.28/node_modules/@keplr-wallet/proto-types/cosmos/gov/v1beta1/gov.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TallyParams = exports.VotingParams = exports.DepositParams = exports.Vote = exports.TallyResult = exports.Proposal = exports.Deposit = exports.TextProposal = exports.WeightedVoteOption = exports.proposalStatusToJSON = exports.proposalStatusFromJSON = exports.ProposalStatus = exports.voteOptionToJSON = exports.voteOptionFromJSON = exports.VoteOption = exports.protobufPackage = void 0;
    var long_1 = __importDefault(require_long());
    var minimal_1 = __importDefault(require_minimal());
    var timestamp_1 = require_timestamp();
    var coin_1 = require_coin2();
    var any_1 = require_any();
    var duration_1 = require_duration();
    exports.protobufPackage = "cosmos.gov.v1beta1";
    var VoteOption;
    (function(VoteOption2) {
      VoteOption2[VoteOption2["VOTE_OPTION_UNSPECIFIED"] = 0] = "VOTE_OPTION_UNSPECIFIED";
      VoteOption2[VoteOption2["VOTE_OPTION_YES"] = 1] = "VOTE_OPTION_YES";
      VoteOption2[VoteOption2["VOTE_OPTION_ABSTAIN"] = 2] = "VOTE_OPTION_ABSTAIN";
      VoteOption2[VoteOption2["VOTE_OPTION_NO"] = 3] = "VOTE_OPTION_NO";
      VoteOption2[VoteOption2["VOTE_OPTION_NO_WITH_VETO"] = 4] = "VOTE_OPTION_NO_WITH_VETO";
      VoteOption2[VoteOption2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(VoteOption = exports.VoteOption || (exports.VoteOption = {}));
    function voteOptionFromJSON(object2) {
      switch (object2) {
        case 0:
        case "VOTE_OPTION_UNSPECIFIED":
          return VoteOption.VOTE_OPTION_UNSPECIFIED;
        case 1:
        case "VOTE_OPTION_YES":
          return VoteOption.VOTE_OPTION_YES;
        case 2:
        case "VOTE_OPTION_ABSTAIN":
          return VoteOption.VOTE_OPTION_ABSTAIN;
        case 3:
        case "VOTE_OPTION_NO":
          return VoteOption.VOTE_OPTION_NO;
        case 4:
        case "VOTE_OPTION_NO_WITH_VETO":
          return VoteOption.VOTE_OPTION_NO_WITH_VETO;
        case -1:
        case "UNRECOGNIZED":
        default:
          return VoteOption.UNRECOGNIZED;
      }
    }
    exports.voteOptionFromJSON = voteOptionFromJSON;
    function voteOptionToJSON(object2) {
      switch (object2) {
        case VoteOption.VOTE_OPTION_UNSPECIFIED:
          return "VOTE_OPTION_UNSPECIFIED";
        case VoteOption.VOTE_OPTION_YES:
          return "VOTE_OPTION_YES";
        case VoteOption.VOTE_OPTION_ABSTAIN:
          return "VOTE_OPTION_ABSTAIN";
        case VoteOption.VOTE_OPTION_NO:
          return "VOTE_OPTION_NO";
        case VoteOption.VOTE_OPTION_NO_WITH_VETO:
          return "VOTE_OPTION_NO_WITH_VETO";
        default:
          return "UNKNOWN";
      }
    }
    exports.voteOptionToJSON = voteOptionToJSON;
    var ProposalStatus;
    (function(ProposalStatus2) {
      ProposalStatus2[ProposalStatus2["PROPOSAL_STATUS_UNSPECIFIED"] = 0] = "PROPOSAL_STATUS_UNSPECIFIED";
      ProposalStatus2[ProposalStatus2["PROPOSAL_STATUS_DEPOSIT_PERIOD"] = 1] = "PROPOSAL_STATUS_DEPOSIT_PERIOD";
      ProposalStatus2[ProposalStatus2["PROPOSAL_STATUS_VOTING_PERIOD"] = 2] = "PROPOSAL_STATUS_VOTING_PERIOD";
      ProposalStatus2[ProposalStatus2["PROPOSAL_STATUS_PASSED"] = 3] = "PROPOSAL_STATUS_PASSED";
      ProposalStatus2[ProposalStatus2["PROPOSAL_STATUS_REJECTED"] = 4] = "PROPOSAL_STATUS_REJECTED";
      ProposalStatus2[ProposalStatus2["PROPOSAL_STATUS_FAILED"] = 5] = "PROPOSAL_STATUS_FAILED";
      ProposalStatus2[ProposalStatus2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(ProposalStatus = exports.ProposalStatus || (exports.ProposalStatus = {}));
    function proposalStatusFromJSON(object2) {
      switch (object2) {
        case 0:
        case "PROPOSAL_STATUS_UNSPECIFIED":
          return ProposalStatus.PROPOSAL_STATUS_UNSPECIFIED;
        case 1:
        case "PROPOSAL_STATUS_DEPOSIT_PERIOD":
          return ProposalStatus.PROPOSAL_STATUS_DEPOSIT_PERIOD;
        case 2:
        case "PROPOSAL_STATUS_VOTING_PERIOD":
          return ProposalStatus.PROPOSAL_STATUS_VOTING_PERIOD;
        case 3:
        case "PROPOSAL_STATUS_PASSED":
          return ProposalStatus.PROPOSAL_STATUS_PASSED;
        case 4:
        case "PROPOSAL_STATUS_REJECTED":
          return ProposalStatus.PROPOSAL_STATUS_REJECTED;
        case 5:
        case "PROPOSAL_STATUS_FAILED":
          return ProposalStatus.PROPOSAL_STATUS_FAILED;
        case -1:
        case "UNRECOGNIZED":
        default:
          return ProposalStatus.UNRECOGNIZED;
      }
    }
    exports.proposalStatusFromJSON = proposalStatusFromJSON;
    function proposalStatusToJSON(object2) {
      switch (object2) {
        case ProposalStatus.PROPOSAL_STATUS_UNSPECIFIED:
          return "PROPOSAL_STATUS_UNSPECIFIED";
        case ProposalStatus.PROPOSAL_STATUS_DEPOSIT_PERIOD:
          return "PROPOSAL_STATUS_DEPOSIT_PERIOD";
        case ProposalStatus.PROPOSAL_STATUS_VOTING_PERIOD:
          return "PROPOSAL_STATUS_VOTING_PERIOD";
        case ProposalStatus.PROPOSAL_STATUS_PASSED:
          return "PROPOSAL_STATUS_PASSED";
        case ProposalStatus.PROPOSAL_STATUS_REJECTED:
          return "PROPOSAL_STATUS_REJECTED";
        case ProposalStatus.PROPOSAL_STATUS_FAILED:
          return "PROPOSAL_STATUS_FAILED";
        default:
          return "UNKNOWN";
      }
    }
    exports.proposalStatusToJSON = proposalStatusToJSON;
    function createBaseWeightedVoteOption() {
      return { option: 0, weight: "" };
    }
    exports.WeightedVoteOption = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.option !== 0) {
          writer.uint32(8).int32(message.option);
        }
        if (message.weight !== "") {
          writer.uint32(18).string(message.weight);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseWeightedVoteOption();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.option = reader.int32();
              break;
            case 2:
              message.weight = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object2) {
        return {
          option: isSet(object2.option) ? voteOptionFromJSON(object2.option) : 0,
          weight: isSet(object2.weight) ? String(object2.weight) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        message.option !== void 0 && (obj.option = voteOptionToJSON(message.option));
        message.weight !== void 0 && (obj.weight = message.weight);
        return obj;
      },
      fromPartial(object2) {
        var _a2, _b;
        const message = createBaseWeightedVoteOption();
        message.option = (_a2 = object2.option) !== null && _a2 !== void 0 ? _a2 : 0;
        message.weight = (_b = object2.weight) !== null && _b !== void 0 ? _b : "";
        return message;
      }
    };
    function createBaseTextProposal() {
      return { title: "", description: "" };
    }
    exports.TextProposal = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.title !== "") {
          writer.uint32(10).string(message.title);
        }
        if (message.description !== "") {
          writer.uint32(18).string(message.description);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseTextProposal();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.title = reader.string();
              break;
            case 2:
              message.description = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object2) {
        return {
          title: isSet(object2.title) ? String(object2.title) : "",
          description: isSet(object2.description) ? String(object2.description) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        message.title !== void 0 && (obj.title = message.title);
        message.description !== void 0 && (obj.description = message.description);
        return obj;
      },
      fromPartial(object2) {
        var _a2, _b;
        const message = createBaseTextProposal();
        message.title = (_a2 = object2.title) !== null && _a2 !== void 0 ? _a2 : "";
        message.description = (_b = object2.description) !== null && _b !== void 0 ? _b : "";
        return message;
      }
    };
    function createBaseDeposit() {
      return { proposalId: "0", depositor: "", amount: [] };
    }
    exports.Deposit = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.proposalId !== "0") {
          writer.uint32(8).uint64(message.proposalId);
        }
        if (message.depositor !== "") {
          writer.uint32(18).string(message.depositor);
        }
        for (const v5 of message.amount) {
          coin_1.Coin.encode(v5, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseDeposit();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.proposalId = longToString(reader.uint64());
              break;
            case 2:
              message.depositor = reader.string();
              break;
            case 3:
              message.amount.push(coin_1.Coin.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object2) {
        return {
          proposalId: isSet(object2.proposalId) ? String(object2.proposalId) : "0",
          depositor: isSet(object2.depositor) ? String(object2.depositor) : "",
          amount: Array.isArray(object2 === null || object2 === void 0 ? void 0 : object2.amount) ? object2.amount.map((e2) => coin_1.Coin.fromJSON(e2)) : []
        };
      },
      toJSON(message) {
        const obj = {};
        message.proposalId !== void 0 && (obj.proposalId = message.proposalId);
        message.depositor !== void 0 && (obj.depositor = message.depositor);
        if (message.amount) {
          obj.amount = message.amount.map((e2) => e2 ? coin_1.Coin.toJSON(e2) : void 0);
        } else {
          obj.amount = [];
        }
        return obj;
      },
      fromPartial(object2) {
        var _a2, _b, _c;
        const message = createBaseDeposit();
        message.proposalId = (_a2 = object2.proposalId) !== null && _a2 !== void 0 ? _a2 : "0";
        message.depositor = (_b = object2.depositor) !== null && _b !== void 0 ? _b : "";
        message.amount = ((_c = object2.amount) === null || _c === void 0 ? void 0 : _c.map((e2) => coin_1.Coin.fromPartial(e2))) || [];
        return message;
      }
    };
    function createBaseProposal() {
      return {
        proposalId: "0",
        content: void 0,
        status: 0,
        finalTallyResult: void 0,
        submitTime: void 0,
        depositEndTime: void 0,
        totalDeposit: [],
        votingStartTime: void 0,
        votingEndTime: void 0
      };
    }
    exports.Proposal = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.proposalId !== "0") {
          writer.uint32(8).uint64(message.proposalId);
        }
        if (message.content !== void 0) {
          any_1.Any.encode(message.content, writer.uint32(18).fork()).ldelim();
        }
        if (message.status !== 0) {
          writer.uint32(24).int32(message.status);
        }
        if (message.finalTallyResult !== void 0) {
          exports.TallyResult.encode(message.finalTallyResult, writer.uint32(34).fork()).ldelim();
        }
        if (message.submitTime !== void 0) {
          timestamp_1.Timestamp.encode(toTimestamp(message.submitTime), writer.uint32(42).fork()).ldelim();
        }
        if (message.depositEndTime !== void 0) {
          timestamp_1.Timestamp.encode(toTimestamp(message.depositEndTime), writer.uint32(50).fork()).ldelim();
        }
        for (const v5 of message.totalDeposit) {
          coin_1.Coin.encode(v5, writer.uint32(58).fork()).ldelim();
        }
        if (message.votingStartTime !== void 0) {
          timestamp_1.Timestamp.encode(toTimestamp(message.votingStartTime), writer.uint32(66).fork()).ldelim();
        }
        if (message.votingEndTime !== void 0) {
          timestamp_1.Timestamp.encode(toTimestamp(message.votingEndTime), writer.uint32(74).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseProposal();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.proposalId = longToString(reader.uint64());
              break;
            case 2:
              message.content = any_1.Any.decode(reader, reader.uint32());
              break;
            case 3:
              message.status = reader.int32();
              break;
            case 4:
              message.finalTallyResult = exports.TallyResult.decode(reader, reader.uint32());
              break;
            case 5:
              message.submitTime = fromTimestamp(timestamp_1.Timestamp.decode(reader, reader.uint32()));
              break;
            case 6:
              message.depositEndTime = fromTimestamp(timestamp_1.Timestamp.decode(reader, reader.uint32()));
              break;
            case 7:
              message.totalDeposit.push(coin_1.Coin.decode(reader, reader.uint32()));
              break;
            case 8:
              message.votingStartTime = fromTimestamp(timestamp_1.Timestamp.decode(reader, reader.uint32()));
              break;
            case 9:
              message.votingEndTime = fromTimestamp(timestamp_1.Timestamp.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object2) {
        return {
          proposalId: isSet(object2.proposalId) ? String(object2.proposalId) : "0",
          content: isSet(object2.content) ? any_1.Any.fromJSON(object2.content) : void 0,
          status: isSet(object2.status) ? proposalStatusFromJSON(object2.status) : 0,
          finalTallyResult: isSet(object2.finalTallyResult) ? exports.TallyResult.fromJSON(object2.finalTallyResult) : void 0,
          submitTime: isSet(object2.submitTime) ? fromJsonTimestamp(object2.submitTime) : void 0,
          depositEndTime: isSet(object2.depositEndTime) ? fromJsonTimestamp(object2.depositEndTime) : void 0,
          totalDeposit: Array.isArray(object2 === null || object2 === void 0 ? void 0 : object2.totalDeposit) ? object2.totalDeposit.map((e2) => coin_1.Coin.fromJSON(e2)) : [],
          votingStartTime: isSet(object2.votingStartTime) ? fromJsonTimestamp(object2.votingStartTime) : void 0,
          votingEndTime: isSet(object2.votingEndTime) ? fromJsonTimestamp(object2.votingEndTime) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.proposalId !== void 0 && (obj.proposalId = message.proposalId);
        message.content !== void 0 && (obj.content = message.content ? any_1.Any.toJSON(message.content) : void 0);
        message.status !== void 0 && (obj.status = proposalStatusToJSON(message.status));
        message.finalTallyResult !== void 0 && (obj.finalTallyResult = message.finalTallyResult ? exports.TallyResult.toJSON(message.finalTallyResult) : void 0);
        message.submitTime !== void 0 && (obj.submitTime = message.submitTime.toISOString());
        message.depositEndTime !== void 0 && (obj.depositEndTime = message.depositEndTime.toISOString());
        if (message.totalDeposit) {
          obj.totalDeposit = message.totalDeposit.map((e2) => e2 ? coin_1.Coin.toJSON(e2) : void 0);
        } else {
          obj.totalDeposit = [];
        }
        message.votingStartTime !== void 0 && (obj.votingStartTime = message.votingStartTime.toISOString());
        message.votingEndTime !== void 0 && (obj.votingEndTime = message.votingEndTime.toISOString());
        return obj;
      },
      fromPartial(object2) {
        var _a2, _b, _c, _d, _e3, _f, _g;
        const message = createBaseProposal();
        message.proposalId = (_a2 = object2.proposalId) !== null && _a2 !== void 0 ? _a2 : "0";
        message.content = object2.content !== void 0 && object2.content !== null ? any_1.Any.fromPartial(object2.content) : void 0;
        message.status = (_b = object2.status) !== null && _b !== void 0 ? _b : 0;
        message.finalTallyResult = object2.finalTallyResult !== void 0 && object2.finalTallyResult !== null ? exports.TallyResult.fromPartial(object2.finalTallyResult) : void 0;
        message.submitTime = (_c = object2.submitTime) !== null && _c !== void 0 ? _c : void 0;
        message.depositEndTime = (_d = object2.depositEndTime) !== null && _d !== void 0 ? _d : void 0;
        message.totalDeposit = ((_e3 = object2.totalDeposit) === null || _e3 === void 0 ? void 0 : _e3.map((e2) => coin_1.Coin.fromPartial(e2))) || [];
        message.votingStartTime = (_f = object2.votingStartTime) !== null && _f !== void 0 ? _f : void 0;
        message.votingEndTime = (_g = object2.votingEndTime) !== null && _g !== void 0 ? _g : void 0;
        return message;
      }
    };
    function createBaseTallyResult() {
      return { yes: "", abstain: "", no: "", noWithVeto: "" };
    }
    exports.TallyResult = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.yes !== "") {
          writer.uint32(10).string(message.yes);
        }
        if (message.abstain !== "") {
          writer.uint32(18).string(message.abstain);
        }
        if (message.no !== "") {
          writer.uint32(26).string(message.no);
        }
        if (message.noWithVeto !== "") {
          writer.uint32(34).string(message.noWithVeto);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseTallyResult();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.yes = reader.string();
              break;
            case 2:
              message.abstain = reader.string();
              break;
            case 3:
              message.no = reader.string();
              break;
            case 4:
              message.noWithVeto = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object2) {
        return {
          yes: isSet(object2.yes) ? String(object2.yes) : "",
          abstain: isSet(object2.abstain) ? String(object2.abstain) : "",
          no: isSet(object2.no) ? String(object2.no) : "",
          noWithVeto: isSet(object2.noWithVeto) ? String(object2.noWithVeto) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        message.yes !== void 0 && (obj.yes = message.yes);
        message.abstain !== void 0 && (obj.abstain = message.abstain);
        message.no !== void 0 && (obj.no = message.no);
        message.noWithVeto !== void 0 && (obj.noWithVeto = message.noWithVeto);
        return obj;
      },
      fromPartial(object2) {
        var _a2, _b, _c, _d;
        const message = createBaseTallyResult();
        message.yes = (_a2 = object2.yes) !== null && _a2 !== void 0 ? _a2 : "";
        message.abstain = (_b = object2.abstain) !== null && _b !== void 0 ? _b : "";
        message.no = (_c = object2.no) !== null && _c !== void 0 ? _c : "";
        message.noWithVeto = (_d = object2.noWithVeto) !== null && _d !== void 0 ? _d : "";
        return message;
      }
    };
    function createBaseVote() {
      return { proposalId: "0", voter: "", option: 0, options: [] };
    }
    exports.Vote = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.proposalId !== "0") {
          writer.uint32(8).uint64(message.proposalId);
        }
        if (message.voter !== "") {
          writer.uint32(18).string(message.voter);
        }
        if (message.option !== 0) {
          writer.uint32(24).int32(message.option);
        }
        for (const v5 of message.options) {
          exports.WeightedVoteOption.encode(v5, writer.uint32(34).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseVote();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.proposalId = longToString(reader.uint64());
              break;
            case 2:
              message.voter = reader.string();
              break;
            case 3:
              message.option = reader.int32();
              break;
            case 4:
              message.options.push(exports.WeightedVoteOption.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object2) {
        return {
          proposalId: isSet(object2.proposalId) ? String(object2.proposalId) : "0",
          voter: isSet(object2.voter) ? String(object2.voter) : "",
          option: isSet(object2.option) ? voteOptionFromJSON(object2.option) : 0,
          options: Array.isArray(object2 === null || object2 === void 0 ? void 0 : object2.options) ? object2.options.map((e2) => exports.WeightedVoteOption.fromJSON(e2)) : []
        };
      },
      toJSON(message) {
        const obj = {};
        message.proposalId !== void 0 && (obj.proposalId = message.proposalId);
        message.voter !== void 0 && (obj.voter = message.voter);
        message.option !== void 0 && (obj.option = voteOptionToJSON(message.option));
        if (message.options) {
          obj.options = message.options.map((e2) => e2 ? exports.WeightedVoteOption.toJSON(e2) : void 0);
        } else {
          obj.options = [];
        }
        return obj;
      },
      fromPartial(object2) {
        var _a2, _b, _c, _d;
        const message = createBaseVote();
        message.proposalId = (_a2 = object2.proposalId) !== null && _a2 !== void 0 ? _a2 : "0";
        message.voter = (_b = object2.voter) !== null && _b !== void 0 ? _b : "";
        message.option = (_c = object2.option) !== null && _c !== void 0 ? _c : 0;
        message.options = ((_d = object2.options) === null || _d === void 0 ? void 0 : _d.map((e2) => exports.WeightedVoteOption.fromPartial(e2))) || [];
        return message;
      }
    };
    function createBaseDepositParams() {
      return { minDeposit: [], maxDepositPeriod: void 0 };
    }
    exports.DepositParams = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v5 of message.minDeposit) {
          coin_1.Coin.encode(v5, writer.uint32(10).fork()).ldelim();
        }
        if (message.maxDepositPeriod !== void 0) {
          duration_1.Duration.encode(message.maxDepositPeriod, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseDepositParams();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.minDeposit.push(coin_1.Coin.decode(reader, reader.uint32()));
              break;
            case 2:
              message.maxDepositPeriod = duration_1.Duration.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object2) {
        return {
          minDeposit: Array.isArray(object2 === null || object2 === void 0 ? void 0 : object2.minDeposit) ? object2.minDeposit.map((e2) => coin_1.Coin.fromJSON(e2)) : [],
          maxDepositPeriod: isSet(object2.maxDepositPeriod) ? duration_1.Duration.fromJSON(object2.maxDepositPeriod) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        if (message.minDeposit) {
          obj.minDeposit = message.minDeposit.map((e2) => e2 ? coin_1.Coin.toJSON(e2) : void 0);
        } else {
          obj.minDeposit = [];
        }
        message.maxDepositPeriod !== void 0 && (obj.maxDepositPeriod = message.maxDepositPeriod ? duration_1.Duration.toJSON(message.maxDepositPeriod) : void 0);
        return obj;
      },
      fromPartial(object2) {
        var _a2;
        const message = createBaseDepositParams();
        message.minDeposit = ((_a2 = object2.minDeposit) === null || _a2 === void 0 ? void 0 : _a2.map((e2) => coin_1.Coin.fromPartial(e2))) || [];
        message.maxDepositPeriod = object2.maxDepositPeriod !== void 0 && object2.maxDepositPeriod !== null ? duration_1.Duration.fromPartial(object2.maxDepositPeriod) : void 0;
        return message;
      }
    };
    function createBaseVotingParams() {
      return { votingPeriod: void 0 };
    }
    exports.VotingParams = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.votingPeriod !== void 0) {
          duration_1.Duration.encode(message.votingPeriod, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseVotingParams();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.votingPeriod = duration_1.Duration.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object2) {
        return {
          votingPeriod: isSet(object2.votingPeriod) ? duration_1.Duration.fromJSON(object2.votingPeriod) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.votingPeriod !== void 0 && (obj.votingPeriod = message.votingPeriod ? duration_1.Duration.toJSON(message.votingPeriod) : void 0);
        return obj;
      },
      fromPartial(object2) {
        const message = createBaseVotingParams();
        message.votingPeriod = object2.votingPeriod !== void 0 && object2.votingPeriod !== null ? duration_1.Duration.fromPartial(object2.votingPeriod) : void 0;
        return message;
      }
    };
    function createBaseTallyParams() {
      return {
        quorum: new Uint8Array(),
        threshold: new Uint8Array(),
        vetoThreshold: new Uint8Array()
      };
    }
    exports.TallyParams = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.quorum.length !== 0) {
          writer.uint32(10).bytes(message.quorum);
        }
        if (message.threshold.length !== 0) {
          writer.uint32(18).bytes(message.threshold);
        }
        if (message.vetoThreshold.length !== 0) {
          writer.uint32(26).bytes(message.vetoThreshold);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseTallyParams();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.quorum = reader.bytes();
              break;
            case 2:
              message.threshold = reader.bytes();
              break;
            case 3:
              message.vetoThreshold = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object2) {
        return {
          quorum: isSet(object2.quorum) ? bytesFromBase64(object2.quorum) : new Uint8Array(),
          threshold: isSet(object2.threshold) ? bytesFromBase64(object2.threshold) : new Uint8Array(),
          vetoThreshold: isSet(object2.vetoThreshold) ? bytesFromBase64(object2.vetoThreshold) : new Uint8Array()
        };
      },
      toJSON(message) {
        const obj = {};
        message.quorum !== void 0 && (obj.quorum = base64FromBytes(message.quorum !== void 0 ? message.quorum : new Uint8Array()));
        message.threshold !== void 0 && (obj.threshold = base64FromBytes(message.threshold !== void 0 ? message.threshold : new Uint8Array()));
        message.vetoThreshold !== void 0 && (obj.vetoThreshold = base64FromBytes(message.vetoThreshold !== void 0 ? message.vetoThreshold : new Uint8Array()));
        return obj;
      },
      fromPartial(object2) {
        var _a2, _b, _c;
        const message = createBaseTallyParams();
        message.quorum = (_a2 = object2.quorum) !== null && _a2 !== void 0 ? _a2 : new Uint8Array();
        message.threshold = (_b = object2.threshold) !== null && _b !== void 0 ? _b : new Uint8Array();
        message.vetoThreshold = (_c = object2.vetoThreshold) !== null && _c !== void 0 ? _c : new Uint8Array();
        return message;
      }
    };
    var globalThis2 = (() => {
      if (typeof globalThis2 !== "undefined")
        return globalThis2;
      if (typeof self !== "undefined")
        return self;
      if (typeof window !== "undefined")
        return window;
      if (typeof global !== "undefined")
        return global;
      throw "Unable to locate global object";
    })();
    var atob = globalThis2.atob || ((b64) => globalThis2.Buffer.from(b64, "base64").toString("binary"));
    function bytesFromBase64(b64) {
      const bin = atob(b64);
      const arr = new Uint8Array(bin.length);
      for (let i4 = 0; i4 < bin.length; ++i4) {
        arr[i4] = bin.charCodeAt(i4);
      }
      return arr;
    }
    var btoa = globalThis2.btoa || ((bin) => globalThis2.Buffer.from(bin, "binary").toString("base64"));
    function base64FromBytes(arr) {
      const bin = [];
      for (const byte of arr) {
        bin.push(String.fromCharCode(byte));
      }
      return btoa(bin.join(""));
    }
    function toTimestamp(date) {
      const seconds = Math.trunc(date.getTime() / 1e3).toString();
      const nanos = date.getTime() % 1e3 * 1e6;
      return { seconds, nanos };
    }
    function fromTimestamp(t) {
      let millis = Number(t.seconds) * 1e3;
      millis += t.nanos / 1e6;
      return new Date(millis);
    }
    function fromJsonTimestamp(o4) {
      if (o4 instanceof Date) {
        return o4;
      } else if (typeof o4 === "string") {
        return new Date(o4);
      } else {
        return fromTimestamp(timestamp_1.Timestamp.fromJSON(o4));
      }
    }
    function longToString(long) {
      return long.toString();
    }
    if (minimal_1.default.util.Long !== long_1.default) {
      minimal_1.default.util.Long = long_1.default;
      minimal_1.default.configure();
    }
    function isSet(value) {
      return value !== null && value !== void 0;
    }
  }
});

// ../../node_modules/.pnpm/@keplr-wallet+proto-types@0.12.28/node_modules/@keplr-wallet/proto-types/cosmos/gov/v1beta1/tx.js
var require_tx4 = __commonJS({
  "../../node_modules/.pnpm/@keplr-wallet+proto-types@0.12.28/node_modules/@keplr-wallet/proto-types/cosmos/gov/v1beta1/tx.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MsgDepositResponse = exports.MsgDeposit = exports.MsgVoteWeightedResponse = exports.MsgVoteWeighted = exports.MsgVoteResponse = exports.MsgVote = exports.MsgSubmitProposalResponse = exports.MsgSubmitProposal = exports.protobufPackage = void 0;
    var long_1 = __importDefault(require_long());
    var minimal_1 = __importDefault(require_minimal());
    var gov_1 = require_gov();
    var any_1 = require_any();
    var coin_1 = require_coin2();
    exports.protobufPackage = "cosmos.gov.v1beta1";
    function createBaseMsgSubmitProposal() {
      return { content: void 0, initialDeposit: [], proposer: "" };
    }
    exports.MsgSubmitProposal = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.content !== void 0) {
          any_1.Any.encode(message.content, writer.uint32(10).fork()).ldelim();
        }
        for (const v5 of message.initialDeposit) {
          coin_1.Coin.encode(v5, writer.uint32(18).fork()).ldelim();
        }
        if (message.proposer !== "") {
          writer.uint32(26).string(message.proposer);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgSubmitProposal();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.content = any_1.Any.decode(reader, reader.uint32());
              break;
            case 2:
              message.initialDeposit.push(coin_1.Coin.decode(reader, reader.uint32()));
              break;
            case 3:
              message.proposer = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object2) {
        return {
          content: isSet(object2.content) ? any_1.Any.fromJSON(object2.content) : void 0,
          initialDeposit: Array.isArray(object2 === null || object2 === void 0 ? void 0 : object2.initialDeposit) ? object2.initialDeposit.map((e2) => coin_1.Coin.fromJSON(e2)) : [],
          proposer: isSet(object2.proposer) ? String(object2.proposer) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        message.content !== void 0 && (obj.content = message.content ? any_1.Any.toJSON(message.content) : void 0);
        if (message.initialDeposit) {
          obj.initialDeposit = message.initialDeposit.map((e2) => e2 ? coin_1.Coin.toJSON(e2) : void 0);
        } else {
          obj.initialDeposit = [];
        }
        message.proposer !== void 0 && (obj.proposer = message.proposer);
        return obj;
      },
      fromPartial(object2) {
        var _a2, _b;
        const message = createBaseMsgSubmitProposal();
        message.content = object2.content !== void 0 && object2.content !== null ? any_1.Any.fromPartial(object2.content) : void 0;
        message.initialDeposit = ((_a2 = object2.initialDeposit) === null || _a2 === void 0 ? void 0 : _a2.map((e2) => coin_1.Coin.fromPartial(e2))) || [];
        message.proposer = (_b = object2.proposer) !== null && _b !== void 0 ? _b : "";
        return message;
      }
    };
    function createBaseMsgSubmitProposalResponse() {
      return { proposalId: "0" };
    }
    exports.MsgSubmitProposalResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.proposalId !== "0") {
          writer.uint32(8).uint64(message.proposalId);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgSubmitProposalResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.proposalId = longToString(reader.uint64());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object2) {
        return {
          proposalId: isSet(object2.proposalId) ? String(object2.proposalId) : "0"
        };
      },
      toJSON(message) {
        const obj = {};
        message.proposalId !== void 0 && (obj.proposalId = message.proposalId);
        return obj;
      },
      fromPartial(object2) {
        var _a2;
        const message = createBaseMsgSubmitProposalResponse();
        message.proposalId = (_a2 = object2.proposalId) !== null && _a2 !== void 0 ? _a2 : "0";
        return message;
      }
    };
    function createBaseMsgVote() {
      return { proposalId: "0", voter: "", option: 0 };
    }
    exports.MsgVote = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.proposalId !== "0") {
          writer.uint32(8).uint64(message.proposalId);
        }
        if (message.voter !== "") {
          writer.uint32(18).string(message.voter);
        }
        if (message.option !== 0) {
          writer.uint32(24).int32(message.option);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgVote();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.proposalId = longToString(reader.uint64());
              break;
            case 2:
              message.voter = reader.string();
              break;
            case 3:
              message.option = reader.int32();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object2) {
        return {
          proposalId: isSet(object2.proposalId) ? String(object2.proposalId) : "0",
          voter: isSet(object2.voter) ? String(object2.voter) : "",
          option: isSet(object2.option) ? (0, gov_1.voteOptionFromJSON)(object2.option) : 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.proposalId !== void 0 && (obj.proposalId = message.proposalId);
        message.voter !== void 0 && (obj.voter = message.voter);
        message.option !== void 0 && (obj.option = (0, gov_1.voteOptionToJSON)(message.option));
        return obj;
      },
      fromPartial(object2) {
        var _a2, _b, _c;
        const message = createBaseMsgVote();
        message.proposalId = (_a2 = object2.proposalId) !== null && _a2 !== void 0 ? _a2 : "0";
        message.voter = (_b = object2.voter) !== null && _b !== void 0 ? _b : "";
        message.option = (_c = object2.option) !== null && _c !== void 0 ? _c : 0;
        return message;
      }
    };
    function createBaseMsgVoteResponse() {
      return {};
    }
    exports.MsgVoteResponse = {
      encode(_16, writer = minimal_1.default.Writer.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgVoteResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_16) {
        return {};
      },
      toJSON(_16) {
        const obj = {};
        return obj;
      },
      fromPartial(_16) {
        const message = createBaseMsgVoteResponse();
        return message;
      }
    };
    function createBaseMsgVoteWeighted() {
      return { proposalId: "0", voter: "", options: [] };
    }
    exports.MsgVoteWeighted = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.proposalId !== "0") {
          writer.uint32(8).uint64(message.proposalId);
        }
        if (message.voter !== "") {
          writer.uint32(18).string(message.voter);
        }
        for (const v5 of message.options) {
          gov_1.WeightedVoteOption.encode(v5, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgVoteWeighted();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.proposalId = longToString(reader.uint64());
              break;
            case 2:
              message.voter = reader.string();
              break;
            case 3:
              message.options.push(gov_1.WeightedVoteOption.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object2) {
        return {
          proposalId: isSet(object2.proposalId) ? String(object2.proposalId) : "0",
          voter: isSet(object2.voter) ? String(object2.voter) : "",
          options: Array.isArray(object2 === null || object2 === void 0 ? void 0 : object2.options) ? object2.options.map((e2) => gov_1.WeightedVoteOption.fromJSON(e2)) : []
        };
      },
      toJSON(message) {
        const obj = {};
        message.proposalId !== void 0 && (obj.proposalId = message.proposalId);
        message.voter !== void 0 && (obj.voter = message.voter);
        if (message.options) {
          obj.options = message.options.map((e2) => e2 ? gov_1.WeightedVoteOption.toJSON(e2) : void 0);
        } else {
          obj.options = [];
        }
        return obj;
      },
      fromPartial(object2) {
        var _a2, _b, _c;
        const message = createBaseMsgVoteWeighted();
        message.proposalId = (_a2 = object2.proposalId) !== null && _a2 !== void 0 ? _a2 : "0";
        message.voter = (_b = object2.voter) !== null && _b !== void 0 ? _b : "";
        message.options = ((_c = object2.options) === null || _c === void 0 ? void 0 : _c.map((e2) => gov_1.WeightedVoteOption.fromPartial(e2))) || [];
        return message;
      }
    };
    function createBaseMsgVoteWeightedResponse() {
      return {};
    }
    exports.MsgVoteWeightedResponse = {
      encode(_16, writer = minimal_1.default.Writer.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgVoteWeightedResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_16) {
        return {};
      },
      toJSON(_16) {
        const obj = {};
        return obj;
      },
      fromPartial(_16) {
        const message = createBaseMsgVoteWeightedResponse();
        return message;
      }
    };
    function createBaseMsgDeposit() {
      return { proposalId: "0", depositor: "", amount: [] };
    }
    exports.MsgDeposit = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.proposalId !== "0") {
          writer.uint32(8).uint64(message.proposalId);
        }
        if (message.depositor !== "") {
          writer.uint32(18).string(message.depositor);
        }
        for (const v5 of message.amount) {
          coin_1.Coin.encode(v5, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgDeposit();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.proposalId = longToString(reader.uint64());
              break;
            case 2:
              message.depositor = reader.string();
              break;
            case 3:
              message.amount.push(coin_1.Coin.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object2) {
        return {
          proposalId: isSet(object2.proposalId) ? String(object2.proposalId) : "0",
          depositor: isSet(object2.depositor) ? String(object2.depositor) : "",
          amount: Array.isArray(object2 === null || object2 === void 0 ? void 0 : object2.amount) ? object2.amount.map((e2) => coin_1.Coin.fromJSON(e2)) : []
        };
      },
      toJSON(message) {
        const obj = {};
        message.proposalId !== void 0 && (obj.proposalId = message.proposalId);
        message.depositor !== void 0 && (obj.depositor = message.depositor);
        if (message.amount) {
          obj.amount = message.amount.map((e2) => e2 ? coin_1.Coin.toJSON(e2) : void 0);
        } else {
          obj.amount = [];
        }
        return obj;
      },
      fromPartial(object2) {
        var _a2, _b, _c;
        const message = createBaseMsgDeposit();
        message.proposalId = (_a2 = object2.proposalId) !== null && _a2 !== void 0 ? _a2 : "0";
        message.depositor = (_b = object2.depositor) !== null && _b !== void 0 ? _b : "";
        message.amount = ((_c = object2.amount) === null || _c === void 0 ? void 0 : _c.map((e2) => coin_1.Coin.fromPartial(e2))) || [];
        return message;
      }
    };
    function createBaseMsgDepositResponse() {
      return {};
    }
    exports.MsgDepositResponse = {
      encode(_16, writer = minimal_1.default.Writer.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgDepositResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_16) {
        return {};
      },
      toJSON(_16) {
        const obj = {};
        return obj;
      },
      fromPartial(_16) {
        const message = createBaseMsgDepositResponse();
        return message;
      }
    };
    function longToString(long) {
      return long.toString();
    }
    if (minimal_1.default.util.Long !== long_1.default) {
      minimal_1.default.util.Long = long_1.default;
      minimal_1.default.configure();
    }
    function isSet(value) {
      return value !== null && value !== void 0;
    }
  }
});

// ../../node_modules/.pnpm/@keplr-wallet+proto-types@0.12.28/node_modules/@keplr-wallet/proto-types/cosmos/distribution/v1beta1/tx.js
var require_tx5 = __commonJS({
  "../../node_modules/.pnpm/@keplr-wallet+proto-types@0.12.28/node_modules/@keplr-wallet/proto-types/cosmos/distribution/v1beta1/tx.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MsgFundCommunityPoolResponse = exports.MsgFundCommunityPool = exports.MsgWithdrawValidatorCommissionResponse = exports.MsgWithdrawValidatorCommission = exports.MsgWithdrawDelegatorRewardResponse = exports.MsgWithdrawDelegatorReward = exports.MsgSetWithdrawAddressResponse = exports.MsgSetWithdrawAddress = exports.protobufPackage = void 0;
    var long_1 = __importDefault(require_long());
    var minimal_1 = __importDefault(require_minimal());
    var coin_1 = require_coin2();
    exports.protobufPackage = "cosmos.distribution.v1beta1";
    function createBaseMsgSetWithdrawAddress() {
      return { delegatorAddress: "", withdrawAddress: "" };
    }
    exports.MsgSetWithdrawAddress = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.delegatorAddress !== "") {
          writer.uint32(10).string(message.delegatorAddress);
        }
        if (message.withdrawAddress !== "") {
          writer.uint32(18).string(message.withdrawAddress);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgSetWithdrawAddress();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.delegatorAddress = reader.string();
              break;
            case 2:
              message.withdrawAddress = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object2) {
        return {
          delegatorAddress: isSet(object2.delegatorAddress) ? String(object2.delegatorAddress) : "",
          withdrawAddress: isSet(object2.withdrawAddress) ? String(object2.withdrawAddress) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        message.delegatorAddress !== void 0 && (obj.delegatorAddress = message.delegatorAddress);
        message.withdrawAddress !== void 0 && (obj.withdrawAddress = message.withdrawAddress);
        return obj;
      },
      fromPartial(object2) {
        var _a2, _b;
        const message = createBaseMsgSetWithdrawAddress();
        message.delegatorAddress = (_a2 = object2.delegatorAddress) !== null && _a2 !== void 0 ? _a2 : "";
        message.withdrawAddress = (_b = object2.withdrawAddress) !== null && _b !== void 0 ? _b : "";
        return message;
      }
    };
    function createBaseMsgSetWithdrawAddressResponse() {
      return {};
    }
    exports.MsgSetWithdrawAddressResponse = {
      encode(_16, writer = minimal_1.default.Writer.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgSetWithdrawAddressResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_16) {
        return {};
      },
      toJSON(_16) {
        const obj = {};
        return obj;
      },
      fromPartial(_16) {
        const message = createBaseMsgSetWithdrawAddressResponse();
        return message;
      }
    };
    function createBaseMsgWithdrawDelegatorReward() {
      return { delegatorAddress: "", validatorAddress: "" };
    }
    exports.MsgWithdrawDelegatorReward = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.delegatorAddress !== "") {
          writer.uint32(10).string(message.delegatorAddress);
        }
        if (message.validatorAddress !== "") {
          writer.uint32(18).string(message.validatorAddress);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgWithdrawDelegatorReward();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.delegatorAddress = reader.string();
              break;
            case 2:
              message.validatorAddress = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object2) {
        return {
          delegatorAddress: isSet(object2.delegatorAddress) ? String(object2.delegatorAddress) : "",
          validatorAddress: isSet(object2.validatorAddress) ? String(object2.validatorAddress) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        message.delegatorAddress !== void 0 && (obj.delegatorAddress = message.delegatorAddress);
        message.validatorAddress !== void 0 && (obj.validatorAddress = message.validatorAddress);
        return obj;
      },
      fromPartial(object2) {
        var _a2, _b;
        const message = createBaseMsgWithdrawDelegatorReward();
        message.delegatorAddress = (_a2 = object2.delegatorAddress) !== null && _a2 !== void 0 ? _a2 : "";
        message.validatorAddress = (_b = object2.validatorAddress) !== null && _b !== void 0 ? _b : "";
        return message;
      }
    };
    function createBaseMsgWithdrawDelegatorRewardResponse() {
      return {};
    }
    exports.MsgWithdrawDelegatorRewardResponse = {
      encode(_16, writer = minimal_1.default.Writer.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgWithdrawDelegatorRewardResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_16) {
        return {};
      },
      toJSON(_16) {
        const obj = {};
        return obj;
      },
      fromPartial(_16) {
        const message = createBaseMsgWithdrawDelegatorRewardResponse();
        return message;
      }
    };
    function createBaseMsgWithdrawValidatorCommission() {
      return { validatorAddress: "" };
    }
    exports.MsgWithdrawValidatorCommission = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.validatorAddress !== "") {
          writer.uint32(10).string(message.validatorAddress);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgWithdrawValidatorCommission();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.validatorAddress = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object2) {
        return {
          validatorAddress: isSet(object2.validatorAddress) ? String(object2.validatorAddress) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        message.validatorAddress !== void 0 && (obj.validatorAddress = message.validatorAddress);
        return obj;
      },
      fromPartial(object2) {
        var _a2;
        const message = createBaseMsgWithdrawValidatorCommission();
        message.validatorAddress = (_a2 = object2.validatorAddress) !== null && _a2 !== void 0 ? _a2 : "";
        return message;
      }
    };
    function createBaseMsgWithdrawValidatorCommissionResponse() {
      return {};
    }
    exports.MsgWithdrawValidatorCommissionResponse = {
      encode(_16, writer = minimal_1.default.Writer.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgWithdrawValidatorCommissionResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_16) {
        return {};
      },
      toJSON(_16) {
        const obj = {};
        return obj;
      },
      fromPartial(_16) {
        const message = createBaseMsgWithdrawValidatorCommissionResponse();
        return message;
      }
    };
    function createBaseMsgFundCommunityPool() {
      return { amount: [], depositor: "" };
    }
    exports.MsgFundCommunityPool = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v5 of message.amount) {
          coin_1.Coin.encode(v5, writer.uint32(10).fork()).ldelim();
        }
        if (message.depositor !== "") {
          writer.uint32(18).string(message.depositor);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgFundCommunityPool();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.amount.push(coin_1.Coin.decode(reader, reader.uint32()));
              break;
            case 2:
              message.depositor = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object2) {
        return {
          amount: Array.isArray(object2 === null || object2 === void 0 ? void 0 : object2.amount) ? object2.amount.map((e2) => coin_1.Coin.fromJSON(e2)) : [],
          depositor: isSet(object2.depositor) ? String(object2.depositor) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        if (message.amount) {
          obj.amount = message.amount.map((e2) => e2 ? coin_1.Coin.toJSON(e2) : void 0);
        } else {
          obj.amount = [];
        }
        message.depositor !== void 0 && (obj.depositor = message.depositor);
        return obj;
      },
      fromPartial(object2) {
        var _a2, _b;
        const message = createBaseMsgFundCommunityPool();
        message.amount = ((_a2 = object2.amount) === null || _a2 === void 0 ? void 0 : _a2.map((e2) => coin_1.Coin.fromPartial(e2))) || [];
        message.depositor = (_b = object2.depositor) !== null && _b !== void 0 ? _b : "";
        return message;
      }
    };
    function createBaseMsgFundCommunityPoolResponse() {
      return {};
    }
    exports.MsgFundCommunityPoolResponse = {
      encode(_16, writer = minimal_1.default.Writer.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgFundCommunityPoolResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_16) {
        return {};
      },
      toJSON(_16) {
        const obj = {};
        return obj;
      },
      fromPartial(_16) {
        const message = createBaseMsgFundCommunityPoolResponse();
        return message;
      }
    };
    if (minimal_1.default.util.Long !== long_1.default) {
      minimal_1.default.util.Long = long_1.default;
      minimal_1.default.configure();
    }
    function isSet(value) {
      return value !== null && value !== void 0;
    }
  }
});

// ../../node_modules/.pnpm/@keplr-wallet+proto-types@0.12.28/node_modules/@keplr-wallet/proto-types/cosmwasm/wasm/v1/types.js
var require_types5 = __commonJS({
  "../../node_modules/.pnpm/@keplr-wallet+proto-types@0.12.28/node_modules/@keplr-wallet/proto-types/cosmwasm/wasm/v1/types.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Model = exports.AbsoluteTxPosition = exports.ContractCodeHistoryEntry = exports.ContractInfo = exports.CodeInfo = exports.Params = exports.AccessConfig = exports.AccessTypeParam = exports.contractCodeHistoryOperationTypeToJSON = exports.contractCodeHistoryOperationTypeFromJSON = exports.ContractCodeHistoryOperationType = exports.accessTypeToJSON = exports.accessTypeFromJSON = exports.AccessType = exports.protobufPackage = void 0;
    var long_1 = __importDefault(require_long());
    var minimal_1 = __importDefault(require_minimal());
    var any_1 = require_any();
    exports.protobufPackage = "cosmwasm.wasm.v1";
    var AccessType;
    (function(AccessType2) {
      AccessType2[AccessType2["ACCESS_TYPE_UNSPECIFIED"] = 0] = "ACCESS_TYPE_UNSPECIFIED";
      AccessType2[AccessType2["ACCESS_TYPE_NOBODY"] = 1] = "ACCESS_TYPE_NOBODY";
      AccessType2[AccessType2["ACCESS_TYPE_ONLY_ADDRESS"] = 2] = "ACCESS_TYPE_ONLY_ADDRESS";
      AccessType2[AccessType2["ACCESS_TYPE_EVERYBODY"] = 3] = "ACCESS_TYPE_EVERYBODY";
      AccessType2[AccessType2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(AccessType = exports.AccessType || (exports.AccessType = {}));
    function accessTypeFromJSON(object2) {
      switch (object2) {
        case 0:
        case "ACCESS_TYPE_UNSPECIFIED":
          return AccessType.ACCESS_TYPE_UNSPECIFIED;
        case 1:
        case "ACCESS_TYPE_NOBODY":
          return AccessType.ACCESS_TYPE_NOBODY;
        case 2:
        case "ACCESS_TYPE_ONLY_ADDRESS":
          return AccessType.ACCESS_TYPE_ONLY_ADDRESS;
        case 3:
        case "ACCESS_TYPE_EVERYBODY":
          return AccessType.ACCESS_TYPE_EVERYBODY;
        case -1:
        case "UNRECOGNIZED":
        default:
          return AccessType.UNRECOGNIZED;
      }
    }
    exports.accessTypeFromJSON = accessTypeFromJSON;
    function accessTypeToJSON(object2) {
      switch (object2) {
        case AccessType.ACCESS_TYPE_UNSPECIFIED:
          return "ACCESS_TYPE_UNSPECIFIED";
        case AccessType.ACCESS_TYPE_NOBODY:
          return "ACCESS_TYPE_NOBODY";
        case AccessType.ACCESS_TYPE_ONLY_ADDRESS:
          return "ACCESS_TYPE_ONLY_ADDRESS";
        case AccessType.ACCESS_TYPE_EVERYBODY:
          return "ACCESS_TYPE_EVERYBODY";
        default:
          return "UNKNOWN";
      }
    }
    exports.accessTypeToJSON = accessTypeToJSON;
    var ContractCodeHistoryOperationType;
    (function(ContractCodeHistoryOperationType2) {
      ContractCodeHistoryOperationType2[ContractCodeHistoryOperationType2["CONTRACT_CODE_HISTORY_OPERATION_TYPE_UNSPECIFIED"] = 0] = "CONTRACT_CODE_HISTORY_OPERATION_TYPE_UNSPECIFIED";
      ContractCodeHistoryOperationType2[ContractCodeHistoryOperationType2["CONTRACT_CODE_HISTORY_OPERATION_TYPE_INIT"] = 1] = "CONTRACT_CODE_HISTORY_OPERATION_TYPE_INIT";
      ContractCodeHistoryOperationType2[ContractCodeHistoryOperationType2["CONTRACT_CODE_HISTORY_OPERATION_TYPE_MIGRATE"] = 2] = "CONTRACT_CODE_HISTORY_OPERATION_TYPE_MIGRATE";
      ContractCodeHistoryOperationType2[ContractCodeHistoryOperationType2["CONTRACT_CODE_HISTORY_OPERATION_TYPE_GENESIS"] = 3] = "CONTRACT_CODE_HISTORY_OPERATION_TYPE_GENESIS";
      ContractCodeHistoryOperationType2[ContractCodeHistoryOperationType2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(ContractCodeHistoryOperationType = exports.ContractCodeHistoryOperationType || (exports.ContractCodeHistoryOperationType = {}));
    function contractCodeHistoryOperationTypeFromJSON(object2) {
      switch (object2) {
        case 0:
        case "CONTRACT_CODE_HISTORY_OPERATION_TYPE_UNSPECIFIED":
          return ContractCodeHistoryOperationType.CONTRACT_CODE_HISTORY_OPERATION_TYPE_UNSPECIFIED;
        case 1:
        case "CONTRACT_CODE_HISTORY_OPERATION_TYPE_INIT":
          return ContractCodeHistoryOperationType.CONTRACT_CODE_HISTORY_OPERATION_TYPE_INIT;
        case 2:
        case "CONTRACT_CODE_HISTORY_OPERATION_TYPE_MIGRATE":
          return ContractCodeHistoryOperationType.CONTRACT_CODE_HISTORY_OPERATION_TYPE_MIGRATE;
        case 3:
        case "CONTRACT_CODE_HISTORY_OPERATION_TYPE_GENESIS":
          return ContractCodeHistoryOperationType.CONTRACT_CODE_HISTORY_OPERATION_TYPE_GENESIS;
        case -1:
        case "UNRECOGNIZED":
        default:
          return ContractCodeHistoryOperationType.UNRECOGNIZED;
      }
    }
    exports.contractCodeHistoryOperationTypeFromJSON = contractCodeHistoryOperationTypeFromJSON;
    function contractCodeHistoryOperationTypeToJSON(object2) {
      switch (object2) {
        case ContractCodeHistoryOperationType.CONTRACT_CODE_HISTORY_OPERATION_TYPE_UNSPECIFIED:
          return "CONTRACT_CODE_HISTORY_OPERATION_TYPE_UNSPECIFIED";
        case ContractCodeHistoryOperationType.CONTRACT_CODE_HISTORY_OPERATION_TYPE_INIT:
          return "CONTRACT_CODE_HISTORY_OPERATION_TYPE_INIT";
        case ContractCodeHistoryOperationType.CONTRACT_CODE_HISTORY_OPERATION_TYPE_MIGRATE:
          return "CONTRACT_CODE_HISTORY_OPERATION_TYPE_MIGRATE";
        case ContractCodeHistoryOperationType.CONTRACT_CODE_HISTORY_OPERATION_TYPE_GENESIS:
          return "CONTRACT_CODE_HISTORY_OPERATION_TYPE_GENESIS";
        default:
          return "UNKNOWN";
      }
    }
    exports.contractCodeHistoryOperationTypeToJSON = contractCodeHistoryOperationTypeToJSON;
    function createBaseAccessTypeParam() {
      return { value: 0 };
    }
    exports.AccessTypeParam = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.value !== 0) {
          writer.uint32(8).int32(message.value);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseAccessTypeParam();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.value = reader.int32();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object2) {
        return {
          value: isSet(object2.value) ? accessTypeFromJSON(object2.value) : 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.value !== void 0 && (obj.value = accessTypeToJSON(message.value));
        return obj;
      },
      fromPartial(object2) {
        var _a2;
        const message = createBaseAccessTypeParam();
        message.value = (_a2 = object2.value) !== null && _a2 !== void 0 ? _a2 : 0;
        return message;
      }
    };
    function createBaseAccessConfig() {
      return { permission: 0, address: "" };
    }
    exports.AccessConfig = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.permission !== 0) {
          writer.uint32(8).int32(message.permission);
        }
        if (message.address !== "") {
          writer.uint32(18).string(message.address);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseAccessConfig();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.permission = reader.int32();
              break;
            case 2:
              message.address = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object2) {
        return {
          permission: isSet(object2.permission) ? accessTypeFromJSON(object2.permission) : 0,
          address: isSet(object2.address) ? String(object2.address) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        message.permission !== void 0 && (obj.permission = accessTypeToJSON(message.permission));
        message.address !== void 0 && (obj.address = message.address);
        return obj;
      },
      fromPartial(object2) {
        var _a2, _b;
        const message = createBaseAccessConfig();
        message.permission = (_a2 = object2.permission) !== null && _a2 !== void 0 ? _a2 : 0;
        message.address = (_b = object2.address) !== null && _b !== void 0 ? _b : "";
        return message;
      }
    };
    function createBaseParams() {
      return {
        codeUploadAccess: void 0,
        instantiateDefaultPermission: 0,
        maxWasmCodeSize: "0"
      };
    }
    exports.Params = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.codeUploadAccess !== void 0) {
          exports.AccessConfig.encode(message.codeUploadAccess, writer.uint32(10).fork()).ldelim();
        }
        if (message.instantiateDefaultPermission !== 0) {
          writer.uint32(16).int32(message.instantiateDefaultPermission);
        }
        if (message.maxWasmCodeSize !== "0") {
          writer.uint32(24).uint64(message.maxWasmCodeSize);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseParams();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.codeUploadAccess = exports.AccessConfig.decode(reader, reader.uint32());
              break;
            case 2:
              message.instantiateDefaultPermission = reader.int32();
              break;
            case 3:
              message.maxWasmCodeSize = longToString(reader.uint64());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object2) {
        return {
          codeUploadAccess: isSet(object2.codeUploadAccess) ? exports.AccessConfig.fromJSON(object2.codeUploadAccess) : void 0,
          instantiateDefaultPermission: isSet(object2.instantiateDefaultPermission) ? accessTypeFromJSON(object2.instantiateDefaultPermission) : 0,
          maxWasmCodeSize: isSet(object2.maxWasmCodeSize) ? String(object2.maxWasmCodeSize) : "0"
        };
      },
      toJSON(message) {
        const obj = {};
        message.codeUploadAccess !== void 0 && (obj.codeUploadAccess = message.codeUploadAccess ? exports.AccessConfig.toJSON(message.codeUploadAccess) : void 0);
        message.instantiateDefaultPermission !== void 0 && (obj.instantiateDefaultPermission = accessTypeToJSON(message.instantiateDefaultPermission));
        message.maxWasmCodeSize !== void 0 && (obj.maxWasmCodeSize = message.maxWasmCodeSize);
        return obj;
      },
      fromPartial(object2) {
        var _a2, _b;
        const message = createBaseParams();
        message.codeUploadAccess = object2.codeUploadAccess !== void 0 && object2.codeUploadAccess !== null ? exports.AccessConfig.fromPartial(object2.codeUploadAccess) : void 0;
        message.instantiateDefaultPermission = (_a2 = object2.instantiateDefaultPermission) !== null && _a2 !== void 0 ? _a2 : 0;
        message.maxWasmCodeSize = (_b = object2.maxWasmCodeSize) !== null && _b !== void 0 ? _b : "0";
        return message;
      }
    };
    function createBaseCodeInfo() {
      return {
        codeHash: new Uint8Array(),
        creator: "",
        instantiateConfig: void 0
      };
    }
    exports.CodeInfo = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.codeHash.length !== 0) {
          writer.uint32(10).bytes(message.codeHash);
        }
        if (message.creator !== "") {
          writer.uint32(18).string(message.creator);
        }
        if (message.instantiateConfig !== void 0) {
          exports.AccessConfig.encode(message.instantiateConfig, writer.uint32(42).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseCodeInfo();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.codeHash = reader.bytes();
              break;
            case 2:
              message.creator = reader.string();
              break;
            case 5:
              message.instantiateConfig = exports.AccessConfig.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object2) {
        return {
          codeHash: isSet(object2.codeHash) ? bytesFromBase64(object2.codeHash) : new Uint8Array(),
          creator: isSet(object2.creator) ? String(object2.creator) : "",
          instantiateConfig: isSet(object2.instantiateConfig) ? exports.AccessConfig.fromJSON(object2.instantiateConfig) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.codeHash !== void 0 && (obj.codeHash = base64FromBytes(message.codeHash !== void 0 ? message.codeHash : new Uint8Array()));
        message.creator !== void 0 && (obj.creator = message.creator);
        message.instantiateConfig !== void 0 && (obj.instantiateConfig = message.instantiateConfig ? exports.AccessConfig.toJSON(message.instantiateConfig) : void 0);
        return obj;
      },
      fromPartial(object2) {
        var _a2, _b;
        const message = createBaseCodeInfo();
        message.codeHash = (_a2 = object2.codeHash) !== null && _a2 !== void 0 ? _a2 : new Uint8Array();
        message.creator = (_b = object2.creator) !== null && _b !== void 0 ? _b : "";
        message.instantiateConfig = object2.instantiateConfig !== void 0 && object2.instantiateConfig !== null ? exports.AccessConfig.fromPartial(object2.instantiateConfig) : void 0;
        return message;
      }
    };
    function createBaseContractInfo() {
      return {
        codeId: "0",
        creator: "",
        admin: "",
        label: "",
        created: void 0,
        ibcPortId: "",
        extension: void 0
      };
    }
    exports.ContractInfo = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.codeId !== "0") {
          writer.uint32(8).uint64(message.codeId);
        }
        if (message.creator !== "") {
          writer.uint32(18).string(message.creator);
        }
        if (message.admin !== "") {
          writer.uint32(26).string(message.admin);
        }
        if (message.label !== "") {
          writer.uint32(34).string(message.label);
        }
        if (message.created !== void 0) {
          exports.AbsoluteTxPosition.encode(message.created, writer.uint32(42).fork()).ldelim();
        }
        if (message.ibcPortId !== "") {
          writer.uint32(50).string(message.ibcPortId);
        }
        if (message.extension !== void 0) {
          any_1.Any.encode(message.extension, writer.uint32(58).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseContractInfo();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.codeId = longToString(reader.uint64());
              break;
            case 2:
              message.creator = reader.string();
              break;
            case 3:
              message.admin = reader.string();
              break;
            case 4:
              message.label = reader.string();
              break;
            case 5:
              message.created = exports.AbsoluteTxPosition.decode(reader, reader.uint32());
              break;
            case 6:
              message.ibcPortId = reader.string();
              break;
            case 7:
              message.extension = any_1.Any.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object2) {
        return {
          codeId: isSet(object2.codeId) ? String(object2.codeId) : "0",
          creator: isSet(object2.creator) ? String(object2.creator) : "",
          admin: isSet(object2.admin) ? String(object2.admin) : "",
          label: isSet(object2.label) ? String(object2.label) : "",
          created: isSet(object2.created) ? exports.AbsoluteTxPosition.fromJSON(object2.created) : void 0,
          ibcPortId: isSet(object2.ibcPortId) ? String(object2.ibcPortId) : "",
          extension: isSet(object2.extension) ? any_1.Any.fromJSON(object2.extension) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.codeId !== void 0 && (obj.codeId = message.codeId);
        message.creator !== void 0 && (obj.creator = message.creator);
        message.admin !== void 0 && (obj.admin = message.admin);
        message.label !== void 0 && (obj.label = message.label);
        message.created !== void 0 && (obj.created = message.created ? exports.AbsoluteTxPosition.toJSON(message.created) : void 0);
        message.ibcPortId !== void 0 && (obj.ibcPortId = message.ibcPortId);
        message.extension !== void 0 && (obj.extension = message.extension ? any_1.Any.toJSON(message.extension) : void 0);
        return obj;
      },
      fromPartial(object2) {
        var _a2, _b, _c, _d, _e3;
        const message = createBaseContractInfo();
        message.codeId = (_a2 = object2.codeId) !== null && _a2 !== void 0 ? _a2 : "0";
        message.creator = (_b = object2.creator) !== null && _b !== void 0 ? _b : "";
        message.admin = (_c = object2.admin) !== null && _c !== void 0 ? _c : "";
        message.label = (_d = object2.label) !== null && _d !== void 0 ? _d : "";
        message.created = object2.created !== void 0 && object2.created !== null ? exports.AbsoluteTxPosition.fromPartial(object2.created) : void 0;
        message.ibcPortId = (_e3 = object2.ibcPortId) !== null && _e3 !== void 0 ? _e3 : "";
        message.extension = object2.extension !== void 0 && object2.extension !== null ? any_1.Any.fromPartial(object2.extension) : void 0;
        return message;
      }
    };
    function createBaseContractCodeHistoryEntry() {
      return {
        operation: 0,
        codeId: "0",
        updated: void 0,
        msg: new Uint8Array()
      };
    }
    exports.ContractCodeHistoryEntry = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.operation !== 0) {
          writer.uint32(8).int32(message.operation);
        }
        if (message.codeId !== "0") {
          writer.uint32(16).uint64(message.codeId);
        }
        if (message.updated !== void 0) {
          exports.AbsoluteTxPosition.encode(message.updated, writer.uint32(26).fork()).ldelim();
        }
        if (message.msg.length !== 0) {
          writer.uint32(34).bytes(message.msg);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseContractCodeHistoryEntry();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.operation = reader.int32();
              break;
            case 2:
              message.codeId = longToString(reader.uint64());
              break;
            case 3:
              message.updated = exports.AbsoluteTxPosition.decode(reader, reader.uint32());
              break;
            case 4:
              message.msg = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object2) {
        return {
          operation: isSet(object2.operation) ? contractCodeHistoryOperationTypeFromJSON(object2.operation) : 0,
          codeId: isSet(object2.codeId) ? String(object2.codeId) : "0",
          updated: isSet(object2.updated) ? exports.AbsoluteTxPosition.fromJSON(object2.updated) : void 0,
          msg: isSet(object2.msg) ? bytesFromBase64(object2.msg) : new Uint8Array()
        };
      },
      toJSON(message) {
        const obj = {};
        message.operation !== void 0 && (obj.operation = contractCodeHistoryOperationTypeToJSON(message.operation));
        message.codeId !== void 0 && (obj.codeId = message.codeId);
        message.updated !== void 0 && (obj.updated = message.updated ? exports.AbsoluteTxPosition.toJSON(message.updated) : void 0);
        message.msg !== void 0 && (obj.msg = base64FromBytes(message.msg !== void 0 ? message.msg : new Uint8Array()));
        return obj;
      },
      fromPartial(object2) {
        var _a2, _b, _c;
        const message = createBaseContractCodeHistoryEntry();
        message.operation = (_a2 = object2.operation) !== null && _a2 !== void 0 ? _a2 : 0;
        message.codeId = (_b = object2.codeId) !== null && _b !== void 0 ? _b : "0";
        message.updated = object2.updated !== void 0 && object2.updated !== null ? exports.AbsoluteTxPosition.fromPartial(object2.updated) : void 0;
        message.msg = (_c = object2.msg) !== null && _c !== void 0 ? _c : new Uint8Array();
        return message;
      }
    };
    function createBaseAbsoluteTxPosition() {
      return { blockHeight: "0", txIndex: "0" };
    }
    exports.AbsoluteTxPosition = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.blockHeight !== "0") {
          writer.uint32(8).uint64(message.blockHeight);
        }
        if (message.txIndex !== "0") {
          writer.uint32(16).uint64(message.txIndex);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseAbsoluteTxPosition();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.blockHeight = longToString(reader.uint64());
              break;
            case 2:
              message.txIndex = longToString(reader.uint64());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object2) {
        return {
          blockHeight: isSet(object2.blockHeight) ? String(object2.blockHeight) : "0",
          txIndex: isSet(object2.txIndex) ? String(object2.txIndex) : "0"
        };
      },
      toJSON(message) {
        const obj = {};
        message.blockHeight !== void 0 && (obj.blockHeight = message.blockHeight);
        message.txIndex !== void 0 && (obj.txIndex = message.txIndex);
        return obj;
      },
      fromPartial(object2) {
        var _a2, _b;
        const message = createBaseAbsoluteTxPosition();
        message.blockHeight = (_a2 = object2.blockHeight) !== null && _a2 !== void 0 ? _a2 : "0";
        message.txIndex = (_b = object2.txIndex) !== null && _b !== void 0 ? _b : "0";
        return message;
      }
    };
    function createBaseModel() {
      return { key: new Uint8Array(), value: new Uint8Array() };
    }
    exports.Model = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.key.length !== 0) {
          writer.uint32(10).bytes(message.key);
        }
        if (message.value.length !== 0) {
          writer.uint32(18).bytes(message.value);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseModel();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.key = reader.bytes();
              break;
            case 2:
              message.value = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object2) {
        return {
          key: isSet(object2.key) ? bytesFromBase64(object2.key) : new Uint8Array(),
          value: isSet(object2.value) ? bytesFromBase64(object2.value) : new Uint8Array()
        };
      },
      toJSON(message) {
        const obj = {};
        message.key !== void 0 && (obj.key = base64FromBytes(message.key !== void 0 ? message.key : new Uint8Array()));
        message.value !== void 0 && (obj.value = base64FromBytes(message.value !== void 0 ? message.value : new Uint8Array()));
        return obj;
      },
      fromPartial(object2) {
        var _a2, _b;
        const message = createBaseModel();
        message.key = (_a2 = object2.key) !== null && _a2 !== void 0 ? _a2 : new Uint8Array();
        message.value = (_b = object2.value) !== null && _b !== void 0 ? _b : new Uint8Array();
        return message;
      }
    };
    var globalThis2 = (() => {
      if (typeof globalThis2 !== "undefined")
        return globalThis2;
      if (typeof self !== "undefined")
        return self;
      if (typeof window !== "undefined")
        return window;
      if (typeof global !== "undefined")
        return global;
      throw "Unable to locate global object";
    })();
    var atob = globalThis2.atob || ((b64) => globalThis2.Buffer.from(b64, "base64").toString("binary"));
    function bytesFromBase64(b64) {
      const bin = atob(b64);
      const arr = new Uint8Array(bin.length);
      for (let i4 = 0; i4 < bin.length; ++i4) {
        arr[i4] = bin.charCodeAt(i4);
      }
      return arr;
    }
    var btoa = globalThis2.btoa || ((bin) => globalThis2.Buffer.from(bin, "binary").toString("base64"));
    function base64FromBytes(arr) {
      const bin = [];
      for (const byte of arr) {
        bin.push(String.fromCharCode(byte));
      }
      return btoa(bin.join(""));
    }
    function longToString(long) {
      return long.toString();
    }
    if (minimal_1.default.util.Long !== long_1.default) {
      minimal_1.default.util.Long = long_1.default;
      minimal_1.default.configure();
    }
    function isSet(value) {
      return value !== null && value !== void 0;
    }
  }
});

// ../../node_modules/.pnpm/@keplr-wallet+proto-types@0.12.28/node_modules/@keplr-wallet/proto-types/cosmwasm/wasm/v1/tx.js
var require_tx6 = __commonJS({
  "../../node_modules/.pnpm/@keplr-wallet+proto-types@0.12.28/node_modules/@keplr-wallet/proto-types/cosmwasm/wasm/v1/tx.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MsgClearAdminResponse = exports.MsgClearAdmin = exports.MsgUpdateAdminResponse = exports.MsgUpdateAdmin = exports.MsgMigrateContractResponse = exports.MsgMigrateContract = exports.MsgExecuteContractResponse = exports.MsgExecuteContract = exports.MsgInstantiateContractResponse = exports.MsgInstantiateContract = exports.MsgStoreCodeResponse = exports.MsgStoreCode = exports.protobufPackage = void 0;
    var long_1 = __importDefault(require_long());
    var minimal_1 = __importDefault(require_minimal());
    var types_1 = require_types5();
    var coin_1 = require_coin2();
    exports.protobufPackage = "cosmwasm.wasm.v1";
    function createBaseMsgStoreCode() {
      return {
        sender: "",
        wasmByteCode: new Uint8Array(),
        instantiatePermission: void 0
      };
    }
    exports.MsgStoreCode = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.sender !== "") {
          writer.uint32(10).string(message.sender);
        }
        if (message.wasmByteCode.length !== 0) {
          writer.uint32(18).bytes(message.wasmByteCode);
        }
        if (message.instantiatePermission !== void 0) {
          types_1.AccessConfig.encode(message.instantiatePermission, writer.uint32(42).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgStoreCode();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.sender = reader.string();
              break;
            case 2:
              message.wasmByteCode = reader.bytes();
              break;
            case 5:
              message.instantiatePermission = types_1.AccessConfig.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object2) {
        return {
          sender: isSet(object2.sender) ? String(object2.sender) : "",
          wasmByteCode: isSet(object2.wasmByteCode) ? bytesFromBase64(object2.wasmByteCode) : new Uint8Array(),
          instantiatePermission: isSet(object2.instantiatePermission) ? types_1.AccessConfig.fromJSON(object2.instantiatePermission) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.sender !== void 0 && (obj.sender = message.sender);
        message.wasmByteCode !== void 0 && (obj.wasmByteCode = base64FromBytes(message.wasmByteCode !== void 0 ? message.wasmByteCode : new Uint8Array()));
        message.instantiatePermission !== void 0 && (obj.instantiatePermission = message.instantiatePermission ? types_1.AccessConfig.toJSON(message.instantiatePermission) : void 0);
        return obj;
      },
      fromPartial(object2) {
        var _a2, _b;
        const message = createBaseMsgStoreCode();
        message.sender = (_a2 = object2.sender) !== null && _a2 !== void 0 ? _a2 : "";
        message.wasmByteCode = (_b = object2.wasmByteCode) !== null && _b !== void 0 ? _b : new Uint8Array();
        message.instantiatePermission = object2.instantiatePermission !== void 0 && object2.instantiatePermission !== null ? types_1.AccessConfig.fromPartial(object2.instantiatePermission) : void 0;
        return message;
      }
    };
    function createBaseMsgStoreCodeResponse() {
      return { codeId: "0" };
    }
    exports.MsgStoreCodeResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.codeId !== "0") {
          writer.uint32(8).uint64(message.codeId);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgStoreCodeResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.codeId = longToString(reader.uint64());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object2) {
        return {
          codeId: isSet(object2.codeId) ? String(object2.codeId) : "0"
        };
      },
      toJSON(message) {
        const obj = {};
        message.codeId !== void 0 && (obj.codeId = message.codeId);
        return obj;
      },
      fromPartial(object2) {
        var _a2;
        const message = createBaseMsgStoreCodeResponse();
        message.codeId = (_a2 = object2.codeId) !== null && _a2 !== void 0 ? _a2 : "0";
        return message;
      }
    };
    function createBaseMsgInstantiateContract() {
      return {
        sender: "",
        admin: "",
        codeId: "0",
        label: "",
        msg: new Uint8Array(),
        funds: []
      };
    }
    exports.MsgInstantiateContract = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.sender !== "") {
          writer.uint32(10).string(message.sender);
        }
        if (message.admin !== "") {
          writer.uint32(18).string(message.admin);
        }
        if (message.codeId !== "0") {
          writer.uint32(24).uint64(message.codeId);
        }
        if (message.label !== "") {
          writer.uint32(34).string(message.label);
        }
        if (message.msg.length !== 0) {
          writer.uint32(42).bytes(message.msg);
        }
        for (const v5 of message.funds) {
          coin_1.Coin.encode(v5, writer.uint32(50).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgInstantiateContract();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.sender = reader.string();
              break;
            case 2:
              message.admin = reader.string();
              break;
            case 3:
              message.codeId = longToString(reader.uint64());
              break;
            case 4:
              message.label = reader.string();
              break;
            case 5:
              message.msg = reader.bytes();
              break;
            case 6:
              message.funds.push(coin_1.Coin.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object2) {
        return {
          sender: isSet(object2.sender) ? String(object2.sender) : "",
          admin: isSet(object2.admin) ? String(object2.admin) : "",
          codeId: isSet(object2.codeId) ? String(object2.codeId) : "0",
          label: isSet(object2.label) ? String(object2.label) : "",
          msg: isSet(object2.msg) ? bytesFromBase64(object2.msg) : new Uint8Array(),
          funds: Array.isArray(object2 === null || object2 === void 0 ? void 0 : object2.funds) ? object2.funds.map((e2) => coin_1.Coin.fromJSON(e2)) : []
        };
      },
      toJSON(message) {
        const obj = {};
        message.sender !== void 0 && (obj.sender = message.sender);
        message.admin !== void 0 && (obj.admin = message.admin);
        message.codeId !== void 0 && (obj.codeId = message.codeId);
        message.label !== void 0 && (obj.label = message.label);
        message.msg !== void 0 && (obj.msg = base64FromBytes(message.msg !== void 0 ? message.msg : new Uint8Array()));
        if (message.funds) {
          obj.funds = message.funds.map((e2) => e2 ? coin_1.Coin.toJSON(e2) : void 0);
        } else {
          obj.funds = [];
        }
        return obj;
      },
      fromPartial(object2) {
        var _a2, _b, _c, _d, _e3, _f;
        const message = createBaseMsgInstantiateContract();
        message.sender = (_a2 = object2.sender) !== null && _a2 !== void 0 ? _a2 : "";
        message.admin = (_b = object2.admin) !== null && _b !== void 0 ? _b : "";
        message.codeId = (_c = object2.codeId) !== null && _c !== void 0 ? _c : "0";
        message.label = (_d = object2.label) !== null && _d !== void 0 ? _d : "";
        message.msg = (_e3 = object2.msg) !== null && _e3 !== void 0 ? _e3 : new Uint8Array();
        message.funds = ((_f = object2.funds) === null || _f === void 0 ? void 0 : _f.map((e2) => coin_1.Coin.fromPartial(e2))) || [];
        return message;
      }
    };
    function createBaseMsgInstantiateContractResponse() {
      return { address: "", data: new Uint8Array() };
    }
    exports.MsgInstantiateContractResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.address !== "") {
          writer.uint32(10).string(message.address);
        }
        if (message.data.length !== 0) {
          writer.uint32(18).bytes(message.data);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgInstantiateContractResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.address = reader.string();
              break;
            case 2:
              message.data = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object2) {
        return {
          address: isSet(object2.address) ? String(object2.address) : "",
          data: isSet(object2.data) ? bytesFromBase64(object2.data) : new Uint8Array()
        };
      },
      toJSON(message) {
        const obj = {};
        message.address !== void 0 && (obj.address = message.address);
        message.data !== void 0 && (obj.data = base64FromBytes(message.data !== void 0 ? message.data : new Uint8Array()));
        return obj;
      },
      fromPartial(object2) {
        var _a2, _b;
        const message = createBaseMsgInstantiateContractResponse();
        message.address = (_a2 = object2.address) !== null && _a2 !== void 0 ? _a2 : "";
        message.data = (_b = object2.data) !== null && _b !== void 0 ? _b : new Uint8Array();
        return message;
      }
    };
    function createBaseMsgExecuteContract() {
      return { sender: "", contract: "", msg: new Uint8Array(), funds: [] };
    }
    exports.MsgExecuteContract = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.sender !== "") {
          writer.uint32(10).string(message.sender);
        }
        if (message.contract !== "") {
          writer.uint32(18).string(message.contract);
        }
        if (message.msg.length !== 0) {
          writer.uint32(26).bytes(message.msg);
        }
        for (const v5 of message.funds) {
          coin_1.Coin.encode(v5, writer.uint32(42).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgExecuteContract();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.sender = reader.string();
              break;
            case 2:
              message.contract = reader.string();
              break;
            case 3:
              message.msg = reader.bytes();
              break;
            case 5:
              message.funds.push(coin_1.Coin.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object2) {
        return {
          sender: isSet(object2.sender) ? String(object2.sender) : "",
          contract: isSet(object2.contract) ? String(object2.contract) : "",
          msg: isSet(object2.msg) ? bytesFromBase64(object2.msg) : new Uint8Array(),
          funds: Array.isArray(object2 === null || object2 === void 0 ? void 0 : object2.funds) ? object2.funds.map((e2) => coin_1.Coin.fromJSON(e2)) : []
        };
      },
      toJSON(message) {
        const obj = {};
        message.sender !== void 0 && (obj.sender = message.sender);
        message.contract !== void 0 && (obj.contract = message.contract);
        message.msg !== void 0 && (obj.msg = base64FromBytes(message.msg !== void 0 ? message.msg : new Uint8Array()));
        if (message.funds) {
          obj.funds = message.funds.map((e2) => e2 ? coin_1.Coin.toJSON(e2) : void 0);
        } else {
          obj.funds = [];
        }
        return obj;
      },
      fromPartial(object2) {
        var _a2, _b, _c, _d;
        const message = createBaseMsgExecuteContract();
        message.sender = (_a2 = object2.sender) !== null && _a2 !== void 0 ? _a2 : "";
        message.contract = (_b = object2.contract) !== null && _b !== void 0 ? _b : "";
        message.msg = (_c = object2.msg) !== null && _c !== void 0 ? _c : new Uint8Array();
        message.funds = ((_d = object2.funds) === null || _d === void 0 ? void 0 : _d.map((e2) => coin_1.Coin.fromPartial(e2))) || [];
        return message;
      }
    };
    function createBaseMsgExecuteContractResponse() {
      return { data: new Uint8Array() };
    }
    exports.MsgExecuteContractResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.data.length !== 0) {
          writer.uint32(10).bytes(message.data);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgExecuteContractResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.data = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object2) {
        return {
          data: isSet(object2.data) ? bytesFromBase64(object2.data) : new Uint8Array()
        };
      },
      toJSON(message) {
        const obj = {};
        message.data !== void 0 && (obj.data = base64FromBytes(message.data !== void 0 ? message.data : new Uint8Array()));
        return obj;
      },
      fromPartial(object2) {
        var _a2;
        const message = createBaseMsgExecuteContractResponse();
        message.data = (_a2 = object2.data) !== null && _a2 !== void 0 ? _a2 : new Uint8Array();
        return message;
      }
    };
    function createBaseMsgMigrateContract() {
      return { sender: "", contract: "", codeId: "0", msg: new Uint8Array() };
    }
    exports.MsgMigrateContract = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.sender !== "") {
          writer.uint32(10).string(message.sender);
        }
        if (message.contract !== "") {
          writer.uint32(18).string(message.contract);
        }
        if (message.codeId !== "0") {
          writer.uint32(24).uint64(message.codeId);
        }
        if (message.msg.length !== 0) {
          writer.uint32(34).bytes(message.msg);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgMigrateContract();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.sender = reader.string();
              break;
            case 2:
              message.contract = reader.string();
              break;
            case 3:
              message.codeId = longToString(reader.uint64());
              break;
            case 4:
              message.msg = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object2) {
        return {
          sender: isSet(object2.sender) ? String(object2.sender) : "",
          contract: isSet(object2.contract) ? String(object2.contract) : "",
          codeId: isSet(object2.codeId) ? String(object2.codeId) : "0",
          msg: isSet(object2.msg) ? bytesFromBase64(object2.msg) : new Uint8Array()
        };
      },
      toJSON(message) {
        const obj = {};
        message.sender !== void 0 && (obj.sender = message.sender);
        message.contract !== void 0 && (obj.contract = message.contract);
        message.codeId !== void 0 && (obj.codeId = message.codeId);
        message.msg !== void 0 && (obj.msg = base64FromBytes(message.msg !== void 0 ? message.msg : new Uint8Array()));
        return obj;
      },
      fromPartial(object2) {
        var _a2, _b, _c, _d;
        const message = createBaseMsgMigrateContract();
        message.sender = (_a2 = object2.sender) !== null && _a2 !== void 0 ? _a2 : "";
        message.contract = (_b = object2.contract) !== null && _b !== void 0 ? _b : "";
        message.codeId = (_c = object2.codeId) !== null && _c !== void 0 ? _c : "0";
        message.msg = (_d = object2.msg) !== null && _d !== void 0 ? _d : new Uint8Array();
        return message;
      }
    };
    function createBaseMsgMigrateContractResponse() {
      return { data: new Uint8Array() };
    }
    exports.MsgMigrateContractResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.data.length !== 0) {
          writer.uint32(10).bytes(message.data);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgMigrateContractResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.data = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object2) {
        return {
          data: isSet(object2.data) ? bytesFromBase64(object2.data) : new Uint8Array()
        };
      },
      toJSON(message) {
        const obj = {};
        message.data !== void 0 && (obj.data = base64FromBytes(message.data !== void 0 ? message.data : new Uint8Array()));
        return obj;
      },
      fromPartial(object2) {
        var _a2;
        const message = createBaseMsgMigrateContractResponse();
        message.data = (_a2 = object2.data) !== null && _a2 !== void 0 ? _a2 : new Uint8Array();
        return message;
      }
    };
    function createBaseMsgUpdateAdmin() {
      return { sender: "", newAdmin: "", contract: "" };
    }
    exports.MsgUpdateAdmin = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.sender !== "") {
          writer.uint32(10).string(message.sender);
        }
        if (message.newAdmin !== "") {
          writer.uint32(18).string(message.newAdmin);
        }
        if (message.contract !== "") {
          writer.uint32(26).string(message.contract);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgUpdateAdmin();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.sender = reader.string();
              break;
            case 2:
              message.newAdmin = reader.string();
              break;
            case 3:
              message.contract = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object2) {
        return {
          sender: isSet(object2.sender) ? String(object2.sender) : "",
          newAdmin: isSet(object2.newAdmin) ? String(object2.newAdmin) : "",
          contract: isSet(object2.contract) ? String(object2.contract) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        message.sender !== void 0 && (obj.sender = message.sender);
        message.newAdmin !== void 0 && (obj.newAdmin = message.newAdmin);
        message.contract !== void 0 && (obj.contract = message.contract);
        return obj;
      },
      fromPartial(object2) {
        var _a2, _b, _c;
        const message = createBaseMsgUpdateAdmin();
        message.sender = (_a2 = object2.sender) !== null && _a2 !== void 0 ? _a2 : "";
        message.newAdmin = (_b = object2.newAdmin) !== null && _b !== void 0 ? _b : "";
        message.contract = (_c = object2.contract) !== null && _c !== void 0 ? _c : "";
        return message;
      }
    };
    function createBaseMsgUpdateAdminResponse() {
      return {};
    }
    exports.MsgUpdateAdminResponse = {
      encode(_16, writer = minimal_1.default.Writer.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgUpdateAdminResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_16) {
        return {};
      },
      toJSON(_16) {
        const obj = {};
        return obj;
      },
      fromPartial(_16) {
        const message = createBaseMsgUpdateAdminResponse();
        return message;
      }
    };
    function createBaseMsgClearAdmin() {
      return { sender: "", contract: "" };
    }
    exports.MsgClearAdmin = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.sender !== "") {
          writer.uint32(10).string(message.sender);
        }
        if (message.contract !== "") {
          writer.uint32(26).string(message.contract);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgClearAdmin();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.sender = reader.string();
              break;
            case 3:
              message.contract = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object2) {
        return {
          sender: isSet(object2.sender) ? String(object2.sender) : "",
          contract: isSet(object2.contract) ? String(object2.contract) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        message.sender !== void 0 && (obj.sender = message.sender);
        message.contract !== void 0 && (obj.contract = message.contract);
        return obj;
      },
      fromPartial(object2) {
        var _a2, _b;
        const message = createBaseMsgClearAdmin();
        message.sender = (_a2 = object2.sender) !== null && _a2 !== void 0 ? _a2 : "";
        message.contract = (_b = object2.contract) !== null && _b !== void 0 ? _b : "";
        return message;
      }
    };
    function createBaseMsgClearAdminResponse() {
      return {};
    }
    exports.MsgClearAdminResponse = {
      encode(_16, writer = minimal_1.default.Writer.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgClearAdminResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_16) {
        return {};
      },
      toJSON(_16) {
        const obj = {};
        return obj;
      },
      fromPartial(_16) {
        const message = createBaseMsgClearAdminResponse();
        return message;
      }
    };
    var globalThis2 = (() => {
      if (typeof globalThis2 !== "undefined")
        return globalThis2;
      if (typeof self !== "undefined")
        return self;
      if (typeof window !== "undefined")
        return window;
      if (typeof global !== "undefined")
        return global;
      throw "Unable to locate global object";
    })();
    var atob = globalThis2.atob || ((b64) => globalThis2.Buffer.from(b64, "base64").toString("binary"));
    function bytesFromBase64(b64) {
      const bin = atob(b64);
      const arr = new Uint8Array(bin.length);
      for (let i4 = 0; i4 < bin.length; ++i4) {
        arr[i4] = bin.charCodeAt(i4);
      }
      return arr;
    }
    var btoa = globalThis2.btoa || ((bin) => globalThis2.Buffer.from(bin, "binary").toString("base64"));
    function base64FromBytes(arr) {
      const bin = [];
      for (const byte of arr) {
        bin.push(String.fromCharCode(byte));
      }
      return btoa(bin.join(""));
    }
    function longToString(long) {
      return long.toString();
    }
    if (minimal_1.default.util.Long !== long_1.default) {
      minimal_1.default.util.Long = long_1.default;
      minimal_1.default.configure();
    }
    function isSet(value) {
      return value !== null && value !== void 0;
    }
  }
});

// ../../node_modules/.pnpm/@keplr-wallet+proto-types@0.12.28/node_modules/@keplr-wallet/proto-types/cosmos/upgrade/v1beta1/upgrade.js
var require_upgrade = __commonJS({
  "../../node_modules/.pnpm/@keplr-wallet+proto-types@0.12.28/node_modules/@keplr-wallet/proto-types/cosmos/upgrade/v1beta1/upgrade.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ModuleVersion = exports.CancelSoftwareUpgradeProposal = exports.SoftwareUpgradeProposal = exports.Plan = exports.protobufPackage = void 0;
    var long_1 = __importDefault(require_long());
    var minimal_1 = __importDefault(require_minimal());
    var timestamp_1 = require_timestamp();
    var any_1 = require_any();
    exports.protobufPackage = "cosmos.upgrade.v1beta1";
    function createBasePlan() {
      return {
        name: "",
        time: void 0,
        height: "0",
        info: "",
        upgradedClientState: void 0
      };
    }
    exports.Plan = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.name !== "") {
          writer.uint32(10).string(message.name);
        }
        if (message.time !== void 0) {
          timestamp_1.Timestamp.encode(toTimestamp(message.time), writer.uint32(18).fork()).ldelim();
        }
        if (message.height !== "0") {
          writer.uint32(24).int64(message.height);
        }
        if (message.info !== "") {
          writer.uint32(34).string(message.info);
        }
        if (message.upgradedClientState !== void 0) {
          any_1.Any.encode(message.upgradedClientState, writer.uint32(42).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBasePlan();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.name = reader.string();
              break;
            case 2:
              message.time = fromTimestamp(timestamp_1.Timestamp.decode(reader, reader.uint32()));
              break;
            case 3:
              message.height = longToString(reader.int64());
              break;
            case 4:
              message.info = reader.string();
              break;
            case 5:
              message.upgradedClientState = any_1.Any.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object2) {
        return {
          name: isSet(object2.name) ? String(object2.name) : "",
          time: isSet(object2.time) ? fromJsonTimestamp(object2.time) : void 0,
          height: isSet(object2.height) ? String(object2.height) : "0",
          info: isSet(object2.info) ? String(object2.info) : "",
          upgradedClientState: isSet(object2.upgradedClientState) ? any_1.Any.fromJSON(object2.upgradedClientState) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.name !== void 0 && (obj.name = message.name);
        message.time !== void 0 && (obj.time = message.time.toISOString());
        message.height !== void 0 && (obj.height = message.height);
        message.info !== void 0 && (obj.info = message.info);
        message.upgradedClientState !== void 0 && (obj.upgradedClientState = message.upgradedClientState ? any_1.Any.toJSON(message.upgradedClientState) : void 0);
        return obj;
      },
      fromPartial(object2) {
        var _a2, _b, _c, _d;
        const message = createBasePlan();
        message.name = (_a2 = object2.name) !== null && _a2 !== void 0 ? _a2 : "";
        message.time = (_b = object2.time) !== null && _b !== void 0 ? _b : void 0;
        message.height = (_c = object2.height) !== null && _c !== void 0 ? _c : "0";
        message.info = (_d = object2.info) !== null && _d !== void 0 ? _d : "";
        message.upgradedClientState = object2.upgradedClientState !== void 0 && object2.upgradedClientState !== null ? any_1.Any.fromPartial(object2.upgradedClientState) : void 0;
        return message;
      }
    };
    function createBaseSoftwareUpgradeProposal() {
      return { title: "", description: "", plan: void 0 };
    }
    exports.SoftwareUpgradeProposal = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.title !== "") {
          writer.uint32(10).string(message.title);
        }
        if (message.description !== "") {
          writer.uint32(18).string(message.description);
        }
        if (message.plan !== void 0) {
          exports.Plan.encode(message.plan, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseSoftwareUpgradeProposal();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.title = reader.string();
              break;
            case 2:
              message.description = reader.string();
              break;
            case 3:
              message.plan = exports.Plan.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object2) {
        return {
          title: isSet(object2.title) ? String(object2.title) : "",
          description: isSet(object2.description) ? String(object2.description) : "",
          plan: isSet(object2.plan) ? exports.Plan.fromJSON(object2.plan) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.title !== void 0 && (obj.title = message.title);
        message.description !== void 0 && (obj.description = message.description);
        message.plan !== void 0 && (obj.plan = message.plan ? exports.Plan.toJSON(message.plan) : void 0);
        return obj;
      },
      fromPartial(object2) {
        var _a2, _b;
        const message = createBaseSoftwareUpgradeProposal();
        message.title = (_a2 = object2.title) !== null && _a2 !== void 0 ? _a2 : "";
        message.description = (_b = object2.description) !== null && _b !== void 0 ? _b : "";
        message.plan = object2.plan !== void 0 && object2.plan !== null ? exports.Plan.fromPartial(object2.plan) : void 0;
        return message;
      }
    };
    function createBaseCancelSoftwareUpgradeProposal() {
      return { title: "", description: "" };
    }
    exports.CancelSoftwareUpgradeProposal = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.title !== "") {
          writer.uint32(10).string(message.title);
        }
        if (message.description !== "") {
          writer.uint32(18).string(message.description);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseCancelSoftwareUpgradeProposal();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.title = reader.string();
              break;
            case 2:
              message.description = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object2) {
        return {
          title: isSet(object2.title) ? String(object2.title) : "",
          description: isSet(object2.description) ? String(object2.description) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        message.title !== void 0 && (obj.title = message.title);
        message.description !== void 0 && (obj.description = message.description);
        return obj;
      },
      fromPartial(object2) {
        var _a2, _b;
        const message = createBaseCancelSoftwareUpgradeProposal();
        message.title = (_a2 = object2.title) !== null && _a2 !== void 0 ? _a2 : "";
        message.description = (_b = object2.description) !== null && _b !== void 0 ? _b : "";
        return message;
      }
    };
    function createBaseModuleVersion() {
      return { name: "", version: "0" };
    }
    exports.ModuleVersion = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.name !== "") {
          writer.uint32(10).string(message.name);
        }
        if (message.version !== "0") {
          writer.uint32(16).uint64(message.version);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseModuleVersion();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.name = reader.string();
              break;
            case 2:
              message.version = longToString(reader.uint64());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object2) {
        return {
          name: isSet(object2.name) ? String(object2.name) : "",
          version: isSet(object2.version) ? String(object2.version) : "0"
        };
      },
      toJSON(message) {
        const obj = {};
        message.name !== void 0 && (obj.name = message.name);
        message.version !== void 0 && (obj.version = message.version);
        return obj;
      },
      fromPartial(object2) {
        var _a2, _b;
        const message = createBaseModuleVersion();
        message.name = (_a2 = object2.name) !== null && _a2 !== void 0 ? _a2 : "";
        message.version = (_b = object2.version) !== null && _b !== void 0 ? _b : "0";
        return message;
      }
    };
    function toTimestamp(date) {
      const seconds = Math.trunc(date.getTime() / 1e3).toString();
      const nanos = date.getTime() % 1e3 * 1e6;
      return { seconds, nanos };
    }
    function fromTimestamp(t) {
      let millis = Number(t.seconds) * 1e3;
      millis += t.nanos / 1e6;
      return new Date(millis);
    }
    function fromJsonTimestamp(o4) {
      if (o4 instanceof Date) {
        return o4;
      } else if (typeof o4 === "string") {
        return new Date(o4);
      } else {
        return fromTimestamp(timestamp_1.Timestamp.fromJSON(o4));
      }
    }
    function longToString(long) {
      return long.toString();
    }
    if (minimal_1.default.util.Long !== long_1.default) {
      minimal_1.default.util.Long = long_1.default;
      minimal_1.default.configure();
    }
    function isSet(value) {
      return value !== null && value !== void 0;
    }
  }
});

// ../../node_modules/.pnpm/@keplr-wallet+proto-types@0.12.28/node_modules/@keplr-wallet/proto-types/ibc/core/client/v1/client.js
var require_client = __commonJS({
  "../../node_modules/.pnpm/@keplr-wallet+proto-types@0.12.28/node_modules/@keplr-wallet/proto-types/ibc/core/client/v1/client.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Params = exports.Height = exports.UpgradeProposal = exports.ClientUpdateProposal = exports.ClientConsensusStates = exports.ConsensusStateWithHeight = exports.IdentifiedClientState = exports.protobufPackage = void 0;
    var long_1 = __importDefault(require_long());
    var minimal_1 = __importDefault(require_minimal());
    var any_1 = require_any();
    var upgrade_1 = require_upgrade();
    exports.protobufPackage = "ibc.core.client.v1";
    function createBaseIdentifiedClientState() {
      return { clientId: "", clientState: void 0 };
    }
    exports.IdentifiedClientState = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.clientId !== "") {
          writer.uint32(10).string(message.clientId);
        }
        if (message.clientState !== void 0) {
          any_1.Any.encode(message.clientState, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseIdentifiedClientState();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.clientId = reader.string();
              break;
            case 2:
              message.clientState = any_1.Any.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object2) {
        return {
          clientId: isSet(object2.clientId) ? String(object2.clientId) : "",
          clientState: isSet(object2.clientState) ? any_1.Any.fromJSON(object2.clientState) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.clientId !== void 0 && (obj.clientId = message.clientId);
        message.clientState !== void 0 && (obj.clientState = message.clientState ? any_1.Any.toJSON(message.clientState) : void 0);
        return obj;
      },
      fromPartial(object2) {
        var _a2;
        const message = createBaseIdentifiedClientState();
        message.clientId = (_a2 = object2.clientId) !== null && _a2 !== void 0 ? _a2 : "";
        message.clientState = object2.clientState !== void 0 && object2.clientState !== null ? any_1.Any.fromPartial(object2.clientState) : void 0;
        return message;
      }
    };
    function createBaseConsensusStateWithHeight() {
      return { height: void 0, consensusState: void 0 };
    }
    exports.ConsensusStateWithHeight = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.height !== void 0) {
          exports.Height.encode(message.height, writer.uint32(10).fork()).ldelim();
        }
        if (message.consensusState !== void 0) {
          any_1.Any.encode(message.consensusState, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseConsensusStateWithHeight();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.height = exports.Height.decode(reader, reader.uint32());
              break;
            case 2:
              message.consensusState = any_1.Any.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object2) {
        return {
          height: isSet(object2.height) ? exports.Height.fromJSON(object2.height) : void 0,
          consensusState: isSet(object2.consensusState) ? any_1.Any.fromJSON(object2.consensusState) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.height !== void 0 && (obj.height = message.height ? exports.Height.toJSON(message.height) : void 0);
        message.consensusState !== void 0 && (obj.consensusState = message.consensusState ? any_1.Any.toJSON(message.consensusState) : void 0);
        return obj;
      },
      fromPartial(object2) {
        const message = createBaseConsensusStateWithHeight();
        message.height = object2.height !== void 0 && object2.height !== null ? exports.Height.fromPartial(object2.height) : void 0;
        message.consensusState = object2.consensusState !== void 0 && object2.consensusState !== null ? any_1.Any.fromPartial(object2.consensusState) : void 0;
        return message;
      }
    };
    function createBaseClientConsensusStates() {
      return { clientId: "", consensusStates: [] };
    }
    exports.ClientConsensusStates = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.clientId !== "") {
          writer.uint32(10).string(message.clientId);
        }
        for (const v5 of message.consensusStates) {
          exports.ConsensusStateWithHeight.encode(v5, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseClientConsensusStates();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.clientId = reader.string();
              break;
            case 2:
              message.consensusStates.push(exports.ConsensusStateWithHeight.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object2) {
        return {
          clientId: isSet(object2.clientId) ? String(object2.clientId) : "",
          consensusStates: Array.isArray(object2 === null || object2 === void 0 ? void 0 : object2.consensusStates) ? object2.consensusStates.map((e2) => exports.ConsensusStateWithHeight.fromJSON(e2)) : []
        };
      },
      toJSON(message) {
        const obj = {};
        message.clientId !== void 0 && (obj.clientId = message.clientId);
        if (message.consensusStates) {
          obj.consensusStates = message.consensusStates.map((e2) => e2 ? exports.ConsensusStateWithHeight.toJSON(e2) : void 0);
        } else {
          obj.consensusStates = [];
        }
        return obj;
      },
      fromPartial(object2) {
        var _a2, _b;
        const message = createBaseClientConsensusStates();
        message.clientId = (_a2 = object2.clientId) !== null && _a2 !== void 0 ? _a2 : "";
        message.consensusStates = ((_b = object2.consensusStates) === null || _b === void 0 ? void 0 : _b.map((e2) => exports.ConsensusStateWithHeight.fromPartial(e2))) || [];
        return message;
      }
    };
    function createBaseClientUpdateProposal() {
      return {
        title: "",
        description: "",
        subjectClientId: "",
        substituteClientId: ""
      };
    }
    exports.ClientUpdateProposal = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.title !== "") {
          writer.uint32(10).string(message.title);
        }
        if (message.description !== "") {
          writer.uint32(18).string(message.description);
        }
        if (message.subjectClientId !== "") {
          writer.uint32(26).string(message.subjectClientId);
        }
        if (message.substituteClientId !== "") {
          writer.uint32(34).string(message.substituteClientId);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseClientUpdateProposal();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.title = reader.string();
              break;
            case 2:
              message.description = reader.string();
              break;
            case 3:
              message.subjectClientId = reader.string();
              break;
            case 4:
              message.substituteClientId = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object2) {
        return {
          title: isSet(object2.title) ? String(object2.title) : "",
          description: isSet(object2.description) ? String(object2.description) : "",
          subjectClientId: isSet(object2.subjectClientId) ? String(object2.subjectClientId) : "",
          substituteClientId: isSet(object2.substituteClientId) ? String(object2.substituteClientId) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        message.title !== void 0 && (obj.title = message.title);
        message.description !== void 0 && (obj.description = message.description);
        message.subjectClientId !== void 0 && (obj.subjectClientId = message.subjectClientId);
        message.substituteClientId !== void 0 && (obj.substituteClientId = message.substituteClientId);
        return obj;
      },
      fromPartial(object2) {
        var _a2, _b, _c, _d;
        const message = createBaseClientUpdateProposal();
        message.title = (_a2 = object2.title) !== null && _a2 !== void 0 ? _a2 : "";
        message.description = (_b = object2.description) !== null && _b !== void 0 ? _b : "";
        message.subjectClientId = (_c = object2.subjectClientId) !== null && _c !== void 0 ? _c : "";
        message.substituteClientId = (_d = object2.substituteClientId) !== null && _d !== void 0 ? _d : "";
        return message;
      }
    };
    function createBaseUpgradeProposal() {
      return {
        title: "",
        description: "",
        plan: void 0,
        upgradedClientState: void 0
      };
    }
    exports.UpgradeProposal = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.title !== "") {
          writer.uint32(10).string(message.title);
        }
        if (message.description !== "") {
          writer.uint32(18).string(message.description);
        }
        if (message.plan !== void 0) {
          upgrade_1.Plan.encode(message.plan, writer.uint32(26).fork()).ldelim();
        }
        if (message.upgradedClientState !== void 0) {
          any_1.Any.encode(message.upgradedClientState, writer.uint32(34).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseUpgradeProposal();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.title = reader.string();
              break;
            case 2:
              message.description = reader.string();
              break;
            case 3:
              message.plan = upgrade_1.Plan.decode(reader, reader.uint32());
              break;
            case 4:
              message.upgradedClientState = any_1.Any.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object2) {
        return {
          title: isSet(object2.title) ? String(object2.title) : "",
          description: isSet(object2.description) ? String(object2.description) : "",
          plan: isSet(object2.plan) ? upgrade_1.Plan.fromJSON(object2.plan) : void 0,
          upgradedClientState: isSet(object2.upgradedClientState) ? any_1.Any.fromJSON(object2.upgradedClientState) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.title !== void 0 && (obj.title = message.title);
        message.description !== void 0 && (obj.description = message.description);
        message.plan !== void 0 && (obj.plan = message.plan ? upgrade_1.Plan.toJSON(message.plan) : void 0);
        message.upgradedClientState !== void 0 && (obj.upgradedClientState = message.upgradedClientState ? any_1.Any.toJSON(message.upgradedClientState) : void 0);
        return obj;
      },
      fromPartial(object2) {
        var _a2, _b;
        const message = createBaseUpgradeProposal();
        message.title = (_a2 = object2.title) !== null && _a2 !== void 0 ? _a2 : "";
        message.description = (_b = object2.description) !== null && _b !== void 0 ? _b : "";
        message.plan = object2.plan !== void 0 && object2.plan !== null ? upgrade_1.Plan.fromPartial(object2.plan) : void 0;
        message.upgradedClientState = object2.upgradedClientState !== void 0 && object2.upgradedClientState !== null ? any_1.Any.fromPartial(object2.upgradedClientState) : void 0;
        return message;
      }
    };
    function createBaseHeight() {
      return { revisionNumber: "0", revisionHeight: "0" };
    }
    exports.Height = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.revisionNumber !== "0") {
          writer.uint32(8).uint64(message.revisionNumber);
        }
        if (message.revisionHeight !== "0") {
          writer.uint32(16).uint64(message.revisionHeight);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseHeight();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.revisionNumber = longToString(reader.uint64());
              break;
            case 2:
              message.revisionHeight = longToString(reader.uint64());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object2) {
        return {
          revisionNumber: isSet(object2.revisionNumber) ? String(object2.revisionNumber) : "0",
          revisionHeight: isSet(object2.revisionHeight) ? String(object2.revisionHeight) : "0"
        };
      },
      toJSON(message) {
        const obj = {};
        message.revisionNumber !== void 0 && (obj.revisionNumber = message.revisionNumber);
        message.revisionHeight !== void 0 && (obj.revisionHeight = message.revisionHeight);
        return obj;
      },
      fromPartial(object2) {
        var _a2, _b;
        const message = createBaseHeight();
        message.revisionNumber = (_a2 = object2.revisionNumber) !== null && _a2 !== void 0 ? _a2 : "0";
        message.revisionHeight = (_b = object2.revisionHeight) !== null && _b !== void 0 ? _b : "0";
        return message;
      }
    };
    function createBaseParams() {
      return { allowedClients: [] };
    }
    exports.Params = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v5 of message.allowedClients) {
          writer.uint32(10).string(v5);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseParams();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.allowedClients.push(reader.string());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object2) {
        return {
          allowedClients: Array.isArray(object2 === null || object2 === void 0 ? void 0 : object2.allowedClients) ? object2.allowedClients.map((e2) => String(e2)) : []
        };
      },
      toJSON(message) {
        const obj = {};
        if (message.allowedClients) {
          obj.allowedClients = message.allowedClients.map((e2) => e2);
        } else {
          obj.allowedClients = [];
        }
        return obj;
      },
      fromPartial(object2) {
        var _a2;
        const message = createBaseParams();
        message.allowedClients = ((_a2 = object2.allowedClients) === null || _a2 === void 0 ? void 0 : _a2.map((e2) => e2)) || [];
        return message;
      }
    };
    function longToString(long) {
      return long.toString();
    }
    if (minimal_1.default.util.Long !== long_1.default) {
      minimal_1.default.util.Long = long_1.default;
      minimal_1.default.configure();
    }
    function isSet(value) {
      return value !== null && value !== void 0;
    }
  }
});

// ../../node_modules/.pnpm/@keplr-wallet+proto-types@0.12.28/node_modules/@keplr-wallet/proto-types/ibc/applications/transfer/v1/tx.js
var require_tx7 = __commonJS({
  "../../node_modules/.pnpm/@keplr-wallet+proto-types@0.12.28/node_modules/@keplr-wallet/proto-types/ibc/applications/transfer/v1/tx.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MsgTransferResponse = exports.MsgTransfer = exports.protobufPackage = void 0;
    var long_1 = __importDefault(require_long());
    var minimal_1 = __importDefault(require_minimal());
    var coin_1 = require_coin2();
    var client_1 = require_client();
    exports.protobufPackage = "ibc.applications.transfer.v1";
    function createBaseMsgTransfer() {
      return {
        sourcePort: "",
        sourceChannel: "",
        token: void 0,
        sender: "",
        receiver: "",
        timeoutHeight: void 0,
        timeoutTimestamp: "0",
        memo: ""
      };
    }
    exports.MsgTransfer = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.sourcePort !== "") {
          writer.uint32(10).string(message.sourcePort);
        }
        if (message.sourceChannel !== "") {
          writer.uint32(18).string(message.sourceChannel);
        }
        if (message.token !== void 0) {
          coin_1.Coin.encode(message.token, writer.uint32(26).fork()).ldelim();
        }
        if (message.sender !== "") {
          writer.uint32(34).string(message.sender);
        }
        if (message.receiver !== "") {
          writer.uint32(42).string(message.receiver);
        }
        if (message.timeoutHeight !== void 0) {
          client_1.Height.encode(message.timeoutHeight, writer.uint32(50).fork()).ldelim();
        }
        if (message.timeoutTimestamp !== "0") {
          writer.uint32(56).uint64(message.timeoutTimestamp);
        }
        if (message.memo !== "") {
          writer.uint32(66).string(message.memo);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgTransfer();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.sourcePort = reader.string();
              break;
            case 2:
              message.sourceChannel = reader.string();
              break;
            case 3:
              message.token = coin_1.Coin.decode(reader, reader.uint32());
              break;
            case 4:
              message.sender = reader.string();
              break;
            case 5:
              message.receiver = reader.string();
              break;
            case 6:
              message.timeoutHeight = client_1.Height.decode(reader, reader.uint32());
              break;
            case 7:
              message.timeoutTimestamp = longToString(reader.uint64());
              break;
            case 8:
              message.memo = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object2) {
        return {
          sourcePort: isSet(object2.sourcePort) ? String(object2.sourcePort) : "",
          sourceChannel: isSet(object2.sourceChannel) ? String(object2.sourceChannel) : "",
          token: isSet(object2.token) ? coin_1.Coin.fromJSON(object2.token) : void 0,
          sender: isSet(object2.sender) ? String(object2.sender) : "",
          receiver: isSet(object2.receiver) ? String(object2.receiver) : "",
          timeoutHeight: isSet(object2.timeoutHeight) ? client_1.Height.fromJSON(object2.timeoutHeight) : void 0,
          timeoutTimestamp: isSet(object2.timeoutTimestamp) ? String(object2.timeoutTimestamp) : "0",
          memo: isSet(object2.memo) ? String(object2.memo) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        message.sourcePort !== void 0 && (obj.sourcePort = message.sourcePort);
        message.sourceChannel !== void 0 && (obj.sourceChannel = message.sourceChannel);
        message.token !== void 0 && (obj.token = message.token ? coin_1.Coin.toJSON(message.token) : void 0);
        message.sender !== void 0 && (obj.sender = message.sender);
        message.receiver !== void 0 && (obj.receiver = message.receiver);
        message.timeoutHeight !== void 0 && (obj.timeoutHeight = message.timeoutHeight ? client_1.Height.toJSON(message.timeoutHeight) : void 0);
        message.timeoutTimestamp !== void 0 && (obj.timeoutTimestamp = message.timeoutTimestamp);
        message.memo !== void 0 && (obj.memo = message.memo);
        return obj;
      },
      fromPartial(object2) {
        var _a2, _b, _c, _d, _e3, _f;
        const message = createBaseMsgTransfer();
        message.sourcePort = (_a2 = object2.sourcePort) !== null && _a2 !== void 0 ? _a2 : "";
        message.sourceChannel = (_b = object2.sourceChannel) !== null && _b !== void 0 ? _b : "";
        message.token = object2.token !== void 0 && object2.token !== null ? coin_1.Coin.fromPartial(object2.token) : void 0;
        message.sender = (_c = object2.sender) !== null && _c !== void 0 ? _c : "";
        message.receiver = (_d = object2.receiver) !== null && _d !== void 0 ? _d : "";
        message.timeoutHeight = object2.timeoutHeight !== void 0 && object2.timeoutHeight !== null ? client_1.Height.fromPartial(object2.timeoutHeight) : void 0;
        message.timeoutTimestamp = (_e3 = object2.timeoutTimestamp) !== null && _e3 !== void 0 ? _e3 : "0";
        message.memo = (_f = object2.memo) !== null && _f !== void 0 ? _f : "";
        return message;
      }
    };
    function createBaseMsgTransferResponse() {
      return {};
    }
    exports.MsgTransferResponse = {
      encode(_16, writer = minimal_1.default.Writer.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgTransferResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_16) {
        return {};
      },
      toJSON(_16) {
        const obj = {};
        return obj;
      },
      fromPartial(_16) {
        const message = createBaseMsgTransferResponse();
        return message;
      }
    };
    function longToString(long) {
      return long.toString();
    }
    if (minimal_1.default.util.Long !== long_1.default) {
      minimal_1.default.util.Long = long_1.default;
      minimal_1.default.configure();
    }
    function isSet(value) {
      return value !== null && value !== void 0;
    }
  }
});

// ../../node_modules/.pnpm/@keplr-wallet+cosmos@0.12.28/node_modules/@keplr-wallet/cosmos/build/stargate/codec/unknown.js
var require_unknown = __commonJS({
  "../../node_modules/.pnpm/@keplr-wallet+cosmos@0.12.28/node_modules/@keplr-wallet/cosmos/build/stargate/codec/unknown.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.UnknownMessage = void 0;
    var buffer_1 = require_buffer();
    var UnknownMessage = class {
      constructor(_typeUrl, _value) {
        this._typeUrl = _typeUrl;
        this._value = _value;
      }
      get typeUrl() {
        return this._typeUrl;
      }
      get value() {
        return this._value;
      }
      toJSON() {
        return {
          typeUrl: this._typeUrl,
          value: buffer_1.Buffer.from(this._value).toString("base64")
        };
      }
    };
    exports.UnknownMessage = UnknownMessage;
  }
});

// ../../node_modules/.pnpm/@keplr-wallet+proto-types@0.12.28/node_modules/@keplr-wallet/proto-types/cosmos/staking/v1beta1/authz.js
var require_authz2 = __commonJS({
  "../../node_modules/.pnpm/@keplr-wallet+proto-types@0.12.28/node_modules/@keplr-wallet/proto-types/cosmos/staking/v1beta1/authz.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.StakeAuthorization_Validators = exports.StakeAuthorization = exports.authorizationTypeToJSON = exports.authorizationTypeFromJSON = exports.AuthorizationType = exports.protobufPackage = void 0;
    var long_1 = __importDefault(require_long());
    var minimal_1 = __importDefault(require_minimal());
    var coin_1 = require_coin2();
    exports.protobufPackage = "cosmos.staking.v1beta1";
    var AuthorizationType;
    (function(AuthorizationType2) {
      AuthorizationType2[AuthorizationType2["AUTHORIZATION_TYPE_UNSPECIFIED"] = 0] = "AUTHORIZATION_TYPE_UNSPECIFIED";
      AuthorizationType2[AuthorizationType2["AUTHORIZATION_TYPE_DELEGATE"] = 1] = "AUTHORIZATION_TYPE_DELEGATE";
      AuthorizationType2[AuthorizationType2["AUTHORIZATION_TYPE_UNDELEGATE"] = 2] = "AUTHORIZATION_TYPE_UNDELEGATE";
      AuthorizationType2[AuthorizationType2["AUTHORIZATION_TYPE_REDELEGATE"] = 3] = "AUTHORIZATION_TYPE_REDELEGATE";
      AuthorizationType2[AuthorizationType2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(AuthorizationType = exports.AuthorizationType || (exports.AuthorizationType = {}));
    function authorizationTypeFromJSON(object2) {
      switch (object2) {
        case 0:
        case "AUTHORIZATION_TYPE_UNSPECIFIED":
          return AuthorizationType.AUTHORIZATION_TYPE_UNSPECIFIED;
        case 1:
        case "AUTHORIZATION_TYPE_DELEGATE":
          return AuthorizationType.AUTHORIZATION_TYPE_DELEGATE;
        case 2:
        case "AUTHORIZATION_TYPE_UNDELEGATE":
          return AuthorizationType.AUTHORIZATION_TYPE_UNDELEGATE;
        case 3:
        case "AUTHORIZATION_TYPE_REDELEGATE":
          return AuthorizationType.AUTHORIZATION_TYPE_REDELEGATE;
        case -1:
        case "UNRECOGNIZED":
        default:
          return AuthorizationType.UNRECOGNIZED;
      }
    }
    exports.authorizationTypeFromJSON = authorizationTypeFromJSON;
    function authorizationTypeToJSON(object2) {
      switch (object2) {
        case AuthorizationType.AUTHORIZATION_TYPE_UNSPECIFIED:
          return "AUTHORIZATION_TYPE_UNSPECIFIED";
        case AuthorizationType.AUTHORIZATION_TYPE_DELEGATE:
          return "AUTHORIZATION_TYPE_DELEGATE";
        case AuthorizationType.AUTHORIZATION_TYPE_UNDELEGATE:
          return "AUTHORIZATION_TYPE_UNDELEGATE";
        case AuthorizationType.AUTHORIZATION_TYPE_REDELEGATE:
          return "AUTHORIZATION_TYPE_REDELEGATE";
        default:
          return "UNKNOWN";
      }
    }
    exports.authorizationTypeToJSON = authorizationTypeToJSON;
    function createBaseStakeAuthorization() {
      return {
        maxTokens: void 0,
        allowList: void 0,
        denyList: void 0,
        authorizationType: 0
      };
    }
    exports.StakeAuthorization = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.maxTokens !== void 0) {
          coin_1.Coin.encode(message.maxTokens, writer.uint32(10).fork()).ldelim();
        }
        if (message.allowList !== void 0) {
          exports.StakeAuthorization_Validators.encode(message.allowList, writer.uint32(18).fork()).ldelim();
        }
        if (message.denyList !== void 0) {
          exports.StakeAuthorization_Validators.encode(message.denyList, writer.uint32(26).fork()).ldelim();
        }
        if (message.authorizationType !== 0) {
          writer.uint32(32).int32(message.authorizationType);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseStakeAuthorization();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.maxTokens = coin_1.Coin.decode(reader, reader.uint32());
              break;
            case 2:
              message.allowList = exports.StakeAuthorization_Validators.decode(reader, reader.uint32());
              break;
            case 3:
              message.denyList = exports.StakeAuthorization_Validators.decode(reader, reader.uint32());
              break;
            case 4:
              message.authorizationType = reader.int32();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object2) {
        return {
          maxTokens: isSet(object2.maxTokens) ? coin_1.Coin.fromJSON(object2.maxTokens) : void 0,
          allowList: isSet(object2.allowList) ? exports.StakeAuthorization_Validators.fromJSON(object2.allowList) : void 0,
          denyList: isSet(object2.denyList) ? exports.StakeAuthorization_Validators.fromJSON(object2.denyList) : void 0,
          authorizationType: isSet(object2.authorizationType) ? authorizationTypeFromJSON(object2.authorizationType) : 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.maxTokens !== void 0 && (obj.maxTokens = message.maxTokens ? coin_1.Coin.toJSON(message.maxTokens) : void 0);
        message.allowList !== void 0 && (obj.allowList = message.allowList ? exports.StakeAuthorization_Validators.toJSON(message.allowList) : void 0);
        message.denyList !== void 0 && (obj.denyList = message.denyList ? exports.StakeAuthorization_Validators.toJSON(message.denyList) : void 0);
        message.authorizationType !== void 0 && (obj.authorizationType = authorizationTypeToJSON(message.authorizationType));
        return obj;
      },
      fromPartial(object2) {
        var _a2;
        const message = createBaseStakeAuthorization();
        message.maxTokens = object2.maxTokens !== void 0 && object2.maxTokens !== null ? coin_1.Coin.fromPartial(object2.maxTokens) : void 0;
        message.allowList = object2.allowList !== void 0 && object2.allowList !== null ? exports.StakeAuthorization_Validators.fromPartial(object2.allowList) : void 0;
        message.denyList = object2.denyList !== void 0 && object2.denyList !== null ? exports.StakeAuthorization_Validators.fromPartial(object2.denyList) : void 0;
        message.authorizationType = (_a2 = object2.authorizationType) !== null && _a2 !== void 0 ? _a2 : 0;
        return message;
      }
    };
    function createBaseStakeAuthorization_Validators() {
      return { address: [] };
    }
    exports.StakeAuthorization_Validators = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v5 of message.address) {
          writer.uint32(10).string(v5);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseStakeAuthorization_Validators();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.address.push(reader.string());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object2) {
        return {
          address: Array.isArray(object2 === null || object2 === void 0 ? void 0 : object2.address) ? object2.address.map((e2) => String(e2)) : []
        };
      },
      toJSON(message) {
        const obj = {};
        if (message.address) {
          obj.address = message.address.map((e2) => e2);
        } else {
          obj.address = [];
        }
        return obj;
      },
      fromPartial(object2) {
        var _a2;
        const message = createBaseStakeAuthorization_Validators();
        message.address = ((_a2 = object2.address) === null || _a2 === void 0 ? void 0 : _a2.map((e2) => e2)) || [];
        return message;
      }
    };
    if (minimal_1.default.util.Long !== long_1.default) {
      minimal_1.default.util.Long = long_1.default;
      minimal_1.default.configure();
    }
    function isSet(value) {
      return value !== null && value !== void 0;
    }
  }
});

// ../../node_modules/.pnpm/@keplr-wallet+proto-types@0.12.28/node_modules/@keplr-wallet/proto-types/cosmos/bank/v1beta1/authz.js
var require_authz3 = __commonJS({
  "../../node_modules/.pnpm/@keplr-wallet+proto-types@0.12.28/node_modules/@keplr-wallet/proto-types/cosmos/bank/v1beta1/authz.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SendAuthorization = exports.protobufPackage = void 0;
    var long_1 = __importDefault(require_long());
    var minimal_1 = __importDefault(require_minimal());
    var coin_1 = require_coin2();
    exports.protobufPackage = "cosmos.bank.v1beta1";
    function createBaseSendAuthorization() {
      return { spendLimit: [] };
    }
    exports.SendAuthorization = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v5 of message.spendLimit) {
          coin_1.Coin.encode(v5, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseSendAuthorization();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.spendLimit.push(coin_1.Coin.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object2) {
        return {
          spendLimit: Array.isArray(object2 === null || object2 === void 0 ? void 0 : object2.spendLimit) ? object2.spendLimit.map((e2) => coin_1.Coin.fromJSON(e2)) : []
        };
      },
      toJSON(message) {
        const obj = {};
        if (message.spendLimit) {
          obj.spendLimit = message.spendLimit.map((e2) => e2 ? coin_1.Coin.toJSON(e2) : void 0);
        } else {
          obj.spendLimit = [];
        }
        return obj;
      },
      fromPartial(object2) {
        var _a2;
        const message = createBaseSendAuthorization();
        message.spendLimit = ((_a2 = object2.spendLimit) === null || _a2 === void 0 ? void 0 : _a2.map((e2) => coin_1.Coin.fromPartial(e2))) || [];
        return message;
      }
    };
    if (minimal_1.default.util.Long !== long_1.default) {
      minimal_1.default.util.Long = long_1.default;
      minimal_1.default.configure();
    }
  }
});

// ../../node_modules/.pnpm/@keplr-wallet+cosmos@0.12.28/node_modules/@keplr-wallet/cosmos/build/stargate/codec/index.js
var require_codec = __commonJS({
  "../../node_modules/.pnpm/@keplr-wallet+cosmos@0.12.28/node_modules/@keplr-wallet/cosmos/build/stargate/codec/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o4, m3, k5, k22) {
      if (k22 === void 0)
        k22 = k5;
      var desc = Object.getOwnPropertyDescriptor(m3, k5);
      if (!desc || ("get" in desc ? !m3.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m3[k5];
        } };
      }
      Object.defineProperty(o4, k22, desc);
    } : function(o4, m3, k5, k22) {
      if (k22 === void 0)
        k22 = k5;
      o4[k22] = m3[k5];
    });
    var __exportStar = exports && exports.__exportStar || function(m3, exports2) {
      for (var p4 in m3)
        if (p4 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p4))
          __createBinding(exports2, m3, p4);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.defaultProtoCodec = exports.ProtoCodec = void 0;
    var msgs_1 = require_msgs();
    var tx_1 = require_tx();
    var tx_2 = require_tx2();
    var tx_3 = require_tx3();
    var tx_4 = require_tx4();
    var tx_5 = require_tx5();
    var tx_6 = require_tx6();
    var tx_7 = require_tx7();
    var unknown_1 = require_unknown();
    var authz_1 = require_authz();
    var authz_2 = require_authz2();
    var authz_3 = require_authz3();
    var buffer_1 = require_buffer();
    __exportStar(require_unknown(), exports);
    var ProtoCodec = class {
      constructor() {
        this.typeUrlMap = /* @__PURE__ */ new Map();
      }
      unpackAnyFactory(typeUrl) {
        if (!this.typeUrlMap.has(typeUrl)) {
          return void 0;
        }
        return this.typeUrlMap.get(typeUrl);
      }
      /**
       * Unpack the any to the registered message.
       * NOTE: If there is no matched message, it will not throw an error but return the `UnknownMessage` class.
       * @param any
       */
      unpackAny(any) {
        const factory = this.unpackAnyFactory(any.typeUrl);
        if (!factory) {
          return new unknown_1.UnknownMessage(any.typeUrl, any.value);
        }
        const unpacked = factory.decode(any.value);
        return Object.assign(Object.assign({}, any), { unpacked });
      }
      unpackedAnyToJSONRecursive(unpacked) {
        if (unpacked instanceof unknown_1.UnknownMessage) {
          return unpacked.toJSON();
        }
        const factory = this.unpackAnyFactory(unpacked.typeUrl);
        if (factory && "unpacked" in unpacked && unpacked.unpacked) {
          const isJSONEncodedAny = (any) => {
            const r3 = typeof any === "object" && !(any instanceof unknown_1.UnknownMessage) && "typeUrl" in any && any.typeUrl && typeof any.typeUrl === "string" && "value" in any && any.value && typeof any.value === "string";
            if (r3) {
              try {
                buffer_1.Buffer.from(any.value, "base64");
              } catch (_a2) {
                return false;
              }
            }
            return r3;
          };
          const unpackJSONEncodedAnyInner = (jsonEncodedAny) => {
            const factory2 = this.unpackAnyFactory(jsonEncodedAny.typeUrl);
            const bz = buffer_1.Buffer.from(jsonEncodedAny.value, "base64");
            if (!factory2) {
              return new unknown_1.UnknownMessage(jsonEncodedAny.typeUrl, bz).toJSON();
            }
            const unpacked2 = factory2.decode(bz);
            return {
              typeUrl: jsonEncodedAny.typeUrl,
              value: factory2.toJSON(unpacked2)
            };
          };
          const unpackedJSONEncodedAnyRecursive = (obj) => {
            if (Array.isArray(obj)) {
              for (let i4 = 0; i4 < obj.length; i4++) {
                const value = obj[i4];
                if (isJSONEncodedAny(value)) {
                  obj[i4] = unpackJSONEncodedAnyInner(value);
                } else if (typeof value === "object") {
                  obj[i4] = unpackedJSONEncodedAnyRecursive(value);
                }
              }
            } else {
              for (const key in obj) {
                const value = obj[key];
                if (isJSONEncodedAny(value)) {
                  obj[key] = unpackJSONEncodedAnyInner(value);
                } else if (typeof value === "object") {
                  obj[key] = unpackedJSONEncodedAnyRecursive(value);
                }
              }
            }
            return obj;
          };
          let mutObj = factory.toJSON(unpacked.unpacked);
          if (mutObj && typeof mutObj === "object") {
            mutObj = unpackedJSONEncodedAnyRecursive(mutObj);
            return {
              typeUrl: unpacked.typeUrl,
              value: mutObj
            };
          }
        }
        return new unknown_1.UnknownMessage(unpacked.typeUrl, unpacked.value).toJSON();
      }
      registerAny(typeUrl, message) {
        this.typeUrlMap.set(typeUrl, message);
      }
    };
    exports.ProtoCodec = ProtoCodec;
    exports.defaultProtoCodec = new ProtoCodec();
    exports.defaultProtoCodec.registerAny("/agoric.swingset.MsgWalletSpendAction", msgs_1.MsgWalletSpendAction);
    exports.defaultProtoCodec.registerAny("/agoric.swingset.MsgProvision", msgs_1.MsgProvision);
    exports.defaultProtoCodec.registerAny("/cosmos.bank.v1beta1.MsgSend", tx_1.MsgSend);
    exports.defaultProtoCodec.registerAny("/cosmos.bank.v1beta1.MsgMultiSend", tx_1.MsgMultiSend);
    exports.defaultProtoCodec.registerAny("/cosmos.staking.v1beta1.MsgDelegate", tx_2.MsgDelegate);
    exports.defaultProtoCodec.registerAny("/cosmos.staking.v1beta1.MsgUndelegate", tx_2.MsgUndelegate);
    exports.defaultProtoCodec.registerAny("/cosmos.staking.v1beta1.MsgBeginRedelegate", tx_2.MsgBeginRedelegate);
    exports.defaultProtoCodec.registerAny("/cosmwasm.wasm.v1.MsgExecuteContract", tx_6.MsgExecuteContract);
    exports.defaultProtoCodec.registerAny("/cosmwasm.wasm.v1.MsgInstantiateContract", tx_6.MsgInstantiateContract);
    exports.defaultProtoCodec.registerAny("/cosmos.distribution.v1beta1.MsgWithdrawDelegatorReward", tx_5.MsgWithdrawDelegatorReward);
    exports.defaultProtoCodec.registerAny("/cosmos.distribution.v1beta1.MsgSetWithdrawAddress", tx_5.MsgSetWithdrawAddress);
    exports.defaultProtoCodec.registerAny("/ibc.applications.transfer.v1.MsgTransfer", tx_7.MsgTransfer);
    exports.defaultProtoCodec.registerAny("/cosmos.gov.v1beta1.MsgVote", tx_4.MsgVote);
    exports.defaultProtoCodec.registerAny("/cosmos.authz.v1beta1.MsgGrant", tx_3.MsgGrant);
    exports.defaultProtoCodec.registerAny("/cosmos.authz.v1beta1.GenericAuthorization", authz_1.GenericAuthorization);
    exports.defaultProtoCodec.registerAny("/cosmos.staking.v1beta1.StakeAuthorization", authz_2.StakeAuthorization);
    exports.defaultProtoCodec.registerAny("/cosmos.bank.v1beta1.SendAuthorization", authz_3.SendAuthorization);
    exports.defaultProtoCodec.registerAny("/cosmos.authz.v1beta1.MsgRevoke", tx_3.MsgRevoke);
    exports.defaultProtoCodec.registerAny("/cosmos.authz.v1beta1.MsgExec", tx_3.MsgExec);
  }
});

// ../../node_modules/.pnpm/@keplr-wallet+proto-types@0.12.28/node_modules/@keplr-wallet/proto-types/cosmos/crypto/multisig/v1beta1/multisig.js
var require_multisig = __commonJS({
  "../../node_modules/.pnpm/@keplr-wallet+proto-types@0.12.28/node_modules/@keplr-wallet/proto-types/cosmos/crypto/multisig/v1beta1/multisig.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CompactBitArray = exports.MultiSignature = exports.protobufPackage = void 0;
    var long_1 = __importDefault(require_long());
    var minimal_1 = __importDefault(require_minimal());
    exports.protobufPackage = "cosmos.crypto.multisig.v1beta1";
    function createBaseMultiSignature() {
      return { signatures: [] };
    }
    exports.MultiSignature = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v5 of message.signatures) {
          writer.uint32(10).bytes(v5);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMultiSignature();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.signatures.push(reader.bytes());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object2) {
        return {
          signatures: Array.isArray(object2 === null || object2 === void 0 ? void 0 : object2.signatures) ? object2.signatures.map((e2) => bytesFromBase64(e2)) : []
        };
      },
      toJSON(message) {
        const obj = {};
        if (message.signatures) {
          obj.signatures = message.signatures.map((e2) => base64FromBytes(e2 !== void 0 ? e2 : new Uint8Array()));
        } else {
          obj.signatures = [];
        }
        return obj;
      },
      fromPartial(object2) {
        var _a2;
        const message = createBaseMultiSignature();
        message.signatures = ((_a2 = object2.signatures) === null || _a2 === void 0 ? void 0 : _a2.map((e2) => e2)) || [];
        return message;
      }
    };
    function createBaseCompactBitArray() {
      return { extraBitsStored: 0, elems: new Uint8Array() };
    }
    exports.CompactBitArray = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.extraBitsStored !== 0) {
          writer.uint32(8).uint32(message.extraBitsStored);
        }
        if (message.elems.length !== 0) {
          writer.uint32(18).bytes(message.elems);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseCompactBitArray();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.extraBitsStored = reader.uint32();
              break;
            case 2:
              message.elems = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object2) {
        return {
          extraBitsStored: isSet(object2.extraBitsStored) ? Number(object2.extraBitsStored) : 0,
          elems: isSet(object2.elems) ? bytesFromBase64(object2.elems) : new Uint8Array()
        };
      },
      toJSON(message) {
        const obj = {};
        message.extraBitsStored !== void 0 && (obj.extraBitsStored = Math.round(message.extraBitsStored));
        message.elems !== void 0 && (obj.elems = base64FromBytes(message.elems !== void 0 ? message.elems : new Uint8Array()));
        return obj;
      },
      fromPartial(object2) {
        var _a2, _b;
        const message = createBaseCompactBitArray();
        message.extraBitsStored = (_a2 = object2.extraBitsStored) !== null && _a2 !== void 0 ? _a2 : 0;
        message.elems = (_b = object2.elems) !== null && _b !== void 0 ? _b : new Uint8Array();
        return message;
      }
    };
    var globalThis2 = (() => {
      if (typeof globalThis2 !== "undefined")
        return globalThis2;
      if (typeof self !== "undefined")
        return self;
      if (typeof window !== "undefined")
        return window;
      if (typeof global !== "undefined")
        return global;
      throw "Unable to locate global object";
    })();
    var atob = globalThis2.atob || ((b64) => globalThis2.Buffer.from(b64, "base64").toString("binary"));
    function bytesFromBase64(b64) {
      const bin = atob(b64);
      const arr = new Uint8Array(bin.length);
      for (let i4 = 0; i4 < bin.length; ++i4) {
        arr[i4] = bin.charCodeAt(i4);
      }
      return arr;
    }
    var btoa = globalThis2.btoa || ((bin) => globalThis2.Buffer.from(bin, "binary").toString("base64"));
    function base64FromBytes(arr) {
      const bin = [];
      for (const byte of arr) {
        bin.push(String.fromCharCode(byte));
      }
      return btoa(bin.join(""));
    }
    if (minimal_1.default.util.Long !== long_1.default) {
      minimal_1.default.util.Long = long_1.default;
      minimal_1.default.configure();
    }
    function isSet(value) {
      return value !== null && value !== void 0;
    }
  }
});

// ../../node_modules/.pnpm/@keplr-wallet+proto-types@0.12.28/node_modules/@keplr-wallet/proto-types/cosmos/tx/signing/v1beta1/signing.js
var require_signing = __commonJS({
  "../../node_modules/.pnpm/@keplr-wallet+proto-types@0.12.28/node_modules/@keplr-wallet/proto-types/cosmos/tx/signing/v1beta1/signing.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SignatureDescriptor_Data_Multi = exports.SignatureDescriptor_Data_Single = exports.SignatureDescriptor_Data = exports.SignatureDescriptor = exports.SignatureDescriptors = exports.signModeToJSON = exports.signModeFromJSON = exports.SignMode = exports.protobufPackage = void 0;
    var long_1 = __importDefault(require_long());
    var minimal_1 = __importDefault(require_minimal());
    var any_1 = require_any();
    var multisig_1 = require_multisig();
    exports.protobufPackage = "cosmos.tx.signing.v1beta1";
    var SignMode;
    (function(SignMode2) {
      SignMode2[SignMode2["SIGN_MODE_UNSPECIFIED"] = 0] = "SIGN_MODE_UNSPECIFIED";
      SignMode2[SignMode2["SIGN_MODE_DIRECT"] = 1] = "SIGN_MODE_DIRECT";
      SignMode2[SignMode2["SIGN_MODE_TEXTUAL"] = 2] = "SIGN_MODE_TEXTUAL";
      SignMode2[SignMode2["SIGN_MODE_LEGACY_AMINO_JSON"] = 127] = "SIGN_MODE_LEGACY_AMINO_JSON";
      SignMode2[SignMode2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(SignMode = exports.SignMode || (exports.SignMode = {}));
    function signModeFromJSON(object2) {
      switch (object2) {
        case 0:
        case "SIGN_MODE_UNSPECIFIED":
          return SignMode.SIGN_MODE_UNSPECIFIED;
        case 1:
        case "SIGN_MODE_DIRECT":
          return SignMode.SIGN_MODE_DIRECT;
        case 2:
        case "SIGN_MODE_TEXTUAL":
          return SignMode.SIGN_MODE_TEXTUAL;
        case 127:
        case "SIGN_MODE_LEGACY_AMINO_JSON":
          return SignMode.SIGN_MODE_LEGACY_AMINO_JSON;
        case -1:
        case "UNRECOGNIZED":
        default:
          return SignMode.UNRECOGNIZED;
      }
    }
    exports.signModeFromJSON = signModeFromJSON;
    function signModeToJSON(object2) {
      switch (object2) {
        case SignMode.SIGN_MODE_UNSPECIFIED:
          return "SIGN_MODE_UNSPECIFIED";
        case SignMode.SIGN_MODE_DIRECT:
          return "SIGN_MODE_DIRECT";
        case SignMode.SIGN_MODE_TEXTUAL:
          return "SIGN_MODE_TEXTUAL";
        case SignMode.SIGN_MODE_LEGACY_AMINO_JSON:
          return "SIGN_MODE_LEGACY_AMINO_JSON";
        default:
          return "UNKNOWN";
      }
    }
    exports.signModeToJSON = signModeToJSON;
    function createBaseSignatureDescriptors() {
      return { signatures: [] };
    }
    exports.SignatureDescriptors = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v5 of message.signatures) {
          exports.SignatureDescriptor.encode(v5, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseSignatureDescriptors();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.signatures.push(exports.SignatureDescriptor.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object2) {
        return {
          signatures: Array.isArray(object2 === null || object2 === void 0 ? void 0 : object2.signatures) ? object2.signatures.map((e2) => exports.SignatureDescriptor.fromJSON(e2)) : []
        };
      },
      toJSON(message) {
        const obj = {};
        if (message.signatures) {
          obj.signatures = message.signatures.map((e2) => e2 ? exports.SignatureDescriptor.toJSON(e2) : void 0);
        } else {
          obj.signatures = [];
        }
        return obj;
      },
      fromPartial(object2) {
        var _a2;
        const message = createBaseSignatureDescriptors();
        message.signatures = ((_a2 = object2.signatures) === null || _a2 === void 0 ? void 0 : _a2.map((e2) => exports.SignatureDescriptor.fromPartial(e2))) || [];
        return message;
      }
    };
    function createBaseSignatureDescriptor() {
      return { publicKey: void 0, data: void 0, sequence: "0" };
    }
    exports.SignatureDescriptor = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.publicKey !== void 0) {
          any_1.Any.encode(message.publicKey, writer.uint32(10).fork()).ldelim();
        }
        if (message.data !== void 0) {
          exports.SignatureDescriptor_Data.encode(message.data, writer.uint32(18).fork()).ldelim();
        }
        if (message.sequence !== "0") {
          writer.uint32(24).uint64(message.sequence);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseSignatureDescriptor();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.publicKey = any_1.Any.decode(reader, reader.uint32());
              break;
            case 2:
              message.data = exports.SignatureDescriptor_Data.decode(reader, reader.uint32());
              break;
            case 3:
              message.sequence = longToString(reader.uint64());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object2) {
        return {
          publicKey: isSet(object2.publicKey) ? any_1.Any.fromJSON(object2.publicKey) : void 0,
          data: isSet(object2.data) ? exports.SignatureDescriptor_Data.fromJSON(object2.data) : void 0,
          sequence: isSet(object2.sequence) ? String(object2.sequence) : "0"
        };
      },
      toJSON(message) {
        const obj = {};
        message.publicKey !== void 0 && (obj.publicKey = message.publicKey ? any_1.Any.toJSON(message.publicKey) : void 0);
        message.data !== void 0 && (obj.data = message.data ? exports.SignatureDescriptor_Data.toJSON(message.data) : void 0);
        message.sequence !== void 0 && (obj.sequence = message.sequence);
        return obj;
      },
      fromPartial(object2) {
        var _a2;
        const message = createBaseSignatureDescriptor();
        message.publicKey = object2.publicKey !== void 0 && object2.publicKey !== null ? any_1.Any.fromPartial(object2.publicKey) : void 0;
        message.data = object2.data !== void 0 && object2.data !== null ? exports.SignatureDescriptor_Data.fromPartial(object2.data) : void 0;
        message.sequence = (_a2 = object2.sequence) !== null && _a2 !== void 0 ? _a2 : "0";
        return message;
      }
    };
    function createBaseSignatureDescriptor_Data() {
      return { single: void 0, multi: void 0 };
    }
    exports.SignatureDescriptor_Data = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.single !== void 0) {
          exports.SignatureDescriptor_Data_Single.encode(message.single, writer.uint32(10).fork()).ldelim();
        }
        if (message.multi !== void 0) {
          exports.SignatureDescriptor_Data_Multi.encode(message.multi, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseSignatureDescriptor_Data();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.single = exports.SignatureDescriptor_Data_Single.decode(reader, reader.uint32());
              break;
            case 2:
              message.multi = exports.SignatureDescriptor_Data_Multi.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object2) {
        return {
          single: isSet(object2.single) ? exports.SignatureDescriptor_Data_Single.fromJSON(object2.single) : void 0,
          multi: isSet(object2.multi) ? exports.SignatureDescriptor_Data_Multi.fromJSON(object2.multi) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.single !== void 0 && (obj.single = message.single ? exports.SignatureDescriptor_Data_Single.toJSON(message.single) : void 0);
        message.multi !== void 0 && (obj.multi = message.multi ? exports.SignatureDescriptor_Data_Multi.toJSON(message.multi) : void 0);
        return obj;
      },
      fromPartial(object2) {
        const message = createBaseSignatureDescriptor_Data();
        message.single = object2.single !== void 0 && object2.single !== null ? exports.SignatureDescriptor_Data_Single.fromPartial(object2.single) : void 0;
        message.multi = object2.multi !== void 0 && object2.multi !== null ? exports.SignatureDescriptor_Data_Multi.fromPartial(object2.multi) : void 0;
        return message;
      }
    };
    function createBaseSignatureDescriptor_Data_Single() {
      return { mode: 0, signature: new Uint8Array() };
    }
    exports.SignatureDescriptor_Data_Single = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.mode !== 0) {
          writer.uint32(8).int32(message.mode);
        }
        if (message.signature.length !== 0) {
          writer.uint32(18).bytes(message.signature);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseSignatureDescriptor_Data_Single();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.mode = reader.int32();
              break;
            case 2:
              message.signature = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object2) {
        return {
          mode: isSet(object2.mode) ? signModeFromJSON(object2.mode) : 0,
          signature: isSet(object2.signature) ? bytesFromBase64(object2.signature) : new Uint8Array()
        };
      },
      toJSON(message) {
        const obj = {};
        message.mode !== void 0 && (obj.mode = signModeToJSON(message.mode));
        message.signature !== void 0 && (obj.signature = base64FromBytes(message.signature !== void 0 ? message.signature : new Uint8Array()));
        return obj;
      },
      fromPartial(object2) {
        var _a2, _b;
        const message = createBaseSignatureDescriptor_Data_Single();
        message.mode = (_a2 = object2.mode) !== null && _a2 !== void 0 ? _a2 : 0;
        message.signature = (_b = object2.signature) !== null && _b !== void 0 ? _b : new Uint8Array();
        return message;
      }
    };
    function createBaseSignatureDescriptor_Data_Multi() {
      return { bitarray: void 0, signatures: [] };
    }
    exports.SignatureDescriptor_Data_Multi = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.bitarray !== void 0) {
          multisig_1.CompactBitArray.encode(message.bitarray, writer.uint32(10).fork()).ldelim();
        }
        for (const v5 of message.signatures) {
          exports.SignatureDescriptor_Data.encode(v5, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseSignatureDescriptor_Data_Multi();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.bitarray = multisig_1.CompactBitArray.decode(reader, reader.uint32());
              break;
            case 2:
              message.signatures.push(exports.SignatureDescriptor_Data.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object2) {
        return {
          bitarray: isSet(object2.bitarray) ? multisig_1.CompactBitArray.fromJSON(object2.bitarray) : void 0,
          signatures: Array.isArray(object2 === null || object2 === void 0 ? void 0 : object2.signatures) ? object2.signatures.map((e2) => exports.SignatureDescriptor_Data.fromJSON(e2)) : []
        };
      },
      toJSON(message) {
        const obj = {};
        message.bitarray !== void 0 && (obj.bitarray = message.bitarray ? multisig_1.CompactBitArray.toJSON(message.bitarray) : void 0);
        if (message.signatures) {
          obj.signatures = message.signatures.map((e2) => e2 ? exports.SignatureDescriptor_Data.toJSON(e2) : void 0);
        } else {
          obj.signatures = [];
        }
        return obj;
      },
      fromPartial(object2) {
        var _a2;
        const message = createBaseSignatureDescriptor_Data_Multi();
        message.bitarray = object2.bitarray !== void 0 && object2.bitarray !== null ? multisig_1.CompactBitArray.fromPartial(object2.bitarray) : void 0;
        message.signatures = ((_a2 = object2.signatures) === null || _a2 === void 0 ? void 0 : _a2.map((e2) => exports.SignatureDescriptor_Data.fromPartial(e2))) || [];
        return message;
      }
    };
    var globalThis2 = (() => {
      if (typeof globalThis2 !== "undefined")
        return globalThis2;
      if (typeof self !== "undefined")
        return self;
      if (typeof window !== "undefined")
        return window;
      if (typeof global !== "undefined")
        return global;
      throw "Unable to locate global object";
    })();
    var atob = globalThis2.atob || ((b64) => globalThis2.Buffer.from(b64, "base64").toString("binary"));
    function bytesFromBase64(b64) {
      const bin = atob(b64);
      const arr = new Uint8Array(bin.length);
      for (let i4 = 0; i4 < bin.length; ++i4) {
        arr[i4] = bin.charCodeAt(i4);
      }
      return arr;
    }
    var btoa = globalThis2.btoa || ((bin) => globalThis2.Buffer.from(bin, "binary").toString("base64"));
    function base64FromBytes(arr) {
      const bin = [];
      for (const byte of arr) {
        bin.push(String.fromCharCode(byte));
      }
      return btoa(bin.join(""));
    }
    function longToString(long) {
      return long.toString();
    }
    if (minimal_1.default.util.Long !== long_1.default) {
      minimal_1.default.util.Long = long_1.default;
      minimal_1.default.configure();
    }
    function isSet(value) {
      return value !== null && value !== void 0;
    }
  }
});

// ../../node_modules/.pnpm/@keplr-wallet+proto-types@0.12.28/node_modules/@keplr-wallet/proto-types/cosmos/tx/v1beta1/tx.js
var require_tx8 = __commonJS({
  "../../node_modules/.pnpm/@keplr-wallet+proto-types@0.12.28/node_modules/@keplr-wallet/proto-types/cosmos/tx/v1beta1/tx.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Fee = exports.ModeInfo_Multi = exports.ModeInfo_Single = exports.ModeInfo = exports.SignerInfo = exports.AuthInfo = exports.TxBody = exports.SignDoc = exports.TxRaw = exports.Tx = exports.protobufPackage = void 0;
    var long_1 = __importDefault(require_long());
    var minimal_1 = __importDefault(require_minimal());
    var signing_1 = require_signing();
    var any_1 = require_any();
    var multisig_1 = require_multisig();
    var coin_1 = require_coin2();
    exports.protobufPackage = "cosmos.tx.v1beta1";
    function createBaseTx() {
      return { body: void 0, authInfo: void 0, signatures: [] };
    }
    exports.Tx = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.body !== void 0) {
          exports.TxBody.encode(message.body, writer.uint32(10).fork()).ldelim();
        }
        if (message.authInfo !== void 0) {
          exports.AuthInfo.encode(message.authInfo, writer.uint32(18).fork()).ldelim();
        }
        for (const v5 of message.signatures) {
          writer.uint32(26).bytes(v5);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseTx();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.body = exports.TxBody.decode(reader, reader.uint32());
              break;
            case 2:
              message.authInfo = exports.AuthInfo.decode(reader, reader.uint32());
              break;
            case 3:
              message.signatures.push(reader.bytes());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object2) {
        return {
          body: isSet(object2.body) ? exports.TxBody.fromJSON(object2.body) : void 0,
          authInfo: isSet(object2.authInfo) ? exports.AuthInfo.fromJSON(object2.authInfo) : void 0,
          signatures: Array.isArray(object2 === null || object2 === void 0 ? void 0 : object2.signatures) ? object2.signatures.map((e2) => bytesFromBase64(e2)) : []
        };
      },
      toJSON(message) {
        const obj = {};
        message.body !== void 0 && (obj.body = message.body ? exports.TxBody.toJSON(message.body) : void 0);
        message.authInfo !== void 0 && (obj.authInfo = message.authInfo ? exports.AuthInfo.toJSON(message.authInfo) : void 0);
        if (message.signatures) {
          obj.signatures = message.signatures.map((e2) => base64FromBytes(e2 !== void 0 ? e2 : new Uint8Array()));
        } else {
          obj.signatures = [];
        }
        return obj;
      },
      fromPartial(object2) {
        var _a2;
        const message = createBaseTx();
        message.body = object2.body !== void 0 && object2.body !== null ? exports.TxBody.fromPartial(object2.body) : void 0;
        message.authInfo = object2.authInfo !== void 0 && object2.authInfo !== null ? exports.AuthInfo.fromPartial(object2.authInfo) : void 0;
        message.signatures = ((_a2 = object2.signatures) === null || _a2 === void 0 ? void 0 : _a2.map((e2) => e2)) || [];
        return message;
      }
    };
    function createBaseTxRaw() {
      return {
        bodyBytes: new Uint8Array(),
        authInfoBytes: new Uint8Array(),
        signatures: []
      };
    }
    exports.TxRaw = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.bodyBytes.length !== 0) {
          writer.uint32(10).bytes(message.bodyBytes);
        }
        if (message.authInfoBytes.length !== 0) {
          writer.uint32(18).bytes(message.authInfoBytes);
        }
        for (const v5 of message.signatures) {
          writer.uint32(26).bytes(v5);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseTxRaw();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.bodyBytes = reader.bytes();
              break;
            case 2:
              message.authInfoBytes = reader.bytes();
              break;
            case 3:
              message.signatures.push(reader.bytes());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object2) {
        return {
          bodyBytes: isSet(object2.bodyBytes) ? bytesFromBase64(object2.bodyBytes) : new Uint8Array(),
          authInfoBytes: isSet(object2.authInfoBytes) ? bytesFromBase64(object2.authInfoBytes) : new Uint8Array(),
          signatures: Array.isArray(object2 === null || object2 === void 0 ? void 0 : object2.signatures) ? object2.signatures.map((e2) => bytesFromBase64(e2)) : []
        };
      },
      toJSON(message) {
        const obj = {};
        message.bodyBytes !== void 0 && (obj.bodyBytes = base64FromBytes(message.bodyBytes !== void 0 ? message.bodyBytes : new Uint8Array()));
        message.authInfoBytes !== void 0 && (obj.authInfoBytes = base64FromBytes(message.authInfoBytes !== void 0 ? message.authInfoBytes : new Uint8Array()));
        if (message.signatures) {
          obj.signatures = message.signatures.map((e2) => base64FromBytes(e2 !== void 0 ? e2 : new Uint8Array()));
        } else {
          obj.signatures = [];
        }
        return obj;
      },
      fromPartial(object2) {
        var _a2, _b, _c;
        const message = createBaseTxRaw();
        message.bodyBytes = (_a2 = object2.bodyBytes) !== null && _a2 !== void 0 ? _a2 : new Uint8Array();
        message.authInfoBytes = (_b = object2.authInfoBytes) !== null && _b !== void 0 ? _b : new Uint8Array();
        message.signatures = ((_c = object2.signatures) === null || _c === void 0 ? void 0 : _c.map((e2) => e2)) || [];
        return message;
      }
    };
    function createBaseSignDoc() {
      return {
        bodyBytes: new Uint8Array(),
        authInfoBytes: new Uint8Array(),
        chainId: "",
        accountNumber: "0"
      };
    }
    exports.SignDoc = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.bodyBytes.length !== 0) {
          writer.uint32(10).bytes(message.bodyBytes);
        }
        if (message.authInfoBytes.length !== 0) {
          writer.uint32(18).bytes(message.authInfoBytes);
        }
        if (message.chainId !== "") {
          writer.uint32(26).string(message.chainId);
        }
        if (message.accountNumber !== "0") {
          writer.uint32(32).uint64(message.accountNumber);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseSignDoc();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.bodyBytes = reader.bytes();
              break;
            case 2:
              message.authInfoBytes = reader.bytes();
              break;
            case 3:
              message.chainId = reader.string();
              break;
            case 4:
              message.accountNumber = longToString(reader.uint64());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object2) {
        return {
          bodyBytes: isSet(object2.bodyBytes) ? bytesFromBase64(object2.bodyBytes) : new Uint8Array(),
          authInfoBytes: isSet(object2.authInfoBytes) ? bytesFromBase64(object2.authInfoBytes) : new Uint8Array(),
          chainId: isSet(object2.chainId) ? String(object2.chainId) : "",
          accountNumber: isSet(object2.accountNumber) ? String(object2.accountNumber) : "0"
        };
      },
      toJSON(message) {
        const obj = {};
        message.bodyBytes !== void 0 && (obj.bodyBytes = base64FromBytes(message.bodyBytes !== void 0 ? message.bodyBytes : new Uint8Array()));
        message.authInfoBytes !== void 0 && (obj.authInfoBytes = base64FromBytes(message.authInfoBytes !== void 0 ? message.authInfoBytes : new Uint8Array()));
        message.chainId !== void 0 && (obj.chainId = message.chainId);
        message.accountNumber !== void 0 && (obj.accountNumber = message.accountNumber);
        return obj;
      },
      fromPartial(object2) {
        var _a2, _b, _c, _d;
        const message = createBaseSignDoc();
        message.bodyBytes = (_a2 = object2.bodyBytes) !== null && _a2 !== void 0 ? _a2 : new Uint8Array();
        message.authInfoBytes = (_b = object2.authInfoBytes) !== null && _b !== void 0 ? _b : new Uint8Array();
        message.chainId = (_c = object2.chainId) !== null && _c !== void 0 ? _c : "";
        message.accountNumber = (_d = object2.accountNumber) !== null && _d !== void 0 ? _d : "0";
        return message;
      }
    };
    function createBaseTxBody() {
      return {
        messages: [],
        memo: "",
        timeoutHeight: "0",
        extensionOptions: [],
        nonCriticalExtensionOptions: []
      };
    }
    exports.TxBody = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v5 of message.messages) {
          any_1.Any.encode(v5, writer.uint32(10).fork()).ldelim();
        }
        if (message.memo !== "") {
          writer.uint32(18).string(message.memo);
        }
        if (message.timeoutHeight !== "0") {
          writer.uint32(24).uint64(message.timeoutHeight);
        }
        for (const v5 of message.extensionOptions) {
          any_1.Any.encode(v5, writer.uint32(8186).fork()).ldelim();
        }
        for (const v5 of message.nonCriticalExtensionOptions) {
          any_1.Any.encode(v5, writer.uint32(16378).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseTxBody();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.messages.push(any_1.Any.decode(reader, reader.uint32()));
              break;
            case 2:
              message.memo = reader.string();
              break;
            case 3:
              message.timeoutHeight = longToString(reader.uint64());
              break;
            case 1023:
              message.extensionOptions.push(any_1.Any.decode(reader, reader.uint32()));
              break;
            case 2047:
              message.nonCriticalExtensionOptions.push(any_1.Any.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object2) {
        return {
          messages: Array.isArray(object2 === null || object2 === void 0 ? void 0 : object2.messages) ? object2.messages.map((e2) => any_1.Any.fromJSON(e2)) : [],
          memo: isSet(object2.memo) ? String(object2.memo) : "",
          timeoutHeight: isSet(object2.timeoutHeight) ? String(object2.timeoutHeight) : "0",
          extensionOptions: Array.isArray(object2 === null || object2 === void 0 ? void 0 : object2.extensionOptions) ? object2.extensionOptions.map((e2) => any_1.Any.fromJSON(e2)) : [],
          nonCriticalExtensionOptions: Array.isArray(object2 === null || object2 === void 0 ? void 0 : object2.nonCriticalExtensionOptions) ? object2.nonCriticalExtensionOptions.map((e2) => any_1.Any.fromJSON(e2)) : []
        };
      },
      toJSON(message) {
        const obj = {};
        if (message.messages) {
          obj.messages = message.messages.map((e2) => e2 ? any_1.Any.toJSON(e2) : void 0);
        } else {
          obj.messages = [];
        }
        message.memo !== void 0 && (obj.memo = message.memo);
        message.timeoutHeight !== void 0 && (obj.timeoutHeight = message.timeoutHeight);
        if (message.extensionOptions) {
          obj.extensionOptions = message.extensionOptions.map((e2) => e2 ? any_1.Any.toJSON(e2) : void 0);
        } else {
          obj.extensionOptions = [];
        }
        if (message.nonCriticalExtensionOptions) {
          obj.nonCriticalExtensionOptions = message.nonCriticalExtensionOptions.map((e2) => e2 ? any_1.Any.toJSON(e2) : void 0);
        } else {
          obj.nonCriticalExtensionOptions = [];
        }
        return obj;
      },
      fromPartial(object2) {
        var _a2, _b, _c, _d, _e3;
        const message = createBaseTxBody();
        message.messages = ((_a2 = object2.messages) === null || _a2 === void 0 ? void 0 : _a2.map((e2) => any_1.Any.fromPartial(e2))) || [];
        message.memo = (_b = object2.memo) !== null && _b !== void 0 ? _b : "";
        message.timeoutHeight = (_c = object2.timeoutHeight) !== null && _c !== void 0 ? _c : "0";
        message.extensionOptions = ((_d = object2.extensionOptions) === null || _d === void 0 ? void 0 : _d.map((e2) => any_1.Any.fromPartial(e2))) || [];
        message.nonCriticalExtensionOptions = ((_e3 = object2.nonCriticalExtensionOptions) === null || _e3 === void 0 ? void 0 : _e3.map((e2) => any_1.Any.fromPartial(e2))) || [];
        return message;
      }
    };
    function createBaseAuthInfo() {
      return { signerInfos: [], fee: void 0 };
    }
    exports.AuthInfo = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v5 of message.signerInfos) {
          exports.SignerInfo.encode(v5, writer.uint32(10).fork()).ldelim();
        }
        if (message.fee !== void 0) {
          exports.Fee.encode(message.fee, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseAuthInfo();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.signerInfos.push(exports.SignerInfo.decode(reader, reader.uint32()));
              break;
            case 2:
              message.fee = exports.Fee.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object2) {
        return {
          signerInfos: Array.isArray(object2 === null || object2 === void 0 ? void 0 : object2.signerInfos) ? object2.signerInfos.map((e2) => exports.SignerInfo.fromJSON(e2)) : [],
          fee: isSet(object2.fee) ? exports.Fee.fromJSON(object2.fee) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        if (message.signerInfos) {
          obj.signerInfos = message.signerInfos.map((e2) => e2 ? exports.SignerInfo.toJSON(e2) : void 0);
        } else {
          obj.signerInfos = [];
        }
        message.fee !== void 0 && (obj.fee = message.fee ? exports.Fee.toJSON(message.fee) : void 0);
        return obj;
      },
      fromPartial(object2) {
        var _a2;
        const message = createBaseAuthInfo();
        message.signerInfos = ((_a2 = object2.signerInfos) === null || _a2 === void 0 ? void 0 : _a2.map((e2) => exports.SignerInfo.fromPartial(e2))) || [];
        message.fee = object2.fee !== void 0 && object2.fee !== null ? exports.Fee.fromPartial(object2.fee) : void 0;
        return message;
      }
    };
    function createBaseSignerInfo() {
      return { publicKey: void 0, modeInfo: void 0, sequence: "0" };
    }
    exports.SignerInfo = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.publicKey !== void 0) {
          any_1.Any.encode(message.publicKey, writer.uint32(10).fork()).ldelim();
        }
        if (message.modeInfo !== void 0) {
          exports.ModeInfo.encode(message.modeInfo, writer.uint32(18).fork()).ldelim();
        }
        if (message.sequence !== "0") {
          writer.uint32(24).uint64(message.sequence);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseSignerInfo();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.publicKey = any_1.Any.decode(reader, reader.uint32());
              break;
            case 2:
              message.modeInfo = exports.ModeInfo.decode(reader, reader.uint32());
              break;
            case 3:
              message.sequence = longToString(reader.uint64());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object2) {
        return {
          publicKey: isSet(object2.publicKey) ? any_1.Any.fromJSON(object2.publicKey) : void 0,
          modeInfo: isSet(object2.modeInfo) ? exports.ModeInfo.fromJSON(object2.modeInfo) : void 0,
          sequence: isSet(object2.sequence) ? String(object2.sequence) : "0"
        };
      },
      toJSON(message) {
        const obj = {};
        message.publicKey !== void 0 && (obj.publicKey = message.publicKey ? any_1.Any.toJSON(message.publicKey) : void 0);
        message.modeInfo !== void 0 && (obj.modeInfo = message.modeInfo ? exports.ModeInfo.toJSON(message.modeInfo) : void 0);
        message.sequence !== void 0 && (obj.sequence = message.sequence);
        return obj;
      },
      fromPartial(object2) {
        var _a2;
        const message = createBaseSignerInfo();
        message.publicKey = object2.publicKey !== void 0 && object2.publicKey !== null ? any_1.Any.fromPartial(object2.publicKey) : void 0;
        message.modeInfo = object2.modeInfo !== void 0 && object2.modeInfo !== null ? exports.ModeInfo.fromPartial(object2.modeInfo) : void 0;
        message.sequence = (_a2 = object2.sequence) !== null && _a2 !== void 0 ? _a2 : "0";
        return message;
      }
    };
    function createBaseModeInfo() {
      return { single: void 0, multi: void 0 };
    }
    exports.ModeInfo = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.single !== void 0) {
          exports.ModeInfo_Single.encode(message.single, writer.uint32(10).fork()).ldelim();
        }
        if (message.multi !== void 0) {
          exports.ModeInfo_Multi.encode(message.multi, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseModeInfo();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.single = exports.ModeInfo_Single.decode(reader, reader.uint32());
              break;
            case 2:
              message.multi = exports.ModeInfo_Multi.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object2) {
        return {
          single: isSet(object2.single) ? exports.ModeInfo_Single.fromJSON(object2.single) : void 0,
          multi: isSet(object2.multi) ? exports.ModeInfo_Multi.fromJSON(object2.multi) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.single !== void 0 && (obj.single = message.single ? exports.ModeInfo_Single.toJSON(message.single) : void 0);
        message.multi !== void 0 && (obj.multi = message.multi ? exports.ModeInfo_Multi.toJSON(message.multi) : void 0);
        return obj;
      },
      fromPartial(object2) {
        const message = createBaseModeInfo();
        message.single = object2.single !== void 0 && object2.single !== null ? exports.ModeInfo_Single.fromPartial(object2.single) : void 0;
        message.multi = object2.multi !== void 0 && object2.multi !== null ? exports.ModeInfo_Multi.fromPartial(object2.multi) : void 0;
        return message;
      }
    };
    function createBaseModeInfo_Single() {
      return { mode: 0 };
    }
    exports.ModeInfo_Single = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.mode !== 0) {
          writer.uint32(8).int32(message.mode);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseModeInfo_Single();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.mode = reader.int32();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object2) {
        return {
          mode: isSet(object2.mode) ? (0, signing_1.signModeFromJSON)(object2.mode) : 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.mode !== void 0 && (obj.mode = (0, signing_1.signModeToJSON)(message.mode));
        return obj;
      },
      fromPartial(object2) {
        var _a2;
        const message = createBaseModeInfo_Single();
        message.mode = (_a2 = object2.mode) !== null && _a2 !== void 0 ? _a2 : 0;
        return message;
      }
    };
    function createBaseModeInfo_Multi() {
      return { bitarray: void 0, modeInfos: [] };
    }
    exports.ModeInfo_Multi = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.bitarray !== void 0) {
          multisig_1.CompactBitArray.encode(message.bitarray, writer.uint32(10).fork()).ldelim();
        }
        for (const v5 of message.modeInfos) {
          exports.ModeInfo.encode(v5, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseModeInfo_Multi();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.bitarray = multisig_1.CompactBitArray.decode(reader, reader.uint32());
              break;
            case 2:
              message.modeInfos.push(exports.ModeInfo.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object2) {
        return {
          bitarray: isSet(object2.bitarray) ? multisig_1.CompactBitArray.fromJSON(object2.bitarray) : void 0,
          modeInfos: Array.isArray(object2 === null || object2 === void 0 ? void 0 : object2.modeInfos) ? object2.modeInfos.map((e2) => exports.ModeInfo.fromJSON(e2)) : []
        };
      },
      toJSON(message) {
        const obj = {};
        message.bitarray !== void 0 && (obj.bitarray = message.bitarray ? multisig_1.CompactBitArray.toJSON(message.bitarray) : void 0);
        if (message.modeInfos) {
          obj.modeInfos = message.modeInfos.map((e2) => e2 ? exports.ModeInfo.toJSON(e2) : void 0);
        } else {
          obj.modeInfos = [];
        }
        return obj;
      },
      fromPartial(object2) {
        var _a2;
        const message = createBaseModeInfo_Multi();
        message.bitarray = object2.bitarray !== void 0 && object2.bitarray !== null ? multisig_1.CompactBitArray.fromPartial(object2.bitarray) : void 0;
        message.modeInfos = ((_a2 = object2.modeInfos) === null || _a2 === void 0 ? void 0 : _a2.map((e2) => exports.ModeInfo.fromPartial(e2))) || [];
        return message;
      }
    };
    function createBaseFee() {
      return { amount: [], gasLimit: "0", payer: "", granter: "" };
    }
    exports.Fee = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v5 of message.amount) {
          coin_1.Coin.encode(v5, writer.uint32(10).fork()).ldelim();
        }
        if (message.gasLimit !== "0") {
          writer.uint32(16).uint64(message.gasLimit);
        }
        if (message.payer !== "") {
          writer.uint32(26).string(message.payer);
        }
        if (message.granter !== "") {
          writer.uint32(34).string(message.granter);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseFee();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.amount.push(coin_1.Coin.decode(reader, reader.uint32()));
              break;
            case 2:
              message.gasLimit = longToString(reader.uint64());
              break;
            case 3:
              message.payer = reader.string();
              break;
            case 4:
              message.granter = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object2) {
        return {
          amount: Array.isArray(object2 === null || object2 === void 0 ? void 0 : object2.amount) ? object2.amount.map((e2) => coin_1.Coin.fromJSON(e2)) : [],
          gasLimit: isSet(object2.gasLimit) ? String(object2.gasLimit) : "0",
          payer: isSet(object2.payer) ? String(object2.payer) : "",
          granter: isSet(object2.granter) ? String(object2.granter) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        if (message.amount) {
          obj.amount = message.amount.map((e2) => e2 ? coin_1.Coin.toJSON(e2) : void 0);
        } else {
          obj.amount = [];
        }
        message.gasLimit !== void 0 && (obj.gasLimit = message.gasLimit);
        message.payer !== void 0 && (obj.payer = message.payer);
        message.granter !== void 0 && (obj.granter = message.granter);
        return obj;
      },
      fromPartial(object2) {
        var _a2, _b, _c, _d;
        const message = createBaseFee();
        message.amount = ((_a2 = object2.amount) === null || _a2 === void 0 ? void 0 : _a2.map((e2) => coin_1.Coin.fromPartial(e2))) || [];
        message.gasLimit = (_b = object2.gasLimit) !== null && _b !== void 0 ? _b : "0";
        message.payer = (_c = object2.payer) !== null && _c !== void 0 ? _c : "";
        message.granter = (_d = object2.granter) !== null && _d !== void 0 ? _d : "";
        return message;
      }
    };
    var globalThis2 = (() => {
      if (typeof globalThis2 !== "undefined")
        return globalThis2;
      if (typeof self !== "undefined")
        return self;
      if (typeof window !== "undefined")
        return window;
      if (typeof global !== "undefined")
        return global;
      throw "Unable to locate global object";
    })();
    var atob = globalThis2.atob || ((b64) => globalThis2.Buffer.from(b64, "base64").toString("binary"));
    function bytesFromBase64(b64) {
      const bin = atob(b64);
      const arr = new Uint8Array(bin.length);
      for (let i4 = 0; i4 < bin.length; ++i4) {
        arr[i4] = bin.charCodeAt(i4);
      }
      return arr;
    }
    var btoa = globalThis2.btoa || ((bin) => globalThis2.Buffer.from(bin, "binary").toString("base64"));
    function base64FromBytes(arr) {
      const bin = [];
      for (const byte of arr) {
        bin.push(String.fromCharCode(byte));
      }
      return btoa(bin.join(""));
    }
    function longToString(long) {
      return long.toString();
    }
    if (minimal_1.default.util.Long !== long_1.default) {
      minimal_1.default.util.Long = long_1.default;
      minimal_1.default.configure();
    }
    function isSet(value) {
      return value !== null && value !== void 0;
    }
  }
});

// ../../node_modules/.pnpm/@keplr-wallet+cosmos@0.12.28/node_modules/@keplr-wallet/cosmos/build/stargate/decoder/index.js
var require_decoder = __commonJS({
  "../../node_modules/.pnpm/@keplr-wallet+cosmos@0.12.28/node_modules/@keplr-wallet/cosmos/build/stargate/decoder/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ProtoSignDocDecoder = void 0;
    var tx_1 = require_tx8();
    var codec_1 = require_codec();
    var ProtoSignDocDecoder = class _ProtoSignDocDecoder {
      static decode(bytes) {
        return new _ProtoSignDocDecoder(tx_1.SignDoc.decode(bytes));
      }
      constructor(signDoc, protoCodec = codec_1.defaultProtoCodec) {
        this.signDoc = signDoc;
        this.protoCodec = protoCodec;
      }
      get txBody() {
        if (!this._txBody) {
          this._txBody = tx_1.TxBody.decode(this.signDoc.bodyBytes);
        }
        return this._txBody;
      }
      get txMsgs() {
        const msgs = [];
        for (const msg of this.txBody.messages) {
          msgs.push(this.protoCodec.unpackAny(msg));
        }
        return msgs;
      }
      get authInfo() {
        if (!this._authInfo) {
          this._authInfo = tx_1.AuthInfo.decode(this.signDoc.authInfoBytes);
        }
        return this._authInfo;
      }
      get chainId() {
        return this.signDoc.chainId;
      }
      get accountNumber() {
        return this.signDoc.accountNumber.toString();
      }
      toBytes() {
        return tx_1.SignDoc.encode(this.signDoc).finish();
      }
      toJSON() {
        return {
          txBody: Object.assign(Object.assign({}, tx_1.TxBody.toJSON(this.txBody)), {
            messages: this.txMsgs.map((msg) => {
              return this.protoCodec.unpackedAnyToJSONRecursive(msg);
            })
          }),
          authInfo: tx_1.AuthInfo.toJSON(this.authInfo),
          chainId: this.chainId,
          accountNumber: this.accountNumber
        };
      }
    };
    exports.ProtoSignDocDecoder = ProtoSignDocDecoder;
  }
});

// ../../node_modules/.pnpm/@keplr-wallet+common@0.12.28/node_modules/@keplr-wallet/common/build/kv-store/interface.js
var require_interface = __commonJS({
  "../../node_modules/.pnpm/@keplr-wallet+common@0.12.28/node_modules/@keplr-wallet/common/build/kv-store/interface.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// ../../node_modules/.pnpm/@keplr-wallet+common@0.12.28/node_modules/@keplr-wallet/common/build/kv-store/base.js
var require_base = __commonJS({
  "../../node_modules/.pnpm/@keplr-wallet+common@0.12.28/node_modules/@keplr-wallet/common/build/kv-store/base.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P3, generator) {
      function adopt(value) {
        return value instanceof P3 ? value : new P3(function(resolve) {
          resolve(value);
        });
      }
      return new (P3 || (P3 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e2) {
            reject(e2);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e2) {
            reject(e2);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BaseKVStore = void 0;
    var BaseKVStore = class {
      constructor(provider, _prefix) {
        this.provider = provider;
        this._prefix = _prefix;
      }
      get(key) {
        return __awaiter(this, void 0, void 0, function* () {
          const k5 = this.prefix() + "/" + key;
          const data = yield this.provider.get();
          return data[k5];
        });
      }
      set(key, data) {
        const k5 = this.prefix() + "/" + key;
        return this.provider.set({ [k5]: data });
      }
      prefix() {
        return this._prefix;
      }
    };
    exports.BaseKVStore = BaseKVStore;
  }
});

// ../../node_modules/.pnpm/@keplr-wallet+common@0.12.28/node_modules/@keplr-wallet/common/build/kv-store/extension.js
var require_extension = __commonJS({
  "../../node_modules/.pnpm/@keplr-wallet+common@0.12.28/node_modules/@keplr-wallet/common/build/kv-store/extension.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P3, generator) {
      function adopt(value) {
        return value instanceof P3 ? value : new P3(function(resolve) {
          resolve(value);
        });
      }
      return new (P3 || (P3 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e2) {
            reject(e2);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e2) {
            reject(e2);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ExtensionKVStore = void 0;
    var base_1 = require_base();
    var ExtensionKVStore = class _ExtensionKVStore extends base_1.BaseKVStore {
      constructor(prefix) {
        if (!_ExtensionKVStore.KVStoreProvider) {
          if (typeof browser === "undefined") {
            console.log("You should use ExtensionKVStore on the extension environment.");
          } else if (!browser.storage || !browser.storage.local) {
            console.log("The 'browser' exists, but it doesn't seem to be an extension environment. This can happen in Safari browser.");
          } else {
            _ExtensionKVStore.KVStoreProvider = {
              get: browser.storage.local.get,
              set: browser.storage.local.set,
              multiGet: browser.storage.local.get
            };
          }
        }
        if (!_ExtensionKVStore.KVStoreProvider) {
          throw new Error("Can't initialize kv store for browser extension");
        }
        super(_ExtensionKVStore.KVStoreProvider, prefix);
      }
      multiGet(keys3) {
        var _a2;
        return __awaiter(this, void 0, void 0, function* () {
          keys3 = Array.from(new Set(keys3));
          const res = (_a2 = yield _ExtensionKVStore.KVStoreProvider.multiGet(keys3.map((k5) => this.prefix() + "/" + k5))) !== null && _a2 !== void 0 ? _a2 : {};
          const prefixedKeys = Object.keys(res);
          for (const prefixedKey of prefixedKeys) {
            const key = prefixedKey.slice(this.prefix().length + 1);
            res[key] = res[prefixedKey];
            delete res[prefixedKey];
          }
          return res;
        });
      }
    };
    exports.ExtensionKVStore = ExtensionKVStore;
  }
});

// ../../node_modules/.pnpm/@keplr-wallet+common@0.12.28/node_modules/@keplr-wallet/common/build/kv-store/memory.js
var require_memory = __commonJS({
  "../../node_modules/.pnpm/@keplr-wallet+common@0.12.28/node_modules/@keplr-wallet/common/build/kv-store/memory.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MemoryKVStore = void 0;
    var base_1 = require_base();
    var MemoryKVStoreProvider = class {
      constructor() {
        this.store = {};
      }
      get() {
        return Promise.resolve(this.store);
      }
      set(items) {
        if (typeof process !== "undefined" && true) {
          this.checkNotPrimitiveField(items);
        }
        this.store = Object.assign(Object.assign({}, this.store), items);
        return Promise.resolve();
      }
      checkNotPrimitiveField(items) {
        Object.keys(items).forEach((key) => {
          const value = items[key];
          if (value != null && typeof value === "object") {
            if (value.constructor !== Object && value.constructor !== Array) {
              throw new Error(`${key} may not be serializable: ${value.constructor.name}`);
            }
            this.checkNotPrimitiveField(value);
          }
        });
      }
    };
    var MemoryKVStore = class extends base_1.BaseKVStore {
      constructor(prefix) {
        super(new MemoryKVStoreProvider(), prefix);
      }
    };
    exports.MemoryKVStore = MemoryKVStore;
  }
});

// ../../node_modules/.pnpm/@keplr-wallet+common@0.12.28/node_modules/@keplr-wallet/common/build/kv-store/local.js
var require_local = __commonJS({
  "../../node_modules/.pnpm/@keplr-wallet+common@0.12.28/node_modules/@keplr-wallet/common/build/kv-store/local.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LocalKVStore = void 0;
    var LocalKVStore = class {
      constructor(_prefix) {
        this._prefix = _prefix;
      }
      get(key) {
        const k5 = this.prefix() + "/" + key;
        const data = localStorage.getItem(k5);
        if (data === null) {
          return Promise.resolve(void 0);
        }
        return Promise.resolve(JSON.parse(data));
      }
      set(key, data) {
        const k5 = this.prefix() + "/" + key;
        if (data === null) {
          return Promise.resolve(localStorage.removeItem(k5));
        }
        return Promise.resolve(localStorage.setItem(k5, JSON.stringify(data)));
      }
      prefix() {
        return this._prefix;
      }
    };
    exports.LocalKVStore = LocalKVStore;
  }
});

// ../../node_modules/.pnpm/@keplr-wallet+common@0.12.28/node_modules/@keplr-wallet/common/build/kv-store/indexed-db.js
var require_indexed_db = __commonJS({
  "../../node_modules/.pnpm/@keplr-wallet+common@0.12.28/node_modules/@keplr-wallet/common/build/kv-store/indexed-db.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P3, generator) {
      function adopt(value) {
        return value instanceof P3 ? value : new P3(function(resolve) {
          resolve(value);
        });
      }
      return new (P3 || (P3 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e2) {
            reject(e2);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e2) {
            reject(e2);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IndexedDBKVStore = void 0;
    var IndexedDBKVStore = class {
      constructor(_prefix) {
        this._prefix = _prefix;
      }
      get(key) {
        return __awaiter(this, void 0, void 0, function* () {
          const tx = (yield this.getDB()).transaction([this.prefix()], "readonly");
          const store = tx.objectStore(this.prefix());
          return new Promise((resolve, reject) => {
            const request = store.get(key);
            request.onerror = (event) => {
              event.stopPropagation();
              reject(event.target);
            };
            request.onsuccess = () => {
              if (!request.result) {
                resolve(void 0);
              } else {
                resolve(request.result.data);
              }
            };
          });
        });
      }
      set(key, data) {
        return __awaiter(this, void 0, void 0, function* () {
          if (data === null) {
            const tx = (yield this.getDB()).transaction([this.prefix()], "readwrite");
            const store = tx.objectStore(this.prefix());
            return new Promise((resolve, reject) => {
              const request = store.delete(key);
              request.onerror = (event) => {
                event.stopPropagation();
                reject(event.target);
              };
              request.onsuccess = () => {
                resolve();
              };
            });
          } else {
            const tx = (yield this.getDB()).transaction([this.prefix()], "readwrite");
            const store = tx.objectStore(this.prefix());
            return new Promise((resolve, reject) => {
              const request = store.put({
                key,
                data
              });
              request.onerror = (event) => {
                event.stopPropagation();
                reject(event.target);
              };
              request.onsuccess = () => {
                resolve();
              };
            });
          }
        });
      }
      prefix() {
        return this._prefix;
      }
      getDB() {
        return __awaiter(this, void 0, void 0, function* () {
          if (this.cachedDB) {
            return this.cachedDB;
          }
          return new Promise((resolve, reject) => {
            const request = window.indexedDB.open(this.prefix());
            request.onerror = (event) => {
              event.stopPropagation();
              reject(event.target);
            };
            request.onupgradeneeded = (event) => {
              const db = event.target.result;
              db.createObjectStore(this.prefix(), { keyPath: "key" });
            };
            request.onsuccess = () => {
              this.cachedDB = request.result;
              resolve(request.result);
            };
          });
        });
      }
    };
    exports.IndexedDBKVStore = IndexedDBKVStore;
  }
});

// ../../node_modules/.pnpm/@keplr-wallet+common@0.12.28/node_modules/@keplr-wallet/common/build/kv-store/prefix.js
var require_prefix = __commonJS({
  "../../node_modules/.pnpm/@keplr-wallet+common@0.12.28/node_modules/@keplr-wallet/common/build/kv-store/prefix.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P3, generator) {
      function adopt(value) {
        return value instanceof P3 ? value : new P3(function(resolve) {
          resolve(value);
        });
      }
      return new (P3 || (P3 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e2) {
            reject(e2);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e2) {
            reject(e2);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PrefixKVStore = void 0;
    var PrefixKVStore = class {
      constructor(kvStore, _prefix) {
        this.kvStore = kvStore;
        this._prefix = _prefix;
      }
      prefix() {
        return this._prefix;
      }
      get(key) {
        return __awaiter(this, void 0, void 0, function* () {
          const k5 = this.prefix() + "/" + key;
          return yield this.kvStore.get(k5);
        });
      }
      set(key, data) {
        return __awaiter(this, void 0, void 0, function* () {
          const k5 = this.prefix() + "/" + key;
          return yield this.kvStore.set(k5, data);
        });
      }
    };
    exports.PrefixKVStore = PrefixKVStore;
  }
});

// ../../node_modules/.pnpm/@keplr-wallet+common@0.12.28/node_modules/@keplr-wallet/common/build/kv-store/multi-get.js
var require_multi_get = __commonJS({
  "../../node_modules/.pnpm/@keplr-wallet+common@0.12.28/node_modules/@keplr-wallet/common/build/kv-store/multi-get.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P3, generator) {
      function adopt(value) {
        return value instanceof P3 ? value : new P3(function(resolve) {
          resolve(value);
        });
      }
      return new (P3 || (P3 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e2) {
            reject(e2);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e2) {
            reject(e2);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WrapMultiGetKVStore = void 0;
    var WrapMultiGetKVStore = class {
      constructor(kvStore) {
        this.kvStore = kvStore;
      }
      multiGet(keys3) {
        return __awaiter(this, void 0, void 0, function* () {
          keys3 = Array.from(new Set(keys3));
          const res = {};
          const promises = [];
          for (const key of keys3) {
            promises.push((() => __awaiter(this, void 0, void 0, function* () {
              res[key] = yield this.kvStore.get(key);
            }))());
          }
          yield Promise.all(promises);
          return res;
        });
      }
    };
    exports.WrapMultiGetKVStore = WrapMultiGetKVStore;
  }
});

// ../../node_modules/.pnpm/@keplr-wallet+common@0.12.28/node_modules/@keplr-wallet/common/build/kv-store/index.js
var require_kv_store = __commonJS({
  "../../node_modules/.pnpm/@keplr-wallet+common@0.12.28/node_modules/@keplr-wallet/common/build/kv-store/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o4, m3, k5, k22) {
      if (k22 === void 0)
        k22 = k5;
      var desc = Object.getOwnPropertyDescriptor(m3, k5);
      if (!desc || ("get" in desc ? !m3.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m3[k5];
        } };
      }
      Object.defineProperty(o4, k22, desc);
    } : function(o4, m3, k5, k22) {
      if (k22 === void 0)
        k22 = k5;
      o4[k22] = m3[k5];
    });
    var __exportStar = exports && exports.__exportStar || function(m3, exports2) {
      for (var p4 in m3)
        if (p4 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p4))
          __createBinding(exports2, m3, p4);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_interface(), exports);
    __exportStar(require_extension(), exports);
    __exportStar(require_base(), exports);
    __exportStar(require_memory(), exports);
    __exportStar(require_local(), exports);
    __exportStar(require_indexed_db(), exports);
    __exportStar(require_prefix(), exports);
    __exportStar(require_multi_get(), exports);
  }
});

// ../../node_modules/.pnpm/bip39@3.1.0/node_modules/bip39/src/wordlists/czech.json
var require_czech = __commonJS({
  "../../node_modules/.pnpm/bip39@3.1.0/node_modules/bip39/src/wordlists/czech.json"(exports, module) {
    module.exports = [
      "abdikace",
      "abeceda",
      "adresa",
      "agrese",
      "akce",
      "aktovka",
      "alej",
      "alkohol",
      "amputace",
      "ananas",
      "andulka",
      "anekdota",
      "anketa",
      "antika",
      "anulovat",
      "archa",
      "arogance",
      "asfalt",
      "asistent",
      "aspirace",
      "astma",
      "astronom",
      "atlas",
      "atletika",
      "atol",
      "autobus",
      "azyl",
      "babka",
      "bachor",
      "bacil",
      "baculka",
      "badatel",
      "bageta",
      "bagr",
      "bahno",
      "bakterie",
      "balada",
      "baletka",
      "balkon",
      "balonek",
      "balvan",
      "balza",
      "bambus",
      "bankomat",
      "barbar",
      "baret",
      "barman",
      "baroko",
      "barva",
      "baterka",
      "batoh",
      "bavlna",
      "bazalka",
      "bazilika",
      "bazuka",
      "bedna",
      "beran",
      "beseda",
      "bestie",
      "beton",
      "bezinka",
      "bezmoc",
      "beztak",
      "bicykl",
      "bidlo",
      "biftek",
      "bikiny",
      "bilance",
      "biograf",
      "biolog",
      "bitva",
      "bizon",
      "blahobyt",
      "blatouch",
      "blecha",
      "bledule",
      "blesk",
      "blikat",
      "blizna",
      "blokovat",
      "bloudit",
      "blud",
      "bobek",
      "bobr",
      "bodlina",
      "bodnout",
      "bohatost",
      "bojkot",
      "bojovat",
      "bokorys",
      "bolest",
      "borec",
      "borovice",
      "bota",
      "boubel",
      "bouchat",
      "bouda",
      "boule",
      "bourat",
      "boxer",
      "bradavka",
      "brambora",
      "branka",
      "bratr",
      "brepta",
      "briketa",
      "brko",
      "brloh",
      "bronz",
      "broskev",
      "brunetka",
      "brusinka",
      "brzda",
      "brzy",
      "bublina",
      "bubnovat",
      "buchta",
      "buditel",
      "budka",
      "budova",
      "bufet",
      "bujarost",
      "bukvice",
      "buldok",
      "bulva",
      "bunda",
      "bunkr",
      "burza",
      "butik",
      "buvol",
      "buzola",
      "bydlet",
      "bylina",
      "bytovka",
      "bzukot",
      "capart",
      "carevna",
      "cedr",
      "cedule",
      "cejch",
      "cejn",
      "cela",
      "celer",
      "celkem",
      "celnice",
      "cenina",
      "cennost",
      "cenovka",
      "centrum",
      "cenzor",
      "cestopis",
      "cetka",
      "chalupa",
      "chapadlo",
      "charita",
      "chata",
      "chechtat",
      "chemie",
      "chichot",
      "chirurg",
      "chlad",
      "chleba",
      "chlubit",
      "chmel",
      "chmura",
      "chobot",
      "chochol",
      "chodba",
      "cholera",
      "chomout",
      "chopit",
      "choroba",
      "chov",
      "chrapot",
      "chrlit",
      "chrt",
      "chrup",
      "chtivost",
      "chudina",
      "chutnat",
      "chvat",
      "chvilka",
      "chvost",
      "chyba",
      "chystat",
      "chytit",
      "cibule",
      "cigareta",
      "cihelna",
      "cihla",
      "cinkot",
      "cirkus",
      "cisterna",
      "citace",
      "citrus",
      "cizinec",
      "cizost",
      "clona",
      "cokoliv",
      "couvat",
      "ctitel",
      "ctnost",
      "cudnost",
      "cuketa",
      "cukr",
      "cupot",
      "cvaknout",
      "cval",
      "cvik",
      "cvrkot",
      "cyklista",
      "daleko",
      "dareba",
      "datel",
      "datum",
      "dcera",
      "debata",
      "dechovka",
      "decibel",
      "deficit",
      "deflace",
      "dekl",
      "dekret",
      "demokrat",
      "deprese",
      "derby",
      "deska",
      "detektiv",
      "dikobraz",
      "diktovat",
      "dioda",
      "diplom",
      "disk",
      "displej",
      "divadlo",
      "divoch",
      "dlaha",
      "dlouho",
      "dluhopis",
      "dnes",
      "dobro",
      "dobytek",
      "docent",
      "dochutit",
      "dodnes",
      "dohled",
      "dohoda",
      "dohra",
      "dojem",
      "dojnice",
      "doklad",
      "dokola",
      "doktor",
      "dokument",
      "dolar",
      "doleva",
      "dolina",
      "doma",
      "dominant",
      "domluvit",
      "domov",
      "donutit",
      "dopad",
      "dopis",
      "doplnit",
      "doposud",
      "doprovod",
      "dopustit",
      "dorazit",
      "dorost",
      "dort",
      "dosah",
      "doslov",
      "dostatek",
      "dosud",
      "dosyta",
      "dotaz",
      "dotek",
      "dotknout",
      "doufat",
      "doutnat",
      "dovozce",
      "dozadu",
      "doznat",
      "dozorce",
      "drahota",
      "drak",
      "dramatik",
      "dravec",
      "draze",
      "drdol",
      "drobnost",
      "drogerie",
      "drozd",
      "drsnost",
      "drtit",
      "drzost",
      "duben",
      "duchovno",
      "dudek",
      "duha",
      "duhovka",
      "dusit",
      "dusno",
      "dutost",
      "dvojice",
      "dvorec",
      "dynamit",
      "ekolog",
      "ekonomie",
      "elektron",
      "elipsa",
      "email",
      "emise",
      "emoce",
      "empatie",
      "epizoda",
      "epocha",
      "epopej",
      "epos",
      "esej",
      "esence",
      "eskorta",
      "eskymo",
      "etiketa",
      "euforie",
      "evoluce",
      "exekuce",
      "exkurze",
      "expedice",
      "exploze",
      "export",
      "extrakt",
      "facka",
      "fajfka",
      "fakulta",
      "fanatik",
      "fantazie",
      "farmacie",
      "favorit",
      "fazole",
      "federace",
      "fejeton",
      "fenka",
      "fialka",
      "figurant",
      "filozof",
      "filtr",
      "finance",
      "finta",
      "fixace",
      "fjord",
      "flanel",
      "flirt",
      "flotila",
      "fond",
      "fosfor",
      "fotbal",
      "fotka",
      "foton",
      "frakce",
      "freska",
      "fronta",
      "fukar",
      "funkce",
      "fyzika",
      "galeje",
      "garant",
      "genetika",
      "geolog",
      "gilotina",
      "glazura",
      "glejt",
      "golem",
      "golfista",
      "gotika",
      "graf",
      "gramofon",
      "granule",
      "grep",
      "gril",
      "grog",
      "groteska",
      "guma",
      "hadice",
      "hadr",
      "hala",
      "halenka",
      "hanba",
      "hanopis",
      "harfa",
      "harpuna",
      "havran",
      "hebkost",
      "hejkal",
      "hejno",
      "hejtman",
      "hektar",
      "helma",
      "hematom",
      "herec",
      "herna",
      "heslo",
      "hezky",
      "historik",
      "hladovka",
      "hlasivky",
      "hlava",
      "hledat",
      "hlen",
      "hlodavec",
      "hloh",
      "hloupost",
      "hltat",
      "hlubina",
      "hluchota",
      "hmat",
      "hmota",
      "hmyz",
      "hnis",
      "hnojivo",
      "hnout",
      "hoblina",
      "hoboj",
      "hoch",
      "hodiny",
      "hodlat",
      "hodnota",
      "hodovat",
      "hojnost",
      "hokej",
      "holinka",
      "holka",
      "holub",
      "homole",
      "honitba",
      "honorace",
      "horal",
      "horda",
      "horizont",
      "horko",
      "horlivec",
      "hormon",
      "hornina",
      "horoskop",
      "horstvo",
      "hospoda",
      "hostina",
      "hotovost",
      "houba",
      "houf",
      "houpat",
      "houska",
      "hovor",
      "hradba",
      "hranice",
      "hravost",
      "hrazda",
      "hrbolek",
      "hrdina",
      "hrdlo",
      "hrdost",
      "hrnek",
      "hrobka",
      "hromada",
      "hrot",
      "hrouda",
      "hrozen",
      "hrstka",
      "hrubost",
      "hryzat",
      "hubenost",
      "hubnout",
      "hudba",
      "hukot",
      "humr",
      "husita",
      "hustota",
      "hvozd",
      "hybnost",
      "hydrant",
      "hygiena",
      "hymna",
      "hysterik",
      "idylka",
      "ihned",
      "ikona",
      "iluze",
      "imunita",
      "infekce",
      "inflace",
      "inkaso",
      "inovace",
      "inspekce",
      "internet",
      "invalida",
      "investor",
      "inzerce",
      "ironie",
      "jablko",
      "jachta",
      "jahoda",
      "jakmile",
      "jakost",
      "jalovec",
      "jantar",
      "jarmark",
      "jaro",
      "jasan",
      "jasno",
      "jatka",
      "javor",
      "jazyk",
      "jedinec",
      "jedle",
      "jednatel",
      "jehlan",
      "jekot",
      "jelen",
      "jelito",
      "jemnost",
      "jenom",
      "jepice",
      "jeseter",
      "jevit",
      "jezdec",
      "jezero",
      "jinak",
      "jindy",
      "jinoch",
      "jiskra",
      "jistota",
      "jitrnice",
      "jizva",
      "jmenovat",
      "jogurt",
      "jurta",
      "kabaret",
      "kabel",
      "kabinet",
      "kachna",
      "kadet",
      "kadidlo",
      "kahan",
      "kajak",
      "kajuta",
      "kakao",
      "kaktus",
      "kalamita",
      "kalhoty",
      "kalibr",
      "kalnost",
      "kamera",
      "kamkoliv",
      "kamna",
      "kanibal",
      "kanoe",
      "kantor",
      "kapalina",
      "kapela",
      "kapitola",
      "kapka",
      "kaple",
      "kapota",
      "kapr",
      "kapusta",
      "kapybara",
      "karamel",
      "karotka",
      "karton",
      "kasa",
      "katalog",
      "katedra",
      "kauce",
      "kauza",
      "kavalec",
      "kazajka",
      "kazeta",
      "kazivost",
      "kdekoliv",
      "kdesi",
      "kedluben",
      "kemp",
      "keramika",
      "kino",
      "klacek",
      "kladivo",
      "klam",
      "klapot",
      "klasika",
      "klaun",
      "klec",
      "klenba",
      "klepat",
      "klesnout",
      "klid",
      "klima",
      "klisna",
      "klobouk",
      "klokan",
      "klopa",
      "kloub",
      "klubovna",
      "klusat",
      "kluzkost",
      "kmen",
      "kmitat",
      "kmotr",
      "kniha",
      "knot",
      "koalice",
      "koberec",
      "kobka",
      "kobliha",
      "kobyla",
      "kocour",
      "kohout",
      "kojenec",
      "kokos",
      "koktejl",
      "kolaps",
      "koleda",
      "kolize",
      "kolo",
      "komando",
      "kometa",
      "komik",
      "komnata",
      "komora",
      "kompas",
      "komunita",
      "konat",
      "koncept",
      "kondice",
      "konec",
      "konfese",
      "kongres",
      "konina",
      "konkurs",
      "kontakt",
      "konzerva",
      "kopanec",
      "kopie",
      "kopnout",
      "koprovka",
      "korbel",
      "korektor",
      "kormidlo",
      "koroptev",
      "korpus",
      "koruna",
      "koryto",
      "korzet",
      "kosatec",
      "kostka",
      "kotel",
      "kotleta",
      "kotoul",
      "koukat",
      "koupelna",
      "kousek",
      "kouzlo",
      "kovboj",
      "koza",
      "kozoroh",
      "krabice",
      "krach",
      "krajina",
      "kralovat",
      "krasopis",
      "kravata",
      "kredit",
      "krejcar",
      "kresba",
      "kreveta",
      "kriket",
      "kritik",
      "krize",
      "krkavec",
      "krmelec",
      "krmivo",
      "krocan",
      "krok",
      "kronika",
      "kropit",
      "kroupa",
      "krovka",
      "krtek",
      "kruhadlo",
      "krupice",
      "krutost",
      "krvinka",
      "krychle",
      "krypta",
      "krystal",
      "kryt",
      "kudlanka",
      "kufr",
      "kujnost",
      "kukla",
      "kulajda",
      "kulich",
      "kulka",
      "kulomet",
      "kultura",
      "kuna",
      "kupodivu",
      "kurt",
      "kurzor",
      "kutil",
      "kvalita",
      "kvasinka",
      "kvestor",
      "kynolog",
      "kyselina",
      "kytara",
      "kytice",
      "kytka",
      "kytovec",
      "kyvadlo",
      "labrador",
      "lachtan",
      "ladnost",
      "laik",
      "lakomec",
      "lamela",
      "lampa",
      "lanovka",
      "lasice",
      "laso",
      "lastura",
      "latinka",
      "lavina",
      "lebka",
      "leckdy",
      "leden",
      "lednice",
      "ledovka",
      "ledvina",
      "legenda",
      "legie",
      "legrace",
      "lehce",
      "lehkost",
      "lehnout",
      "lektvar",
      "lenochod",
      "lentilka",
      "lepenka",
      "lepidlo",
      "letadlo",
      "letec",
      "letmo",
      "letokruh",
      "levhart",
      "levitace",
      "levobok",
      "libra",
      "lichotka",
      "lidojed",
      "lidskost",
      "lihovina",
      "lijavec",
      "lilek",
      "limetka",
      "linie",
      "linka",
      "linoleum",
      "listopad",
      "litina",
      "litovat",
      "lobista",
      "lodivod",
      "logika",
      "logoped",
      "lokalita",
      "loket",
      "lomcovat",
      "lopata",
      "lopuch",
      "lord",
      "losos",
      "lotr",
      "loudal",
      "louh",
      "louka",
      "louskat",
      "lovec",
      "lstivost",
      "lucerna",
      "lucifer",
      "lump",
      "lusk",
      "lustrace",
      "lvice",
      "lyra",
      "lyrika",
      "lysina",
      "madam",
      "madlo",
      "magistr",
      "mahagon",
      "majetek",
      "majitel",
      "majorita",
      "makak",
      "makovice",
      "makrela",
      "malba",
      "malina",
      "malovat",
      "malvice",
      "maminka",
      "mandle",
      "manko",
      "marnost",
      "masakr",
      "maskot",
      "masopust",
      "matice",
      "matrika",
      "maturita",
      "mazanec",
      "mazivo",
      "mazlit",
      "mazurka",
      "mdloba",
      "mechanik",
      "meditace",
      "medovina",
      "melasa",
      "meloun",
      "mentolka",
      "metla",
      "metoda",
      "metr",
      "mezera",
      "migrace",
      "mihnout",
      "mihule",
      "mikina",
      "mikrofon",
      "milenec",
      "milimetr",
      "milost",
      "mimika",
      "mincovna",
      "minibar",
      "minomet",
      "minulost",
      "miska",
      "mistr",
      "mixovat",
      "mladost",
      "mlha",
      "mlhovina",
      "mlok",
      "mlsat",
      "mluvit",
      "mnich",
      "mnohem",
      "mobil",
      "mocnost",
      "modelka",
      "modlitba",
      "mohyla",
      "mokro",
      "molekula",
      "momentka",
      "monarcha",
      "monokl",
      "monstrum",
      "montovat",
      "monzun",
      "mosaz",
      "moskyt",
      "most",
      "motivace",
      "motorka",
      "motyka",
      "moucha",
      "moudrost",
      "mozaika",
      "mozek",
      "mozol",
      "mramor",
      "mravenec",
      "mrkev",
      "mrtvola",
      "mrzet",
      "mrzutost",
      "mstitel",
      "mudrc",
      "muflon",
      "mulat",
      "mumie",
      "munice",
      "muset",
      "mutace",
      "muzeum",
      "muzikant",
      "myslivec",
      "mzda",
      "nabourat",
      "nachytat",
      "nadace",
      "nadbytek",
      "nadhoz",
      "nadobro",
      "nadpis",
      "nahlas",
      "nahnat",
      "nahodile",
      "nahradit",
      "naivita",
      "najednou",
      "najisto",
      "najmout",
      "naklonit",
      "nakonec",
      "nakrmit",
      "nalevo",
      "namazat",
      "namluvit",
      "nanometr",
      "naoko",
      "naopak",
      "naostro",
      "napadat",
      "napevno",
      "naplnit",
      "napnout",
      "naposled",
      "naprosto",
      "narodit",
      "naruby",
      "narychlo",
      "nasadit",
      "nasekat",
      "naslepo",
      "nastat",
      "natolik",
      "navenek",
      "navrch",
      "navzdory",
      "nazvat",
      "nebe",
      "nechat",
      "necky",
      "nedaleko",
      "nedbat",
      "neduh",
      "negace",
      "nehet",
      "nehoda",
      "nejen",
      "nejprve",
      "neklid",
      "nelibost",
      "nemilost",
      "nemoc",
      "neochota",
      "neonka",
      "nepokoj",
      "nerost",
      "nerv",
      "nesmysl",
      "nesoulad",
      "netvor",
      "neuron",
      "nevina",
      "nezvykle",
      "nicota",
      "nijak",
      "nikam",
      "nikdy",
      "nikl",
      "nikterak",
      "nitro",
      "nocleh",
      "nohavice",
      "nominace",
      "nora",
      "norek",
      "nositel",
      "nosnost",
      "nouze",
      "noviny",
      "novota",
      "nozdra",
      "nuda",
      "nudle",
      "nuget",
      "nutit",
      "nutnost",
      "nutrie",
      "nymfa",
      "obal",
      "obarvit",
      "obava",
      "obdiv",
      "obec",
      "obehnat",
      "obejmout",
      "obezita",
      "obhajoba",
      "obilnice",
      "objasnit",
      "objekt",
      "obklopit",
      "oblast",
      "oblek",
      "obliba",
      "obloha",
      "obluda",
      "obnos",
      "obohatit",
      "obojek",
      "obout",
      "obrazec",
      "obrna",
      "obruba",
      "obrys",
      "obsah",
      "obsluha",
      "obstarat",
      "obuv",
      "obvaz",
      "obvinit",
      "obvod",
      "obvykle",
      "obyvatel",
      "obzor",
      "ocas",
      "ocel",
      "ocenit",
      "ochladit",
      "ochota",
      "ochrana",
      "ocitnout",
      "odboj",
      "odbyt",
      "odchod",
      "odcizit",
      "odebrat",
      "odeslat",
      "odevzdat",
      "odezva",
      "odhadce",
      "odhodit",
      "odjet",
      "odjinud",
      "odkaz",
      "odkoupit",
      "odliv",
      "odluka",
      "odmlka",
      "odolnost",
      "odpad",
      "odpis",
      "odplout",
      "odpor",
      "odpustit",
      "odpykat",
      "odrazka",
      "odsoudit",
      "odstup",
      "odsun",
      "odtok",
      "odtud",
      "odvaha",
      "odveta",
      "odvolat",
      "odvracet",
      "odznak",
      "ofina",
      "ofsajd",
      "ohlas",
      "ohnisko",
      "ohrada",
      "ohrozit",
      "ohryzek",
      "okap",
      "okenice",
      "oklika",
      "okno",
      "okouzlit",
      "okovy",
      "okrasa",
      "okres",
      "okrsek",
      "okruh",
      "okupant",
      "okurka",
      "okusit",
      "olejnina",
      "olizovat",
      "omak",
      "omeleta",
      "omezit",
      "omladina",
      "omlouvat",
      "omluva",
      "omyl",
      "onehdy",
      "opakovat",
      "opasek",
      "operace",
      "opice",
      "opilost",
      "opisovat",
      "opora",
      "opozice",
      "opravdu",
      "oproti",
      "orbital",
      "orchestr",
      "orgie",
      "orlice",
      "orloj",
      "ortel",
      "osada",
      "oschnout",
      "osika",
      "osivo",
      "oslava",
      "oslepit",
      "oslnit",
      "oslovit",
      "osnova",
      "osoba",
      "osolit",
      "ospalec",
      "osten",
      "ostraha",
      "ostuda",
      "ostych",
      "osvojit",
      "oteplit",
      "otisk",
      "otop",
      "otrhat",
      "otrlost",
      "otrok",
      "otruby",
      "otvor",
      "ovanout",
      "ovar",
      "oves",
      "ovlivnit",
      "ovoce",
      "oxid",
      "ozdoba",
      "pachatel",
      "pacient",
      "padouch",
      "pahorek",
      "pakt",
      "palanda",
      "palec",
      "palivo",
      "paluba",
      "pamflet",
      "pamlsek",
      "panenka",
      "panika",
      "panna",
      "panovat",
      "panstvo",
      "pantofle",
      "paprika",
      "parketa",
      "parodie",
      "parta",
      "paruka",
      "paryba",
      "paseka",
      "pasivita",
      "pastelka",
      "patent",
      "patrona",
      "pavouk",
      "pazneht",
      "pazourek",
      "pecka",
      "pedagog",
      "pejsek",
      "peklo",
      "peloton",
      "penalta",
      "pendrek",
      "penze",
      "periskop",
      "pero",
      "pestrost",
      "petarda",
      "petice",
      "petrolej",
      "pevnina",
      "pexeso",
      "pianista",
      "piha",
      "pijavice",
      "pikle",
      "piknik",
      "pilina",
      "pilnost",
      "pilulka",
      "pinzeta",
      "pipeta",
      "pisatel",
      "pistole",
      "pitevna",
      "pivnice",
      "pivovar",
      "placenta",
      "plakat",
      "plamen",
      "planeta",
      "plastika",
      "platit",
      "plavidlo",
      "plaz",
      "plech",
      "plemeno",
      "plenta",
      "ples",
      "pletivo",
      "plevel",
      "plivat",
      "plnit",
      "plno",
      "plocha",
      "plodina",
      "plomba",
      "plout",
      "pluk",
      "plyn",
      "pobavit",
      "pobyt",
      "pochod",
      "pocit",
      "poctivec",
      "podat",
      "podcenit",
      "podepsat",
      "podhled",
      "podivit",
      "podklad",
      "podmanit",
      "podnik",
      "podoba",
      "podpora",
      "podraz",
      "podstata",
      "podvod",
      "podzim",
      "poezie",
      "pohanka",
      "pohnutka",
      "pohovor",
      "pohroma",
      "pohyb",
      "pointa",
      "pojistka",
      "pojmout",
      "pokazit",
      "pokles",
      "pokoj",
      "pokrok",
      "pokuta",
      "pokyn",
      "poledne",
      "polibek",
      "polknout",
      "poloha",
      "polynom",
      "pomalu",
      "pominout",
      "pomlka",
      "pomoc",
      "pomsta",
      "pomyslet",
      "ponechat",
      "ponorka",
      "ponurost",
      "popadat",
      "popel",
      "popisek",
      "poplach",
      "poprosit",
      "popsat",
      "popud",
      "poradce",
      "porce",
      "porod",
      "porucha",
      "poryv",
      "posadit",
      "posed",
      "posila",
      "poskok",
      "poslanec",
      "posoudit",
      "pospolu",
      "postava",
      "posudek",
      "posyp",
      "potah",
      "potkan",
      "potlesk",
      "potomek",
      "potrava",
      "potupa",
      "potvora",
      "poukaz",
      "pouto",
      "pouzdro",
      "povaha",
      "povidla",
      "povlak",
      "povoz",
      "povrch",
      "povstat",
      "povyk",
      "povzdech",
      "pozdrav",
      "pozemek",
      "poznatek",
      "pozor",
      "pozvat",
      "pracovat",
      "prahory",
      "praktika",
      "prales",
      "praotec",
      "praporek",
      "prase",
      "pravda",
      "princip",
      "prkno",
      "probudit",
      "procento",
      "prodej",
      "profese",
      "prohra",
      "projekt",
      "prolomit",
      "promile",
      "pronikat",
      "propad",
      "prorok",
      "prosba",
      "proton",
      "proutek",
      "provaz",
      "prskavka",
      "prsten",
      "prudkost",
      "prut",
      "prvek",
      "prvohory",
      "psanec",
      "psovod",
      "pstruh",
      "ptactvo",
      "puberta",
      "puch",
      "pudl",
      "pukavec",
      "puklina",
      "pukrle",
      "pult",
      "pumpa",
      "punc",
      "pupen",
      "pusa",
      "pusinka",
      "pustina",
      "putovat",
      "putyka",
      "pyramida",
      "pysk",
      "pytel",
      "racek",
      "rachot",
      "radiace",
      "radnice",
      "radon",
      "raft",
      "ragby",
      "raketa",
      "rakovina",
      "rameno",
      "rampouch",
      "rande",
      "rarach",
      "rarita",
      "rasovna",
      "rastr",
      "ratolest",
      "razance",
      "razidlo",
      "reagovat",
      "reakce",
      "recept",
      "redaktor",
      "referent",
      "reflex",
      "rejnok",
      "reklama",
      "rekord",
      "rekrut",
      "rektor",
      "reputace",
      "revize",
      "revma",
      "revolver",
      "rezerva",
      "riskovat",
      "riziko",
      "robotika",
      "rodokmen",
      "rohovka",
      "rokle",
      "rokoko",
      "romaneto",
      "ropovod",
      "ropucha",
      "rorejs",
      "rosol",
      "rostlina",
      "rotmistr",
      "rotoped",
      "rotunda",
      "roubenka",
      "roucho",
      "roup",
      "roura",
      "rovina",
      "rovnice",
      "rozbor",
      "rozchod",
      "rozdat",
      "rozeznat",
      "rozhodce",
      "rozinka",
      "rozjezd",
      "rozkaz",
      "rozloha",
      "rozmar",
      "rozpad",
      "rozruch",
      "rozsah",
      "roztok",
      "rozum",
      "rozvod",
      "rubrika",
      "ruchadlo",
      "rukavice",
      "rukopis",
      "ryba",
      "rybolov",
      "rychlost",
      "rydlo",
      "rypadlo",
      "rytina",
      "ryzost",
      "sadista",
      "sahat",
      "sako",
      "samec",
      "samizdat",
      "samota",
      "sanitka",
      "sardinka",
      "sasanka",
      "satelit",
      "sazba",
      "sazenice",
      "sbor",
      "schovat",
      "sebranka",
      "secese",
      "sedadlo",
      "sediment",
      "sedlo",
      "sehnat",
      "sejmout",
      "sekera",
      "sekta",
      "sekunda",
      "sekvoje",
      "semeno",
      "seno",
      "servis",
      "sesadit",
      "seshora",
      "seskok",
      "seslat",
      "sestra",
      "sesuv",
      "sesypat",
      "setba",
      "setina",
      "setkat",
      "setnout",
      "setrvat",
      "sever",
      "seznam",
      "shoda",
      "shrnout",
      "sifon",
      "silnice",
      "sirka",
      "sirotek",
      "sirup",
      "situace",
      "skafandr",
      "skalisko",
      "skanzen",
      "skaut",
      "skeptik",
      "skica",
      "skladba",
      "sklenice",
      "sklo",
      "skluz",
      "skoba",
      "skokan",
      "skoro",
      "skripta",
      "skrz",
      "skupina",
      "skvost",
      "skvrna",
      "slabika",
      "sladidlo",
      "slanina",
      "slast",
      "slavnost",
      "sledovat",
      "slepec",
      "sleva",
      "slezina",
      "slib",
      "slina",
      "sliznice",
      "slon",
      "sloupek",
      "slovo",
      "sluch",
      "sluha",
      "slunce",
      "slupka",
      "slza",
      "smaragd",
      "smetana",
      "smilstvo",
      "smlouva",
      "smog",
      "smrad",
      "smrk",
      "smrtka",
      "smutek",
      "smysl",
      "snad",
      "snaha",
      "snob",
      "sobota",
      "socha",
      "sodovka",
      "sokol",
      "sopka",
      "sotva",
      "souboj",
      "soucit",
      "soudce",
      "souhlas",
      "soulad",
      "soumrak",
      "souprava",
      "soused",
      "soutok",
      "souviset",
      "spalovna",
      "spasitel",
      "spis",
      "splav",
      "spodek",
      "spojenec",
      "spolu",
      "sponzor",
      "spornost",
      "spousta",
      "sprcha",
      "spustit",
      "sranda",
      "sraz",
      "srdce",
      "srna",
      "srnec",
      "srovnat",
      "srpen",
      "srst",
      "srub",
      "stanice",
      "starosta",
      "statika",
      "stavba",
      "stehno",
      "stezka",
      "stodola",
      "stolek",
      "stopa",
      "storno",
      "stoupat",
      "strach",
      "stres",
      "strhnout",
      "strom",
      "struna",
      "studna",
      "stupnice",
      "stvol",
      "styk",
      "subjekt",
      "subtropy",
      "suchar",
      "sudost",
      "sukno",
      "sundat",
      "sunout",
      "surikata",
      "surovina",
      "svah",
      "svalstvo",
      "svetr",
      "svatba",
      "svazek",
      "svisle",
      "svitek",
      "svoboda",
      "svodidlo",
      "svorka",
      "svrab",
      "sykavka",
      "sykot",
      "synek",
      "synovec",
      "sypat",
      "sypkost",
      "syrovost",
      "sysel",
      "sytost",
      "tabletka",
      "tabule",
      "tahoun",
      "tajemno",
      "tajfun",
      "tajga",
      "tajit",
      "tajnost",
      "taktika",
      "tamhle",
      "tampon",
      "tancovat",
      "tanec",
      "tanker",
      "tapeta",
      "tavenina",
      "tazatel",
      "technika",
      "tehdy",
      "tekutina",
      "telefon",
      "temnota",
      "tendence",
      "tenista",
      "tenor",
      "teplota",
      "tepna",
      "teprve",
      "terapie",
      "termoska",
      "textil",
      "ticho",
      "tiskopis",
      "titulek",
      "tkadlec",
      "tkanina",
      "tlapka",
      "tleskat",
      "tlukot",
      "tlupa",
      "tmel",
      "toaleta",
      "topinka",
      "topol",
      "torzo",
      "touha",
      "toulec",
      "tradice",
      "traktor",
      "tramp",
      "trasa",
      "traverza",
      "trefit",
      "trest",
      "trezor",
      "trhavina",
      "trhlina",
      "trochu",
      "trojice",
      "troska",
      "trouba",
      "trpce",
      "trpitel",
      "trpkost",
      "trubec",
      "truchlit",
      "truhlice",
      "trus",
      "trvat",
      "tudy",
      "tuhnout",
      "tuhost",
      "tundra",
      "turista",
      "turnaj",
      "tuzemsko",
      "tvaroh",
      "tvorba",
      "tvrdost",
      "tvrz",
      "tygr",
      "tykev",
      "ubohost",
      "uboze",
      "ubrat",
      "ubrousek",
      "ubrus",
      "ubytovna",
      "ucho",
      "uctivost",
      "udivit",
      "uhradit",
      "ujednat",
      "ujistit",
      "ujmout",
      "ukazatel",
      "uklidnit",
      "uklonit",
      "ukotvit",
      "ukrojit",
      "ulice",
      "ulita",
      "ulovit",
      "umyvadlo",
      "unavit",
      "uniforma",
      "uniknout",
      "upadnout",
      "uplatnit",
      "uplynout",
      "upoutat",
      "upravit",
      "uran",
      "urazit",
      "usednout",
      "usilovat",
      "usmrtit",
      "usnadnit",
      "usnout",
      "usoudit",
      "ustlat",
      "ustrnout",
      "utahovat",
      "utkat",
      "utlumit",
      "utonout",
      "utopenec",
      "utrousit",
      "uvalit",
      "uvolnit",
      "uvozovka",
      "uzdravit",
      "uzel",
      "uzenina",
      "uzlina",
      "uznat",
      "vagon",
      "valcha",
      "valoun",
      "vana",
      "vandal",
      "vanilka",
      "varan",
      "varhany",
      "varovat",
      "vcelku",
      "vchod",
      "vdova",
      "vedro",
      "vegetace",
      "vejce",
      "velbloud",
      "veletrh",
      "velitel",
      "velmoc",
      "velryba",
      "venkov",
      "veranda",
      "verze",
      "veselka",
      "veskrze",
      "vesnice",
      "vespodu",
      "vesta",
      "veterina",
      "veverka",
      "vibrace",
      "vichr",
      "videohra",
      "vidina",
      "vidle",
      "vila",
      "vinice",
      "viset",
      "vitalita",
      "vize",
      "vizitka",
      "vjezd",
      "vklad",
      "vkus",
      "vlajka",
      "vlak",
      "vlasec",
      "vlevo",
      "vlhkost",
      "vliv",
      "vlnovka",
      "vloupat",
      "vnucovat",
      "vnuk",
      "voda",
      "vodivost",
      "vodoznak",
      "vodstvo",
      "vojensky",
      "vojna",
      "vojsko",
      "volant",
      "volba",
      "volit",
      "volno",
      "voskovka",
      "vozidlo",
      "vozovna",
      "vpravo",
      "vrabec",
      "vracet",
      "vrah",
      "vrata",
      "vrba",
      "vrcholek",
      "vrhat",
      "vrstva",
      "vrtule",
      "vsadit",
      "vstoupit",
      "vstup",
      "vtip",
      "vybavit",
      "vybrat",
      "vychovat",
      "vydat",
      "vydra",
      "vyfotit",
      "vyhledat",
      "vyhnout",
      "vyhodit",
      "vyhradit",
      "vyhubit",
      "vyjasnit",
      "vyjet",
      "vyjmout",
      "vyklopit",
      "vykonat",
      "vylekat",
      "vymazat",
      "vymezit",
      "vymizet",
      "vymyslet",
      "vynechat",
      "vynikat",
      "vynutit",
      "vypadat",
      "vyplatit",
      "vypravit",
      "vypustit",
      "vyrazit",
      "vyrovnat",
      "vyrvat",
      "vyslovit",
      "vysoko",
      "vystavit",
      "vysunout",
      "vysypat",
      "vytasit",
      "vytesat",
      "vytratit",
      "vyvinout",
      "vyvolat",
      "vyvrhel",
      "vyzdobit",
      "vyznat",
      "vzadu",
      "vzbudit",
      "vzchopit",
      "vzdor",
      "vzduch",
      "vzdychat",
      "vzestup",
      "vzhledem",
      "vzkaz",
      "vzlykat",
      "vznik",
      "vzorek",
      "vzpoura",
      "vztah",
      "vztek",
      "xylofon",
      "zabrat",
      "zabydlet",
      "zachovat",
      "zadarmo",
      "zadusit",
      "zafoukat",
      "zahltit",
      "zahodit",
      "zahrada",
      "zahynout",
      "zajatec",
      "zajet",
      "zajistit",
      "zaklepat",
      "zakoupit",
      "zalepit",
      "zamezit",
      "zamotat",
      "zamyslet",
      "zanechat",
      "zanikat",
      "zaplatit",
      "zapojit",
      "zapsat",
      "zarazit",
      "zastavit",
      "zasunout",
      "zatajit",
      "zatemnit",
      "zatknout",
      "zaujmout",
      "zavalit",
      "zavelet",
      "zavinit",
      "zavolat",
      "zavrtat",
      "zazvonit",
      "zbavit",
      "zbrusu",
      "zbudovat",
      "zbytek",
      "zdaleka",
      "zdarma",
      "zdatnost",
      "zdivo",
      "zdobit",
      "zdroj",
      "zdvih",
      "zdymadlo",
      "zelenina",
      "zeman",
      "zemina",
      "zeptat",
      "zezadu",
      "zezdola",
      "zhatit",
      "zhltnout",
      "zhluboka",
      "zhotovit",
      "zhruba",
      "zima",
      "zimnice",
      "zjemnit",
      "zklamat",
      "zkoumat",
      "zkratka",
      "zkumavka",
      "zlato",
      "zlehka",
      "zloba",
      "zlom",
      "zlost",
      "zlozvyk",
      "zmapovat",
      "zmar",
      "zmatek",
      "zmije",
      "zmizet",
      "zmocnit",
      "zmodrat",
      "zmrzlina",
      "zmutovat",
      "znak",
      "znalost",
      "znamenat",
      "znovu",
      "zobrazit",
      "zotavit",
      "zoubek",
      "zoufale",
      "zplodit",
      "zpomalit",
      "zprava",
      "zprostit",
      "zprudka",
      "zprvu",
      "zrada",
      "zranit",
      "zrcadlo",
      "zrnitost",
      "zrno",
      "zrovna",
      "zrychlit",
      "zrzavost",
      "zticha",
      "ztratit",
      "zubovina",
      "zubr",
      "zvednout",
      "zvenku",
      "zvesela",
      "zvon",
      "zvrat",
      "zvukovod",
      "zvyk"
    ];
  }
});

// ../../node_modules/.pnpm/bip39@3.1.0/node_modules/bip39/src/wordlists/chinese_simplified.json
var require_chinese_simplified = __commonJS({
  "../../node_modules/.pnpm/bip39@3.1.0/node_modules/bip39/src/wordlists/chinese_simplified.json"(exports, module) {
    module.exports = [
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      ""
    ];
  }
});

// ../../node_modules/.pnpm/bip39@3.1.0/node_modules/bip39/src/wordlists/chinese_traditional.json
var require_chinese_traditional = __commonJS({
  "../../node_modules/.pnpm/bip39@3.1.0/node_modules/bip39/src/wordlists/chinese_traditional.json"(exports, module) {
    module.exports = [
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      ""
    ];
  }
});

// ../../node_modules/.pnpm/bip39@3.1.0/node_modules/bip39/src/wordlists/korean.json
var require_korean = __commonJS({
  "../../node_modules/.pnpm/bip39@3.1.0/node_modules/bip39/src/wordlists/korean.json"(exports, module) {
    module.exports = [
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      ""
    ];
  }
});

// ../../node_modules/.pnpm/bip39@3.1.0/node_modules/bip39/src/wordlists/french.json
var require_french = __commonJS({
  "../../node_modules/.pnpm/bip39@3.1.0/node_modules/bip39/src/wordlists/french.json"(exports, module) {
    module.exports = [
      "abaisser",
      "abandon",
      "abdiquer",
      "abeille",
      "abolir",
      "aborder",
      "aboutir",
      "aboyer",
      "abrasif",
      "abreuver",
      "abriter",
      "abroger",
      "abrupt",
      "absence",
      "absolu",
      "absurde",
      "abusif",
      "abyssal",
      "academie",
      "acajou",
      "acarien",
      "accabler",
      "accepter",
      "acclamer",
      "accolade",
      "accroche",
      "accuser",
      "acerbe",
      "achat",
      "acheter",
      "aciduler",
      "acier",
      "acompte",
      "acquerir",
      "acronyme",
      "acteur",
      "actif",
      "actuel",
      "adepte",
      "adequat",
      "adhesif",
      "adjectif",
      "adjuger",
      "admettre",
      "admirer",
      "adopter",
      "adorer",
      "adoucir",
      "adresse",
      "adroit",
      "adulte",
      "adverbe",
      "aerer",
      "aeronef",
      "affaire",
      "affecter",
      "affiche",
      "affreux",
      "affubler",
      "agacer",
      "agencer",
      "agile",
      "agiter",
      "agrafer",
      "agreable",
      "agrume",
      "aider",
      "aiguille",
      "ailier",
      "aimable",
      "aisance",
      "ajouter",
      "ajuster",
      "alarmer",
      "alchimie",
      "alerte",
      "algebre",
      "algue",
      "aliener",
      "aliment",
      "alleger",
      "alliage",
      "allouer",
      "allumer",
      "alourdir",
      "alpaga",
      "altesse",
      "alveole",
      "amateur",
      "ambigu",
      "ambre",
      "amenager",
      "amertume",
      "amidon",
      "amiral",
      "amorcer",
      "amour",
      "amovible",
      "amphibie",
      "ampleur",
      "amusant",
      "analyse",
      "anaphore",
      "anarchie",
      "anatomie",
      "ancien",
      "aneantir",
      "angle",
      "angoisse",
      "anguleux",
      "animal",
      "annexer",
      "annonce",
      "annuel",
      "anodin",
      "anomalie",
      "anonyme",
      "anormal",
      "antenne",
      "antidote",
      "anxieux",
      "apaiser",
      "aperitif",
      "aplanir",
      "apologie",
      "appareil",
      "appeler",
      "apporter",
      "appuyer",
      "aquarium",
      "aqueduc",
      "arbitre",
      "arbuste",
      "ardeur",
      "ardoise",
      "argent",
      "arlequin",
      "armature",
      "armement",
      "armoire",
      "armure",
      "arpenter",
      "arracher",
      "arriver",
      "arroser",
      "arsenic",
      "arteriel",
      "article",
      "aspect",
      "asphalte",
      "aspirer",
      "assaut",
      "asservir",
      "assiette",
      "associer",
      "assurer",
      "asticot",
      "astre",
      "astuce",
      "atelier",
      "atome",
      "atrium",
      "atroce",
      "attaque",
      "attentif",
      "attirer",
      "attraper",
      "aubaine",
      "auberge",
      "audace",
      "audible",
      "augurer",
      "aurore",
      "automne",
      "autruche",
      "avaler",
      "avancer",
      "avarice",
      "avenir",
      "averse",
      "aveugle",
      "aviateur",
      "avide",
      "avion",
      "aviser",
      "avoine",
      "avouer",
      "avril",
      "axial",
      "axiome",
      "badge",
      "bafouer",
      "bagage",
      "baguette",
      "baignade",
      "balancer",
      "balcon",
      "baleine",
      "balisage",
      "bambin",
      "bancaire",
      "bandage",
      "banlieue",
      "banniere",
      "banquier",
      "barbier",
      "baril",
      "baron",
      "barque",
      "barrage",
      "bassin",
      "bastion",
      "bataille",
      "bateau",
      "batterie",
      "baudrier",
      "bavarder",
      "belette",
      "belier",
      "belote",
      "benefice",
      "berceau",
      "berger",
      "berline",
      "bermuda",
      "besace",
      "besogne",
      "betail",
      "beurre",
      "biberon",
      "bicycle",
      "bidule",
      "bijou",
      "bilan",
      "bilingue",
      "billard",
      "binaire",
      "biologie",
      "biopsie",
      "biotype",
      "biscuit",
      "bison",
      "bistouri",
      "bitume",
      "bizarre",
      "blafard",
      "blague",
      "blanchir",
      "blessant",
      "blinder",
      "blond",
      "bloquer",
      "blouson",
      "bobard",
      "bobine",
      "boire",
      "boiser",
      "bolide",
      "bonbon",
      "bondir",
      "bonheur",
      "bonifier",
      "bonus",
      "bordure",
      "borne",
      "botte",
      "boucle",
      "boueux",
      "bougie",
      "boulon",
      "bouquin",
      "bourse",
      "boussole",
      "boutique",
      "boxeur",
      "branche",
      "brasier",
      "brave",
      "brebis",
      "breche",
      "breuvage",
      "bricoler",
      "brigade",
      "brillant",
      "brioche",
      "brique",
      "brochure",
      "broder",
      "bronzer",
      "brousse",
      "broyeur",
      "brume",
      "brusque",
      "brutal",
      "bruyant",
      "buffle",
      "buisson",
      "bulletin",
      "bureau",
      "burin",
      "bustier",
      "butiner",
      "butoir",
      "buvable",
      "buvette",
      "cabanon",
      "cabine",
      "cachette",
      "cadeau",
      "cadre",
      "cafeine",
      "caillou",
      "caisson",
      "calculer",
      "calepin",
      "calibre",
      "calmer",
      "calomnie",
      "calvaire",
      "camarade",
      "camera",
      "camion",
      "campagne",
      "canal",
      "caneton",
      "canon",
      "cantine",
      "canular",
      "capable",
      "caporal",
      "caprice",
      "capsule",
      "capter",
      "capuche",
      "carabine",
      "carbone",
      "caresser",
      "caribou",
      "carnage",
      "carotte",
      "carreau",
      "carton",
      "cascade",
      "casier",
      "casque",
      "cassure",
      "causer",
      "caution",
      "cavalier",
      "caverne",
      "caviar",
      "cedille",
      "ceinture",
      "celeste",
      "cellule",
      "cendrier",
      "censurer",
      "central",
      "cercle",
      "cerebral",
      "cerise",
      "cerner",
      "cerveau",
      "cesser",
      "chagrin",
      "chaise",
      "chaleur",
      "chambre",
      "chance",
      "chapitre",
      "charbon",
      "chasseur",
      "chaton",
      "chausson",
      "chavirer",
      "chemise",
      "chenille",
      "chequier",
      "chercher",
      "cheval",
      "chien",
      "chiffre",
      "chignon",
      "chimere",
      "chiot",
      "chlorure",
      "chocolat",
      "choisir",
      "chose",
      "chouette",
      "chrome",
      "chute",
      "cigare",
      "cigogne",
      "cimenter",
      "cinema",
      "cintrer",
      "circuler",
      "cirer",
      "cirque",
      "citerne",
      "citoyen",
      "citron",
      "civil",
      "clairon",
      "clameur",
      "claquer",
      "classe",
      "clavier",
      "client",
      "cligner",
      "climat",
      "clivage",
      "cloche",
      "clonage",
      "cloporte",
      "cobalt",
      "cobra",
      "cocasse",
      "cocotier",
      "coder",
      "codifier",
      "coffre",
      "cogner",
      "cohesion",
      "coiffer",
      "coincer",
      "colere",
      "colibri",
      "colline",
      "colmater",
      "colonel",
      "combat",
      "comedie",
      "commande",
      "compact",
      "concert",
      "conduire",
      "confier",
      "congeler",
      "connoter",
      "consonne",
      "contact",
      "convexe",
      "copain",
      "copie",
      "corail",
      "corbeau",
      "cordage",
      "corniche",
      "corpus",
      "correct",
      "cortege",
      "cosmique",
      "costume",
      "coton",
      "coude",
      "coupure",
      "courage",
      "couteau",
      "couvrir",
      "coyote",
      "crabe",
      "crainte",
      "cravate",
      "crayon",
      "creature",
      "crediter",
      "cremeux",
      "creuser",
      "crevette",
      "cribler",
      "crier",
      "cristal",
      "critere",
      "croire",
      "croquer",
      "crotale",
      "crucial",
      "cruel",
      "crypter",
      "cubique",
      "cueillir",
      "cuillere",
      "cuisine",
      "cuivre",
      "culminer",
      "cultiver",
      "cumuler",
      "cupide",
      "curatif",
      "curseur",
      "cyanure",
      "cycle",
      "cylindre",
      "cynique",
      "daigner",
      "damier",
      "danger",
      "danseur",
      "dauphin",
      "debattre",
      "debiter",
      "deborder",
      "debrider",
      "debutant",
      "decaler",
      "decembre",
      "dechirer",
      "decider",
      "declarer",
      "decorer",
      "decrire",
      "decupler",
      "dedale",
      "deductif",
      "deesse",
      "defensif",
      "defiler",
      "defrayer",
      "degager",
      "degivrer",
      "deglutir",
      "degrafer",
      "dejeuner",
      "delice",
      "deloger",
      "demander",
      "demeurer",
      "demolir",
      "denicher",
      "denouer",
      "dentelle",
      "denuder",
      "depart",
      "depenser",
      "dephaser",
      "deplacer",
      "deposer",
      "deranger",
      "derober",
      "desastre",
      "descente",
      "desert",
      "designer",
      "desobeir",
      "dessiner",
      "destrier",
      "detacher",
      "detester",
      "detourer",
      "detresse",
      "devancer",
      "devenir",
      "deviner",
      "devoir",
      "diable",
      "dialogue",
      "diamant",
      "dicter",
      "differer",
      "digerer",
      "digital",
      "digne",
      "diluer",
      "dimanche",
      "diminuer",
      "dioxyde",
      "directif",
      "diriger",
      "discuter",
      "disposer",
      "dissiper",
      "distance",
      "divertir",
      "diviser",
      "docile",
      "docteur",
      "dogme",
      "doigt",
      "domaine",
      "domicile",
      "dompter",
      "donateur",
      "donjon",
      "donner",
      "dopamine",
      "dortoir",
      "dorure",
      "dosage",
      "doseur",
      "dossier",
      "dotation",
      "douanier",
      "double",
      "douceur",
      "douter",
      "doyen",
      "dragon",
      "draper",
      "dresser",
      "dribbler",
      "droiture",
      "duperie",
      "duplexe",
      "durable",
      "durcir",
      "dynastie",
      "eblouir",
      "ecarter",
      "echarpe",
      "echelle",
      "eclairer",
      "eclipse",
      "eclore",
      "ecluse",
      "ecole",
      "economie",
      "ecorce",
      "ecouter",
      "ecraser",
      "ecremer",
      "ecrivain",
      "ecrou",
      "ecume",
      "ecureuil",
      "edifier",
      "eduquer",
      "effacer",
      "effectif",
      "effigie",
      "effort",
      "effrayer",
      "effusion",
      "egaliser",
      "egarer",
      "ejecter",
      "elaborer",
      "elargir",
      "electron",
      "elegant",
      "elephant",
      "eleve",
      "eligible",
      "elitisme",
      "eloge",
      "elucider",
      "eluder",
      "emballer",
      "embellir",
      "embryon",
      "emeraude",
      "emission",
      "emmener",
      "emotion",
      "emouvoir",
      "empereur",
      "employer",
      "emporter",
      "emprise",
      "emulsion",
      "encadrer",
      "enchere",
      "enclave",
      "encoche",
      "endiguer",
      "endosser",
      "endroit",
      "enduire",
      "energie",
      "enfance",
      "enfermer",
      "enfouir",
      "engager",
      "engin",
      "englober",
      "enigme",
      "enjamber",
      "enjeu",
      "enlever",
      "ennemi",
      "ennuyeux",
      "enrichir",
      "enrobage",
      "enseigne",
      "entasser",
      "entendre",
      "entier",
      "entourer",
      "entraver",
      "enumerer",
      "envahir",
      "enviable",
      "envoyer",
      "enzyme",
      "eolien",
      "epaissir",
      "epargne",
      "epatant",
      "epaule",
      "epicerie",
      "epidemie",
      "epier",
      "epilogue",
      "epine",
      "episode",
      "epitaphe",
      "epoque",
      "epreuve",
      "eprouver",
      "epuisant",
      "equerre",
      "equipe",
      "eriger",
      "erosion",
      "erreur",
      "eruption",
      "escalier",
      "espadon",
      "espece",
      "espiegle",
      "espoir",
      "esprit",
      "esquiver",
      "essayer",
      "essence",
      "essieu",
      "essorer",
      "estime",
      "estomac",
      "estrade",
      "etagere",
      "etaler",
      "etanche",
      "etatique",
      "eteindre",
      "etendoir",
      "eternel",
      "ethanol",
      "ethique",
      "ethnie",
      "etirer",
      "etoffer",
      "etoile",
      "etonnant",
      "etourdir",
      "etrange",
      "etroit",
      "etude",
      "euphorie",
      "evaluer",
      "evasion",
      "eventail",
      "evidence",
      "eviter",
      "evolutif",
      "evoquer",
      "exact",
      "exagerer",
      "exaucer",
      "exceller",
      "excitant",
      "exclusif",
      "excuse",
      "executer",
      "exemple",
      "exercer",
      "exhaler",
      "exhorter",
      "exigence",
      "exiler",
      "exister",
      "exotique",
      "expedier",
      "explorer",
      "exposer",
      "exprimer",
      "exquis",
      "extensif",
      "extraire",
      "exulter",
      "fable",
      "fabuleux",
      "facette",
      "facile",
      "facture",
      "faiblir",
      "falaise",
      "fameux",
      "famille",
      "farceur",
      "farfelu",
      "farine",
      "farouche",
      "fasciner",
      "fatal",
      "fatigue",
      "faucon",
      "fautif",
      "faveur",
      "favori",
      "febrile",
      "feconder",
      "federer",
      "felin",
      "femme",
      "femur",
      "fendoir",
      "feodal",
      "fermer",
      "feroce",
      "ferveur",
      "festival",
      "feuille",
      "feutre",
      "fevrier",
      "fiasco",
      "ficeler",
      "fictif",
      "fidele",
      "figure",
      "filature",
      "filetage",
      "filiere",
      "filleul",
      "filmer",
      "filou",
      "filtrer",
      "financer",
      "finir",
      "fiole",
      "firme",
      "fissure",
      "fixer",
      "flairer",
      "flamme",
      "flasque",
      "flatteur",
      "fleau",
      "fleche",
      "fleur",
      "flexion",
      "flocon",
      "flore",
      "fluctuer",
      "fluide",
      "fluvial",
      "folie",
      "fonderie",
      "fongible",
      "fontaine",
      "forcer",
      "forgeron",
      "formuler",
      "fortune",
      "fossile",
      "foudre",
      "fougere",
      "fouiller",
      "foulure",
      "fourmi",
      "fragile",
      "fraise",
      "franchir",
      "frapper",
      "frayeur",
      "fregate",
      "freiner",
      "frelon",
      "fremir",
      "frenesie",
      "frere",
      "friable",
      "friction",
      "frisson",
      "frivole",
      "froid",
      "fromage",
      "frontal",
      "frotter",
      "fruit",
      "fugitif",
      "fuite",
      "fureur",
      "furieux",
      "furtif",
      "fusion",
      "futur",
      "gagner",
      "galaxie",
      "galerie",
      "gambader",
      "garantir",
      "gardien",
      "garnir",
      "garrigue",
      "gazelle",
      "gazon",
      "geant",
      "gelatine",
      "gelule",
      "gendarme",
      "general",
      "genie",
      "genou",
      "gentil",
      "geologie",
      "geometre",
      "geranium",
      "germe",
      "gestuel",
      "geyser",
      "gibier",
      "gicler",
      "girafe",
      "givre",
      "glace",
      "glaive",
      "glisser",
      "globe",
      "gloire",
      "glorieux",
      "golfeur",
      "gomme",
      "gonfler",
      "gorge",
      "gorille",
      "goudron",
      "gouffre",
      "goulot",
      "goupille",
      "gourmand",
      "goutte",
      "graduel",
      "graffiti",
      "graine",
      "grand",
      "grappin",
      "gratuit",
      "gravir",
      "grenat",
      "griffure",
      "griller",
      "grimper",
      "grogner",
      "gronder",
      "grotte",
      "groupe",
      "gruger",
      "grutier",
      "gruyere",
      "guepard",
      "guerrier",
      "guide",
      "guimauve",
      "guitare",
      "gustatif",
      "gymnaste",
      "gyrostat",
      "habitude",
      "hachoir",
      "halte",
      "hameau",
      "hangar",
      "hanneton",
      "haricot",
      "harmonie",
      "harpon",
      "hasard",
      "helium",
      "hematome",
      "herbe",
      "herisson",
      "hermine",
      "heron",
      "hesiter",
      "heureux",
      "hiberner",
      "hibou",
      "hilarant",
      "histoire",
      "hiver",
      "homard",
      "hommage",
      "homogene",
      "honneur",
      "honorer",
      "honteux",
      "horde",
      "horizon",
      "horloge",
      "hormone",
      "horrible",
      "houleux",
      "housse",
      "hublot",
      "huileux",
      "humain",
      "humble",
      "humide",
      "humour",
      "hurler",
      "hydromel",
      "hygiene",
      "hymne",
      "hypnose",
      "idylle",
      "ignorer",
      "iguane",
      "illicite",
      "illusion",
      "image",
      "imbiber",
      "imiter",
      "immense",
      "immobile",
      "immuable",
      "impact",
      "imperial",
      "implorer",
      "imposer",
      "imprimer",
      "imputer",
      "incarner",
      "incendie",
      "incident",
      "incliner",
      "incolore",
      "indexer",
      "indice",
      "inductif",
      "inedit",
      "ineptie",
      "inexact",
      "infini",
      "infliger",
      "informer",
      "infusion",
      "ingerer",
      "inhaler",
      "inhiber",
      "injecter",
      "injure",
      "innocent",
      "inoculer",
      "inonder",
      "inscrire",
      "insecte",
      "insigne",
      "insolite",
      "inspirer",
      "instinct",
      "insulter",
      "intact",
      "intense",
      "intime",
      "intrigue",
      "intuitif",
      "inutile",
      "invasion",
      "inventer",
      "inviter",
      "invoquer",
      "ironique",
      "irradier",
      "irreel",
      "irriter",
      "isoler",
      "ivoire",
      "ivresse",
      "jaguar",
      "jaillir",
      "jambe",
      "janvier",
      "jardin",
      "jauger",
      "jaune",
      "javelot",
      "jetable",
      "jeton",
      "jeudi",
      "jeunesse",
      "joindre",
      "joncher",
      "jongler",
      "joueur",
      "jouissif",
      "journal",
      "jovial",
      "joyau",
      "joyeux",
      "jubiler",
      "jugement",
      "junior",
      "jupon",
      "juriste",
      "justice",
      "juteux",
      "juvenile",
      "kayak",
      "kimono",
      "kiosque",
      "label",
      "labial",
      "labourer",
      "lacerer",
      "lactose",
      "lagune",
      "laine",
      "laisser",
      "laitier",
      "lambeau",
      "lamelle",
      "lampe",
      "lanceur",
      "langage",
      "lanterne",
      "lapin",
      "largeur",
      "larme",
      "laurier",
      "lavabo",
      "lavoir",
      "lecture",
      "legal",
      "leger",
      "legume",
      "lessive",
      "lettre",
      "levier",
      "lexique",
      "lezard",
      "liasse",
      "liberer",
      "libre",
      "licence",
      "licorne",
      "liege",
      "lievre",
      "ligature",
      "ligoter",
      "ligue",
      "limer",
      "limite",
      "limonade",
      "limpide",
      "lineaire",
      "lingot",
      "lionceau",
      "liquide",
      "lisiere",
      "lister",
      "lithium",
      "litige",
      "littoral",
      "livreur",
      "logique",
      "lointain",
      "loisir",
      "lombric",
      "loterie",
      "louer",
      "lourd",
      "loutre",
      "louve",
      "loyal",
      "lubie",
      "lucide",
      "lucratif",
      "lueur",
      "lugubre",
      "luisant",
      "lumiere",
      "lunaire",
      "lundi",
      "luron",
      "lutter",
      "luxueux",
      "machine",
      "magasin",
      "magenta",
      "magique",
      "maigre",
      "maillon",
      "maintien",
      "mairie",
      "maison",
      "majorer",
      "malaxer",
      "malefice",
      "malheur",
      "malice",
      "mallette",
      "mammouth",
      "mandater",
      "maniable",
      "manquant",
      "manteau",
      "manuel",
      "marathon",
      "marbre",
      "marchand",
      "mardi",
      "maritime",
      "marqueur",
      "marron",
      "marteler",
      "mascotte",
      "massif",
      "materiel",
      "matiere",
      "matraque",
      "maudire",
      "maussade",
      "mauve",
      "maximal",
      "mechant",
      "meconnu",
      "medaille",
      "medecin",
      "mediter",
      "meduse",
      "meilleur",
      "melange",
      "melodie",
      "membre",
      "memoire",
      "menacer",
      "mener",
      "menhir",
      "mensonge",
      "mentor",
      "mercredi",
      "merite",
      "merle",
      "messager",
      "mesure",
      "metal",
      "meteore",
      "methode",
      "metier",
      "meuble",
      "miauler",
      "microbe",
      "miette",
      "mignon",
      "migrer",
      "milieu",
      "million",
      "mimique",
      "mince",
      "mineral",
      "minimal",
      "minorer",
      "minute",
      "miracle",
      "miroiter",
      "missile",
      "mixte",
      "mobile",
      "moderne",
      "moelleux",
      "mondial",
      "moniteur",
      "monnaie",
      "monotone",
      "monstre",
      "montagne",
      "monument",
      "moqueur",
      "morceau",
      "morsure",
      "mortier",
      "moteur",
      "motif",
      "mouche",
      "moufle",
      "moulin",
      "mousson",
      "mouton",
      "mouvant",
      "multiple",
      "munition",
      "muraille",
      "murene",
      "murmure",
      "muscle",
      "museum",
      "musicien",
      "mutation",
      "muter",
      "mutuel",
      "myriade",
      "myrtille",
      "mystere",
      "mythique",
      "nageur",
      "nappe",
      "narquois",
      "narrer",
      "natation",
      "nation",
      "nature",
      "naufrage",
      "nautique",
      "navire",
      "nebuleux",
      "nectar",
      "nefaste",
      "negation",
      "negliger",
      "negocier",
      "neige",
      "nerveux",
      "nettoyer",
      "neurone",
      "neutron",
      "neveu",
      "niche",
      "nickel",
      "nitrate",
      "niveau",
      "noble",
      "nocif",
      "nocturne",
      "noirceur",
      "noisette",
      "nomade",
      "nombreux",
      "nommer",
      "normatif",
      "notable",
      "notifier",
      "notoire",
      "nourrir",
      "nouveau",
      "novateur",
      "novembre",
      "novice",
      "nuage",
      "nuancer",
      "nuire",
      "nuisible",
      "numero",
      "nuptial",
      "nuque",
      "nutritif",
      "obeir",
      "objectif",
      "obliger",
      "obscur",
      "observer",
      "obstacle",
      "obtenir",
      "obturer",
      "occasion",
      "occuper",
      "ocean",
      "octobre",
      "octroyer",
      "octupler",
      "oculaire",
      "odeur",
      "odorant",
      "offenser",
      "officier",
      "offrir",
      "ogive",
      "oiseau",
      "oisillon",
      "olfactif",
      "olivier",
      "ombrage",
      "omettre",
      "onctueux",
      "onduler",
      "onereux",
      "onirique",
      "opale",
      "opaque",
      "operer",
      "opinion",
      "opportun",
      "opprimer",
      "opter",
      "optique",
      "orageux",
      "orange",
      "orbite",
      "ordonner",
      "oreille",
      "organe",
      "orgueil",
      "orifice",
      "ornement",
      "orque",
      "ortie",
      "osciller",
      "osmose",
      "ossature",
      "otarie",
      "ouragan",
      "ourson",
      "outil",
      "outrager",
      "ouvrage",
      "ovation",
      "oxyde",
      "oxygene",
      "ozone",
      "paisible",
      "palace",
      "palmares",
      "palourde",
      "palper",
      "panache",
      "panda",
      "pangolin",
      "paniquer",
      "panneau",
      "panorama",
      "pantalon",
      "papaye",
      "papier",
      "papoter",
      "papyrus",
      "paradoxe",
      "parcelle",
      "paresse",
      "parfumer",
      "parler",
      "parole",
      "parrain",
      "parsemer",
      "partager",
      "parure",
      "parvenir",
      "passion",
      "pasteque",
      "paternel",
      "patience",
      "patron",
      "pavillon",
      "pavoiser",
      "payer",
      "paysage",
      "peigne",
      "peintre",
      "pelage",
      "pelican",
      "pelle",
      "pelouse",
      "peluche",
      "pendule",
      "penetrer",
      "penible",
      "pensif",
      "penurie",
      "pepite",
      "peplum",
      "perdrix",
      "perforer",
      "periode",
      "permuter",
      "perplexe",
      "persil",
      "perte",
      "peser",
      "petale",
      "petit",
      "petrir",
      "peuple",
      "pharaon",
      "phobie",
      "phoque",
      "photon",
      "phrase",
      "physique",
      "piano",
      "pictural",
      "piece",
      "pierre",
      "pieuvre",
      "pilote",
      "pinceau",
      "pipette",
      "piquer",
      "pirogue",
      "piscine",
      "piston",
      "pivoter",
      "pixel",
      "pizza",
      "placard",
      "plafond",
      "plaisir",
      "planer",
      "plaque",
      "plastron",
      "plateau",
      "pleurer",
      "plexus",
      "pliage",
      "plomb",
      "plonger",
      "pluie",
      "plumage",
      "pochette",
      "poesie",
      "poete",
      "pointe",
      "poirier",
      "poisson",
      "poivre",
      "polaire",
      "policier",
      "pollen",
      "polygone",
      "pommade",
      "pompier",
      "ponctuel",
      "ponderer",
      "poney",
      "portique",
      "position",
      "posseder",
      "posture",
      "potager",
      "poteau",
      "potion",
      "pouce",
      "poulain",
      "poumon",
      "pourpre",
      "poussin",
      "pouvoir",
      "prairie",
      "pratique",
      "precieux",
      "predire",
      "prefixe",
      "prelude",
      "prenom",
      "presence",
      "pretexte",
      "prevoir",
      "primitif",
      "prince",
      "prison",
      "priver",
      "probleme",
      "proceder",
      "prodige",
      "profond",
      "progres",
      "proie",
      "projeter",
      "prologue",
      "promener",
      "propre",
      "prospere",
      "proteger",
      "prouesse",
      "proverbe",
      "prudence",
      "pruneau",
      "psychose",
      "public",
      "puceron",
      "puiser",
      "pulpe",
      "pulsar",
      "punaise",
      "punitif",
      "pupitre",
      "purifier",
      "puzzle",
      "pyramide",
      "quasar",
      "querelle",
      "question",
      "quietude",
      "quitter",
      "quotient",
      "racine",
      "raconter",
      "radieux",
      "ragondin",
      "raideur",
      "raisin",
      "ralentir",
      "rallonge",
      "ramasser",
      "rapide",
      "rasage",
      "ratisser",
      "ravager",
      "ravin",
      "rayonner",
      "reactif",
      "reagir",
      "realiser",
      "reanimer",
      "recevoir",
      "reciter",
      "reclamer",
      "recolter",
      "recruter",
      "reculer",
      "recycler",
      "rediger",
      "redouter",
      "refaire",
      "reflexe",
      "reformer",
      "refrain",
      "refuge",
      "regalien",
      "region",
      "reglage",
      "regulier",
      "reiterer",
      "rejeter",
      "rejouer",
      "relatif",
      "relever",
      "relief",
      "remarque",
      "remede",
      "remise",
      "remonter",
      "remplir",
      "remuer",
      "renard",
      "renfort",
      "renifler",
      "renoncer",
      "rentrer",
      "renvoi",
      "replier",
      "reporter",
      "reprise",
      "reptile",
      "requin",
      "reserve",
      "resineux",
      "resoudre",
      "respect",
      "rester",
      "resultat",
      "retablir",
      "retenir",
      "reticule",
      "retomber",
      "retracer",
      "reunion",
      "reussir",
      "revanche",
      "revivre",
      "revolte",
      "revulsif",
      "richesse",
      "rideau",
      "rieur",
      "rigide",
      "rigoler",
      "rincer",
      "riposter",
      "risible",
      "risque",
      "rituel",
      "rival",
      "riviere",
      "rocheux",
      "romance",
      "rompre",
      "ronce",
      "rondin",
      "roseau",
      "rosier",
      "rotatif",
      "rotor",
      "rotule",
      "rouge",
      "rouille",
      "rouleau",
      "routine",
      "royaume",
      "ruban",
      "rubis",
      "ruche",
      "ruelle",
      "rugueux",
      "ruiner",
      "ruisseau",
      "ruser",
      "rustique",
      "rythme",
      "sabler",
      "saboter",
      "sabre",
      "sacoche",
      "safari",
      "sagesse",
      "saisir",
      "salade",
      "salive",
      "salon",
      "saluer",
      "samedi",
      "sanction",
      "sanglier",
      "sarcasme",
      "sardine",
      "saturer",
      "saugrenu",
      "saumon",
      "sauter",
      "sauvage",
      "savant",
      "savonner",
      "scalpel",
      "scandale",
      "scelerat",
      "scenario",
      "sceptre",
      "schema",
      "science",
      "scinder",
      "score",
      "scrutin",
      "sculpter",
      "seance",
      "secable",
      "secher",
      "secouer",
      "secreter",
      "sedatif",
      "seduire",
      "seigneur",
      "sejour",
      "selectif",
      "semaine",
      "sembler",
      "semence",
      "seminal",
      "senateur",
      "sensible",
      "sentence",
      "separer",
      "sequence",
      "serein",
      "sergent",
      "serieux",
      "serrure",
      "serum",
      "service",
      "sesame",
      "sevir",
      "sevrage",
      "sextuple",
      "sideral",
      "siecle",
      "sieger",
      "siffler",
      "sigle",
      "signal",
      "silence",
      "silicium",
      "simple",
      "sincere",
      "sinistre",
      "siphon",
      "sirop",
      "sismique",
      "situer",
      "skier",
      "social",
      "socle",
      "sodium",
      "soigneux",
      "soldat",
      "soleil",
      "solitude",
      "soluble",
      "sombre",
      "sommeil",
      "somnoler",
      "sonde",
      "songeur",
      "sonnette",
      "sonore",
      "sorcier",
      "sortir",
      "sosie",
      "sottise",
      "soucieux",
      "soudure",
      "souffle",
      "soulever",
      "soupape",
      "source",
      "soutirer",
      "souvenir",
      "spacieux",
      "spatial",
      "special",
      "sphere",
      "spiral",
      "stable",
      "station",
      "sternum",
      "stimulus",
      "stipuler",
      "strict",
      "studieux",
      "stupeur",
      "styliste",
      "sublime",
      "substrat",
      "subtil",
      "subvenir",
      "succes",
      "sucre",
      "suffixe",
      "suggerer",
      "suiveur",
      "sulfate",
      "superbe",
      "supplier",
      "surface",
      "suricate",
      "surmener",
      "surprise",
      "sursaut",
      "survie",
      "suspect",
      "syllabe",
      "symbole",
      "symetrie",
      "synapse",
      "syntaxe",
      "systeme",
      "tabac",
      "tablier",
      "tactile",
      "tailler",
      "talent",
      "talisman",
      "talonner",
      "tambour",
      "tamiser",
      "tangible",
      "tapis",
      "taquiner",
      "tarder",
      "tarif",
      "tartine",
      "tasse",
      "tatami",
      "tatouage",
      "taupe",
      "taureau",
      "taxer",
      "temoin",
      "temporel",
      "tenaille",
      "tendre",
      "teneur",
      "tenir",
      "tension",
      "terminer",
      "terne",
      "terrible",
      "tetine",
      "texte",
      "theme",
      "theorie",
      "therapie",
      "thorax",
      "tibia",
      "tiede",
      "timide",
      "tirelire",
      "tiroir",
      "tissu",
      "titane",
      "titre",
      "tituber",
      "toboggan",
      "tolerant",
      "tomate",
      "tonique",
      "tonneau",
      "toponyme",
      "torche",
      "tordre",
      "tornade",
      "torpille",
      "torrent",
      "torse",
      "tortue",
      "totem",
      "toucher",
      "tournage",
      "tousser",
      "toxine",
      "traction",
      "trafic",
      "tragique",
      "trahir",
      "train",
      "trancher",
      "travail",
      "trefle",
      "tremper",
      "tresor",
      "treuil",
      "triage",
      "tribunal",
      "tricoter",
      "trilogie",
      "triomphe",
      "tripler",
      "triturer",
      "trivial",
      "trombone",
      "tronc",
      "tropical",
      "troupeau",
      "tuile",
      "tulipe",
      "tumulte",
      "tunnel",
      "turbine",
      "tuteur",
      "tutoyer",
      "tuyau",
      "tympan",
      "typhon",
      "typique",
      "tyran",
      "ubuesque",
      "ultime",
      "ultrason",
      "unanime",
      "unifier",
      "union",
      "unique",
      "unitaire",
      "univers",
      "uranium",
      "urbain",
      "urticant",
      "usage",
      "usine",
      "usuel",
      "usure",
      "utile",
      "utopie",
      "vacarme",
      "vaccin",
      "vagabond",
      "vague",
      "vaillant",
      "vaincre",
      "vaisseau",
      "valable",
      "valise",
      "vallon",
      "valve",
      "vampire",
      "vanille",
      "vapeur",
      "varier",
      "vaseux",
      "vassal",
      "vaste",
      "vecteur",
      "vedette",
      "vegetal",
      "vehicule",
      "veinard",
      "veloce",
      "vendredi",
      "venerer",
      "venger",
      "venimeux",
      "ventouse",
      "verdure",
      "verin",
      "vernir",
      "verrou",
      "verser",
      "vertu",
      "veston",
      "veteran",
      "vetuste",
      "vexant",
      "vexer",
      "viaduc",
      "viande",
      "victoire",
      "vidange",
      "video",
      "vignette",
      "vigueur",
      "vilain",
      "village",
      "vinaigre",
      "violon",
      "vipere",
      "virement",
      "virtuose",
      "virus",
      "visage",
      "viseur",
      "vision",
      "visqueux",
      "visuel",
      "vital",
      "vitesse",
      "viticole",
      "vitrine",
      "vivace",
      "vivipare",
      "vocation",
      "voguer",
      "voile",
      "voisin",
      "voiture",
      "volaille",
      "volcan",
      "voltiger",
      "volume",
      "vorace",
      "vortex",
      "voter",
      "vouloir",
      "voyage",
      "voyelle",
      "wagon",
      "xenon",
      "yacht",
      "zebre",
      "zenith",
      "zeste",
      "zoologie"
    ];
  }
});

// ../../node_modules/.pnpm/bip39@3.1.0/node_modules/bip39/src/wordlists/italian.json
var require_italian = __commonJS({
  "../../node_modules/.pnpm/bip39@3.1.0/node_modules/bip39/src/wordlists/italian.json"(exports, module) {
    module.exports = [
      "abaco",
      "abbaglio",
      "abbinato",
      "abete",
      "abisso",
      "abolire",
      "abrasivo",
      "abrogato",
      "accadere",
      "accenno",
      "accusato",
      "acetone",
      "achille",
      "acido",
      "acqua",
      "acre",
      "acrilico",
      "acrobata",
      "acuto",
      "adagio",
      "addebito",
      "addome",
      "adeguato",
      "aderire",
      "adipe",
      "adottare",
      "adulare",
      "affabile",
      "affetto",
      "affisso",
      "affranto",
      "aforisma",
      "afoso",
      "africano",
      "agave",
      "agente",
      "agevole",
      "aggancio",
      "agire",
      "agitare",
      "agonismo",
      "agricolo",
      "agrumeto",
      "aguzzo",
      "alabarda",
      "alato",
      "albatro",
      "alberato",
      "albo",
      "albume",
      "alce",
      "alcolico",
      "alettone",
      "alfa",
      "algebra",
      "aliante",
      "alibi",
      "alimento",
      "allagato",
      "allegro",
      "allievo",
      "allodola",
      "allusivo",
      "almeno",
      "alogeno",
      "alpaca",
      "alpestre",
      "altalena",
      "alterno",
      "alticcio",
      "altrove",
      "alunno",
      "alveolo",
      "alzare",
      "amalgama",
      "amanita",
      "amarena",
      "ambito",
      "ambrato",
      "ameba",
      "america",
      "ametista",
      "amico",
      "ammasso",
      "ammenda",
      "ammirare",
      "ammonito",
      "amore",
      "ampio",
      "ampliare",
      "amuleto",
      "anacardo",
      "anagrafe",
      "analista",
      "anarchia",
      "anatra",
      "anca",
      "ancella",
      "ancora",
      "andare",
      "andrea",
      "anello",
      "angelo",
      "angolare",
      "angusto",
      "anima",
      "annegare",
      "annidato",
      "anno",
      "annuncio",
      "anonimo",
      "anticipo",
      "anzi",
      "apatico",
      "apertura",
      "apode",
      "apparire",
      "appetito",
      "appoggio",
      "approdo",
      "appunto",
      "aprile",
      "arabica",
      "arachide",
      "aragosta",
      "araldica",
      "arancio",
      "aratura",
      "arazzo",
      "arbitro",
      "archivio",
      "ardito",
      "arenile",
      "argento",
      "argine",
      "arguto",
      "aria",
      "armonia",
      "arnese",
      "arredato",
      "arringa",
      "arrosto",
      "arsenico",
      "arso",
      "artefice",
      "arzillo",
      "asciutto",
      "ascolto",
      "asepsi",
      "asettico",
      "asfalto",
      "asino",
      "asola",
      "aspirato",
      "aspro",
      "assaggio",
      "asse",
      "assoluto",
      "assurdo",
      "asta",
      "astenuto",
      "astice",
      "astratto",
      "atavico",
      "ateismo",
      "atomico",
      "atono",
      "attesa",
      "attivare",
      "attorno",
      "attrito",
      "attuale",
      "ausilio",
      "austria",
      "autista",
      "autonomo",
      "autunno",
      "avanzato",
      "avere",
      "avvenire",
      "avviso",
      "avvolgere",
      "azione",
      "azoto",
      "azzimo",
      "azzurro",
      "babele",
      "baccano",
      "bacino",
      "baco",
      "badessa",
      "badilata",
      "bagnato",
      "baita",
      "balcone",
      "baldo",
      "balena",
      "ballata",
      "balzano",
      "bambino",
      "bandire",
      "baraonda",
      "barbaro",
      "barca",
      "baritono",
      "barlume",
      "barocco",
      "basilico",
      "basso",
      "batosta",
      "battuto",
      "baule",
      "bava",
      "bavosa",
      "becco",
      "beffa",
      "belgio",
      "belva",
      "benda",
      "benevole",
      "benigno",
      "benzina",
      "bere",
      "berlina",
      "beta",
      "bibita",
      "bici",
      "bidone",
      "bifido",
      "biga",
      "bilancia",
      "bimbo",
      "binocolo",
      "biologo",
      "bipede",
      "bipolare",
      "birbante",
      "birra",
      "biscotto",
      "bisesto",
      "bisnonno",
      "bisonte",
      "bisturi",
      "bizzarro",
      "blando",
      "blatta",
      "bollito",
      "bonifico",
      "bordo",
      "bosco",
      "botanico",
      "bottino",
      "bozzolo",
      "braccio",
      "bradipo",
      "brama",
      "branca",
      "bravura",
      "bretella",
      "brevetto",
      "brezza",
      "briglia",
      "brillante",
      "brindare",
      "broccolo",
      "brodo",
      "bronzina",
      "brullo",
      "bruno",
      "bubbone",
      "buca",
      "budino",
      "buffone",
      "buio",
      "bulbo",
      "buono",
      "burlone",
      "burrasca",
      "bussola",
      "busta",
      "cadetto",
      "caduco",
      "calamaro",
      "calcolo",
      "calesse",
      "calibro",
      "calmo",
      "caloria",
      "cambusa",
      "camerata",
      "camicia",
      "cammino",
      "camola",
      "campale",
      "canapa",
      "candela",
      "cane",
      "canino",
      "canotto",
      "cantina",
      "capace",
      "capello",
      "capitolo",
      "capogiro",
      "cappero",
      "capra",
      "capsula",
      "carapace",
      "carcassa",
      "cardo",
      "carisma",
      "carovana",
      "carretto",
      "cartolina",
      "casaccio",
      "cascata",
      "caserma",
      "caso",
      "cassone",
      "castello",
      "casuale",
      "catasta",
      "catena",
      "catrame",
      "cauto",
      "cavillo",
      "cedibile",
      "cedrata",
      "cefalo",
      "celebre",
      "cellulare",
      "cena",
      "cenone",
      "centesimo",
      "ceramica",
      "cercare",
      "certo",
      "cerume",
      "cervello",
      "cesoia",
      "cespo",
      "ceto",
      "chela",
      "chiaro",
      "chicca",
      "chiedere",
      "chimera",
      "china",
      "chirurgo",
      "chitarra",
      "ciao",
      "ciclismo",
      "cifrare",
      "cigno",
      "cilindro",
      "ciottolo",
      "circa",
      "cirrosi",
      "citrico",
      "cittadino",
      "ciuffo",
      "civetta",
      "civile",
      "classico",
      "clinica",
      "cloro",
      "cocco",
      "codardo",
      "codice",
      "coerente",
      "cognome",
      "collare",
      "colmato",
      "colore",
      "colposo",
      "coltivato",
      "colza",
      "coma",
      "cometa",
      "commando",
      "comodo",
      "computer",
      "comune",
      "conciso",
      "condurre",
      "conferma",
      "congelare",
      "coniuge",
      "connesso",
      "conoscere",
      "consumo",
      "continuo",
      "convegno",
      "coperto",
      "copione",
      "coppia",
      "copricapo",
      "corazza",
      "cordata",
      "coricato",
      "cornice",
      "corolla",
      "corpo",
      "corredo",
      "corsia",
      "cortese",
      "cosmico",
      "costante",
      "cottura",
      "covato",
      "cratere",
      "cravatta",
      "creato",
      "credere",
      "cremoso",
      "crescita",
      "creta",
      "criceto",
      "crinale",
      "crisi",
      "critico",
      "croce",
      "cronaca",
      "crostata",
      "cruciale",
      "crusca",
      "cucire",
      "cuculo",
      "cugino",
      "cullato",
      "cupola",
      "curatore",
      "cursore",
      "curvo",
      "cuscino",
      "custode",
      "dado",
      "daino",
      "dalmata",
      "damerino",
      "daniela",
      "dannoso",
      "danzare",
      "datato",
      "davanti",
      "davvero",
      "debutto",
      "decennio",
      "deciso",
      "declino",
      "decollo",
      "decreto",
      "dedicato",
      "definito",
      "deforme",
      "degno",
      "delegare",
      "delfino",
      "delirio",
      "delta",
      "demenza",
      "denotato",
      "dentro",
      "deposito",
      "derapata",
      "derivare",
      "deroga",
      "descritto",
      "deserto",
      "desiderio",
      "desumere",
      "detersivo",
      "devoto",
      "diametro",
      "dicembre",
      "diedro",
      "difeso",
      "diffuso",
      "digerire",
      "digitale",
      "diluvio",
      "dinamico",
      "dinnanzi",
      "dipinto",
      "diploma",
      "dipolo",
      "diradare",
      "dire",
      "dirotto",
      "dirupo",
      "disagio",
      "discreto",
      "disfare",
      "disgelo",
      "disposto",
      "distanza",
      "disumano",
      "dito",
      "divano",
      "divelto",
      "dividere",
      "divorato",
      "doblone",
      "docente",
      "doganale",
      "dogma",
      "dolce",
      "domato",
      "domenica",
      "dominare",
      "dondolo",
      "dono",
      "dormire",
      "dote",
      "dottore",
      "dovuto",
      "dozzina",
      "drago",
      "druido",
      "dubbio",
      "dubitare",
      "ducale",
      "duna",
      "duomo",
      "duplice",
      "duraturo",
      "ebano",
      "eccesso",
      "ecco",
      "eclissi",
      "economia",
      "edera",
      "edicola",
      "edile",
      "editoria",
      "educare",
      "egemonia",
      "egli",
      "egoismo",
      "egregio",
      "elaborato",
      "elargire",
      "elegante",
      "elencato",
      "eletto",
      "elevare",
      "elfico",
      "elica",
      "elmo",
      "elsa",
      "eluso",
      "emanato",
      "emblema",
      "emesso",
      "emiro",
      "emotivo",
      "emozione",
      "empirico",
      "emulo",
      "endemico",
      "enduro",
      "energia",
      "enfasi",
      "enoteca",
      "entrare",
      "enzima",
      "epatite",
      "epilogo",
      "episodio",
      "epocale",
      "eppure",
      "equatore",
      "erario",
      "erba",
      "erboso",
      "erede",
      "eremita",
      "erigere",
      "ermetico",
      "eroe",
      "erosivo",
      "errante",
      "esagono",
      "esame",
      "esanime",
      "esaudire",
      "esca",
      "esempio",
      "esercito",
      "esibito",
      "esigente",
      "esistere",
      "esito",
      "esofago",
      "esortato",
      "esoso",
      "espanso",
      "espresso",
      "essenza",
      "esso",
      "esteso",
      "estimare",
      "estonia",
      "estroso",
      "esultare",
      "etilico",
      "etnico",
      "etrusco",
      "etto",
      "euclideo",
      "europa",
      "evaso",
      "evidenza",
      "evitato",
      "evoluto",
      "evviva",
      "fabbrica",
      "faccenda",
      "fachiro",
      "falco",
      "famiglia",
      "fanale",
      "fanfara",
      "fango",
      "fantasma",
      "fare",
      "farfalla",
      "farinoso",
      "farmaco",
      "fascia",
      "fastoso",
      "fasullo",
      "faticare",
      "fato",
      "favoloso",
      "febbre",
      "fecola",
      "fede",
      "fegato",
      "felpa",
      "feltro",
      "femmina",
      "fendere",
      "fenomeno",
      "fermento",
      "ferro",
      "fertile",
      "fessura",
      "festivo",
      "fetta",
      "feudo",
      "fiaba",
      "fiducia",
      "fifa",
      "figurato",
      "filo",
      "finanza",
      "finestra",
      "finire",
      "fiore",
      "fiscale",
      "fisico",
      "fiume",
      "flacone",
      "flamenco",
      "flebo",
      "flemma",
      "florido",
      "fluente",
      "fluoro",
      "fobico",
      "focaccia",
      "focoso",
      "foderato",
      "foglio",
      "folata",
      "folclore",
      "folgore",
      "fondente",
      "fonetico",
      "fonia",
      "fontana",
      "forbito",
      "forchetta",
      "foresta",
      "formica",
      "fornaio",
      "foro",
      "fortezza",
      "forzare",
      "fosfato",
      "fosso",
      "fracasso",
      "frana",
      "frassino",
      "fratello",
      "freccetta",
      "frenata",
      "fresco",
      "frigo",
      "frollino",
      "fronde",
      "frugale",
      "frutta",
      "fucilata",
      "fucsia",
      "fuggente",
      "fulmine",
      "fulvo",
      "fumante",
      "fumetto",
      "fumoso",
      "fune",
      "funzione",
      "fuoco",
      "furbo",
      "furgone",
      "furore",
      "fuso",
      "futile",
      "gabbiano",
      "gaffe",
      "galateo",
      "gallina",
      "galoppo",
      "gambero",
      "gamma",
      "garanzia",
      "garbo",
      "garofano",
      "garzone",
      "gasdotto",
      "gasolio",
      "gastrico",
      "gatto",
      "gaudio",
      "gazebo",
      "gazzella",
      "geco",
      "gelatina",
      "gelso",
      "gemello",
      "gemmato",
      "gene",
      "genitore",
      "gennaio",
      "genotipo",
      "gergo",
      "ghepardo",
      "ghiaccio",
      "ghisa",
      "giallo",
      "gilda",
      "ginepro",
      "giocare",
      "gioiello",
      "giorno",
      "giove",
      "girato",
      "girone",
      "gittata",
      "giudizio",
      "giurato",
      "giusto",
      "globulo",
      "glutine",
      "gnomo",
      "gobba",
      "golf",
      "gomito",
      "gommone",
      "gonfio",
      "gonna",
      "governo",
      "gracile",
      "grado",
      "grafico",
      "grammo",
      "grande",
      "grattare",
      "gravoso",
      "grazia",
      "greca",
      "gregge",
      "grifone",
      "grigio",
      "grinza",
      "grotta",
      "gruppo",
      "guadagno",
      "guaio",
      "guanto",
      "guardare",
      "gufo",
      "guidare",
      "ibernato",
      "icona",
      "identico",
      "idillio",
      "idolo",
      "idra",
      "idrico",
      "idrogeno",
      "igiene",
      "ignaro",
      "ignorato",
      "ilare",
      "illeso",
      "illogico",
      "illudere",
      "imballo",
      "imbevuto",
      "imbocco",
      "imbuto",
      "immane",
      "immerso",
      "immolato",
      "impacco",
      "impeto",
      "impiego",
      "importo",
      "impronta",
      "inalare",
      "inarcare",
      "inattivo",
      "incanto",
      "incendio",
      "inchino",
      "incisivo",
      "incluso",
      "incontro",
      "incrocio",
      "incubo",
      "indagine",
      "india",
      "indole",
      "inedito",
      "infatti",
      "infilare",
      "inflitto",
      "ingaggio",
      "ingegno",
      "inglese",
      "ingordo",
      "ingrosso",
      "innesco",
      "inodore",
      "inoltrare",
      "inondato",
      "insano",
      "insetto",
      "insieme",
      "insonnia",
      "insulina",
      "intasato",
      "intero",
      "intonaco",
      "intuito",
      "inumidire",
      "invalido",
      "invece",
      "invito",
      "iperbole",
      "ipnotico",
      "ipotesi",
      "ippica",
      "iride",
      "irlanda",
      "ironico",
      "irrigato",
      "irrorare",
      "isolato",
      "isotopo",
      "isterico",
      "istituto",
      "istrice",
      "italia",
      "iterare",
      "labbro",
      "labirinto",
      "lacca",
      "lacerato",
      "lacrima",
      "lacuna",
      "laddove",
      "lago",
      "lampo",
      "lancetta",
      "lanterna",
      "lardoso",
      "larga",
      "laringe",
      "lastra",
      "latenza",
      "latino",
      "lattuga",
      "lavagna",
      "lavoro",
      "legale",
      "leggero",
      "lembo",
      "lentezza",
      "lenza",
      "leone",
      "lepre",
      "lesivo",
      "lessato",
      "lesto",
      "letterale",
      "leva",
      "levigato",
      "libero",
      "lido",
      "lievito",
      "lilla",
      "limatura",
      "limitare",
      "limpido",
      "lineare",
      "lingua",
      "liquido",
      "lira",
      "lirica",
      "lisca",
      "lite",
      "litigio",
      "livrea",
      "locanda",
      "lode",
      "logica",
      "lombare",
      "londra",
      "longevo",
      "loquace",
      "lorenzo",
      "loto",
      "lotteria",
      "luce",
      "lucidato",
      "lumaca",
      "luminoso",
      "lungo",
      "lupo",
      "luppolo",
      "lusinga",
      "lusso",
      "lutto",
      "macabro",
      "macchina",
      "macero",
      "macinato",
      "madama",
      "magico",
      "maglia",
      "magnete",
      "magro",
      "maiolica",
      "malafede",
      "malgrado",
      "malinteso",
      "malsano",
      "malto",
      "malumore",
      "mana",
      "mancia",
      "mandorla",
      "mangiare",
      "manifesto",
      "mannaro",
      "manovra",
      "mansarda",
      "mantide",
      "manubrio",
      "mappa",
      "maratona",
      "marcire",
      "maretta",
      "marmo",
      "marsupio",
      "maschera",
      "massaia",
      "mastino",
      "materasso",
      "matricola",
      "mattone",
      "maturo",
      "mazurca",
      "meandro",
      "meccanico",
      "mecenate",
      "medesimo",
      "meditare",
      "mega",
      "melassa",
      "melis",
      "melodia",
      "meninge",
      "meno",
      "mensola",
      "mercurio",
      "merenda",
      "merlo",
      "meschino",
      "mese",
      "messere",
      "mestolo",
      "metallo",
      "metodo",
      "mettere",
      "miagolare",
      "mica",
      "micelio",
      "michele",
      "microbo",
      "midollo",
      "miele",
      "migliore",
      "milano",
      "milite",
      "mimosa",
      "minerale",
      "mini",
      "minore",
      "mirino",
      "mirtillo",
      "miscela",
      "missiva",
      "misto",
      "misurare",
      "mitezza",
      "mitigare",
      "mitra",
      "mittente",
      "mnemonico",
      "modello",
      "modifica",
      "modulo",
      "mogano",
      "mogio",
      "mole",
      "molosso",
      "monastero",
      "monco",
      "mondina",
      "monetario",
      "monile",
      "monotono",
      "monsone",
      "montato",
      "monviso",
      "mora",
      "mordere",
      "morsicato",
      "mostro",
      "motivato",
      "motosega",
      "motto",
      "movenza",
      "movimento",
      "mozzo",
      "mucca",
      "mucosa",
      "muffa",
      "mughetto",
      "mugnaio",
      "mulatto",
      "mulinello",
      "multiplo",
      "mummia",
      "munto",
      "muovere",
      "murale",
      "musa",
      "muscolo",
      "musica",
      "mutevole",
      "muto",
      "nababbo",
      "nafta",
      "nanometro",
      "narciso",
      "narice",
      "narrato",
      "nascere",
      "nastrare",
      "naturale",
      "nautica",
      "naviglio",
      "nebulosa",
      "necrosi",
      "negativo",
      "negozio",
      "nemmeno",
      "neofita",
      "neretto",
      "nervo",
      "nessuno",
      "nettuno",
      "neutrale",
      "neve",
      "nevrotico",
      "nicchia",
      "ninfa",
      "nitido",
      "nobile",
      "nocivo",
      "nodo",
      "nome",
      "nomina",
      "nordico",
      "normale",
      "norvegese",
      "nostrano",
      "notare",
      "notizia",
      "notturno",
      "novella",
      "nucleo",
      "nulla",
      "numero",
      "nuovo",
      "nutrire",
      "nuvola",
      "nuziale",
      "oasi",
      "obbedire",
      "obbligo",
      "obelisco",
      "oblio",
      "obolo",
      "obsoleto",
      "occasione",
      "occhio",
      "occidente",
      "occorrere",
      "occultare",
      "ocra",
      "oculato",
      "odierno",
      "odorare",
      "offerta",
      "offrire",
      "offuscato",
      "oggetto",
      "oggi",
      "ognuno",
      "olandese",
      "olfatto",
      "oliato",
      "oliva",
      "ologramma",
      "oltre",
      "omaggio",
      "ombelico",
      "ombra",
      "omega",
      "omissione",
      "ondoso",
      "onere",
      "onice",
      "onnivoro",
      "onorevole",
      "onta",
      "operato",
      "opinione",
      "opposto",
      "oracolo",
      "orafo",
      "ordine",
      "orecchino",
      "orefice",
      "orfano",
      "organico",
      "origine",
      "orizzonte",
      "orma",
      "ormeggio",
      "ornativo",
      "orologio",
      "orrendo",
      "orribile",
      "ortensia",
      "ortica",
      "orzata",
      "orzo",
      "osare",
      "oscurare",
      "osmosi",
      "ospedale",
      "ospite",
      "ossa",
      "ossidare",
      "ostacolo",
      "oste",
      "otite",
      "otre",
      "ottagono",
      "ottimo",
      "ottobre",
      "ovale",
      "ovest",
      "ovino",
      "oviparo",
      "ovocito",
      "ovunque",
      "ovviare",
      "ozio",
      "pacchetto",
      "pace",
      "pacifico",
      "padella",
      "padrone",
      "paese",
      "paga",
      "pagina",
      "palazzina",
      "palesare",
      "pallido",
      "palo",
      "palude",
      "pandoro",
      "pannello",
      "paolo",
      "paonazzo",
      "paprica",
      "parabola",
      "parcella",
      "parere",
      "pargolo",
      "pari",
      "parlato",
      "parola",
      "partire",
      "parvenza",
      "parziale",
      "passivo",
      "pasticca",
      "patacca",
      "patologia",
      "pattume",
      "pavone",
      "peccato",
      "pedalare",
      "pedonale",
      "peggio",
      "peloso",
      "penare",
      "pendice",
      "penisola",
      "pennuto",
      "penombra",
      "pensare",
      "pentola",
      "pepe",
      "pepita",
      "perbene",
      "percorso",
      "perdonato",
      "perforare",
      "pergamena",
      "periodo",
      "permesso",
      "perno",
      "perplesso",
      "persuaso",
      "pertugio",
      "pervaso",
      "pesatore",
      "pesista",
      "peso",
      "pestifero",
      "petalo",
      "pettine",
      "petulante",
      "pezzo",
      "piacere",
      "pianta",
      "piattino",
      "piccino",
      "picozza",
      "piega",
      "pietra",
      "piffero",
      "pigiama",
      "pigolio",
      "pigro",
      "pila",
      "pilifero",
      "pillola",
      "pilota",
      "pimpante",
      "pineta",
      "pinna",
      "pinolo",
      "pioggia",
      "piombo",
      "piramide",
      "piretico",
      "pirite",
      "pirolisi",
      "pitone",
      "pizzico",
      "placebo",
      "planare",
      "plasma",
      "platano",
      "plenario",
      "pochezza",
      "poderoso",
      "podismo",
      "poesia",
      "poggiare",
      "polenta",
      "poligono",
      "pollice",
      "polmonite",
      "polpetta",
      "polso",
      "poltrona",
      "polvere",
      "pomice",
      "pomodoro",
      "ponte",
      "popoloso",
      "porfido",
      "poroso",
      "porpora",
      "porre",
      "portata",
      "posa",
      "positivo",
      "possesso",
      "postulato",
      "potassio",
      "potere",
      "pranzo",
      "prassi",
      "pratica",
      "precluso",
      "predica",
      "prefisso",
      "pregiato",
      "prelievo",
      "premere",
      "prenotare",
      "preparato",
      "presenza",
      "pretesto",
      "prevalso",
      "prima",
      "principe",
      "privato",
      "problema",
      "procura",
      "produrre",
      "profumo",
      "progetto",
      "prolunga",
      "promessa",
      "pronome",
      "proposta",
      "proroga",
      "proteso",
      "prova",
      "prudente",
      "prugna",
      "prurito",
      "psiche",
      "pubblico",
      "pudica",
      "pugilato",
      "pugno",
      "pulce",
      "pulito",
      "pulsante",
      "puntare",
      "pupazzo",
      "pupilla",
      "puro",
      "quadro",
      "qualcosa",
      "quasi",
      "querela",
      "quota",
      "raccolto",
      "raddoppio",
      "radicale",
      "radunato",
      "raffica",
      "ragazzo",
      "ragione",
      "ragno",
      "ramarro",
      "ramingo",
      "ramo",
      "randagio",
      "rantolare",
      "rapato",
      "rapina",
      "rappreso",
      "rasatura",
      "raschiato",
      "rasente",
      "rassegna",
      "rastrello",
      "rata",
      "ravveduto",
      "reale",
      "recepire",
      "recinto",
      "recluta",
      "recondito",
      "recupero",
      "reddito",
      "redimere",
      "regalato",
      "registro",
      "regola",
      "regresso",
      "relazione",
      "remare",
      "remoto",
      "renna",
      "replica",
      "reprimere",
      "reputare",
      "resa",
      "residente",
      "responso",
      "restauro",
      "rete",
      "retina",
      "retorica",
      "rettifica",
      "revocato",
      "riassunto",
      "ribadire",
      "ribelle",
      "ribrezzo",
      "ricarica",
      "ricco",
      "ricevere",
      "riciclato",
      "ricordo",
      "ricreduto",
      "ridicolo",
      "ridurre",
      "rifasare",
      "riflesso",
      "riforma",
      "rifugio",
      "rigare",
      "rigettato",
      "righello",
      "rilassato",
      "rilevato",
      "rimanere",
      "rimbalzo",
      "rimedio",
      "rimorchio",
      "rinascita",
      "rincaro",
      "rinforzo",
      "rinnovo",
      "rinomato",
      "rinsavito",
      "rintocco",
      "rinuncia",
      "rinvenire",
      "riparato",
      "ripetuto",
      "ripieno",
      "riportare",
      "ripresa",
      "ripulire",
      "risata",
      "rischio",
      "riserva",
      "risibile",
      "riso",
      "rispetto",
      "ristoro",
      "risultato",
      "risvolto",
      "ritardo",
      "ritegno",
      "ritmico",
      "ritrovo",
      "riunione",
      "riva",
      "riverso",
      "rivincita",
      "rivolto",
      "rizoma",
      "roba",
      "robotico",
      "robusto",
      "roccia",
      "roco",
      "rodaggio",
      "rodere",
      "roditore",
      "rogito",
      "rollio",
      "romantico",
      "rompere",
      "ronzio",
      "rosolare",
      "rospo",
      "rotante",
      "rotondo",
      "rotula",
      "rovescio",
      "rubizzo",
      "rubrica",
      "ruga",
      "rullino",
      "rumine",
      "rumoroso",
      "ruolo",
      "rupe",
      "russare",
      "rustico",
      "sabato",
      "sabbiare",
      "sabotato",
      "sagoma",
      "salasso",
      "saldatura",
      "salgemma",
      "salivare",
      "salmone",
      "salone",
      "saltare",
      "saluto",
      "salvo",
      "sapere",
      "sapido",
      "saporito",
      "saraceno",
      "sarcasmo",
      "sarto",
      "sassoso",
      "satellite",
      "satira",
      "satollo",
      "saturno",
      "savana",
      "savio",
      "saziato",
      "sbadiglio",
      "sbalzo",
      "sbancato",
      "sbarra",
      "sbattere",
      "sbavare",
      "sbendare",
      "sbirciare",
      "sbloccato",
      "sbocciato",
      "sbrinare",
      "sbruffone",
      "sbuffare",
      "scabroso",
      "scadenza",
      "scala",
      "scambiare",
      "scandalo",
      "scapola",
      "scarso",
      "scatenare",
      "scavato",
      "scelto",
      "scenico",
      "scettro",
      "scheda",
      "schiena",
      "sciarpa",
      "scienza",
      "scindere",
      "scippo",
      "sciroppo",
      "scivolo",
      "sclerare",
      "scodella",
      "scolpito",
      "scomparto",
      "sconforto",
      "scoprire",
      "scorta",
      "scossone",
      "scozzese",
      "scriba",
      "scrollare",
      "scrutinio",
      "scuderia",
      "scultore",
      "scuola",
      "scuro",
      "scusare",
      "sdebitare",
      "sdoganare",
      "seccatura",
      "secondo",
      "sedano",
      "seggiola",
      "segnalato",
      "segregato",
      "seguito",
      "selciato",
      "selettivo",
      "sella",
      "selvaggio",
      "semaforo",
      "sembrare",
      "seme",
      "seminato",
      "sempre",
      "senso",
      "sentire",
      "sepolto",
      "sequenza",
      "serata",
      "serbato",
      "sereno",
      "serio",
      "serpente",
      "serraglio",
      "servire",
      "sestina",
      "setola",
      "settimana",
      "sfacelo",
      "sfaldare",
      "sfamato",
      "sfarzoso",
      "sfaticato",
      "sfera",
      "sfida",
      "sfilato",
      "sfinge",
      "sfocato",
      "sfoderare",
      "sfogo",
      "sfoltire",
      "sforzato",
      "sfratto",
      "sfruttato",
      "sfuggito",
      "sfumare",
      "sfuso",
      "sgabello",
      "sgarbato",
      "sgonfiare",
      "sgorbio",
      "sgrassato",
      "sguardo",
      "sibilo",
      "siccome",
      "sierra",
      "sigla",
      "signore",
      "silenzio",
      "sillaba",
      "simbolo",
      "simpatico",
      "simulato",
      "sinfonia",
      "singolo",
      "sinistro",
      "sino",
      "sintesi",
      "sinusoide",
      "sipario",
      "sisma",
      "sistole",
      "situato",
      "slitta",
      "slogatura",
      "sloveno",
      "smarrito",
      "smemorato",
      "smentito",
      "smeraldo",
      "smilzo",
      "smontare",
      "smottato",
      "smussato",
      "snellire",
      "snervato",
      "snodo",
      "sobbalzo",
      "sobrio",
      "soccorso",
      "sociale",
      "sodale",
      "soffitto",
      "sogno",
      "soldato",
      "solenne",
      "solido",
      "sollazzo",
      "solo",
      "solubile",
      "solvente",
      "somatico",
      "somma",
      "sonda",
      "sonetto",
      "sonnifero",
      "sopire",
      "soppeso",
      "sopra",
      "sorgere",
      "sorpasso",
      "sorriso",
      "sorso",
      "sorteggio",
      "sorvolato",
      "sospiro",
      "sosta",
      "sottile",
      "spada",
      "spalla",
      "spargere",
      "spatola",
      "spavento",
      "spazzola",
      "specie",
      "spedire",
      "spegnere",
      "spelatura",
      "speranza",
      "spessore",
      "spettrale",
      "spezzato",
      "spia",
      "spigoloso",
      "spillato",
      "spinoso",
      "spirale",
      "splendido",
      "sportivo",
      "sposo",
      "spranga",
      "sprecare",
      "spronato",
      "spruzzo",
      "spuntino",
      "squillo",
      "sradicare",
      "srotolato",
      "stabile",
      "stacco",
      "staffa",
      "stagnare",
      "stampato",
      "stantio",
      "starnuto",
      "stasera",
      "statuto",
      "stelo",
      "steppa",
      "sterzo",
      "stiletto",
      "stima",
      "stirpe",
      "stivale",
      "stizzoso",
      "stonato",
      "storico",
      "strappo",
      "stregato",
      "stridulo",
      "strozzare",
      "strutto",
      "stuccare",
      "stufo",
      "stupendo",
      "subentro",
      "succoso",
      "sudore",
      "suggerito",
      "sugo",
      "sultano",
      "suonare",
      "superbo",
      "supporto",
      "surgelato",
      "surrogato",
      "sussurro",
      "sutura",
      "svagare",
      "svedese",
      "sveglio",
      "svelare",
      "svenuto",
      "svezia",
      "sviluppo",
      "svista",
      "svizzera",
      "svolta",
      "svuotare",
      "tabacco",
      "tabulato",
      "tacciare",
      "taciturno",
      "tale",
      "talismano",
      "tampone",
      "tannino",
      "tara",
      "tardivo",
      "targato",
      "tariffa",
      "tarpare",
      "tartaruga",
      "tasto",
      "tattico",
      "taverna",
      "tavolata",
      "tazza",
      "teca",
      "tecnico",
      "telefono",
      "temerario",
      "tempo",
      "temuto",
      "tendone",
      "tenero",
      "tensione",
      "tentacolo",
      "teorema",
      "terme",
      "terrazzo",
      "terzetto",
      "tesi",
      "tesserato",
      "testato",
      "tetro",
      "tettoia",
      "tifare",
      "tigella",
      "timbro",
      "tinto",
      "tipico",
      "tipografo",
      "tiraggio",
      "tiro",
      "titanio",
      "titolo",
      "titubante",
      "tizio",
      "tizzone",
      "toccare",
      "tollerare",
      "tolto",
      "tombola",
      "tomo",
      "tonfo",
      "tonsilla",
      "topazio",
      "topologia",
      "toppa",
      "torba",
      "tornare",
      "torrone",
      "tortora",
      "toscano",
      "tossire",
      "tostatura",
      "totano",
      "trabocco",
      "trachea",
      "trafila",
      "tragedia",
      "tralcio",
      "tramonto",
      "transito",
      "trapano",
      "trarre",
      "trasloco",
      "trattato",
      "trave",
      "treccia",
      "tremolio",
      "trespolo",
      "tributo",
      "tricheco",
      "trifoglio",
      "trillo",
      "trincea",
      "trio",
      "tristezza",
      "triturato",
      "trivella",
      "tromba",
      "trono",
      "troppo",
      "trottola",
      "trovare",
      "truccato",
      "tubatura",
      "tuffato",
      "tulipano",
      "tumulto",
      "tunisia",
      "turbare",
      "turchino",
      "tuta",
      "tutela",
      "ubicato",
      "uccello",
      "uccisore",
      "udire",
      "uditivo",
      "uffa",
      "ufficio",
      "uguale",
      "ulisse",
      "ultimato",
      "umano",
      "umile",
      "umorismo",
      "uncinetto",
      "ungere",
      "ungherese",
      "unicorno",
      "unificato",
      "unisono",
      "unitario",
      "unte",
      "uovo",
      "upupa",
      "uragano",
      "urgenza",
      "urlo",
      "usanza",
      "usato",
      "uscito",
      "usignolo",
      "usuraio",
      "utensile",
      "utilizzo",
      "utopia",
      "vacante",
      "vaccinato",
      "vagabondo",
      "vagliato",
      "valanga",
      "valgo",
      "valico",
      "valletta",
      "valoroso",
      "valutare",
      "valvola",
      "vampata",
      "vangare",
      "vanitoso",
      "vano",
      "vantaggio",
      "vanvera",
      "vapore",
      "varano",
      "varcato",
      "variante",
      "vasca",
      "vedetta",
      "vedova",
      "veduto",
      "vegetale",
      "veicolo",
      "velcro",
      "velina",
      "velluto",
      "veloce",
      "venato",
      "vendemmia",
      "vento",
      "verace",
      "verbale",
      "vergogna",
      "verifica",
      "vero",
      "verruca",
      "verticale",
      "vescica",
      "vessillo",
      "vestale",
      "veterano",
      "vetrina",
      "vetusto",
      "viandante",
      "vibrante",
      "vicenda",
      "vichingo",
      "vicinanza",
      "vidimare",
      "vigilia",
      "vigneto",
      "vigore",
      "vile",
      "villano",
      "vimini",
      "vincitore",
      "viola",
      "vipera",
      "virgola",
      "virologo",
      "virulento",
      "viscoso",
      "visione",
      "vispo",
      "vissuto",
      "visura",
      "vita",
      "vitello",
      "vittima",
      "vivanda",
      "vivido",
      "viziare",
      "voce",
      "voga",
      "volatile",
      "volere",
      "volpe",
      "voragine",
      "vulcano",
      "zampogna",
      "zanna",
      "zappato",
      "zattera",
      "zavorra",
      "zefiro",
      "zelante",
      "zelo",
      "zenzero",
      "zerbino",
      "zibetto",
      "zinco",
      "zircone",
      "zitto",
      "zolla",
      "zotico",
      "zucchero",
      "zufolo",
      "zulu",
      "zuppa"
    ];
  }
});

// ../../node_modules/.pnpm/bip39@3.1.0/node_modules/bip39/src/wordlists/spanish.json
var require_spanish = __commonJS({
  "../../node_modules/.pnpm/bip39@3.1.0/node_modules/bip39/src/wordlists/spanish.json"(exports, module) {
    module.exports = [
      "abaco",
      "abdomen",
      "abeja",
      "abierto",
      "abogado",
      "abono",
      "aborto",
      "abrazo",
      "abrir",
      "abuelo",
      "abuso",
      "acabar",
      "academia",
      "acceso",
      "accion",
      "aceite",
      "acelga",
      "acento",
      "aceptar",
      "acido",
      "aclarar",
      "acne",
      "acoger",
      "acoso",
      "activo",
      "acto",
      "actriz",
      "actuar",
      "acudir",
      "acuerdo",
      "acusar",
      "adicto",
      "admitir",
      "adoptar",
      "adorno",
      "aduana",
      "adulto",
      "aereo",
      "afectar",
      "aficion",
      "afinar",
      "afirmar",
      "agil",
      "agitar",
      "agonia",
      "agosto",
      "agotar",
      "agregar",
      "agrio",
      "agua",
      "agudo",
      "aguila",
      "aguja",
      "ahogo",
      "ahorro",
      "aire",
      "aislar",
      "ajedrez",
      "ajeno",
      "ajuste",
      "alacran",
      "alambre",
      "alarma",
      "alba",
      "album",
      "alcalde",
      "aldea",
      "alegre",
      "alejar",
      "alerta",
      "aleta",
      "alfiler",
      "alga",
      "algodon",
      "aliado",
      "aliento",
      "alivio",
      "alma",
      "almeja",
      "almibar",
      "altar",
      "alteza",
      "altivo",
      "alto",
      "altura",
      "alumno",
      "alzar",
      "amable",
      "amante",
      "amapola",
      "amargo",
      "amasar",
      "ambar",
      "ambito",
      "ameno",
      "amigo",
      "amistad",
      "amor",
      "amparo",
      "amplio",
      "ancho",
      "anciano",
      "ancla",
      "andar",
      "anden",
      "anemia",
      "angulo",
      "anillo",
      "animo",
      "anis",
      "anotar",
      "antena",
      "antiguo",
      "antojo",
      "anual",
      "anular",
      "anuncio",
      "anadir",
      "anejo",
      "ano",
      "apagar",
      "aparato",
      "apetito",
      "apio",
      "aplicar",
      "apodo",
      "aporte",
      "apoyo",
      "aprender",
      "aprobar",
      "apuesta",
      "apuro",
      "arado",
      "arana",
      "arar",
      "arbitro",
      "arbol",
      "arbusto",
      "archivo",
      "arco",
      "arder",
      "ardilla",
      "arduo",
      "area",
      "arido",
      "aries",
      "armonia",
      "arnes",
      "aroma",
      "arpa",
      "arpon",
      "arreglo",
      "arroz",
      "arruga",
      "arte",
      "artista",
      "asa",
      "asado",
      "asalto",
      "ascenso",
      "asegurar",
      "aseo",
      "asesor",
      "asiento",
      "asilo",
      "asistir",
      "asno",
      "asombro",
      "aspero",
      "astilla",
      "astro",
      "astuto",
      "asumir",
      "asunto",
      "atajo",
      "ataque",
      "atar",
      "atento",
      "ateo",
      "atico",
      "atleta",
      "atomo",
      "atraer",
      "atroz",
      "atun",
      "audaz",
      "audio",
      "auge",
      "aula",
      "aumento",
      "ausente",
      "autor",
      "aval",
      "avance",
      "avaro",
      "ave",
      "avellana",
      "avena",
      "avestruz",
      "avion",
      "aviso",
      "ayer",
      "ayuda",
      "ayuno",
      "azafran",
      "azar",
      "azote",
      "azucar",
      "azufre",
      "azul",
      "baba",
      "babor",
      "bache",
      "bahia",
      "baile",
      "bajar",
      "balanza",
      "balcon",
      "balde",
      "bambu",
      "banco",
      "banda",
      "bano",
      "barba",
      "barco",
      "barniz",
      "barro",
      "bascula",
      "baston",
      "basura",
      "batalla",
      "bateria",
      "batir",
      "batuta",
      "baul",
      "bazar",
      "bebe",
      "bebida",
      "bello",
      "besar",
      "beso",
      "bestia",
      "bicho",
      "bien",
      "bingo",
      "blanco",
      "bloque",
      "blusa",
      "boa",
      "bobina",
      "bobo",
      "boca",
      "bocina",
      "boda",
      "bodega",
      "boina",
      "bola",
      "bolero",
      "bolsa",
      "bomba",
      "bondad",
      "bonito",
      "bono",
      "bonsai",
      "borde",
      "borrar",
      "bosque",
      "bote",
      "botin",
      "boveda",
      "bozal",
      "bravo",
      "brazo",
      "brecha",
      "breve",
      "brillo",
      "brinco",
      "brisa",
      "broca",
      "broma",
      "bronce",
      "brote",
      "bruja",
      "brusco",
      "bruto",
      "buceo",
      "bucle",
      "bueno",
      "buey",
      "bufanda",
      "bufon",
      "buho",
      "buitre",
      "bulto",
      "burbuja",
      "burla",
      "burro",
      "buscar",
      "butaca",
      "buzon",
      "caballo",
      "cabeza",
      "cabina",
      "cabra",
      "cacao",
      "cadaver",
      "cadena",
      "caer",
      "cafe",
      "caida",
      "caiman",
      "caja",
      "cajon",
      "cal",
      "calamar",
      "calcio",
      "caldo",
      "calidad",
      "calle",
      "calma",
      "calor",
      "calvo",
      "cama",
      "cambio",
      "camello",
      "camino",
      "campo",
      "cancer",
      "candil",
      "canela",
      "canguro",
      "canica",
      "canto",
      "cana",
      "canon",
      "caoba",
      "caos",
      "capaz",
      "capitan",
      "capote",
      "captar",
      "capucha",
      "cara",
      "carbon",
      "carcel",
      "careta",
      "carga",
      "carino",
      "carne",
      "carpeta",
      "carro",
      "carta",
      "casa",
      "casco",
      "casero",
      "caspa",
      "castor",
      "catorce",
      "catre",
      "caudal",
      "causa",
      "cazo",
      "cebolla",
      "ceder",
      "cedro",
      "celda",
      "celebre",
      "celoso",
      "celula",
      "cemento",
      "ceniza",
      "centro",
      "cerca",
      "cerdo",
      "cereza",
      "cero",
      "cerrar",
      "certeza",
      "cesped",
      "cetro",
      "chacal",
      "chaleco",
      "champu",
      "chancla",
      "chapa",
      "charla",
      "chico",
      "chiste",
      "chivo",
      "choque",
      "choza",
      "chuleta",
      "chupar",
      "ciclon",
      "ciego",
      "cielo",
      "cien",
      "cierto",
      "cifra",
      "cigarro",
      "cima",
      "cinco",
      "cine",
      "cinta",
      "cipres",
      "circo",
      "ciruela",
      "cisne",
      "cita",
      "ciudad",
      "clamor",
      "clan",
      "claro",
      "clase",
      "clave",
      "cliente",
      "clima",
      "clinica",
      "cobre",
      "coccion",
      "cochino",
      "cocina",
      "coco",
      "codigo",
      "codo",
      "cofre",
      "coger",
      "cohete",
      "cojin",
      "cojo",
      "cola",
      "colcha",
      "colegio",
      "colgar",
      "colina",
      "collar",
      "colmo",
      "columna",
      "combate",
      "comer",
      "comida",
      "comodo",
      "compra",
      "conde",
      "conejo",
      "conga",
      "conocer",
      "consejo",
      "contar",
      "copa",
      "copia",
      "corazon",
      "corbata",
      "corcho",
      "cordon",
      "corona",
      "correr",
      "coser",
      "cosmos",
      "costa",
      "craneo",
      "crater",
      "crear",
      "crecer",
      "creido",
      "crema",
      "cria",
      "crimen",
      "cripta",
      "crisis",
      "cromo",
      "cronica",
      "croqueta",
      "crudo",
      "cruz",
      "cuadro",
      "cuarto",
      "cuatro",
      "cubo",
      "cubrir",
      "cuchara",
      "cuello",
      "cuento",
      "cuerda",
      "cuesta",
      "cueva",
      "cuidar",
      "culebra",
      "culpa",
      "culto",
      "cumbre",
      "cumplir",
      "cuna",
      "cuneta",
      "cuota",
      "cupon",
      "cupula",
      "curar",
      "curioso",
      "curso",
      "curva",
      "cutis",
      "dama",
      "danza",
      "dar",
      "dardo",
      "datil",
      "deber",
      "debil",
      "decada",
      "decir",
      "dedo",
      "defensa",
      "definir",
      "dejar",
      "delfin",
      "delgado",
      "delito",
      "demora",
      "denso",
      "dental",
      "deporte",
      "derecho",
      "derrota",
      "desayuno",
      "deseo",
      "desfile",
      "desnudo",
      "destino",
      "desvio",
      "detalle",
      "detener",
      "deuda",
      "dia",
      "diablo",
      "diadema",
      "diamante",
      "diana",
      "diario",
      "dibujo",
      "dictar",
      "diente",
      "dieta",
      "diez",
      "dificil",
      "digno",
      "dilema",
      "diluir",
      "dinero",
      "directo",
      "dirigir",
      "disco",
      "diseno",
      "disfraz",
      "diva",
      "divino",
      "doble",
      "doce",
      "dolor",
      "domingo",
      "don",
      "donar",
      "dorado",
      "dormir",
      "dorso",
      "dos",
      "dosis",
      "dragon",
      "droga",
      "ducha",
      "duda",
      "duelo",
      "dueno",
      "dulce",
      "duo",
      "duque",
      "durar",
      "dureza",
      "duro",
      "ebano",
      "ebrio",
      "echar",
      "eco",
      "ecuador",
      "edad",
      "edicion",
      "edificio",
      "editor",
      "educar",
      "efecto",
      "eficaz",
      "eje",
      "ejemplo",
      "elefante",
      "elegir",
      "elemento",
      "elevar",
      "elipse",
      "elite",
      "elixir",
      "elogio",
      "eludir",
      "embudo",
      "emitir",
      "emocion",
      "empate",
      "empeno",
      "empleo",
      "empresa",
      "enano",
      "encargo",
      "enchufe",
      "encia",
      "enemigo",
      "enero",
      "enfado",
      "enfermo",
      "engano",
      "enigma",
      "enlace",
      "enorme",
      "enredo",
      "ensayo",
      "ensenar",
      "entero",
      "entrar",
      "envase",
      "envio",
      "epoca",
      "equipo",
      "erizo",
      "escala",
      "escena",
      "escolar",
      "escribir",
      "escudo",
      "esencia",
      "esfera",
      "esfuerzo",
      "espada",
      "espejo",
      "espia",
      "esposa",
      "espuma",
      "esqui",
      "estar",
      "este",
      "estilo",
      "estufa",
      "etapa",
      "eterno",
      "etica",
      "etnia",
      "evadir",
      "evaluar",
      "evento",
      "evitar",
      "exacto",
      "examen",
      "exceso",
      "excusa",
      "exento",
      "exigir",
      "exilio",
      "existir",
      "exito",
      "experto",
      "explicar",
      "exponer",
      "extremo",
      "fabrica",
      "fabula",
      "fachada",
      "facil",
      "factor",
      "faena",
      "faja",
      "falda",
      "fallo",
      "falso",
      "faltar",
      "fama",
      "familia",
      "famoso",
      "faraon",
      "farmacia",
      "farol",
      "farsa",
      "fase",
      "fatiga",
      "fauna",
      "favor",
      "fax",
      "febrero",
      "fecha",
      "feliz",
      "feo",
      "feria",
      "feroz",
      "fertil",
      "fervor",
      "festin",
      "fiable",
      "fianza",
      "fiar",
      "fibra",
      "ficcion",
      "ficha",
      "fideo",
      "fiebre",
      "fiel",
      "fiera",
      "fiesta",
      "figura",
      "fijar",
      "fijo",
      "fila",
      "filete",
      "filial",
      "filtro",
      "fin",
      "finca",
      "fingir",
      "finito",
      "firma",
      "flaco",
      "flauta",
      "flecha",
      "flor",
      "flota",
      "fluir",
      "flujo",
      "fluor",
      "fobia",
      "foca",
      "fogata",
      "fogon",
      "folio",
      "folleto",
      "fondo",
      "forma",
      "forro",
      "fortuna",
      "forzar",
      "fosa",
      "foto",
      "fracaso",
      "fragil",
      "franja",
      "frase",
      "fraude",
      "freir",
      "freno",
      "fresa",
      "frio",
      "frito",
      "fruta",
      "fuego",
      "fuente",
      "fuerza",
      "fuga",
      "fumar",
      "funcion",
      "funda",
      "furgon",
      "furia",
      "fusil",
      "futbol",
      "futuro",
      "gacela",
      "gafas",
      "gaita",
      "gajo",
      "gala",
      "galeria",
      "gallo",
      "gamba",
      "ganar",
      "gancho",
      "ganga",
      "ganso",
      "garaje",
      "garza",
      "gasolina",
      "gastar",
      "gato",
      "gavilan",
      "gemelo",
      "gemir",
      "gen",
      "genero",
      "genio",
      "gente",
      "geranio",
      "gerente",
      "germen",
      "gesto",
      "gigante",
      "gimnasio",
      "girar",
      "giro",
      "glaciar",
      "globo",
      "gloria",
      "gol",
      "golfo",
      "goloso",
      "golpe",
      "goma",
      "gordo",
      "gorila",
      "gorra",
      "gota",
      "goteo",
      "gozar",
      "grada",
      "grafico",
      "grano",
      "grasa",
      "gratis",
      "grave",
      "grieta",
      "grillo",
      "gripe",
      "gris",
      "grito",
      "grosor",
      "grua",
      "grueso",
      "grumo",
      "grupo",
      "guante",
      "guapo",
      "guardia",
      "guerra",
      "guia",
      "guino",
      "guion",
      "guiso",
      "guitarra",
      "gusano",
      "gustar",
      "haber",
      "habil",
      "hablar",
      "hacer",
      "hacha",
      "hada",
      "hallar",
      "hamaca",
      "harina",
      "haz",
      "hazana",
      "hebilla",
      "hebra",
      "hecho",
      "helado",
      "helio",
      "hembra",
      "herir",
      "hermano",
      "heroe",
      "hervir",
      "hielo",
      "hierro",
      "higado",
      "higiene",
      "hijo",
      "himno",
      "historia",
      "hocico",
      "hogar",
      "hoguera",
      "hoja",
      "hombre",
      "hongo",
      "honor",
      "honra",
      "hora",
      "hormiga",
      "horno",
      "hostil",
      "hoyo",
      "hueco",
      "huelga",
      "huerta",
      "hueso",
      "huevo",
      "huida",
      "huir",
      "humano",
      "humedo",
      "humilde",
      "humo",
      "hundir",
      "huracan",
      "hurto",
      "icono",
      "ideal",
      "idioma",
      "idolo",
      "iglesia",
      "iglu",
      "igual",
      "ilegal",
      "ilusion",
      "imagen",
      "iman",
      "imitar",
      "impar",
      "imperio",
      "imponer",
      "impulso",
      "incapaz",
      "indice",
      "inerte",
      "infiel",
      "informe",
      "ingenio",
      "inicio",
      "inmenso",
      "inmune",
      "innato",
      "insecto",
      "instante",
      "interes",
      "intimo",
      "intuir",
      "inutil",
      "invierno",
      "ira",
      "iris",
      "ironia",
      "isla",
      "islote",
      "jabali",
      "jabon",
      "jamon",
      "jarabe",
      "jardin",
      "jarra",
      "jaula",
      "jazmin",
      "jefe",
      "jeringa",
      "jinete",
      "jornada",
      "joroba",
      "joven",
      "joya",
      "juerga",
      "jueves",
      "juez",
      "jugador",
      "jugo",
      "juguete",
      "juicio",
      "junco",
      "jungla",
      "junio",
      "juntar",
      "jupiter",
      "jurar",
      "justo",
      "juvenil",
      "juzgar",
      "kilo",
      "koala",
      "labio",
      "lacio",
      "lacra",
      "lado",
      "ladron",
      "lagarto",
      "lagrima",
      "laguna",
      "laico",
      "lamer",
      "lamina",
      "lampara",
      "lana",
      "lancha",
      "langosta",
      "lanza",
      "lapiz",
      "largo",
      "larva",
      "lastima",
      "lata",
      "latex",
      "latir",
      "laurel",
      "lavar",
      "lazo",
      "leal",
      "leccion",
      "leche",
      "lector",
      "leer",
      "legion",
      "legumbre",
      "lejano",
      "lengua",
      "lento",
      "lena",
      "leon",
      "leopardo",
      "lesion",
      "letal",
      "letra",
      "leve",
      "leyenda",
      "libertad",
      "libro",
      "licor",
      "lider",
      "lidiar",
      "lienzo",
      "liga",
      "ligero",
      "lima",
      "limite",
      "limon",
      "limpio",
      "lince",
      "lindo",
      "linea",
      "lingote",
      "lino",
      "linterna",
      "liquido",
      "liso",
      "lista",
      "litera",
      "litio",
      "litro",
      "llaga",
      "llama",
      "llanto",
      "llave",
      "llegar",
      "llenar",
      "llevar",
      "llorar",
      "llover",
      "lluvia",
      "lobo",
      "locion",
      "loco",
      "locura",
      "logica",
      "logro",
      "lombriz",
      "lomo",
      "lonja",
      "lote",
      "lucha",
      "lucir",
      "lugar",
      "lujo",
      "luna",
      "lunes",
      "lupa",
      "lustro",
      "luto",
      "luz",
      "maceta",
      "macho",
      "madera",
      "madre",
      "maduro",
      "maestro",
      "mafia",
      "magia",
      "mago",
      "maiz",
      "maldad",
      "maleta",
      "malla",
      "malo",
      "mama",
      "mambo",
      "mamut",
      "manco",
      "mando",
      "manejar",
      "manga",
      "maniqui",
      "manjar",
      "mano",
      "manso",
      "manta",
      "manana",
      "mapa",
      "maquina",
      "mar",
      "marco",
      "marea",
      "marfil",
      "margen",
      "marido",
      "marmol",
      "marron",
      "martes",
      "marzo",
      "masa",
      "mascara",
      "masivo",
      "matar",
      "materia",
      "matiz",
      "matriz",
      "maximo",
      "mayor",
      "mazorca",
      "mecha",
      "medalla",
      "medio",
      "medula",
      "mejilla",
      "mejor",
      "melena",
      "melon",
      "memoria",
      "menor",
      "mensaje",
      "mente",
      "menu",
      "mercado",
      "merengue",
      "merito",
      "mes",
      "meson",
      "meta",
      "meter",
      "metodo",
      "metro",
      "mezcla",
      "miedo",
      "miel",
      "miembro",
      "miga",
      "mil",
      "milagro",
      "militar",
      "millon",
      "mimo",
      "mina",
      "minero",
      "minimo",
      "minuto",
      "miope",
      "mirar",
      "misa",
      "miseria",
      "misil",
      "mismo",
      "mitad",
      "mito",
      "mochila",
      "mocion",
      "moda",
      "modelo",
      "moho",
      "mojar",
      "molde",
      "moler",
      "molino",
      "momento",
      "momia",
      "monarca",
      "moneda",
      "monja",
      "monto",
      "mono",
      "morada",
      "morder",
      "moreno",
      "morir",
      "morro",
      "morsa",
      "mortal",
      "mosca",
      "mostrar",
      "motivo",
      "mover",
      "movil",
      "mozo",
      "mucho",
      "mudar",
      "mueble",
      "muela",
      "muerte",
      "muestra",
      "mugre",
      "mujer",
      "mula",
      "muleta",
      "multa",
      "mundo",
      "muneca",
      "mural",
      "muro",
      "musculo",
      "museo",
      "musgo",
      "musica",
      "muslo",
      "nacar",
      "nacion",
      "nadar",
      "naipe",
      "naranja",
      "nariz",
      "narrar",
      "nasal",
      "natal",
      "nativo",
      "natural",
      "nausea",
      "naval",
      "nave",
      "navidad",
      "necio",
      "nectar",
      "negar",
      "negocio",
      "negro",
      "neon",
      "nervio",
      "neto",
      "neutro",
      "nevar",
      "nevera",
      "nicho",
      "nido",
      "niebla",
      "nieto",
      "ninez",
      "nino",
      "nitido",
      "nivel",
      "nobleza",
      "noche",
      "nomina",
      "noria",
      "norma",
      "norte",
      "nota",
      "noticia",
      "novato",
      "novela",
      "novio",
      "nube",
      "nuca",
      "nucleo",
      "nudillo",
      "nudo",
      "nuera",
      "nueve",
      "nuez",
      "nulo",
      "numero",
      "nutria",
      "oasis",
      "obeso",
      "obispo",
      "objeto",
      "obra",
      "obrero",
      "observar",
      "obtener",
      "obvio",
      "oca",
      "ocaso",
      "oceano",
      "ochenta",
      "ocho",
      "ocio",
      "ocre",
      "octavo",
      "octubre",
      "oculto",
      "ocupar",
      "ocurrir",
      "odiar",
      "odio",
      "odisea",
      "oeste",
      "ofensa",
      "oferta",
      "oficio",
      "ofrecer",
      "ogro",
      "oido",
      "oir",
      "ojo",
      "ola",
      "oleada",
      "olfato",
      "olivo",
      "olla",
      "olmo",
      "olor",
      "olvido",
      "ombligo",
      "onda",
      "onza",
      "opaco",
      "opcion",
      "opera",
      "opinar",
      "oponer",
      "optar",
      "optica",
      "opuesto",
      "oracion",
      "orador",
      "oral",
      "orbita",
      "orca",
      "orden",
      "oreja",
      "organo",
      "orgia",
      "orgullo",
      "oriente",
      "origen",
      "orilla",
      "oro",
      "orquesta",
      "oruga",
      "osadia",
      "oscuro",
      "osezno",
      "oso",
      "ostra",
      "otono",
      "otro",
      "oveja",
      "ovulo",
      "oxido",
      "oxigeno",
      "oyente",
      "ozono",
      "pacto",
      "padre",
      "paella",
      "pagina",
      "pago",
      "pais",
      "pajaro",
      "palabra",
      "palco",
      "paleta",
      "palido",
      "palma",
      "paloma",
      "palpar",
      "pan",
      "panal",
      "panico",
      "pantera",
      "panuelo",
      "papa",
      "papel",
      "papilla",
      "paquete",
      "parar",
      "parcela",
      "pared",
      "parir",
      "paro",
      "parpado",
      "parque",
      "parrafo",
      "parte",
      "pasar",
      "paseo",
      "pasion",
      "paso",
      "pasta",
      "pata",
      "patio",
      "patria",
      "pausa",
      "pauta",
      "pavo",
      "payaso",
      "peaton",
      "pecado",
      "pecera",
      "pecho",
      "pedal",
      "pedir",
      "pegar",
      "peine",
      "pelar",
      "peldano",
      "pelea",
      "peligro",
      "pellejo",
      "pelo",
      "peluca",
      "pena",
      "pensar",
      "penon",
      "peon",
      "peor",
      "pepino",
      "pequeno",
      "pera",
      "percha",
      "perder",
      "pereza",
      "perfil",
      "perico",
      "perla",
      "permiso",
      "perro",
      "persona",
      "pesa",
      "pesca",
      "pesimo",
      "pestana",
      "petalo",
      "petroleo",
      "pez",
      "pezuna",
      "picar",
      "pichon",
      "pie",
      "piedra",
      "pierna",
      "pieza",
      "pijama",
      "pilar",
      "piloto",
      "pimienta",
      "pino",
      "pintor",
      "pinza",
      "pina",
      "piojo",
      "pipa",
      "pirata",
      "pisar",
      "piscina",
      "piso",
      "pista",
      "piton",
      "pizca",
      "placa",
      "plan",
      "plata",
      "playa",
      "plaza",
      "pleito",
      "pleno",
      "plomo",
      "pluma",
      "plural",
      "pobre",
      "poco",
      "poder",
      "podio",
      "poema",
      "poesia",
      "poeta",
      "polen",
      "policia",
      "pollo",
      "polvo",
      "pomada",
      "pomelo",
      "pomo",
      "pompa",
      "poner",
      "porcion",
      "portal",
      "posada",
      "poseer",
      "posible",
      "poste",
      "potencia",
      "potro",
      "pozo",
      "prado",
      "precoz",
      "pregunta",
      "premio",
      "prensa",
      "preso",
      "previo",
      "primo",
      "principe",
      "prision",
      "privar",
      "proa",
      "probar",
      "proceso",
      "producto",
      "proeza",
      "profesor",
      "programa",
      "prole",
      "promesa",
      "pronto",
      "propio",
      "proximo",
      "prueba",
      "publico",
      "puchero",
      "pudor",
      "pueblo",
      "puerta",
      "puesto",
      "pulga",
      "pulir",
      "pulmon",
      "pulpo",
      "pulso",
      "puma",
      "punto",
      "punal",
      "puno",
      "pupa",
      "pupila",
      "pure",
      "quedar",
      "queja",
      "quemar",
      "querer",
      "queso",
      "quieto",
      "quimica",
      "quince",
      "quitar",
      "rabano",
      "rabia",
      "rabo",
      "racion",
      "radical",
      "raiz",
      "rama",
      "rampa",
      "rancho",
      "rango",
      "rapaz",
      "rapido",
      "rapto",
      "rasgo",
      "raspa",
      "rato",
      "rayo",
      "raza",
      "razon",
      "reaccion",
      "realidad",
      "rebano",
      "rebote",
      "recaer",
      "receta",
      "rechazo",
      "recoger",
      "recreo",
      "recto",
      "recurso",
      "red",
      "redondo",
      "reducir",
      "reflejo",
      "reforma",
      "refran",
      "refugio",
      "regalo",
      "regir",
      "regla",
      "regreso",
      "rehen",
      "reino",
      "reir",
      "reja",
      "relato",
      "relevo",
      "relieve",
      "relleno",
      "reloj",
      "remar",
      "remedio",
      "remo",
      "rencor",
      "rendir",
      "renta",
      "reparto",
      "repetir",
      "reposo",
      "reptil",
      "res",
      "rescate",
      "resina",
      "respeto",
      "resto",
      "resumen",
      "retiro",
      "retorno",
      "retrato",
      "reunir",
      "reves",
      "revista",
      "rey",
      "rezar",
      "rico",
      "riego",
      "rienda",
      "riesgo",
      "rifa",
      "rigido",
      "rigor",
      "rincon",
      "rinon",
      "rio",
      "riqueza",
      "risa",
      "ritmo",
      "rito",
      "rizo",
      "roble",
      "roce",
      "rociar",
      "rodar",
      "rodeo",
      "rodilla",
      "roer",
      "rojizo",
      "rojo",
      "romero",
      "romper",
      "ron",
      "ronco",
      "ronda",
      "ropa",
      "ropero",
      "rosa",
      "rosca",
      "rostro",
      "rotar",
      "rubi",
      "rubor",
      "rudo",
      "rueda",
      "rugir",
      "ruido",
      "ruina",
      "ruleta",
      "rulo",
      "rumbo",
      "rumor",
      "ruptura",
      "ruta",
      "rutina",
      "sabado",
      "saber",
      "sabio",
      "sable",
      "sacar",
      "sagaz",
      "sagrado",
      "sala",
      "saldo",
      "salero",
      "salir",
      "salmon",
      "salon",
      "salsa",
      "salto",
      "salud",
      "salvar",
      "samba",
      "sancion",
      "sandia",
      "sanear",
      "sangre",
      "sanidad",
      "sano",
      "santo",
      "sapo",
      "saque",
      "sardina",
      "sarten",
      "sastre",
      "satan",
      "sauna",
      "saxofon",
      "seccion",
      "seco",
      "secreto",
      "secta",
      "sed",
      "seguir",
      "seis",
      "sello",
      "selva",
      "semana",
      "semilla",
      "senda",
      "sensor",
      "senal",
      "senor",
      "separar",
      "sepia",
      "sequia",
      "ser",
      "serie",
      "sermon",
      "servir",
      "sesenta",
      "sesion",
      "seta",
      "setenta",
      "severo",
      "sexo",
      "sexto",
      "sidra",
      "siesta",
      "siete",
      "siglo",
      "signo",
      "silaba",
      "silbar",
      "silencio",
      "silla",
      "simbolo",
      "simio",
      "sirena",
      "sistema",
      "sitio",
      "situar",
      "sobre",
      "socio",
      "sodio",
      "sol",
      "solapa",
      "soldado",
      "soledad",
      "solido",
      "soltar",
      "solucion",
      "sombra",
      "sondeo",
      "sonido",
      "sonoro",
      "sonrisa",
      "sopa",
      "soplar",
      "soporte",
      "sordo",
      "sorpresa",
      "sorteo",
      "sosten",
      "sotano",
      "suave",
      "subir",
      "suceso",
      "sudor",
      "suegra",
      "suelo",
      "sueno",
      "suerte",
      "sufrir",
      "sujeto",
      "sultan",
      "sumar",
      "superar",
      "suplir",
      "suponer",
      "supremo",
      "sur",
      "surco",
      "sureno",
      "surgir",
      "susto",
      "sutil",
      "tabaco",
      "tabique",
      "tabla",
      "tabu",
      "taco",
      "tacto",
      "tajo",
      "talar",
      "talco",
      "talento",
      "talla",
      "talon",
      "tamano",
      "tambor",
      "tango",
      "tanque",
      "tapa",
      "tapete",
      "tapia",
      "tapon",
      "taquilla",
      "tarde",
      "tarea",
      "tarifa",
      "tarjeta",
      "tarot",
      "tarro",
      "tarta",
      "tatuaje",
      "tauro",
      "taza",
      "tazon",
      "teatro",
      "techo",
      "tecla",
      "tecnica",
      "tejado",
      "tejer",
      "tejido",
      "tela",
      "telefono",
      "tema",
      "temor",
      "templo",
      "tenaz",
      "tender",
      "tener",
      "tenis",
      "tenso",
      "teoria",
      "terapia",
      "terco",
      "termino",
      "ternura",
      "terror",
      "tesis",
      "tesoro",
      "testigo",
      "tetera",
      "texto",
      "tez",
      "tibio",
      "tiburon",
      "tiempo",
      "tienda",
      "tierra",
      "tieso",
      "tigre",
      "tijera",
      "tilde",
      "timbre",
      "timido",
      "timo",
      "tinta",
      "tio",
      "tipico",
      "tipo",
      "tira",
      "tiron",
      "titan",
      "titere",
      "titulo",
      "tiza",
      "toalla",
      "tobillo",
      "tocar",
      "tocino",
      "todo",
      "toga",
      "toldo",
      "tomar",
      "tono",
      "tonto",
      "topar",
      "tope",
      "toque",
      "torax",
      "torero",
      "tormenta",
      "torneo",
      "toro",
      "torpedo",
      "torre",
      "torso",
      "tortuga",
      "tos",
      "tosco",
      "toser",
      "toxico",
      "trabajo",
      "tractor",
      "traer",
      "trafico",
      "trago",
      "traje",
      "tramo",
      "trance",
      "trato",
      "trauma",
      "trazar",
      "trebol",
      "tregua",
      "treinta",
      "tren",
      "trepar",
      "tres",
      "tribu",
      "trigo",
      "tripa",
      "triste",
      "triunfo",
      "trofeo",
      "trompa",
      "tronco",
      "tropa",
      "trote",
      "trozo",
      "truco",
      "trueno",
      "trufa",
      "tuberia",
      "tubo",
      "tuerto",
      "tumba",
      "tumor",
      "tunel",
      "tunica",
      "turbina",
      "turismo",
      "turno",
      "tutor",
      "ubicar",
      "ulcera",
      "umbral",
      "unidad",
      "unir",
      "universo",
      "uno",
      "untar",
      "una",
      "urbano",
      "urbe",
      "urgente",
      "urna",
      "usar",
      "usuario",
      "util",
      "utopia",
      "uva",
      "vaca",
      "vacio",
      "vacuna",
      "vagar",
      "vago",
      "vaina",
      "vajilla",
      "vale",
      "valido",
      "valle",
      "valor",
      "valvula",
      "vampiro",
      "vara",
      "variar",
      "varon",
      "vaso",
      "vecino",
      "vector",
      "vehiculo",
      "veinte",
      "vejez",
      "vela",
      "velero",
      "veloz",
      "vena",
      "vencer",
      "venda",
      "veneno",
      "vengar",
      "venir",
      "venta",
      "venus",
      "ver",
      "verano",
      "verbo",
      "verde",
      "vereda",
      "verja",
      "verso",
      "verter",
      "via",
      "viaje",
      "vibrar",
      "vicio",
      "victima",
      "vida",
      "video",
      "vidrio",
      "viejo",
      "viernes",
      "vigor",
      "vil",
      "villa",
      "vinagre",
      "vino",
      "vinedo",
      "violin",
      "viral",
      "virgo",
      "virtud",
      "visor",
      "vispera",
      "vista",
      "vitamina",
      "viudo",
      "vivaz",
      "vivero",
      "vivir",
      "vivo",
      "volcan",
      "volumen",
      "volver",
      "voraz",
      "votar",
      "voto",
      "voz",
      "vuelo",
      "vulgar",
      "yacer",
      "yate",
      "yegua",
      "yema",
      "yerno",
      "yeso",
      "yodo",
      "yoga",
      "yogur",
      "zafiro",
      "zanja",
      "zapato",
      "zarza",
      "zona",
      "zorro",
      "zumo",
      "zurdo"
    ];
  }
});

// ../../node_modules/.pnpm/bip39@3.1.0/node_modules/bip39/src/wordlists/japanese.json
var require_japanese = __commonJS({
  "../../node_modules/.pnpm/bip39@3.1.0/node_modules/bip39/src/wordlists/japanese.json"(exports, module) {
    module.exports = [
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      ""
    ];
  }
});

// ../../node_modules/.pnpm/bip39@3.1.0/node_modules/bip39/src/wordlists/portuguese.json
var require_portuguese = __commonJS({
  "../../node_modules/.pnpm/bip39@3.1.0/node_modules/bip39/src/wordlists/portuguese.json"(exports, module) {
    module.exports = [
      "abacate",
      "abaixo",
      "abalar",
      "abater",
      "abduzir",
      "abelha",
      "aberto",
      "abismo",
      "abotoar",
      "abranger",
      "abreviar",
      "abrigar",
      "abrupto",
      "absinto",
      "absoluto",
      "absurdo",
      "abutre",
      "acabado",
      "acalmar",
      "acampar",
      "acanhar",
      "acaso",
      "aceitar",
      "acelerar",
      "acenar",
      "acervo",
      "acessar",
      "acetona",
      "achatar",
      "acidez",
      "acima",
      "acionado",
      "acirrar",
      "aclamar",
      "aclive",
      "acolhida",
      "acomodar",
      "acoplar",
      "acordar",
      "acumular",
      "acusador",
      "adaptar",
      "adega",
      "adentro",
      "adepto",
      "adequar",
      "aderente",
      "adesivo",
      "adeus",
      "adiante",
      "aditivo",
      "adjetivo",
      "adjunto",
      "admirar",
      "adorar",
      "adquirir",
      "adubo",
      "adverso",
      "advogado",
      "aeronave",
      "afastar",
      "aferir",
      "afetivo",
      "afinador",
      "afivelar",
      "aflito",
      "afluente",
      "afrontar",
      "agachar",
      "agarrar",
      "agasalho",
      "agenciar",
      "agilizar",
      "agiota",
      "agitado",
      "agora",
      "agradar",
      "agreste",
      "agrupar",
      "aguardar",
      "agulha",
      "ajoelhar",
      "ajudar",
      "ajustar",
      "alameda",
      "alarme",
      "alastrar",
      "alavanca",
      "albergue",
      "albino",
      "alcatra",
      "aldeia",
      "alecrim",
      "alegria",
      "alertar",
      "alface",
      "alfinete",
      "algum",
      "alheio",
      "aliar",
      "alicate",
      "alienar",
      "alinhar",
      "aliviar",
      "almofada",
      "alocar",
      "alpiste",
      "alterar",
      "altitude",
      "alucinar",
      "alugar",
      "aluno",
      "alusivo",
      "alvo",
      "amaciar",
      "amador",
      "amarelo",
      "amassar",
      "ambas",
      "ambiente",
      "ameixa",
      "amenizar",
      "amido",
      "amistoso",
      "amizade",
      "amolador",
      "amontoar",
      "amoroso",
      "amostra",
      "amparar",
      "ampliar",
      "ampola",
      "anagrama",
      "analisar",
      "anarquia",
      "anatomia",
      "andaime",
      "anel",
      "anexo",
      "angular",
      "animar",
      "anjo",
      "anomalia",
      "anotado",
      "ansioso",
      "anterior",
      "anuidade",
      "anunciar",
      "anzol",
      "apagador",
      "apalpar",
      "apanhado",
      "apego",
      "apelido",
      "apertada",
      "apesar",
      "apetite",
      "apito",
      "aplauso",
      "aplicada",
      "apoio",
      "apontar",
      "aposta",
      "aprendiz",
      "aprovar",
      "aquecer",
      "arame",
      "aranha",
      "arara",
      "arcada",
      "ardente",
      "areia",
      "arejar",
      "arenito",
      "aresta",
      "argiloso",
      "argola",
      "arma",
      "arquivo",
      "arraial",
      "arrebate",
      "arriscar",
      "arroba",
      "arrumar",
      "arsenal",
      "arterial",
      "artigo",
      "arvoredo",
      "asfaltar",
      "asilado",
      "aspirar",
      "assador",
      "assinar",
      "assoalho",
      "assunto",
      "astral",
      "atacado",
      "atadura",
      "atalho",
      "atarefar",
      "atear",
      "atender",
      "aterro",
      "ateu",
      "atingir",
      "atirador",
      "ativo",
      "atoleiro",
      "atracar",
      "atrevido",
      "atriz",
      "atual",
      "atum",
      "auditor",
      "aumentar",
      "aura",
      "aurora",
      "autismo",
      "autoria",
      "autuar",
      "avaliar",
      "avante",
      "avaria",
      "avental",
      "avesso",
      "aviador",
      "avisar",
      "avulso",
      "axila",
      "azarar",
      "azedo",
      "azeite",
      "azulejo",
      "babar",
      "babosa",
      "bacalhau",
      "bacharel",
      "bacia",
      "bagagem",
      "baiano",
      "bailar",
      "baioneta",
      "bairro",
      "baixista",
      "bajular",
      "baleia",
      "baliza",
      "balsa",
      "banal",
      "bandeira",
      "banho",
      "banir",
      "banquete",
      "barato",
      "barbado",
      "baronesa",
      "barraca",
      "barulho",
      "baseado",
      "bastante",
      "batata",
      "batedor",
      "batida",
      "batom",
      "batucar",
      "baunilha",
      "beber",
      "beijo",
      "beirada",
      "beisebol",
      "beldade",
      "beleza",
      "belga",
      "beliscar",
      "bendito",
      "bengala",
      "benzer",
      "berimbau",
      "berlinda",
      "berro",
      "besouro",
      "bexiga",
      "bezerro",
      "bico",
      "bicudo",
      "bienal",
      "bifocal",
      "bifurcar",
      "bigorna",
      "bilhete",
      "bimestre",
      "bimotor",
      "biologia",
      "biombo",
      "biosfera",
      "bipolar",
      "birrento",
      "biscoito",
      "bisneto",
      "bispo",
      "bissexto",
      "bitola",
      "bizarro",
      "blindado",
      "bloco",
      "bloquear",
      "boato",
      "bobagem",
      "bocado",
      "bocejo",
      "bochecha",
      "boicotar",
      "bolada",
      "boletim",
      "bolha",
      "bolo",
      "bombeiro",
      "bonde",
      "boneco",
      "bonita",
      "borbulha",
      "borda",
      "boreal",
      "borracha",
      "bovino",
      "boxeador",
      "branco",
      "brasa",
      "braveza",
      "breu",
      "briga",
      "brilho",
      "brincar",
      "broa",
      "brochura",
      "bronzear",
      "broto",
      "bruxo",
      "bucha",
      "budismo",
      "bufar",
      "bule",
      "buraco",
      "busca",
      "busto",
      "buzina",
      "cabana",
      "cabelo",
      "cabide",
      "cabo",
      "cabrito",
      "cacau",
      "cacetada",
      "cachorro",
      "cacique",
      "cadastro",
      "cadeado",
      "cafezal",
      "caiaque",
      "caipira",
      "caixote",
      "cajado",
      "caju",
      "calafrio",
      "calcular",
      "caldeira",
      "calibrar",
      "calmante",
      "calota",
      "camada",
      "cambista",
      "camisa",
      "camomila",
      "campanha",
      "camuflar",
      "canavial",
      "cancelar",
      "caneta",
      "canguru",
      "canhoto",
      "canivete",
      "canoa",
      "cansado",
      "cantar",
      "canudo",
      "capacho",
      "capela",
      "capinar",
      "capotar",
      "capricho",
      "captador",
      "capuz",
      "caracol",
      "carbono",
      "cardeal",
      "careca",
      "carimbar",
      "carneiro",
      "carpete",
      "carreira",
      "cartaz",
      "carvalho",
      "casaco",
      "casca",
      "casebre",
      "castelo",
      "casulo",
      "catarata",
      "cativar",
      "caule",
      "causador",
      "cautelar",
      "cavalo",
      "caverna",
      "cebola",
      "cedilha",
      "cegonha",
      "celebrar",
      "celular",
      "cenoura",
      "censo",
      "centeio",
      "cercar",
      "cerrado",
      "certeiro",
      "cerveja",
      "cetim",
      "cevada",
      "chacota",
      "chaleira",
      "chamado",
      "chapada",
      "charme",
      "chatice",
      "chave",
      "chefe",
      "chegada",
      "cheiro",
      "cheque",
      "chicote",
      "chifre",
      "chinelo",
      "chocalho",
      "chover",
      "chumbo",
      "chutar",
      "chuva",
      "cicatriz",
      "ciclone",
      "cidade",
      "cidreira",
      "ciente",
      "cigana",
      "cimento",
      "cinto",
      "cinza",
      "ciranda",
      "circuito",
      "cirurgia",
      "citar",
      "clareza",
      "clero",
      "clicar",
      "clone",
      "clube",
      "coado",
      "coagir",
      "cobaia",
      "cobertor",
      "cobrar",
      "cocada",
      "coelho",
      "coentro",
      "coeso",
      "cogumelo",
      "coibir",
      "coifa",
      "coiote",
      "colar",
      "coleira",
      "colher",
      "colidir",
      "colmeia",
      "colono",
      "coluna",
      "comando",
      "combinar",
      "comentar",
      "comitiva",
      "comover",
      "complexo",
      "comum",
      "concha",
      "condor",
      "conectar",
      "confuso",
      "congelar",
      "conhecer",
      "conjugar",
      "consumir",
      "contrato",
      "convite",
      "cooperar",
      "copeiro",
      "copiador",
      "copo",
      "coquetel",
      "coragem",
      "cordial",
      "corneta",
      "coronha",
      "corporal",
      "correio",
      "cortejo",
      "coruja",
      "corvo",
      "cosseno",
      "costela",
      "cotonete",
      "couro",
      "couve",
      "covil",
      "cozinha",
      "cratera",
      "cravo",
      "creche",
      "credor",
      "creme",
      "crer",
      "crespo",
      "criada",
      "criminal",
      "crioulo",
      "crise",
      "criticar",
      "crosta",
      "crua",
      "cruzeiro",
      "cubano",
      "cueca",
      "cuidado",
      "cujo",
      "culatra",
      "culminar",
      "culpar",
      "cultura",
      "cumprir",
      "cunhado",
      "cupido",
      "curativo",
      "curral",
      "cursar",
      "curto",
      "cuspir",
      "custear",
      "cutelo",
      "damasco",
      "datar",
      "debater",
      "debitar",
      "deboche",
      "debulhar",
      "decalque",
      "decimal",
      "declive",
      "decote",
      "decretar",
      "dedal",
      "dedicado",
      "deduzir",
      "defesa",
      "defumar",
      "degelo",
      "degrau",
      "degustar",
      "deitado",
      "deixar",
      "delator",
      "delegado",
      "delinear",
      "delonga",
      "demanda",
      "demitir",
      "demolido",
      "dentista",
      "depenado",
      "depilar",
      "depois",
      "depressa",
      "depurar",
      "deriva",
      "derramar",
      "desafio",
      "desbotar",
      "descanso",
      "desenho",
      "desfiado",
      "desgaste",
      "desigual",
      "deslize",
      "desmamar",
      "desova",
      "despesa",
      "destaque",
      "desviar",
      "detalhar",
      "detentor",
      "detonar",
      "detrito",
      "deusa",
      "dever",
      "devido",
      "devotado",
      "dezena",
      "diagrama",
      "dialeto",
      "didata",
      "difuso",
      "digitar",
      "dilatado",
      "diluente",
      "diminuir",
      "dinastia",
      "dinheiro",
      "diocese",
      "direto",
      "discreta",
      "disfarce",
      "disparo",
      "disquete",
      "dissipar",
      "distante",
      "ditador",
      "diurno",
      "diverso",
      "divisor",
      "divulgar",
      "dizer",
      "dobrador",
      "dolorido",
      "domador",
      "dominado",
      "donativo",
      "donzela",
      "dormente",
      "dorsal",
      "dosagem",
      "dourado",
      "doutor",
      "drenagem",
      "drible",
      "drogaria",
      "duelar",
      "duende",
      "dueto",
      "duplo",
      "duquesa",
      "durante",
      "duvidoso",
      "eclodir",
      "ecoar",
      "ecologia",
      "edificar",
      "edital",
      "educado",
      "efeito",
      "efetivar",
      "ejetar",
      "elaborar",
      "eleger",
      "eleitor",
      "elenco",
      "elevador",
      "eliminar",
      "elogiar",
      "embargo",
      "embolado",
      "embrulho",
      "embutido",
      "emenda",
      "emergir",
      "emissor",
      "empatia",
      "empenho",
      "empinado",
      "empolgar",
      "emprego",
      "empurrar",
      "emulador",
      "encaixe",
      "encenado",
      "enchente",
      "encontro",
      "endeusar",
      "endossar",
      "enfaixar",
      "enfeite",
      "enfim",
      "engajado",
      "engenho",
      "englobar",
      "engomado",
      "engraxar",
      "enguia",
      "enjoar",
      "enlatar",
      "enquanto",
      "enraizar",
      "enrolado",
      "enrugar",
      "ensaio",
      "enseada",
      "ensino",
      "ensopado",
      "entanto",
      "enteado",
      "entidade",
      "entortar",
      "entrada",
      "entulho",
      "envergar",
      "enviado",
      "envolver",
      "enxame",
      "enxerto",
      "enxofre",
      "enxuto",
      "epiderme",
      "equipar",
      "ereto",
      "erguido",
      "errata",
      "erva",
      "ervilha",
      "esbanjar",
      "esbelto",
      "escama",
      "escola",
      "escrita",
      "escuta",
      "esfinge",
      "esfolar",
      "esfregar",
      "esfumado",
      "esgrima",
      "esmalte",
      "espanto",
      "espelho",
      "espiga",
      "esponja",
      "espreita",
      "espumar",
      "esquerda",
      "estaca",
      "esteira",
      "esticar",
      "estofado",
      "estrela",
      "estudo",
      "esvaziar",
      "etanol",
      "etiqueta",
      "euforia",
      "europeu",
      "evacuar",
      "evaporar",
      "evasivo",
      "eventual",
      "evidente",
      "evoluir",
      "exagero",
      "exalar",
      "examinar",
      "exato",
      "exausto",
      "excesso",
      "excitar",
      "exclamar",
      "executar",
      "exemplo",
      "exibir",
      "exigente",
      "exonerar",
      "expandir",
      "expelir",
      "expirar",
      "explanar",
      "exposto",
      "expresso",
      "expulsar",
      "externo",
      "extinto",
      "extrato",
      "fabricar",
      "fabuloso",
      "faceta",
      "facial",
      "fada",
      "fadiga",
      "faixa",
      "falar",
      "falta",
      "familiar",
      "fandango",
      "fanfarra",
      "fantoche",
      "fardado",
      "farelo",
      "farinha",
      "farofa",
      "farpa",
      "fartura",
      "fatia",
      "fator",
      "favorita",
      "faxina",
      "fazenda",
      "fechado",
      "feijoada",
      "feirante",
      "felino",
      "feminino",
      "fenda",
      "feno",
      "fera",
      "feriado",
      "ferrugem",
      "ferver",
      "festejar",
      "fetal",
      "feudal",
      "fiapo",
      "fibrose",
      "ficar",
      "ficheiro",
      "figurado",
      "fileira",
      "filho",
      "filme",
      "filtrar",
      "firmeza",
      "fisgada",
      "fissura",
      "fita",
      "fivela",
      "fixador",
      "fixo",
      "flacidez",
      "flamingo",
      "flanela",
      "flechada",
      "flora",
      "flutuar",
      "fluxo",
      "focal",
      "focinho",
      "fofocar",
      "fogo",
      "foguete",
      "foice",
      "folgado",
      "folheto",
      "forjar",
      "formiga",
      "forno",
      "forte",
      "fosco",
      "fossa",
      "fragata",
      "fralda",
      "frango",
      "frasco",
      "fraterno",
      "freira",
      "frente",
      "fretar",
      "frieza",
      "friso",
      "fritura",
      "fronha",
      "frustrar",
      "fruteira",
      "fugir",
      "fulano",
      "fuligem",
      "fundar",
      "fungo",
      "funil",
      "furador",
      "furioso",
      "futebol",
      "gabarito",
      "gabinete",
      "gado",
      "gaiato",
      "gaiola",
      "gaivota",
      "galega",
      "galho",
      "galinha",
      "galocha",
      "ganhar",
      "garagem",
      "garfo",
      "gargalo",
      "garimpo",
      "garoupa",
      "garrafa",
      "gasoduto",
      "gasto",
      "gata",
      "gatilho",
      "gaveta",
      "gazela",
      "gelado",
      "geleia",
      "gelo",
      "gemada",
      "gemer",
      "gemido",
      "generoso",
      "gengiva",
      "genial",
      "genoma",
      "genro",
      "geologia",
      "gerador",
      "germinar",
      "gesso",
      "gestor",
      "ginasta",
      "gincana",
      "gingado",
      "girafa",
      "girino",
      "glacial",
      "glicose",
      "global",
      "glorioso",
      "goela",
      "goiaba",
      "golfe",
      "golpear",
      "gordura",
      "gorjeta",
      "gorro",
      "gostoso",
      "goteira",
      "governar",
      "gracejo",
      "gradual",
      "grafite",
      "gralha",
      "grampo",
      "granada",
      "gratuito",
      "graveto",
      "graxa",
      "grego",
      "grelhar",
      "greve",
      "grilo",
      "grisalho",
      "gritaria",
      "grosso",
      "grotesco",
      "grudado",
      "grunhido",
      "gruta",
      "guache",
      "guarani",
      "guaxinim",
      "guerrear",
      "guiar",
      "guincho",
      "guisado",
      "gula",
      "guloso",
      "guru",
      "habitar",
      "harmonia",
      "haste",
      "haver",
      "hectare",
      "herdar",
      "heresia",
      "hesitar",
      "hiato",
      "hibernar",
      "hidratar",
      "hiena",
      "hino",
      "hipismo",
      "hipnose",
      "hipoteca",
      "hoje",
      "holofote",
      "homem",
      "honesto",
      "honrado",
      "hormonal",
      "hospedar",
      "humorado",
      "iate",
      "ideia",
      "idoso",
      "ignorado",
      "igreja",
      "iguana",
      "ileso",
      "ilha",
      "iludido",
      "iluminar",
      "ilustrar",
      "imagem",
      "imediato",
      "imenso",
      "imersivo",
      "iminente",
      "imitador",
      "imortal",
      "impacto",
      "impedir",
      "implante",
      "impor",
      "imprensa",
      "impune",
      "imunizar",
      "inalador",
      "inapto",
      "inativo",
      "incenso",
      "inchar",
      "incidir",
      "incluir",
      "incolor",
      "indeciso",
      "indireto",
      "indutor",
      "ineficaz",
      "inerente",
      "infantil",
      "infestar",
      "infinito",
      "inflamar",
      "informal",
      "infrator",
      "ingerir",
      "inibido",
      "inicial",
      "inimigo",
      "injetar",
      "inocente",
      "inodoro",
      "inovador",
      "inox",
      "inquieto",
      "inscrito",
      "inseto",
      "insistir",
      "inspetor",
      "instalar",
      "insulto",
      "intacto",
      "integral",
      "intimar",
      "intocado",
      "intriga",
      "invasor",
      "inverno",
      "invicto",
      "invocar",
      "iogurte",
      "iraniano",
      "ironizar",
      "irreal",
      "irritado",
      "isca",
      "isento",
      "isolado",
      "isqueiro",
      "italiano",
      "janeiro",
      "jangada",
      "janta",
      "jararaca",
      "jardim",
      "jarro",
      "jasmim",
      "jato",
      "javali",
      "jazida",
      "jejum",
      "joaninha",
      "joelhada",
      "jogador",
      "joia",
      "jornal",
      "jorrar",
      "jovem",
      "juba",
      "judeu",
      "judoca",
      "juiz",
      "julgador",
      "julho",
      "jurado",
      "jurista",
      "juro",
      "justa",
      "labareda",
      "laboral",
      "lacre",
      "lactante",
      "ladrilho",
      "lagarta",
      "lagoa",
      "laje",
      "lamber",
      "lamentar",
      "laminar",
      "lampejo",
      "lanche",
      "lapidar",
      "lapso",
      "laranja",
      "lareira",
      "largura",
      "lasanha",
      "lastro",
      "lateral",
      "latido",
      "lavanda",
      "lavoura",
      "lavrador",
      "laxante",
      "lazer",
      "lealdade",
      "lebre",
      "legado",
      "legendar",
      "legista",
      "leigo",
      "leiloar",
      "leitura",
      "lembrete",
      "leme",
      "lenhador",
      "lentilha",
      "leoa",
      "lesma",
      "leste",
      "letivo",
      "letreiro",
      "levar",
      "leveza",
      "levitar",
      "liberal",
      "libido",
      "liderar",
      "ligar",
      "ligeiro",
      "limitar",
      "limoeiro",
      "limpador",
      "linda",
      "linear",
      "linhagem",
      "liquidez",
      "listagem",
      "lisura",
      "litoral",
      "livro",
      "lixa",
      "lixeira",
      "locador",
      "locutor",
      "lojista",
      "lombo",
      "lona",
      "longe",
      "lontra",
      "lorde",
      "lotado",
      "loteria",
      "loucura",
      "lousa",
      "louvar",
      "luar",
      "lucidez",
      "lucro",
      "luneta",
      "lustre",
      "lutador",
      "luva",
      "macaco",
      "macete",
      "machado",
      "macio",
      "madeira",
      "madrinha",
      "magnata",
      "magreza",
      "maior",
      "mais",
      "malandro",
      "malha",
      "malote",
      "maluco",
      "mamilo",
      "mamoeiro",
      "mamute",
      "manada",
      "mancha",
      "mandato",
      "manequim",
      "manhoso",
      "manivela",
      "manobrar",
      "mansa",
      "manter",
      "manusear",
      "mapeado",
      "maquinar",
      "marcador",
      "maresia",
      "marfim",
      "margem",
      "marinho",
      "marmita",
      "maroto",
      "marquise",
      "marreco",
      "martelo",
      "marujo",
      "mascote",
      "masmorra",
      "massagem",
      "mastigar",
      "matagal",
      "materno",
      "matinal",
      "matutar",
      "maxilar",
      "medalha",
      "medida",
      "medusa",
      "megafone",
      "meiga",
      "melancia",
      "melhor",
      "membro",
      "memorial",
      "menino",
      "menos",
      "mensagem",
      "mental",
      "merecer",
      "mergulho",
      "mesada",
      "mesclar",
      "mesmo",
      "mesquita",
      "mestre",
      "metade",
      "meteoro",
      "metragem",
      "mexer",
      "mexicano",
      "micro",
      "migalha",
      "migrar",
      "milagre",
      "milenar",
      "milhar",
      "mimado",
      "minerar",
      "minhoca",
      "ministro",
      "minoria",
      "miolo",
      "mirante",
      "mirtilo",
      "misturar",
      "mocidade",
      "moderno",
      "modular",
      "moeda",
      "moer",
      "moinho",
      "moita",
      "moldura",
      "moleza",
      "molho",
      "molinete",
      "molusco",
      "montanha",
      "moqueca",
      "morango",
      "morcego",
      "mordomo",
      "morena",
      "mosaico",
      "mosquete",
      "mostarda",
      "motel",
      "motim",
      "moto",
      "motriz",
      "muda",
      "muito",
      "mulata",
      "mulher",
      "multar",
      "mundial",
      "munido",
      "muralha",
      "murcho",
      "muscular",
      "museu",
      "musical",
      "nacional",
      "nadador",
      "naja",
      "namoro",
      "narina",
      "narrado",
      "nascer",
      "nativa",
      "natureza",
      "navalha",
      "navegar",
      "navio",
      "neblina",
      "nebuloso",
      "negativa",
      "negociar",
      "negrito",
      "nervoso",
      "neta",
      "neural",
      "nevasca",
      "nevoeiro",
      "ninar",
      "ninho",
      "nitidez",
      "nivelar",
      "nobreza",
      "noite",
      "noiva",
      "nomear",
      "nominal",
      "nordeste",
      "nortear",
      "notar",
      "noticiar",
      "noturno",
      "novelo",
      "novilho",
      "novo",
      "nublado",
      "nudez",
      "numeral",
      "nupcial",
      "nutrir",
      "nuvem",
      "obcecado",
      "obedecer",
      "objetivo",
      "obrigado",
      "obscuro",
      "obstetra",
      "obter",
      "obturar",
      "ocidente",
      "ocioso",
      "ocorrer",
      "oculista",
      "ocupado",
      "ofegante",
      "ofensiva",
      "oferenda",
      "oficina",
      "ofuscado",
      "ogiva",
      "olaria",
      "oleoso",
      "olhar",
      "oliveira",
      "ombro",
      "omelete",
      "omisso",
      "omitir",
      "ondulado",
      "oneroso",
      "ontem",
      "opcional",
      "operador",
      "oponente",
      "oportuno",
      "oposto",
      "orar",
      "orbitar",
      "ordem",
      "ordinal",
      "orfanato",
      "orgasmo",
      "orgulho",
      "oriental",
      "origem",
      "oriundo",
      "orla",
      "ortodoxo",
      "orvalho",
      "oscilar",
      "ossada",
      "osso",
      "ostentar",
      "otimismo",
      "ousadia",
      "outono",
      "outubro",
      "ouvido",
      "ovelha",
      "ovular",
      "oxidar",
      "oxigenar",
      "pacato",
      "paciente",
      "pacote",
      "pactuar",
      "padaria",
      "padrinho",
      "pagar",
      "pagode",
      "painel",
      "pairar",
      "paisagem",
      "palavra",
      "palestra",
      "palheta",
      "palito",
      "palmada",
      "palpitar",
      "pancada",
      "panela",
      "panfleto",
      "panqueca",
      "pantanal",
      "papagaio",
      "papelada",
      "papiro",
      "parafina",
      "parcial",
      "pardal",
      "parede",
      "partida",
      "pasmo",
      "passado",
      "pastel",
      "patamar",
      "patente",
      "patinar",
      "patrono",
      "paulada",
      "pausar",
      "peculiar",
      "pedalar",
      "pedestre",
      "pediatra",
      "pedra",
      "pegada",
      "peitoral",
      "peixe",
      "pele",
      "pelicano",
      "penca",
      "pendurar",
      "peneira",
      "penhasco",
      "pensador",
      "pente",
      "perceber",
      "perfeito",
      "pergunta",
      "perito",
      "permitir",
      "perna",
      "perplexo",
      "persiana",
      "pertence",
      "peruca",
      "pescado",
      "pesquisa",
      "pessoa",
      "petiscar",
      "piada",
      "picado",
      "piedade",
      "pigmento",
      "pilastra",
      "pilhado",
      "pilotar",
      "pimenta",
      "pincel",
      "pinguim",
      "pinha",
      "pinote",
      "pintar",
      "pioneiro",
      "pipoca",
      "piquete",
      "piranha",
      "pires",
      "pirueta",
      "piscar",
      "pistola",
      "pitanga",
      "pivete",
      "planta",
      "plaqueta",
      "platina",
      "plebeu",
      "plumagem",
      "pluvial",
      "pneu",
      "poda",
      "poeira",
      "poetisa",
      "polegada",
      "policiar",
      "poluente",
      "polvilho",
      "pomar",
      "pomba",
      "ponderar",
      "pontaria",
      "populoso",
      "porta",
      "possuir",
      "postal",
      "pote",
      "poupar",
      "pouso",
      "povoar",
      "praia",
      "prancha",
      "prato",
      "praxe",
      "prece",
      "predador",
      "prefeito",
      "premiar",
      "prensar",
      "preparar",
      "presilha",
      "pretexto",
      "prevenir",
      "prezar",
      "primata",
      "princesa",
      "prisma",
      "privado",
      "processo",
      "produto",
      "profeta",
      "proibido",
      "projeto",
      "prometer",
      "propagar",
      "prosa",
      "protetor",
      "provador",
      "publicar",
      "pudim",
      "pular",
      "pulmonar",
      "pulseira",
      "punhal",
      "punir",
      "pupilo",
      "pureza",
      "puxador",
      "quadra",
      "quantia",
      "quarto",
      "quase",
      "quebrar",
      "queda",
      "queijo",
      "quente",
      "querido",
      "quimono",
      "quina",
      "quiosque",
      "rabanada",
      "rabisco",
      "rachar",
      "racionar",
      "radial",
      "raiar",
      "rainha",
      "raio",
      "raiva",
      "rajada",
      "ralado",
      "ramal",
      "ranger",
      "ranhura",
      "rapadura",
      "rapel",
      "rapidez",
      "raposa",
      "raquete",
      "raridade",
      "rasante",
      "rascunho",
      "rasgar",
      "raspador",
      "rasteira",
      "rasurar",
      "ratazana",
      "ratoeira",
      "realeza",
      "reanimar",
      "reaver",
      "rebaixar",
      "rebelde",
      "rebolar",
      "recado",
      "recente",
      "recheio",
      "recibo",
      "recordar",
      "recrutar",
      "recuar",
      "rede",
      "redimir",
      "redonda",
      "reduzida",
      "reenvio",
      "refinar",
      "refletir",
      "refogar",
      "refresco",
      "refugiar",
      "regalia",
      "regime",
      "regra",
      "reinado",
      "reitor",
      "rejeitar",
      "relativo",
      "remador",
      "remendo",
      "remorso",
      "renovado",
      "reparo",
      "repelir",
      "repleto",
      "repolho",
      "represa",
      "repudiar",
      "requerer",
      "resenha",
      "resfriar",
      "resgatar",
      "residir",
      "resolver",
      "respeito",
      "ressaca",
      "restante",
      "resumir",
      "retalho",
      "reter",
      "retirar",
      "retomada",
      "retratar",
      "revelar",
      "revisor",
      "revolta",
      "riacho",
      "rica",
      "rigidez",
      "rigoroso",
      "rimar",
      "ringue",
      "risada",
      "risco",
      "risonho",
      "robalo",
      "rochedo",
      "rodada",
      "rodeio",
      "rodovia",
      "roedor",
      "roleta",
      "romano",
      "roncar",
      "rosado",
      "roseira",
      "rosto",
      "rota",
      "roteiro",
      "rotina",
      "rotular",
      "rouco",
      "roupa",
      "roxo",
      "rubro",
      "rugido",
      "rugoso",
      "ruivo",
      "rumo",
      "rupestre",
      "russo",
      "sabor",
      "saciar",
      "sacola",
      "sacudir",
      "sadio",
      "safira",
      "saga",
      "sagrada",
      "saibro",
      "salada",
      "saleiro",
      "salgado",
      "saliva",
      "salpicar",
      "salsicha",
      "saltar",
      "salvador",
      "sambar",
      "samurai",
      "sanar",
      "sanfona",
      "sangue",
      "sanidade",
      "sapato",
      "sarda",
      "sargento",
      "sarjeta",
      "saturar",
      "saudade",
      "saxofone",
      "sazonal",
      "secar",
      "secular",
      "seda",
      "sedento",
      "sediado",
      "sedoso",
      "sedutor",
      "segmento",
      "segredo",
      "segundo",
      "seiva",
      "seleto",
      "selvagem",
      "semanal",
      "semente",
      "senador",
      "senhor",
      "sensual",
      "sentado",
      "separado",
      "sereia",
      "seringa",
      "serra",
      "servo",
      "setembro",
      "setor",
      "sigilo",
      "silhueta",
      "silicone",
      "simetria",
      "simpatia",
      "simular",
      "sinal",
      "sincero",
      "singular",
      "sinopse",
      "sintonia",
      "sirene",
      "siri",
      "situado",
      "soberano",
      "sobra",
      "socorro",
      "sogro",
      "soja",
      "solda",
      "soletrar",
      "solteiro",
      "sombrio",
      "sonata",
      "sondar",
      "sonegar",
      "sonhador",
      "sono",
      "soprano",
      "soquete",
      "sorrir",
      "sorteio",
      "sossego",
      "sotaque",
      "soterrar",
      "sovado",
      "sozinho",
      "suavizar",
      "subida",
      "submerso",
      "subsolo",
      "subtrair",
      "sucata",
      "sucesso",
      "suco",
      "sudeste",
      "sufixo",
      "sugador",
      "sugerir",
      "sujeito",
      "sulfato",
      "sumir",
      "suor",
      "superior",
      "suplicar",
      "suposto",
      "suprimir",
      "surdina",
      "surfista",
      "surpresa",
      "surreal",
      "surtir",
      "suspiro",
      "sustento",
      "tabela",
      "tablete",
      "tabuada",
      "tacho",
      "tagarela",
      "talher",
      "talo",
      "talvez",
      "tamanho",
      "tamborim",
      "tampa",
      "tangente",
      "tanto",
      "tapar",
      "tapioca",
      "tardio",
      "tarefa",
      "tarja",
      "tarraxa",
      "tatuagem",
      "taurino",
      "taxativo",
      "taxista",
      "teatral",
      "tecer",
      "tecido",
      "teclado",
      "tedioso",
      "teia",
      "teimar",
      "telefone",
      "telhado",
      "tempero",
      "tenente",
      "tensor",
      "tentar",
      "termal",
      "terno",
      "terreno",
      "tese",
      "tesoura",
      "testado",
      "teto",
      "textura",
      "texugo",
      "tiara",
      "tigela",
      "tijolo",
      "timbrar",
      "timidez",
      "tingido",
      "tinteiro",
      "tiragem",
      "titular",
      "toalha",
      "tocha",
      "tolerar",
      "tolice",
      "tomada",
      "tomilho",
      "tonel",
      "tontura",
      "topete",
      "tora",
      "torcido",
      "torneio",
      "torque",
      "torrada",
      "torto",
      "tostar",
      "touca",
      "toupeira",
      "toxina",
      "trabalho",
      "tracejar",
      "tradutor",
      "trafegar",
      "trajeto",
      "trama",
      "trancar",
      "trapo",
      "traseiro",
      "tratador",
      "travar",
      "treino",
      "tremer",
      "trepidar",
      "trevo",
      "triagem",
      "tribo",
      "triciclo",
      "tridente",
      "trilogia",
      "trindade",
      "triplo",
      "triturar",
      "triunfal",
      "trocar",
      "trombeta",
      "trova",
      "trunfo",
      "truque",
      "tubular",
      "tucano",
      "tudo",
      "tulipa",
      "tupi",
      "turbo",
      "turma",
      "turquesa",
      "tutelar",
      "tutorial",
      "uivar",
      "umbigo",
      "unha",
      "unidade",
      "uniforme",
      "urologia",
      "urso",
      "urtiga",
      "urubu",
      "usado",
      "usina",
      "usufruir",
      "vacina",
      "vadiar",
      "vagaroso",
      "vaidoso",
      "vala",
      "valente",
      "validade",
      "valores",
      "vantagem",
      "vaqueiro",
      "varanda",
      "vareta",
      "varrer",
      "vascular",
      "vasilha",
      "vassoura",
      "vazar",
      "vazio",
      "veado",
      "vedar",
      "vegetar",
      "veicular",
      "veleiro",
      "velhice",
      "veludo",
      "vencedor",
      "vendaval",
      "venerar",
      "ventre",
      "verbal",
      "verdade",
      "vereador",
      "vergonha",
      "vermelho",
      "verniz",
      "versar",
      "vertente",
      "vespa",
      "vestido",
      "vetorial",
      "viaduto",
      "viagem",
      "viajar",
      "viatura",
      "vibrador",
      "videira",
      "vidraria",
      "viela",
      "viga",
      "vigente",
      "vigiar",
      "vigorar",
      "vilarejo",
      "vinco",
      "vinheta",
      "vinil",
      "violeta",
      "virada",
      "virtude",
      "visitar",
      "visto",
      "vitral",
      "viveiro",
      "vizinho",
      "voador",
      "voar",
      "vogal",
      "volante",
      "voleibol",
      "voltagem",
      "volumoso",
      "vontade",
      "vulto",
      "vuvuzela",
      "xadrez",
      "xarope",
      "xeque",
      "xeretar",
      "xerife",
      "xingar",
      "zangado",
      "zarpar",
      "zebu",
      "zelador",
      "zombar",
      "zoologia",
      "zumbido"
    ];
  }
});

// ../../node_modules/.pnpm/bip39@3.1.0/node_modules/bip39/src/wordlists/english.json
var require_english = __commonJS({
  "../../node_modules/.pnpm/bip39@3.1.0/node_modules/bip39/src/wordlists/english.json"(exports, module) {
    module.exports = [
      "abandon",
      "ability",
      "able",
      "about",
      "above",
      "absent",
      "absorb",
      "abstract",
      "absurd",
      "abuse",
      "access",
      "accident",
      "account",
      "accuse",
      "achieve",
      "acid",
      "acoustic",
      "acquire",
      "across",
      "act",
      "action",
      "actor",
      "actress",
      "actual",
      "adapt",
      "add",
      "addict",
      "address",
      "adjust",
      "admit",
      "adult",
      "advance",
      "advice",
      "aerobic",
      "affair",
      "afford",
      "afraid",
      "again",
      "age",
      "agent",
      "agree",
      "ahead",
      "aim",
      "air",
      "airport",
      "aisle",
      "alarm",
      "album",
      "alcohol",
      "alert",
      "alien",
      "all",
      "alley",
      "allow",
      "almost",
      "alone",
      "alpha",
      "already",
      "also",
      "alter",
      "always",
      "amateur",
      "amazing",
      "among",
      "amount",
      "amused",
      "analyst",
      "anchor",
      "ancient",
      "anger",
      "angle",
      "angry",
      "animal",
      "ankle",
      "announce",
      "annual",
      "another",
      "answer",
      "antenna",
      "antique",
      "anxiety",
      "any",
      "apart",
      "apology",
      "appear",
      "apple",
      "approve",
      "april",
      "arch",
      "arctic",
      "area",
      "arena",
      "argue",
      "arm",
      "armed",
      "armor",
      "army",
      "around",
      "arrange",
      "arrest",
      "arrive",
      "arrow",
      "art",
      "artefact",
      "artist",
      "artwork",
      "ask",
      "aspect",
      "assault",
      "asset",
      "assist",
      "assume",
      "asthma",
      "athlete",
      "atom",
      "attack",
      "attend",
      "attitude",
      "attract",
      "auction",
      "audit",
      "august",
      "aunt",
      "author",
      "auto",
      "autumn",
      "average",
      "avocado",
      "avoid",
      "awake",
      "aware",
      "away",
      "awesome",
      "awful",
      "awkward",
      "axis",
      "baby",
      "bachelor",
      "bacon",
      "badge",
      "bag",
      "balance",
      "balcony",
      "ball",
      "bamboo",
      "banana",
      "banner",
      "bar",
      "barely",
      "bargain",
      "barrel",
      "base",
      "basic",
      "basket",
      "battle",
      "beach",
      "bean",
      "beauty",
      "because",
      "become",
      "beef",
      "before",
      "begin",
      "behave",
      "behind",
      "believe",
      "below",
      "belt",
      "bench",
      "benefit",
      "best",
      "betray",
      "better",
      "between",
      "beyond",
      "bicycle",
      "bid",
      "bike",
      "bind",
      "biology",
      "bird",
      "birth",
      "bitter",
      "black",
      "blade",
      "blame",
      "blanket",
      "blast",
      "bleak",
      "bless",
      "blind",
      "blood",
      "blossom",
      "blouse",
      "blue",
      "blur",
      "blush",
      "board",
      "boat",
      "body",
      "boil",
      "bomb",
      "bone",
      "bonus",
      "book",
      "boost",
      "border",
      "boring",
      "borrow",
      "boss",
      "bottom",
      "bounce",
      "box",
      "boy",
      "bracket",
      "brain",
      "brand",
      "brass",
      "brave",
      "bread",
      "breeze",
      "brick",
      "bridge",
      "brief",
      "bright",
      "bring",
      "brisk",
      "broccoli",
      "broken",
      "bronze",
      "broom",
      "brother",
      "brown",
      "brush",
      "bubble",
      "buddy",
      "budget",
      "buffalo",
      "build",
      "bulb",
      "bulk",
      "bullet",
      "bundle",
      "bunker",
      "burden",
      "burger",
      "burst",
      "bus",
      "business",
      "busy",
      "butter",
      "buyer",
      "buzz",
      "cabbage",
      "cabin",
      "cable",
      "cactus",
      "cage",
      "cake",
      "call",
      "calm",
      "camera",
      "camp",
      "can",
      "canal",
      "cancel",
      "candy",
      "cannon",
      "canoe",
      "canvas",
      "canyon",
      "capable",
      "capital",
      "captain",
      "car",
      "carbon",
      "card",
      "cargo",
      "carpet",
      "carry",
      "cart",
      "case",
      "cash",
      "casino",
      "castle",
      "casual",
      "cat",
      "catalog",
      "catch",
      "category",
      "cattle",
      "caught",
      "cause",
      "caution",
      "cave",
      "ceiling",
      "celery",
      "cement",
      "census",
      "century",
      "cereal",
      "certain",
      "chair",
      "chalk",
      "champion",
      "change",
      "chaos",
      "chapter",
      "charge",
      "chase",
      "chat",
      "cheap",
      "check",
      "cheese",
      "chef",
      "cherry",
      "chest",
      "chicken",
      "chief",
      "child",
      "chimney",
      "choice",
      "choose",
      "chronic",
      "chuckle",
      "chunk",
      "churn",
      "cigar",
      "cinnamon",
      "circle",
      "citizen",
      "city",
      "civil",
      "claim",
      "clap",
      "clarify",
      "claw",
      "clay",
      "clean",
      "clerk",
      "clever",
      "click",
      "client",
      "cliff",
      "climb",
      "clinic",
      "clip",
      "clock",
      "clog",
      "close",
      "cloth",
      "cloud",
      "clown",
      "club",
      "clump",
      "cluster",
      "clutch",
      "coach",
      "coast",
      "coconut",
      "code",
      "coffee",
      "coil",
      "coin",
      "collect",
      "color",
      "column",
      "combine",
      "come",
      "comfort",
      "comic",
      "common",
      "company",
      "concert",
      "conduct",
      "confirm",
      "congress",
      "connect",
      "consider",
      "control",
      "convince",
      "cook",
      "cool",
      "copper",
      "copy",
      "coral",
      "core",
      "corn",
      "correct",
      "cost",
      "cotton",
      "couch",
      "country",
      "couple",
      "course",
      "cousin",
      "cover",
      "coyote",
      "crack",
      "cradle",
      "craft",
      "cram",
      "crane",
      "crash",
      "crater",
      "crawl",
      "crazy",
      "cream",
      "credit",
      "creek",
      "crew",
      "cricket",
      "crime",
      "crisp",
      "critic",
      "crop",
      "cross",
      "crouch",
      "crowd",
      "crucial",
      "cruel",
      "cruise",
      "crumble",
      "crunch",
      "crush",
      "cry",
      "crystal",
      "cube",
      "culture",
      "cup",
      "cupboard",
      "curious",
      "current",
      "curtain",
      "curve",
      "cushion",
      "custom",
      "cute",
      "cycle",
      "dad",
      "damage",
      "damp",
      "dance",
      "danger",
      "daring",
      "dash",
      "daughter",
      "dawn",
      "day",
      "deal",
      "debate",
      "debris",
      "decade",
      "december",
      "decide",
      "decline",
      "decorate",
      "decrease",
      "deer",
      "defense",
      "define",
      "defy",
      "degree",
      "delay",
      "deliver",
      "demand",
      "demise",
      "denial",
      "dentist",
      "deny",
      "depart",
      "depend",
      "deposit",
      "depth",
      "deputy",
      "derive",
      "describe",
      "desert",
      "design",
      "desk",
      "despair",
      "destroy",
      "detail",
      "detect",
      "develop",
      "device",
      "devote",
      "diagram",
      "dial",
      "diamond",
      "diary",
      "dice",
      "diesel",
      "diet",
      "differ",
      "digital",
      "dignity",
      "dilemma",
      "dinner",
      "dinosaur",
      "direct",
      "dirt",
      "disagree",
      "discover",
      "disease",
      "dish",
      "dismiss",
      "disorder",
      "display",
      "distance",
      "divert",
      "divide",
      "divorce",
      "dizzy",
      "doctor",
      "document",
      "dog",
      "doll",
      "dolphin",
      "domain",
      "donate",
      "donkey",
      "donor",
      "door",
      "dose",
      "double",
      "dove",
      "draft",
      "dragon",
      "drama",
      "drastic",
      "draw",
      "dream",
      "dress",
      "drift",
      "drill",
      "drink",
      "drip",
      "drive",
      "drop",
      "drum",
      "dry",
      "duck",
      "dumb",
      "dune",
      "during",
      "dust",
      "dutch",
      "duty",
      "dwarf",
      "dynamic",
      "eager",
      "eagle",
      "early",
      "earn",
      "earth",
      "easily",
      "east",
      "easy",
      "echo",
      "ecology",
      "economy",
      "edge",
      "edit",
      "educate",
      "effort",
      "egg",
      "eight",
      "either",
      "elbow",
      "elder",
      "electric",
      "elegant",
      "element",
      "elephant",
      "elevator",
      "elite",
      "else",
      "embark",
      "embody",
      "embrace",
      "emerge",
      "emotion",
      "employ",
      "empower",
      "empty",
      "enable",
      "enact",
      "end",
      "endless",
      "endorse",
      "enemy",
      "energy",
      "enforce",
      "engage",
      "engine",
      "enhance",
      "enjoy",
      "enlist",
      "enough",
      "enrich",
      "enroll",
      "ensure",
      "enter",
      "entire",
      "entry",
      "envelope",
      "episode",
      "equal",
      "equip",
      "era",
      "erase",
      "erode",
      "erosion",
      "error",
      "erupt",
      "escape",
      "essay",
      "essence",
      "estate",
      "eternal",
      "ethics",
      "evidence",
      "evil",
      "evoke",
      "evolve",
      "exact",
      "example",
      "excess",
      "exchange",
      "excite",
      "exclude",
      "excuse",
      "execute",
      "exercise",
      "exhaust",
      "exhibit",
      "exile",
      "exist",
      "exit",
      "exotic",
      "expand",
      "expect",
      "expire",
      "explain",
      "expose",
      "express",
      "extend",
      "extra",
      "eye",
      "eyebrow",
      "fabric",
      "face",
      "faculty",
      "fade",
      "faint",
      "faith",
      "fall",
      "false",
      "fame",
      "family",
      "famous",
      "fan",
      "fancy",
      "fantasy",
      "farm",
      "fashion",
      "fat",
      "fatal",
      "father",
      "fatigue",
      "fault",
      "favorite",
      "feature",
      "february",
      "federal",
      "fee",
      "feed",
      "feel",
      "female",
      "fence",
      "festival",
      "fetch",
      "fever",
      "few",
      "fiber",
      "fiction",
      "field",
      "figure",
      "file",
      "film",
      "filter",
      "final",
      "find",
      "fine",
      "finger",
      "finish",
      "fire",
      "firm",
      "first",
      "fiscal",
      "fish",
      "fit",
      "fitness",
      "fix",
      "flag",
      "flame",
      "flash",
      "flat",
      "flavor",
      "flee",
      "flight",
      "flip",
      "float",
      "flock",
      "floor",
      "flower",
      "fluid",
      "flush",
      "fly",
      "foam",
      "focus",
      "fog",
      "foil",
      "fold",
      "follow",
      "food",
      "foot",
      "force",
      "forest",
      "forget",
      "fork",
      "fortune",
      "forum",
      "forward",
      "fossil",
      "foster",
      "found",
      "fox",
      "fragile",
      "frame",
      "frequent",
      "fresh",
      "friend",
      "fringe",
      "frog",
      "front",
      "frost",
      "frown",
      "frozen",
      "fruit",
      "fuel",
      "fun",
      "funny",
      "furnace",
      "fury",
      "future",
      "gadget",
      "gain",
      "galaxy",
      "gallery",
      "game",
      "gap",
      "garage",
      "garbage",
      "garden",
      "garlic",
      "garment",
      "gas",
      "gasp",
      "gate",
      "gather",
      "gauge",
      "gaze",
      "general",
      "genius",
      "genre",
      "gentle",
      "genuine",
      "gesture",
      "ghost",
      "giant",
      "gift",
      "giggle",
      "ginger",
      "giraffe",
      "girl",
      "give",
      "glad",
      "glance",
      "glare",
      "glass",
      "glide",
      "glimpse",
      "globe",
      "gloom",
      "glory",
      "glove",
      "glow",
      "glue",
      "goat",
      "goddess",
      "gold",
      "good",
      "goose",
      "gorilla",
      "gospel",
      "gossip",
      "govern",
      "gown",
      "grab",
      "grace",
      "grain",
      "grant",
      "grape",
      "grass",
      "gravity",
      "great",
      "green",
      "grid",
      "grief",
      "grit",
      "grocery",
      "group",
      "grow",
      "grunt",
      "guard",
      "guess",
      "guide",
      "guilt",
      "guitar",
      "gun",
      "gym",
      "habit",
      "hair",
      "half",
      "hammer",
      "hamster",
      "hand",
      "happy",
      "harbor",
      "hard",
      "harsh",
      "harvest",
      "hat",
      "have",
      "hawk",
      "hazard",
      "head",
      "health",
      "heart",
      "heavy",
      "hedgehog",
      "height",
      "hello",
      "helmet",
      "help",
      "hen",
      "hero",
      "hidden",
      "high",
      "hill",
      "hint",
      "hip",
      "hire",
      "history",
      "hobby",
      "hockey",
      "hold",
      "hole",
      "holiday",
      "hollow",
      "home",
      "honey",
      "hood",
      "hope",
      "horn",
      "horror",
      "horse",
      "hospital",
      "host",
      "hotel",
      "hour",
      "hover",
      "hub",
      "huge",
      "human",
      "humble",
      "humor",
      "hundred",
      "hungry",
      "hunt",
      "hurdle",
      "hurry",
      "hurt",
      "husband",
      "hybrid",
      "ice",
      "icon",
      "idea",
      "identify",
      "idle",
      "ignore",
      "ill",
      "illegal",
      "illness",
      "image",
      "imitate",
      "immense",
      "immune",
      "impact",
      "impose",
      "improve",
      "impulse",
      "inch",
      "include",
      "income",
      "increase",
      "index",
      "indicate",
      "indoor",
      "industry",
      "infant",
      "inflict",
      "inform",
      "inhale",
      "inherit",
      "initial",
      "inject",
      "injury",
      "inmate",
      "inner",
      "innocent",
      "input",
      "inquiry",
      "insane",
      "insect",
      "inside",
      "inspire",
      "install",
      "intact",
      "interest",
      "into",
      "invest",
      "invite",
      "involve",
      "iron",
      "island",
      "isolate",
      "issue",
      "item",
      "ivory",
      "jacket",
      "jaguar",
      "jar",
      "jazz",
      "jealous",
      "jeans",
      "jelly",
      "jewel",
      "job",
      "join",
      "joke",
      "journey",
      "joy",
      "judge",
      "juice",
      "jump",
      "jungle",
      "junior",
      "junk",
      "just",
      "kangaroo",
      "keen",
      "keep",
      "ketchup",
      "key",
      "kick",
      "kid",
      "kidney",
      "kind",
      "kingdom",
      "kiss",
      "kit",
      "kitchen",
      "kite",
      "kitten",
      "kiwi",
      "knee",
      "knife",
      "knock",
      "know",
      "lab",
      "label",
      "labor",
      "ladder",
      "lady",
      "lake",
      "lamp",
      "language",
      "laptop",
      "large",
      "later",
      "latin",
      "laugh",
      "laundry",
      "lava",
      "law",
      "lawn",
      "lawsuit",
      "layer",
      "lazy",
      "leader",
      "leaf",
      "learn",
      "leave",
      "lecture",
      "left",
      "leg",
      "legal",
      "legend",
      "leisure",
      "lemon",
      "lend",
      "length",
      "lens",
      "leopard",
      "lesson",
      "letter",
      "level",
      "liar",
      "liberty",
      "library",
      "license",
      "life",
      "lift",
      "light",
      "like",
      "limb",
      "limit",
      "link",
      "lion",
      "liquid",
      "list",
      "little",
      "live",
      "lizard",
      "load",
      "loan",
      "lobster",
      "local",
      "lock",
      "logic",
      "lonely",
      "long",
      "loop",
      "lottery",
      "loud",
      "lounge",
      "love",
      "loyal",
      "lucky",
      "luggage",
      "lumber",
      "lunar",
      "lunch",
      "luxury",
      "lyrics",
      "machine",
      "mad",
      "magic",
      "magnet",
      "maid",
      "mail",
      "main",
      "major",
      "make",
      "mammal",
      "man",
      "manage",
      "mandate",
      "mango",
      "mansion",
      "manual",
      "maple",
      "marble",
      "march",
      "margin",
      "marine",
      "market",
      "marriage",
      "mask",
      "mass",
      "master",
      "match",
      "material",
      "math",
      "matrix",
      "matter",
      "maximum",
      "maze",
      "meadow",
      "mean",
      "measure",
      "meat",
      "mechanic",
      "medal",
      "media",
      "melody",
      "melt",
      "member",
      "memory",
      "mention",
      "menu",
      "mercy",
      "merge",
      "merit",
      "merry",
      "mesh",
      "message",
      "metal",
      "method",
      "middle",
      "midnight",
      "milk",
      "million",
      "mimic",
      "mind",
      "minimum",
      "minor",
      "minute",
      "miracle",
      "mirror",
      "misery",
      "miss",
      "mistake",
      "mix",
      "mixed",
      "mixture",
      "mobile",
      "model",
      "modify",
      "mom",
      "moment",
      "monitor",
      "monkey",
      "monster",
      "month",
      "moon",
      "moral",
      "more",
      "morning",
      "mosquito",
      "mother",
      "motion",
      "motor",
      "mountain",
      "mouse",
      "move",
      "movie",
      "much",
      "muffin",
      "mule",
      "multiply",
      "muscle",
      "museum",
      "mushroom",
      "music",
      "must",
      "mutual",
      "myself",
      "mystery",
      "myth",
      "naive",
      "name",
      "napkin",
      "narrow",
      "nasty",
      "nation",
      "nature",
      "near",
      "neck",
      "need",
      "negative",
      "neglect",
      "neither",
      "nephew",
      "nerve",
      "nest",
      "net",
      "network",
      "neutral",
      "never",
      "news",
      "next",
      "nice",
      "night",
      "noble",
      "noise",
      "nominee",
      "noodle",
      "normal",
      "north",
      "nose",
      "notable",
      "note",
      "nothing",
      "notice",
      "novel",
      "now",
      "nuclear",
      "number",
      "nurse",
      "nut",
      "oak",
      "obey",
      "object",
      "oblige",
      "obscure",
      "observe",
      "obtain",
      "obvious",
      "occur",
      "ocean",
      "october",
      "odor",
      "off",
      "offer",
      "office",
      "often",
      "oil",
      "okay",
      "old",
      "olive",
      "olympic",
      "omit",
      "once",
      "one",
      "onion",
      "online",
      "only",
      "open",
      "opera",
      "opinion",
      "oppose",
      "option",
      "orange",
      "orbit",
      "orchard",
      "order",
      "ordinary",
      "organ",
      "orient",
      "original",
      "orphan",
      "ostrich",
      "other",
      "outdoor",
      "outer",
      "output",
      "outside",
      "oval",
      "oven",
      "over",
      "own",
      "owner",
      "oxygen",
      "oyster",
      "ozone",
      "pact",
      "paddle",
      "page",
      "pair",
      "palace",
      "palm",
      "panda",
      "panel",
      "panic",
      "panther",
      "paper",
      "parade",
      "parent",
      "park",
      "parrot",
      "party",
      "pass",
      "patch",
      "path",
      "patient",
      "patrol",
      "pattern",
      "pause",
      "pave",
      "payment",
      "peace",
      "peanut",
      "pear",
      "peasant",
      "pelican",
      "pen",
      "penalty",
      "pencil",
      "people",
      "pepper",
      "perfect",
      "permit",
      "person",
      "pet",
      "phone",
      "photo",
      "phrase",
      "physical",
      "piano",
      "picnic",
      "picture",
      "piece",
      "pig",
      "pigeon",
      "pill",
      "pilot",
      "pink",
      "pioneer",
      "pipe",
      "pistol",
      "pitch",
      "pizza",
      "place",
      "planet",
      "plastic",
      "plate",
      "play",
      "please",
      "pledge",
      "pluck",
      "plug",
      "plunge",
      "poem",
      "poet",
      "point",
      "polar",
      "pole",
      "police",
      "pond",
      "pony",
      "pool",
      "popular",
      "portion",
      "position",
      "possible",
      "post",
      "potato",
      "pottery",
      "poverty",
      "powder",
      "power",
      "practice",
      "praise",
      "predict",
      "prefer",
      "prepare",
      "present",
      "pretty",
      "prevent",
      "price",
      "pride",
      "primary",
      "print",
      "priority",
      "prison",
      "private",
      "prize",
      "problem",
      "process",
      "produce",
      "profit",
      "program",
      "project",
      "promote",
      "proof",
      "property",
      "prosper",
      "protect",
      "proud",
      "provide",
      "public",
      "pudding",
      "pull",
      "pulp",
      "pulse",
      "pumpkin",
      "punch",
      "pupil",
      "puppy",
      "purchase",
      "purity",
      "purpose",
      "purse",
      "push",
      "put",
      "puzzle",
      "pyramid",
      "quality",
      "quantum",
      "quarter",
      "question",
      "quick",
      "quit",
      "quiz",
      "quote",
      "rabbit",
      "raccoon",
      "race",
      "rack",
      "radar",
      "radio",
      "rail",
      "rain",
      "raise",
      "rally",
      "ramp",
      "ranch",
      "random",
      "range",
      "rapid",
      "rare",
      "rate",
      "rather",
      "raven",
      "raw",
      "razor",
      "ready",
      "real",
      "reason",
      "rebel",
      "rebuild",
      "recall",
      "receive",
      "recipe",
      "record",
      "recycle",
      "reduce",
      "reflect",
      "reform",
      "refuse",
      "region",
      "regret",
      "regular",
      "reject",
      "relax",
      "release",
      "relief",
      "rely",
      "remain",
      "remember",
      "remind",
      "remove",
      "render",
      "renew",
      "rent",
      "reopen",
      "repair",
      "repeat",
      "replace",
      "report",
      "require",
      "rescue",
      "resemble",
      "resist",
      "resource",
      "response",
      "result",
      "retire",
      "retreat",
      "return",
      "reunion",
      "reveal",
      "review",
      "reward",
      "rhythm",
      "rib",
      "ribbon",
      "rice",
      "rich",
      "ride",
      "ridge",
      "rifle",
      "right",
      "rigid",
      "ring",
      "riot",
      "ripple",
      "risk",
      "ritual",
      "rival",
      "river",
      "road",
      "roast",
      "robot",
      "robust",
      "rocket",
      "romance",
      "roof",
      "rookie",
      "room",
      "rose",
      "rotate",
      "rough",
      "round",
      "route",
      "royal",
      "rubber",
      "rude",
      "rug",
      "rule",
      "run",
      "runway",
      "rural",
      "sad",
      "saddle",
      "sadness",
      "safe",
      "sail",
      "salad",
      "salmon",
      "salon",
      "salt",
      "salute",
      "same",
      "sample",
      "sand",
      "satisfy",
      "satoshi",
      "sauce",
      "sausage",
      "save",
      "say",
      "scale",
      "scan",
      "scare",
      "scatter",
      "scene",
      "scheme",
      "school",
      "science",
      "scissors",
      "scorpion",
      "scout",
      "scrap",
      "screen",
      "script",
      "scrub",
      "sea",
      "search",
      "season",
      "seat",
      "second",
      "secret",
      "section",
      "security",
      "seed",
      "seek",
      "segment",
      "select",
      "sell",
      "seminar",
      "senior",
      "sense",
      "sentence",
      "series",
      "service",
      "session",
      "settle",
      "setup",
      "seven",
      "shadow",
      "shaft",
      "shallow",
      "share",
      "shed",
      "shell",
      "sheriff",
      "shield",
      "shift",
      "shine",
      "ship",
      "shiver",
      "shock",
      "shoe",
      "shoot",
      "shop",
      "short",
      "shoulder",
      "shove",
      "shrimp",
      "shrug",
      "shuffle",
      "shy",
      "sibling",
      "sick",
      "side",
      "siege",
      "sight",
      "sign",
      "silent",
      "silk",
      "silly",
      "silver",
      "similar",
      "simple",
      "since",
      "sing",
      "siren",
      "sister",
      "situate",
      "six",
      "size",
      "skate",
      "sketch",
      "ski",
      "skill",
      "skin",
      "skirt",
      "skull",
      "slab",
      "slam",
      "sleep",
      "slender",
      "slice",
      "slide",
      "slight",
      "slim",
      "slogan",
      "slot",
      "slow",
      "slush",
      "small",
      "smart",
      "smile",
      "smoke",
      "smooth",
      "snack",
      "snake",
      "snap",
      "sniff",
      "snow",
      "soap",
      "soccer",
      "social",
      "sock",
      "soda",
      "soft",
      "solar",
      "soldier",
      "solid",
      "solution",
      "solve",
      "someone",
      "song",
      "soon",
      "sorry",
      "sort",
      "soul",
      "sound",
      "soup",
      "source",
      "south",
      "space",
      "spare",
      "spatial",
      "spawn",
      "speak",
      "special",
      "speed",
      "spell",
      "spend",
      "sphere",
      "spice",
      "spider",
      "spike",
      "spin",
      "spirit",
      "split",
      "spoil",
      "sponsor",
      "spoon",
      "sport",
      "spot",
      "spray",
      "spread",
      "spring",
      "spy",
      "square",
      "squeeze",
      "squirrel",
      "stable",
      "stadium",
      "staff",
      "stage",
      "stairs",
      "stamp",
      "stand",
      "start",
      "state",
      "stay",
      "steak",
      "steel",
      "stem",
      "step",
      "stereo",
      "stick",
      "still",
      "sting",
      "stock",
      "stomach",
      "stone",
      "stool",
      "story",
      "stove",
      "strategy",
      "street",
      "strike",
      "strong",
      "struggle",
      "student",
      "stuff",
      "stumble",
      "style",
      "subject",
      "submit",
      "subway",
      "success",
      "such",
      "sudden",
      "suffer",
      "sugar",
      "suggest",
      "suit",
      "summer",
      "sun",
      "sunny",
      "sunset",
      "super",
      "supply",
      "supreme",
      "sure",
      "surface",
      "surge",
      "surprise",
      "surround",
      "survey",
      "suspect",
      "sustain",
      "swallow",
      "swamp",
      "swap",
      "swarm",
      "swear",
      "sweet",
      "swift",
      "swim",
      "swing",
      "switch",
      "sword",
      "symbol",
      "symptom",
      "syrup",
      "system",
      "table",
      "tackle",
      "tag",
      "tail",
      "talent",
      "talk",
      "tank",
      "tape",
      "target",
      "task",
      "taste",
      "tattoo",
      "taxi",
      "teach",
      "team",
      "tell",
      "ten",
      "tenant",
      "tennis",
      "tent",
      "term",
      "test",
      "text",
      "thank",
      "that",
      "theme",
      "then",
      "theory",
      "there",
      "they",
      "thing",
      "this",
      "thought",
      "three",
      "thrive",
      "throw",
      "thumb",
      "thunder",
      "ticket",
      "tide",
      "tiger",
      "tilt",
      "timber",
      "time",
      "tiny",
      "tip",
      "tired",
      "tissue",
      "title",
      "toast",
      "tobacco",
      "today",
      "toddler",
      "toe",
      "together",
      "toilet",
      "token",
      "tomato",
      "tomorrow",
      "tone",
      "tongue",
      "tonight",
      "tool",
      "tooth",
      "top",
      "topic",
      "topple",
      "torch",
      "tornado",
      "tortoise",
      "toss",
      "total",
      "tourist",
      "toward",
      "tower",
      "town",
      "toy",
      "track",
      "trade",
      "traffic",
      "tragic",
      "train",
      "transfer",
      "trap",
      "trash",
      "travel",
      "tray",
      "treat",
      "tree",
      "trend",
      "trial",
      "tribe",
      "trick",
      "trigger",
      "trim",
      "trip",
      "trophy",
      "trouble",
      "truck",
      "true",
      "truly",
      "trumpet",
      "trust",
      "truth",
      "try",
      "tube",
      "tuition",
      "tumble",
      "tuna",
      "tunnel",
      "turkey",
      "turn",
      "turtle",
      "twelve",
      "twenty",
      "twice",
      "twin",
      "twist",
      "two",
      "type",
      "typical",
      "ugly",
      "umbrella",
      "unable",
      "unaware",
      "uncle",
      "uncover",
      "under",
      "undo",
      "unfair",
      "unfold",
      "unhappy",
      "uniform",
      "unique",
      "unit",
      "universe",
      "unknown",
      "unlock",
      "until",
      "unusual",
      "unveil",
      "update",
      "upgrade",
      "uphold",
      "upon",
      "upper",
      "upset",
      "urban",
      "urge",
      "usage",
      "use",
      "used",
      "useful",
      "useless",
      "usual",
      "utility",
      "vacant",
      "vacuum",
      "vague",
      "valid",
      "valley",
      "valve",
      "van",
      "vanish",
      "vapor",
      "various",
      "vast",
      "vault",
      "vehicle",
      "velvet",
      "vendor",
      "venture",
      "venue",
      "verb",
      "verify",
      "version",
      "very",
      "vessel",
      "veteran",
      "viable",
      "vibrant",
      "vicious",
      "victory",
      "video",
      "view",
      "village",
      "vintage",
      "violin",
      "virtual",
      "virus",
      "visa",
      "visit",
      "visual",
      "vital",
      "vivid",
      "vocal",
      "voice",
      "void",
      "volcano",
      "volume",
      "vote",
      "voyage",
      "wage",
      "wagon",
      "wait",
      "walk",
      "wall",
      "walnut",
      "want",
      "warfare",
      "warm",
      "warrior",
      "wash",
      "wasp",
      "waste",
      "water",
      "wave",
      "way",
      "wealth",
      "weapon",
      "wear",
      "weasel",
      "weather",
      "web",
      "wedding",
      "weekend",
      "weird",
      "welcome",
      "west",
      "wet",
      "whale",
      "what",
      "wheat",
      "wheel",
      "when",
      "where",
      "whip",
      "whisper",
      "wide",
      "width",
      "wife",
      "wild",
      "will",
      "win",
      "window",
      "wine",
      "wing",
      "wink",
      "winner",
      "winter",
      "wire",
      "wisdom",
      "wise",
      "wish",
      "witness",
      "wolf",
      "woman",
      "wonder",
      "wood",
      "wool",
      "word",
      "work",
      "world",
      "worry",
      "worth",
      "wrap",
      "wreck",
      "wrestle",
      "wrist",
      "write",
      "wrong",
      "yard",
      "year",
      "yellow",
      "you",
      "young",
      "youth",
      "zebra",
      "zero",
      "zone",
      "zoo"
    ];
  }
});

// ../../node_modules/.pnpm/bip39@3.1.0/node_modules/bip39/src/_wordlists.js
var require_wordlists = __commonJS({
  "../../node_modules/.pnpm/bip39@3.1.0/node_modules/bip39/src/_wordlists.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var wordlists = {};
    exports.wordlists = wordlists;
    var _default;
    exports._default = _default;
    try {
      exports._default = _default = require_czech();
      wordlists.czech = _default;
    } catch (err) {
    }
    try {
      exports._default = _default = require_chinese_simplified();
      wordlists.chinese_simplified = _default;
    } catch (err) {
    }
    try {
      exports._default = _default = require_chinese_traditional();
      wordlists.chinese_traditional = _default;
    } catch (err) {
    }
    try {
      exports._default = _default = require_korean();
      wordlists.korean = _default;
    } catch (err) {
    }
    try {
      exports._default = _default = require_french();
      wordlists.french = _default;
    } catch (err) {
    }
    try {
      exports._default = _default = require_italian();
      wordlists.italian = _default;
    } catch (err) {
    }
    try {
      exports._default = _default = require_spanish();
      wordlists.spanish = _default;
    } catch (err) {
    }
    try {
      exports._default = _default = require_japanese();
      wordlists.japanese = _default;
      wordlists.JA = _default;
    } catch (err) {
    }
    try {
      exports._default = _default = require_portuguese();
      wordlists.portuguese = _default;
    } catch (err) {
    }
    try {
      exports._default = _default = require_english();
      wordlists.english = _default;
      wordlists.EN = _default;
    } catch (err) {
    }
  }
});

// ../../node_modules/.pnpm/bip39@3.1.0/node_modules/bip39/src/index.js
var require_src = __commonJS({
  "../../node_modules/.pnpm/bip39@3.1.0/node_modules/bip39/src/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var sha256_1 = require_sha256();
    var sha512_1 = require_sha512();
    var pbkdf2_1 = require_pbkdf2();
    var utils_1 = require_utils();
    var _wordlists_1 = require_wordlists();
    var DEFAULT_WORDLIST = _wordlists_1._default;
    var INVALID_MNEMONIC = "Invalid mnemonic";
    var INVALID_ENTROPY = "Invalid entropy";
    var INVALID_CHECKSUM = "Invalid mnemonic checksum";
    var WORDLIST_REQUIRED = "A wordlist is required but a default could not be found.\nPlease pass a 2048 word array explicitly.";
    function normalize(str) {
      return (str || "").normalize("NFKD");
    }
    function lpad(str, padString, length) {
      while (str.length < length) {
        str = padString + str;
      }
      return str;
    }
    function binaryToByte(bin) {
      return parseInt(bin, 2);
    }
    function bytesToBinary(bytes) {
      return bytes.map((x4) => lpad(x4.toString(2), "0", 8)).join("");
    }
    function deriveChecksumBits(entropyBuffer) {
      const ENT = entropyBuffer.length * 8;
      const CS = ENT / 32;
      const hash = sha256_1.sha256(Uint8Array.from(entropyBuffer));
      return bytesToBinary(Array.from(hash)).slice(0, CS);
    }
    function salt(password) {
      return "mnemonic" + (password || "");
    }
    function mnemonicToSeedSync(mnemonic, password) {
      const mnemonicBuffer = Uint8Array.from(Buffer.from(normalize(mnemonic), "utf8"));
      const saltBuffer = Uint8Array.from(Buffer.from(salt(normalize(password)), "utf8"));
      const res = pbkdf2_1.pbkdf2(sha512_1.sha512, mnemonicBuffer, saltBuffer, {
        c: 2048,
        dkLen: 64
      });
      return Buffer.from(res);
    }
    exports.mnemonicToSeedSync = mnemonicToSeedSync;
    function mnemonicToSeed(mnemonic, password) {
      const mnemonicBuffer = Uint8Array.from(Buffer.from(normalize(mnemonic), "utf8"));
      const saltBuffer = Uint8Array.from(Buffer.from(salt(normalize(password)), "utf8"));
      return pbkdf2_1.pbkdf2Async(sha512_1.sha512, mnemonicBuffer, saltBuffer, {
        c: 2048,
        dkLen: 64
      }).then((res) => Buffer.from(res));
    }
    exports.mnemonicToSeed = mnemonicToSeed;
    function mnemonicToEntropy(mnemonic, wordlist) {
      wordlist = wordlist || DEFAULT_WORDLIST;
      if (!wordlist) {
        throw new Error(WORDLIST_REQUIRED);
      }
      const words = normalize(mnemonic).split(" ");
      if (words.length % 3 !== 0) {
        throw new Error(INVALID_MNEMONIC);
      }
      const bits = words.map((word) => {
        const index = wordlist.indexOf(word);
        if (index === -1) {
          throw new Error(INVALID_MNEMONIC);
        }
        return lpad(index.toString(2), "0", 11);
      }).join("");
      const dividerIndex = Math.floor(bits.length / 33) * 32;
      const entropyBits = bits.slice(0, dividerIndex);
      const checksumBits = bits.slice(dividerIndex);
      const entropyBytes = entropyBits.match(/(.{1,8})/g).map(binaryToByte);
      if (entropyBytes.length < 16) {
        throw new Error(INVALID_ENTROPY);
      }
      if (entropyBytes.length > 32) {
        throw new Error(INVALID_ENTROPY);
      }
      if (entropyBytes.length % 4 !== 0) {
        throw new Error(INVALID_ENTROPY);
      }
      const entropy = Buffer.from(entropyBytes);
      const newChecksum = deriveChecksumBits(entropy);
      if (newChecksum !== checksumBits) {
        throw new Error(INVALID_CHECKSUM);
      }
      return entropy.toString("hex");
    }
    exports.mnemonicToEntropy = mnemonicToEntropy;
    function entropyToMnemonic(entropy, wordlist) {
      if (!Buffer.isBuffer(entropy)) {
        entropy = Buffer.from(entropy, "hex");
      }
      wordlist = wordlist || DEFAULT_WORDLIST;
      if (!wordlist) {
        throw new Error(WORDLIST_REQUIRED);
      }
      if (entropy.length < 16) {
        throw new TypeError(INVALID_ENTROPY);
      }
      if (entropy.length > 32) {
        throw new TypeError(INVALID_ENTROPY);
      }
      if (entropy.length % 4 !== 0) {
        throw new TypeError(INVALID_ENTROPY);
      }
      const entropyBits = bytesToBinary(Array.from(entropy));
      const checksumBits = deriveChecksumBits(entropy);
      const bits = entropyBits + checksumBits;
      const chunks = bits.match(/(.{1,11})/g);
      const words = chunks.map((binary) => {
        const index = binaryToByte(binary);
        return wordlist[index];
      });
      return wordlist[0] === "" ? words.join("") : words.join(" ");
    }
    exports.entropyToMnemonic = entropyToMnemonic;
    function generateMnemonic(strength, rng, wordlist) {
      strength = strength || 128;
      if (strength % 32 !== 0) {
        throw new TypeError(INVALID_ENTROPY);
      }
      rng = rng || ((size) => Buffer.from(utils_1.randomBytes(size)));
      return entropyToMnemonic(rng(strength / 8), wordlist);
    }
    exports.generateMnemonic = generateMnemonic;
    function validateMnemonic(mnemonic, wordlist) {
      try {
        mnemonicToEntropy(mnemonic, wordlist);
      } catch (e2) {
        return false;
      }
      return true;
    }
    exports.validateMnemonic = validateMnemonic;
    function setDefaultWordlist(language) {
      const result = _wordlists_1.wordlists[language];
      if (result) {
        DEFAULT_WORDLIST = result;
      } else {
        throw new Error('Could not find wordlist for language "' + language + '"');
      }
    }
    exports.setDefaultWordlist = setDefaultWordlist;
    function getDefaultWordlist() {
      if (!DEFAULT_WORDLIST) {
        throw new Error("No Default Wordlist set");
      }
      return Object.keys(_wordlists_1.wordlists).filter((lang) => {
        if (lang === "JA" || lang === "EN") {
          return false;
        }
        return _wordlists_1.wordlists[lang].every((word, index) => word === DEFAULT_WORDLIST[index]);
      })[0];
    }
    exports.getDefaultWordlist = getDefaultWordlist;
    var _wordlists_2 = require_wordlists();
    exports.wordlists = _wordlists_2.wordlists;
  }
});

// ../../node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/stream-browser.js
var require_stream_browser = __commonJS({
  "../../node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/stream-browser.js"(exports, module) {
    module.exports = require_events().EventEmitter;
  }
});

// browser-external:util
var require_util = __commonJS({
  "browser-external:util"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_16, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "util" has been externalized for browser compatibility. Cannot access "util.${key}" in client code. See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// ../../node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/buffer_list.js
var require_buffer_list = __commonJS({
  "../../node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/buffer_list.js"(exports, module) {
    "use strict";
    function ownKeys3(object2, enumerableOnly) {
      var keys3 = Object.keys(object2);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object2);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object2, sym).enumerable;
        })), keys3.push.apply(keys3, symbols);
      }
      return keys3;
    }
    function _objectSpread(target) {
      for (var i4 = 1; i4 < arguments.length; i4++) {
        var source = null != arguments[i4] ? arguments[i4] : {};
        i4 % 2 ? ownKeys3(Object(source), true).forEach(function(key) {
          _defineProperty(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys3(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    function _defineProperty(obj, key, value) {
      key = _toPropertyKey2(key);
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties2(target, props) {
      for (var i4 = 0; i4 < props.length; i4++) {
        var descriptor = props[i4];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, _toPropertyKey2(descriptor.key), descriptor);
      }
    }
    function _createClass2(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties2(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties2(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", { writable: false });
      return Constructor;
    }
    function _toPropertyKey2(arg) {
      var key = _toPrimitive2(arg, "string");
      return typeof key === "symbol" ? key : String(key);
    }
    function _toPrimitive2(input, hint) {
      if (typeof input !== "object" || input === null)
        return input;
      var prim = input[Symbol.toPrimitive];
      if (prim !== void 0) {
        var res = prim.call(input, hint || "default");
        if (typeof res !== "object")
          return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (hint === "string" ? String : Number)(input);
    }
    var _require = require_buffer();
    var Buffer2 = _require.Buffer;
    var _require2 = require_util();
    var inspect = _require2.inspect;
    var custom = inspect && inspect.custom || "inspect";
    function copyBuffer(src, target, offset) {
      Buffer2.prototype.copy.call(src, target, offset);
    }
    module.exports = function() {
      function BufferList() {
        _classCallCheck(this, BufferList);
        this.head = null;
        this.tail = null;
        this.length = 0;
      }
      _createClass2(BufferList, [{
        key: "push",
        value: function push2(v5) {
          var entry = {
            data: v5,
            next: null
          };
          if (this.length > 0)
            this.tail.next = entry;
          else
            this.head = entry;
          this.tail = entry;
          ++this.length;
        }
      }, {
        key: "unshift",
        value: function unshift2(v5) {
          var entry = {
            data: v5,
            next: this.head
          };
          if (this.length === 0)
            this.tail = entry;
          this.head = entry;
          ++this.length;
        }
      }, {
        key: "shift",
        value: function shift2() {
          if (this.length === 0)
            return;
          var ret = this.head.data;
          if (this.length === 1)
            this.head = this.tail = null;
          else
            this.head = this.head.next;
          --this.length;
          return ret;
        }
      }, {
        key: "clear",
        value: function clear3() {
          this.head = this.tail = null;
          this.length = 0;
        }
      }, {
        key: "join",
        value: function join(s3) {
          if (this.length === 0)
            return "";
          var p4 = this.head;
          var ret = "" + p4.data;
          while (p4 = p4.next)
            ret += s3 + p4.data;
          return ret;
        }
      }, {
        key: "concat",
        value: function concat2(n5) {
          if (this.length === 0)
            return Buffer2.alloc(0);
          var ret = Buffer2.allocUnsafe(n5 >>> 0);
          var p4 = this.head;
          var i4 = 0;
          while (p4) {
            copyBuffer(p4.data, ret, i4);
            i4 += p4.data.length;
            p4 = p4.next;
          }
          return ret;
        }
        // Consumes a specified amount of bytes or characters from the buffered data.
      }, {
        key: "consume",
        value: function consume(n5, hasStrings) {
          var ret;
          if (n5 < this.head.data.length) {
            ret = this.head.data.slice(0, n5);
            this.head.data = this.head.data.slice(n5);
          } else if (n5 === this.head.data.length) {
            ret = this.shift();
          } else {
            ret = hasStrings ? this._getString(n5) : this._getBuffer(n5);
          }
          return ret;
        }
      }, {
        key: "first",
        value: function first() {
          return this.head.data;
        }
        // Consumes a specified amount of characters from the buffered data.
      }, {
        key: "_getString",
        value: function _getString(n5) {
          var p4 = this.head;
          var c6 = 1;
          var ret = p4.data;
          n5 -= ret.length;
          while (p4 = p4.next) {
            var str = p4.data;
            var nb = n5 > str.length ? str.length : n5;
            if (nb === str.length)
              ret += str;
            else
              ret += str.slice(0, n5);
            n5 -= nb;
            if (n5 === 0) {
              if (nb === str.length) {
                ++c6;
                if (p4.next)
                  this.head = p4.next;
                else
                  this.head = this.tail = null;
              } else {
                this.head = p4;
                p4.data = str.slice(nb);
              }
              break;
            }
            ++c6;
          }
          this.length -= c6;
          return ret;
        }
        // Consumes a specified amount of bytes from the buffered data.
      }, {
        key: "_getBuffer",
        value: function _getBuffer(n5) {
          var ret = Buffer2.allocUnsafe(n5);
          var p4 = this.head;
          var c6 = 1;
          p4.data.copy(ret);
          n5 -= p4.data.length;
          while (p4 = p4.next) {
            var buf = p4.data;
            var nb = n5 > buf.length ? buf.length : n5;
            buf.copy(ret, ret.length - n5, 0, nb);
            n5 -= nb;
            if (n5 === 0) {
              if (nb === buf.length) {
                ++c6;
                if (p4.next)
                  this.head = p4.next;
                else
                  this.head = this.tail = null;
              } else {
                this.head = p4;
                p4.data = buf.slice(nb);
              }
              break;
            }
            ++c6;
          }
          this.length -= c6;
          return ret;
        }
        // Make sure the linked list only shows the minimal necessary information.
      }, {
        key: custom,
        value: function value(_16, options) {
          return inspect(this, _objectSpread(_objectSpread({}, options), {}, {
            // Only inspect one level.
            depth: 0,
            // It should not recurse.
            customInspect: false
          }));
        }
      }]);
      return BufferList;
    }();
  }
});

// ../../node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/destroy.js
var require_destroy = __commonJS({
  "../../node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/destroy.js"(exports, module) {
    "use strict";
    function destroy(err, cb) {
      var _this = this;
      var readableDestroyed = this._readableState && this._readableState.destroyed;
      var writableDestroyed = this._writableState && this._writableState.destroyed;
      if (readableDestroyed || writableDestroyed) {
        if (cb) {
          cb(err);
        } else if (err) {
          if (!this._writableState) {
            process.nextTick(emitErrorNT, this, err);
          } else if (!this._writableState.errorEmitted) {
            this._writableState.errorEmitted = true;
            process.nextTick(emitErrorNT, this, err);
          }
        }
        return this;
      }
      if (this._readableState) {
        this._readableState.destroyed = true;
      }
      if (this._writableState) {
        this._writableState.destroyed = true;
      }
      this._destroy(err || null, function(err2) {
        if (!cb && err2) {
          if (!_this._writableState) {
            process.nextTick(emitErrorAndCloseNT, _this, err2);
          } else if (!_this._writableState.errorEmitted) {
            _this._writableState.errorEmitted = true;
            process.nextTick(emitErrorAndCloseNT, _this, err2);
          } else {
            process.nextTick(emitCloseNT, _this);
          }
        } else if (cb) {
          process.nextTick(emitCloseNT, _this);
          cb(err2);
        } else {
          process.nextTick(emitCloseNT, _this);
        }
      });
      return this;
    }
    function emitErrorAndCloseNT(self2, err) {
      emitErrorNT(self2, err);
      emitCloseNT(self2);
    }
    function emitCloseNT(self2) {
      if (self2._writableState && !self2._writableState.emitClose)
        return;
      if (self2._readableState && !self2._readableState.emitClose)
        return;
      self2.emit("close");
    }
    function undestroy() {
      if (this._readableState) {
        this._readableState.destroyed = false;
        this._readableState.reading = false;
        this._readableState.ended = false;
        this._readableState.endEmitted = false;
      }
      if (this._writableState) {
        this._writableState.destroyed = false;
        this._writableState.ended = false;
        this._writableState.ending = false;
        this._writableState.finalCalled = false;
        this._writableState.prefinished = false;
        this._writableState.finished = false;
        this._writableState.errorEmitted = false;
      }
    }
    function emitErrorNT(self2, err) {
      self2.emit("error", err);
    }
    function errorOrDestroy(stream, err) {
      var rState = stream._readableState;
      var wState = stream._writableState;
      if (rState && rState.autoDestroy || wState && wState.autoDestroy)
        stream.destroy(err);
      else
        stream.emit("error", err);
    }
    module.exports = {
      destroy,
      undestroy,
      errorOrDestroy
    };
  }
});

// ../../node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/errors-browser.js
var require_errors_browser = __commonJS({
  "../../node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/errors-browser.js"(exports, module) {
    "use strict";
    function _inheritsLoose2(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      subClass.__proto__ = superClass;
    }
    var codes = {};
    function createErrorType(code, message, Base) {
      if (!Base) {
        Base = Error;
      }
      function getMessage(arg1, arg2, arg3) {
        if (typeof message === "string") {
          return message;
        } else {
          return message(arg1, arg2, arg3);
        }
      }
      var NodeError = function(_Base) {
        _inheritsLoose2(NodeError2, _Base);
        function NodeError2(arg1, arg2, arg3) {
          return _Base.call(this, getMessage(arg1, arg2, arg3)) || this;
        }
        return NodeError2;
      }(Base);
      NodeError.prototype.name = Base.name;
      NodeError.prototype.code = code;
      codes[code] = NodeError;
    }
    function oneOf(expected, thing) {
      if (Array.isArray(expected)) {
        var len = expected.length;
        expected = expected.map(function(i4) {
          return String(i4);
        });
        if (len > 2) {
          return "one of ".concat(thing, " ").concat(expected.slice(0, len - 1).join(", "), ", or ") + expected[len - 1];
        } else if (len === 2) {
          return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
        } else {
          return "of ".concat(thing, " ").concat(expected[0]);
        }
      } else {
        return "of ".concat(thing, " ").concat(String(expected));
      }
    }
    function startsWith(str, search, pos) {
      return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
    }
    function endsWith(str, search, this_len) {
      if (this_len === void 0 || this_len > str.length) {
        this_len = str.length;
      }
      return str.substring(this_len - search.length, this_len) === search;
    }
    function includes(str, search, start) {
      if (typeof start !== "number") {
        start = 0;
      }
      if (start + search.length > str.length) {
        return false;
      } else {
        return str.indexOf(search, start) !== -1;
      }
    }
    createErrorType("ERR_INVALID_OPT_VALUE", function(name, value) {
      return 'The value "' + value + '" is invalid for option "' + name + '"';
    }, TypeError);
    createErrorType("ERR_INVALID_ARG_TYPE", function(name, expected, actual) {
      var determiner;
      if (typeof expected === "string" && startsWith(expected, "not ")) {
        determiner = "must not be";
        expected = expected.replace(/^not /, "");
      } else {
        determiner = "must be";
      }
      var msg;
      if (endsWith(name, " argument")) {
        msg = "The ".concat(name, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
      } else {
        var type = includes(name, ".") ? "property" : "argument";
        msg = 'The "'.concat(name, '" ').concat(type, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
      }
      msg += ". Received type ".concat(typeof actual);
      return msg;
    }, TypeError);
    createErrorType("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
    createErrorType("ERR_METHOD_NOT_IMPLEMENTED", function(name) {
      return "The " + name + " method is not implemented";
    });
    createErrorType("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
    createErrorType("ERR_STREAM_DESTROYED", function(name) {
      return "Cannot call " + name + " after a stream was destroyed";
    });
    createErrorType("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
    createErrorType("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
    createErrorType("ERR_STREAM_WRITE_AFTER_END", "write after end");
    createErrorType("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
    createErrorType("ERR_UNKNOWN_ENCODING", function(arg) {
      return "Unknown encoding: " + arg;
    }, TypeError);
    createErrorType("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
    module.exports.codes = codes;
  }
});

// ../../node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/state.js
var require_state = __commonJS({
  "../../node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/state.js"(exports, module) {
    "use strict";
    var ERR_INVALID_OPT_VALUE = require_errors_browser().codes.ERR_INVALID_OPT_VALUE;
    function highWaterMarkFrom(options, isDuplex, duplexKey) {
      return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
    }
    function getHighWaterMark(state, options, duplexKey, isDuplex) {
      var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
      if (hwm != null) {
        if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
          var name = isDuplex ? duplexKey : "highWaterMark";
          throw new ERR_INVALID_OPT_VALUE(name, hwm);
        }
        return Math.floor(hwm);
      }
      return state.objectMode ? 16 : 16 * 1024;
    }
    module.exports = {
      getHighWaterMark
    };
  }
});

// ../../node_modules/.pnpm/util-deprecate@1.0.2/node_modules/util-deprecate/browser.js
var require_browser = __commonJS({
  "../../node_modules/.pnpm/util-deprecate@1.0.2/node_modules/util-deprecate/browser.js"(exports, module) {
    module.exports = deprecate;
    function deprecate(fn2, msg) {
      if (config("noDeprecation")) {
        return fn2;
      }
      var warned = false;
      function deprecated() {
        if (!warned) {
          if (config("throwDeprecation")) {
            throw new Error(msg);
          } else if (config("traceDeprecation")) {
            console.trace(msg);
          } else {
            console.warn(msg);
          }
          warned = true;
        }
        return fn2.apply(this, arguments);
      }
      return deprecated;
    }
    function config(name) {
      try {
        if (!global.localStorage)
          return false;
      } catch (_16) {
        return false;
      }
      var val = global.localStorage[name];
      if (null == val)
        return false;
      return String(val).toLowerCase() === "true";
    }
  }
});

// ../../node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/_stream_writable.js
var require_stream_writable = __commonJS({
  "../../node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/_stream_writable.js"(exports, module) {
    "use strict";
    module.exports = Writable;
    function CorkedRequest(state) {
      var _this = this;
      this.next = null;
      this.entry = null;
      this.finish = function() {
        onCorkedFinish(_this, state);
      };
    }
    var Duplex;
    Writable.WritableState = WritableState;
    var internalUtil = {
      deprecate: require_browser()
    };
    var Stream = require_stream_browser();
    var Buffer2 = require_buffer().Buffer;
    var OurUint8Array = (typeof global !== "undefined" ? global : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
    };
    function _uint8ArrayToBuffer(chunk) {
      return Buffer2.from(chunk);
    }
    function _isUint8Array(obj) {
      return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
    }
    var destroyImpl = require_destroy();
    var _require = require_state();
    var getHighWaterMark = _require.getHighWaterMark;
    var _require$codes = require_errors_browser().codes;
    var ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE;
    var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
    var ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK;
    var ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE;
    var ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
    var ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES;
    var ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END;
    var ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;
    var errorOrDestroy = destroyImpl.errorOrDestroy;
    require_inherits_browser()(Writable, Stream);
    function nop() {
    }
    function WritableState(options, stream, isDuplex) {
      Duplex = Duplex || require_stream_duplex();
      options = options || {};
      if (typeof isDuplex !== "boolean")
        isDuplex = stream instanceof Duplex;
      this.objectMode = !!options.objectMode;
      if (isDuplex)
        this.objectMode = this.objectMode || !!options.writableObjectMode;
      this.highWaterMark = getHighWaterMark(this, options, "writableHighWaterMark", isDuplex);
      this.finalCalled = false;
      this.needDrain = false;
      this.ending = false;
      this.ended = false;
      this.finished = false;
      this.destroyed = false;
      var noDecode = options.decodeStrings === false;
      this.decodeStrings = !noDecode;
      this.defaultEncoding = options.defaultEncoding || "utf8";
      this.length = 0;
      this.writing = false;
      this.corked = 0;
      this.sync = true;
      this.bufferProcessing = false;
      this.onwrite = function(er) {
        onwrite(stream, er);
      };
      this.writecb = null;
      this.writelen = 0;
      this.bufferedRequest = null;
      this.lastBufferedRequest = null;
      this.pendingcb = 0;
      this.prefinished = false;
      this.errorEmitted = false;
      this.emitClose = options.emitClose !== false;
      this.autoDestroy = !!options.autoDestroy;
      this.bufferedRequestCount = 0;
      this.corkedRequestsFree = new CorkedRequest(this);
    }
    WritableState.prototype.getBuffer = function getBuffer() {
      var current = this.bufferedRequest;
      var out = [];
      while (current) {
        out.push(current);
        current = current.next;
      }
      return out;
    };
    (function() {
      try {
        Object.defineProperty(WritableState.prototype, "buffer", {
          get: internalUtil.deprecate(function writableStateBufferGetter() {
            return this.getBuffer();
          }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
        });
      } catch (_16) {
      }
    })();
    var realHasInstance;
    if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
      realHasInstance = Function.prototype[Symbol.hasInstance];
      Object.defineProperty(Writable, Symbol.hasInstance, {
        value: function value(object2) {
          if (realHasInstance.call(this, object2))
            return true;
          if (this !== Writable)
            return false;
          return object2 && object2._writableState instanceof WritableState;
        }
      });
    } else {
      realHasInstance = function realHasInstance2(object2) {
        return object2 instanceof this;
      };
    }
    function Writable(options) {
      Duplex = Duplex || require_stream_duplex();
      var isDuplex = this instanceof Duplex;
      if (!isDuplex && !realHasInstance.call(Writable, this))
        return new Writable(options);
      this._writableState = new WritableState(options, this, isDuplex);
      this.writable = true;
      if (options) {
        if (typeof options.write === "function")
          this._write = options.write;
        if (typeof options.writev === "function")
          this._writev = options.writev;
        if (typeof options.destroy === "function")
          this._destroy = options.destroy;
        if (typeof options.final === "function")
          this._final = options.final;
      }
      Stream.call(this);
    }
    Writable.prototype.pipe = function() {
      errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
    };
    function writeAfterEnd(stream, cb) {
      var er = new ERR_STREAM_WRITE_AFTER_END();
      errorOrDestroy(stream, er);
      process.nextTick(cb, er);
    }
    function validChunk(stream, state, chunk, cb) {
      var er;
      if (chunk === null) {
        er = new ERR_STREAM_NULL_VALUES();
      } else if (typeof chunk !== "string" && !state.objectMode) {
        er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer"], chunk);
      }
      if (er) {
        errorOrDestroy(stream, er);
        process.nextTick(cb, er);
        return false;
      }
      return true;
    }
    Writable.prototype.write = function(chunk, encoding, cb) {
      var state = this._writableState;
      var ret = false;
      var isBuf = !state.objectMode && _isUint8Array(chunk);
      if (isBuf && !Buffer2.isBuffer(chunk)) {
        chunk = _uint8ArrayToBuffer(chunk);
      }
      if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (isBuf)
        encoding = "buffer";
      else if (!encoding)
        encoding = state.defaultEncoding;
      if (typeof cb !== "function")
        cb = nop;
      if (state.ending)
        writeAfterEnd(this, cb);
      else if (isBuf || validChunk(this, state, chunk, cb)) {
        state.pendingcb++;
        ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
      }
      return ret;
    };
    Writable.prototype.cork = function() {
      this._writableState.corked++;
    };
    Writable.prototype.uncork = function() {
      var state = this._writableState;
      if (state.corked) {
        state.corked--;
        if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest)
          clearBuffer(this, state);
      }
    };
    Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
      if (typeof encoding === "string")
        encoding = encoding.toLowerCase();
      if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1))
        throw new ERR_UNKNOWN_ENCODING(encoding);
      this._writableState.defaultEncoding = encoding;
      return this;
    };
    Object.defineProperty(Writable.prototype, "writableBuffer", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get5() {
        return this._writableState && this._writableState.getBuffer();
      }
    });
    function decodeChunk(state, chunk, encoding) {
      if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") {
        chunk = Buffer2.from(chunk, encoding);
      }
      return chunk;
    }
    Object.defineProperty(Writable.prototype, "writableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get5() {
        return this._writableState.highWaterMark;
      }
    });
    function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
      if (!isBuf) {
        var newChunk = decodeChunk(state, chunk, encoding);
        if (chunk !== newChunk) {
          isBuf = true;
          encoding = "buffer";
          chunk = newChunk;
        }
      }
      var len = state.objectMode ? 1 : chunk.length;
      state.length += len;
      var ret = state.length < state.highWaterMark;
      if (!ret)
        state.needDrain = true;
      if (state.writing || state.corked) {
        var last = state.lastBufferedRequest;
        state.lastBufferedRequest = {
          chunk,
          encoding,
          isBuf,
          callback: cb,
          next: null
        };
        if (last) {
          last.next = state.lastBufferedRequest;
        } else {
          state.bufferedRequest = state.lastBufferedRequest;
        }
        state.bufferedRequestCount += 1;
      } else {
        doWrite(stream, state, false, len, chunk, encoding, cb);
      }
      return ret;
    }
    function doWrite(stream, state, writev, len, chunk, encoding, cb) {
      state.writelen = len;
      state.writecb = cb;
      state.writing = true;
      state.sync = true;
      if (state.destroyed)
        state.onwrite(new ERR_STREAM_DESTROYED("write"));
      else if (writev)
        stream._writev(chunk, state.onwrite);
      else
        stream._write(chunk, encoding, state.onwrite);
      state.sync = false;
    }
    function onwriteError(stream, state, sync, er, cb) {
      --state.pendingcb;
      if (sync) {
        process.nextTick(cb, er);
        process.nextTick(finishMaybe, stream, state);
        stream._writableState.errorEmitted = true;
        errorOrDestroy(stream, er);
      } else {
        cb(er);
        stream._writableState.errorEmitted = true;
        errorOrDestroy(stream, er);
        finishMaybe(stream, state);
      }
    }
    function onwriteStateUpdate(state) {
      state.writing = false;
      state.writecb = null;
      state.length -= state.writelen;
      state.writelen = 0;
    }
    function onwrite(stream, er) {
      var state = stream._writableState;
      var sync = state.sync;
      var cb = state.writecb;
      if (typeof cb !== "function")
        throw new ERR_MULTIPLE_CALLBACK();
      onwriteStateUpdate(state);
      if (er)
        onwriteError(stream, state, sync, er, cb);
      else {
        var finished = needFinish(state) || stream.destroyed;
        if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
          clearBuffer(stream, state);
        }
        if (sync) {
          process.nextTick(afterWrite, stream, state, finished, cb);
        } else {
          afterWrite(stream, state, finished, cb);
        }
      }
    }
    function afterWrite(stream, state, finished, cb) {
      if (!finished)
        onwriteDrain(stream, state);
      state.pendingcb--;
      cb();
      finishMaybe(stream, state);
    }
    function onwriteDrain(stream, state) {
      if (state.length === 0 && state.needDrain) {
        state.needDrain = false;
        stream.emit("drain");
      }
    }
    function clearBuffer(stream, state) {
      state.bufferProcessing = true;
      var entry = state.bufferedRequest;
      if (stream._writev && entry && entry.next) {
        var l6 = state.bufferedRequestCount;
        var buffer = new Array(l6);
        var holder = state.corkedRequestsFree;
        holder.entry = entry;
        var count = 0;
        var allBuffers = true;
        while (entry) {
          buffer[count] = entry;
          if (!entry.isBuf)
            allBuffers = false;
          entry = entry.next;
          count += 1;
        }
        buffer.allBuffers = allBuffers;
        doWrite(stream, state, true, state.length, buffer, "", holder.finish);
        state.pendingcb++;
        state.lastBufferedRequest = null;
        if (holder.next) {
          state.corkedRequestsFree = holder.next;
          holder.next = null;
        } else {
          state.corkedRequestsFree = new CorkedRequest(state);
        }
        state.bufferedRequestCount = 0;
      } else {
        while (entry) {
          var chunk = entry.chunk;
          var encoding = entry.encoding;
          var cb = entry.callback;
          var len = state.objectMode ? 1 : chunk.length;
          doWrite(stream, state, false, len, chunk, encoding, cb);
          entry = entry.next;
          state.bufferedRequestCount--;
          if (state.writing) {
            break;
          }
        }
        if (entry === null)
          state.lastBufferedRequest = null;
      }
      state.bufferedRequest = entry;
      state.bufferProcessing = false;
    }
    Writable.prototype._write = function(chunk, encoding, cb) {
      cb(new ERR_METHOD_NOT_IMPLEMENTED("_write()"));
    };
    Writable.prototype._writev = null;
    Writable.prototype.end = function(chunk, encoding, cb) {
      var state = this._writableState;
      if (typeof chunk === "function") {
        cb = chunk;
        chunk = null;
        encoding = null;
      } else if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (chunk !== null && chunk !== void 0)
        this.write(chunk, encoding);
      if (state.corked) {
        state.corked = 1;
        this.uncork();
      }
      if (!state.ending)
        endWritable(this, state, cb);
      return this;
    };
    Object.defineProperty(Writable.prototype, "writableLength", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get5() {
        return this._writableState.length;
      }
    });
    function needFinish(state) {
      return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
    }
    function callFinal(stream, state) {
      stream._final(function(err) {
        state.pendingcb--;
        if (err) {
          errorOrDestroy(stream, err);
        }
        state.prefinished = true;
        stream.emit("prefinish");
        finishMaybe(stream, state);
      });
    }
    function prefinish(stream, state) {
      if (!state.prefinished && !state.finalCalled) {
        if (typeof stream._final === "function" && !state.destroyed) {
          state.pendingcb++;
          state.finalCalled = true;
          process.nextTick(callFinal, stream, state);
        } else {
          state.prefinished = true;
          stream.emit("prefinish");
        }
      }
    }
    function finishMaybe(stream, state) {
      var need = needFinish(state);
      if (need) {
        prefinish(stream, state);
        if (state.pendingcb === 0) {
          state.finished = true;
          stream.emit("finish");
          if (state.autoDestroy) {
            var rState = stream._readableState;
            if (!rState || rState.autoDestroy && rState.endEmitted) {
              stream.destroy();
            }
          }
        }
      }
      return need;
    }
    function endWritable(stream, state, cb) {
      state.ending = true;
      finishMaybe(stream, state);
      if (cb) {
        if (state.finished)
          process.nextTick(cb);
        else
          stream.once("finish", cb);
      }
      state.ended = true;
      stream.writable = false;
    }
    function onCorkedFinish(corkReq, state, err) {
      var entry = corkReq.entry;
      corkReq.entry = null;
      while (entry) {
        var cb = entry.callback;
        state.pendingcb--;
        cb(err);
        entry = entry.next;
      }
      state.corkedRequestsFree.next = corkReq;
    }
    Object.defineProperty(Writable.prototype, "destroyed", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get5() {
        if (this._writableState === void 0) {
          return false;
        }
        return this._writableState.destroyed;
      },
      set: function set6(value) {
        if (!this._writableState) {
          return;
        }
        this._writableState.destroyed = value;
      }
    });
    Writable.prototype.destroy = destroyImpl.destroy;
    Writable.prototype._undestroy = destroyImpl.undestroy;
    Writable.prototype._destroy = function(err, cb) {
      cb(err);
    };
  }
});

// ../../node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/_stream_duplex.js
var require_stream_duplex = __commonJS({
  "../../node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/_stream_duplex.js"(exports, module) {
    "use strict";
    var objectKeys = Object.keys || function(obj) {
      var keys4 = [];
      for (var key in obj)
        keys4.push(key);
      return keys4;
    };
    module.exports = Duplex;
    var Readable = require_stream_readable();
    var Writable = require_stream_writable();
    require_inherits_browser()(Duplex, Readable);
    {
      keys3 = objectKeys(Writable.prototype);
      for (v5 = 0; v5 < keys3.length; v5++) {
        method = keys3[v5];
        if (!Duplex.prototype[method])
          Duplex.prototype[method] = Writable.prototype[method];
      }
    }
    var keys3;
    var method;
    var v5;
    function Duplex(options) {
      if (!(this instanceof Duplex))
        return new Duplex(options);
      Readable.call(this, options);
      Writable.call(this, options);
      this.allowHalfOpen = true;
      if (options) {
        if (options.readable === false)
          this.readable = false;
        if (options.writable === false)
          this.writable = false;
        if (options.allowHalfOpen === false) {
          this.allowHalfOpen = false;
          this.once("end", onend);
        }
      }
    }
    Object.defineProperty(Duplex.prototype, "writableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get5() {
        return this._writableState.highWaterMark;
      }
    });
    Object.defineProperty(Duplex.prototype, "writableBuffer", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get5() {
        return this._writableState && this._writableState.getBuffer();
      }
    });
    Object.defineProperty(Duplex.prototype, "writableLength", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get5() {
        return this._writableState.length;
      }
    });
    function onend() {
      if (this._writableState.ended)
        return;
      process.nextTick(onEndNT, this);
    }
    function onEndNT(self2) {
      self2.end();
    }
    Object.defineProperty(Duplex.prototype, "destroyed", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get5() {
        if (this._readableState === void 0 || this._writableState === void 0) {
          return false;
        }
        return this._readableState.destroyed && this._writableState.destroyed;
      },
      set: function set6(value) {
        if (this._readableState === void 0 || this._writableState === void 0) {
          return;
        }
        this._readableState.destroyed = value;
        this._writableState.destroyed = value;
      }
    });
  }
});

// ../../node_modules/.pnpm/string_decoder@1.3.0/node_modules/string_decoder/lib/string_decoder.js
var require_string_decoder = __commonJS({
  "../../node_modules/.pnpm/string_decoder@1.3.0/node_modules/string_decoder/lib/string_decoder.js"(exports) {
    "use strict";
    var Buffer2 = require_safe_buffer().Buffer;
    var isEncoding = Buffer2.isEncoding || function(encoding) {
      encoding = "" + encoding;
      switch (encoding && encoding.toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
        case "raw":
          return true;
        default:
          return false;
      }
    };
    function _normalizeEncoding(enc) {
      if (!enc)
        return "utf8";
      var retried;
      while (true) {
        switch (enc) {
          case "utf8":
          case "utf-8":
            return "utf8";
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return "utf16le";
          case "latin1":
          case "binary":
            return "latin1";
          case "base64":
          case "ascii":
          case "hex":
            return enc;
          default:
            if (retried)
              return;
            enc = ("" + enc).toLowerCase();
            retried = true;
        }
      }
    }
    function normalizeEncoding(enc) {
      var nenc = _normalizeEncoding(enc);
      if (typeof nenc !== "string" && (Buffer2.isEncoding === isEncoding || !isEncoding(enc)))
        throw new Error("Unknown encoding: " + enc);
      return nenc || enc;
    }
    exports.StringDecoder = StringDecoder;
    function StringDecoder(encoding) {
      this.encoding = normalizeEncoding(encoding);
      var nb;
      switch (this.encoding) {
        case "utf16le":
          this.text = utf16Text;
          this.end = utf16End;
          nb = 4;
          break;
        case "utf8":
          this.fillLast = utf8FillLast;
          nb = 4;
          break;
        case "base64":
          this.text = base64Text;
          this.end = base64End;
          nb = 3;
          break;
        default:
          this.write = simpleWrite;
          this.end = simpleEnd;
          return;
      }
      this.lastNeed = 0;
      this.lastTotal = 0;
      this.lastChar = Buffer2.allocUnsafe(nb);
    }
    StringDecoder.prototype.write = function(buf) {
      if (buf.length === 0)
        return "";
      var r3;
      var i4;
      if (this.lastNeed) {
        r3 = this.fillLast(buf);
        if (r3 === void 0)
          return "";
        i4 = this.lastNeed;
        this.lastNeed = 0;
      } else {
        i4 = 0;
      }
      if (i4 < buf.length)
        return r3 ? r3 + this.text(buf, i4) : this.text(buf, i4);
      return r3 || "";
    };
    StringDecoder.prototype.end = utf8End;
    StringDecoder.prototype.text = utf8Text;
    StringDecoder.prototype.fillLast = function(buf) {
      if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
      }
      buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
      this.lastNeed -= buf.length;
    };
    function utf8CheckByte(byte) {
      if (byte <= 127)
        return 0;
      else if (byte >> 5 === 6)
        return 2;
      else if (byte >> 4 === 14)
        return 3;
      else if (byte >> 3 === 30)
        return 4;
      return byte >> 6 === 2 ? -1 : -2;
    }
    function utf8CheckIncomplete(self2, buf, i4) {
      var j2 = buf.length - 1;
      if (j2 < i4)
        return 0;
      var nb = utf8CheckByte(buf[j2]);
      if (nb >= 0) {
        if (nb > 0)
          self2.lastNeed = nb - 1;
        return nb;
      }
      if (--j2 < i4 || nb === -2)
        return 0;
      nb = utf8CheckByte(buf[j2]);
      if (nb >= 0) {
        if (nb > 0)
          self2.lastNeed = nb - 2;
        return nb;
      }
      if (--j2 < i4 || nb === -2)
        return 0;
      nb = utf8CheckByte(buf[j2]);
      if (nb >= 0) {
        if (nb > 0) {
          if (nb === 2)
            nb = 0;
          else
            self2.lastNeed = nb - 3;
        }
        return nb;
      }
      return 0;
    }
    function utf8CheckExtraBytes(self2, buf, p4) {
      if ((buf[0] & 192) !== 128) {
        self2.lastNeed = 0;
        return "";
      }
      if (self2.lastNeed > 1 && buf.length > 1) {
        if ((buf[1] & 192) !== 128) {
          self2.lastNeed = 1;
          return "";
        }
        if (self2.lastNeed > 2 && buf.length > 2) {
          if ((buf[2] & 192) !== 128) {
            self2.lastNeed = 2;
            return "";
          }
        }
      }
    }
    function utf8FillLast(buf) {
      var p4 = this.lastTotal - this.lastNeed;
      var r3 = utf8CheckExtraBytes(this, buf, p4);
      if (r3 !== void 0)
        return r3;
      if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, p4, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
      }
      buf.copy(this.lastChar, p4, 0, buf.length);
      this.lastNeed -= buf.length;
    }
    function utf8Text(buf, i4) {
      var total = utf8CheckIncomplete(this, buf, i4);
      if (!this.lastNeed)
        return buf.toString("utf8", i4);
      this.lastTotal = total;
      var end = buf.length - (total - this.lastNeed);
      buf.copy(this.lastChar, 0, end);
      return buf.toString("utf8", i4, end);
    }
    function utf8End(buf) {
      var r3 = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed)
        return r3 + "";
      return r3;
    }
    function utf16Text(buf, i4) {
      if ((buf.length - i4) % 2 === 0) {
        var r3 = buf.toString("utf16le", i4);
        if (r3) {
          var c6 = r3.charCodeAt(r3.length - 1);
          if (c6 >= 55296 && c6 <= 56319) {
            this.lastNeed = 2;
            this.lastTotal = 4;
            this.lastChar[0] = buf[buf.length - 2];
            this.lastChar[1] = buf[buf.length - 1];
            return r3.slice(0, -1);
          }
        }
        return r3;
      }
      this.lastNeed = 1;
      this.lastTotal = 2;
      this.lastChar[0] = buf[buf.length - 1];
      return buf.toString("utf16le", i4, buf.length - 1);
    }
    function utf16End(buf) {
      var r3 = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed) {
        var end = this.lastTotal - this.lastNeed;
        return r3 + this.lastChar.toString("utf16le", 0, end);
      }
      return r3;
    }
    function base64Text(buf, i4) {
      var n5 = (buf.length - i4) % 3;
      if (n5 === 0)
        return buf.toString("base64", i4);
      this.lastNeed = 3 - n5;
      this.lastTotal = 3;
      if (n5 === 1) {
        this.lastChar[0] = buf[buf.length - 1];
      } else {
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
      }
      return buf.toString("base64", i4, buf.length - n5);
    }
    function base64End(buf) {
      var r3 = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed)
        return r3 + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
      return r3;
    }
    function simpleWrite(buf) {
      return buf.toString(this.encoding);
    }
    function simpleEnd(buf) {
      return buf && buf.length ? this.write(buf) : "";
    }
  }
});

// ../../node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/end-of-stream.js
var require_end_of_stream = __commonJS({
  "../../node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/end-of-stream.js"(exports, module) {
    "use strict";
    var ERR_STREAM_PREMATURE_CLOSE = require_errors_browser().codes.ERR_STREAM_PREMATURE_CLOSE;
    function once2(callback) {
      var called = false;
      return function() {
        if (called)
          return;
        called = true;
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        callback.apply(this, args);
      };
    }
    function noop3() {
    }
    function isRequest(stream) {
      return stream.setHeader && typeof stream.abort === "function";
    }
    function eos(stream, opts, callback) {
      if (typeof opts === "function")
        return eos(stream, null, opts);
      if (!opts)
        opts = {};
      callback = once2(callback || noop3);
      var readable = opts.readable || opts.readable !== false && stream.readable;
      var writable = opts.writable || opts.writable !== false && stream.writable;
      var onlegacyfinish = function onlegacyfinish2() {
        if (!stream.writable)
          onfinish();
      };
      var writableEnded = stream._writableState && stream._writableState.finished;
      var onfinish = function onfinish2() {
        writable = false;
        writableEnded = true;
        if (!readable)
          callback.call(stream);
      };
      var readableEnded = stream._readableState && stream._readableState.endEmitted;
      var onend = function onend2() {
        readable = false;
        readableEnded = true;
        if (!writable)
          callback.call(stream);
      };
      var onerror = function onerror2(err) {
        callback.call(stream, err);
      };
      var onclose = function onclose2() {
        var err;
        if (readable && !readableEnded) {
          if (!stream._readableState || !stream._readableState.ended)
            err = new ERR_STREAM_PREMATURE_CLOSE();
          return callback.call(stream, err);
        }
        if (writable && !writableEnded) {
          if (!stream._writableState || !stream._writableState.ended)
            err = new ERR_STREAM_PREMATURE_CLOSE();
          return callback.call(stream, err);
        }
      };
      var onrequest = function onrequest2() {
        stream.req.on("finish", onfinish);
      };
      if (isRequest(stream)) {
        stream.on("complete", onfinish);
        stream.on("abort", onclose);
        if (stream.req)
          onrequest();
        else
          stream.on("request", onrequest);
      } else if (writable && !stream._writableState) {
        stream.on("end", onlegacyfinish);
        stream.on("close", onlegacyfinish);
      }
      stream.on("end", onend);
      stream.on("finish", onfinish);
      if (opts.error !== false)
        stream.on("error", onerror);
      stream.on("close", onclose);
      return function() {
        stream.removeListener("complete", onfinish);
        stream.removeListener("abort", onclose);
        stream.removeListener("request", onrequest);
        if (stream.req)
          stream.req.removeListener("finish", onfinish);
        stream.removeListener("end", onlegacyfinish);
        stream.removeListener("close", onlegacyfinish);
        stream.removeListener("finish", onfinish);
        stream.removeListener("end", onend);
        stream.removeListener("error", onerror);
        stream.removeListener("close", onclose);
      };
    }
    module.exports = eos;
  }
});

// ../../node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/async_iterator.js
var require_async_iterator = __commonJS({
  "../../node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/async_iterator.js"(exports, module) {
    "use strict";
    var _Object$setPrototypeO;
    function _defineProperty(obj, key, value) {
      key = _toPropertyKey2(key);
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _toPropertyKey2(arg) {
      var key = _toPrimitive2(arg, "string");
      return typeof key === "symbol" ? key : String(key);
    }
    function _toPrimitive2(input, hint) {
      if (typeof input !== "object" || input === null)
        return input;
      var prim = input[Symbol.toPrimitive];
      if (prim !== void 0) {
        var res = prim.call(input, hint || "default");
        if (typeof res !== "object")
          return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (hint === "string" ? String : Number)(input);
    }
    var finished = require_end_of_stream();
    var kLastResolve = Symbol("lastResolve");
    var kLastReject = Symbol("lastReject");
    var kError = Symbol("error");
    var kEnded = Symbol("ended");
    var kLastPromise = Symbol("lastPromise");
    var kHandlePromise = Symbol("handlePromise");
    var kStream = Symbol("stream");
    function createIterResult(value, done) {
      return {
        value,
        done
      };
    }
    function readAndResolve(iter) {
      var resolve = iter[kLastResolve];
      if (resolve !== null) {
        var data = iter[kStream].read();
        if (data !== null) {
          iter[kLastPromise] = null;
          iter[kLastResolve] = null;
          iter[kLastReject] = null;
          resolve(createIterResult(data, false));
        }
      }
    }
    function onReadable(iter) {
      process.nextTick(readAndResolve, iter);
    }
    function wrapForNext(lastPromise, iter) {
      return function(resolve, reject) {
        lastPromise.then(function() {
          if (iter[kEnded]) {
            resolve(createIterResult(void 0, true));
            return;
          }
          iter[kHandlePromise](resolve, reject);
        }, reject);
      };
    }
    var AsyncIteratorPrototype = Object.getPrototypeOf(function() {
    });
    var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
      get stream() {
        return this[kStream];
      },
      next: function next() {
        var _this = this;
        var error = this[kError];
        if (error !== null) {
          return Promise.reject(error);
        }
        if (this[kEnded]) {
          return Promise.resolve(createIterResult(void 0, true));
        }
        if (this[kStream].destroyed) {
          return new Promise(function(resolve, reject) {
            process.nextTick(function() {
              if (_this[kError]) {
                reject(_this[kError]);
              } else {
                resolve(createIterResult(void 0, true));
              }
            });
          });
        }
        var lastPromise = this[kLastPromise];
        var promise;
        if (lastPromise) {
          promise = new Promise(wrapForNext(lastPromise, this));
        } else {
          var data = this[kStream].read();
          if (data !== null) {
            return Promise.resolve(createIterResult(data, false));
          }
          promise = new Promise(this[kHandlePromise]);
        }
        this[kLastPromise] = promise;
        return promise;
      }
    }, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function() {
      return this;
    }), _defineProperty(_Object$setPrototypeO, "return", function _return() {
      var _this2 = this;
      return new Promise(function(resolve, reject) {
        _this2[kStream].destroy(null, function(err) {
          if (err) {
            reject(err);
            return;
          }
          resolve(createIterResult(void 0, true));
        });
      });
    }), _Object$setPrototypeO), AsyncIteratorPrototype);
    var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator2(stream) {
      var _Object$create;
      var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
        value: stream,
        writable: true
      }), _defineProperty(_Object$create, kLastResolve, {
        value: null,
        writable: true
      }), _defineProperty(_Object$create, kLastReject, {
        value: null,
        writable: true
      }), _defineProperty(_Object$create, kError, {
        value: null,
        writable: true
      }), _defineProperty(_Object$create, kEnded, {
        value: stream._readableState.endEmitted,
        writable: true
      }), _defineProperty(_Object$create, kHandlePromise, {
        value: function value(resolve, reject) {
          var data = iterator[kStream].read();
          if (data) {
            iterator[kLastPromise] = null;
            iterator[kLastResolve] = null;
            iterator[kLastReject] = null;
            resolve(createIterResult(data, false));
          } else {
            iterator[kLastResolve] = resolve;
            iterator[kLastReject] = reject;
          }
        },
        writable: true
      }), _Object$create));
      iterator[kLastPromise] = null;
      finished(stream, function(err) {
        if (err && err.code !== "ERR_STREAM_PREMATURE_CLOSE") {
          var reject = iterator[kLastReject];
          if (reject !== null) {
            iterator[kLastPromise] = null;
            iterator[kLastResolve] = null;
            iterator[kLastReject] = null;
            reject(err);
          }
          iterator[kError] = err;
          return;
        }
        var resolve = iterator[kLastResolve];
        if (resolve !== null) {
          iterator[kLastPromise] = null;
          iterator[kLastResolve] = null;
          iterator[kLastReject] = null;
          resolve(createIterResult(void 0, true));
        }
        iterator[kEnded] = true;
      });
      stream.on("readable", onReadable.bind(null, iterator));
      return iterator;
    };
    module.exports = createReadableStreamAsyncIterator;
  }
});

// ../../node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/from-browser.js
var require_from_browser = __commonJS({
  "../../node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/from-browser.js"(exports, module) {
    module.exports = function() {
      throw new Error("Readable.from is not available in the browser");
    };
  }
});

// ../../node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/_stream_readable.js
var require_stream_readable = __commonJS({
  "../../node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/_stream_readable.js"(exports, module) {
    "use strict";
    module.exports = Readable;
    var Duplex;
    Readable.ReadableState = ReadableState;
    var EE = require_events().EventEmitter;
    var EElistenerCount = function EElistenerCount2(emitter, type) {
      return emitter.listeners(type).length;
    };
    var Stream = require_stream_browser();
    var Buffer2 = require_buffer().Buffer;
    var OurUint8Array = (typeof global !== "undefined" ? global : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
    };
    function _uint8ArrayToBuffer(chunk) {
      return Buffer2.from(chunk);
    }
    function _isUint8Array(obj) {
      return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
    }
    var debugUtil = require_util();
    var debug;
    if (debugUtil && debugUtil.debuglog) {
      debug = debugUtil.debuglog("stream");
    } else {
      debug = function debug2() {
      };
    }
    var BufferList = require_buffer_list();
    var destroyImpl = require_destroy();
    var _require = require_state();
    var getHighWaterMark = _require.getHighWaterMark;
    var _require$codes = require_errors_browser().codes;
    var ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE;
    var ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF;
    var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
    var ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;
    var StringDecoder;
    var createReadableStreamAsyncIterator;
    var from;
    require_inherits_browser()(Readable, Stream);
    var errorOrDestroy = destroyImpl.errorOrDestroy;
    var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
    function prependListener(emitter, event, fn2) {
      if (typeof emitter.prependListener === "function")
        return emitter.prependListener(event, fn2);
      if (!emitter._events || !emitter._events[event])
        emitter.on(event, fn2);
      else if (Array.isArray(emitter._events[event]))
        emitter._events[event].unshift(fn2);
      else
        emitter._events[event] = [fn2, emitter._events[event]];
    }
    function ReadableState(options, stream, isDuplex) {
      Duplex = Duplex || require_stream_duplex();
      options = options || {};
      if (typeof isDuplex !== "boolean")
        isDuplex = stream instanceof Duplex;
      this.objectMode = !!options.objectMode;
      if (isDuplex)
        this.objectMode = this.objectMode || !!options.readableObjectMode;
      this.highWaterMark = getHighWaterMark(this, options, "readableHighWaterMark", isDuplex);
      this.buffer = new BufferList();
      this.length = 0;
      this.pipes = null;
      this.pipesCount = 0;
      this.flowing = null;
      this.ended = false;
      this.endEmitted = false;
      this.reading = false;
      this.sync = true;
      this.needReadable = false;
      this.emittedReadable = false;
      this.readableListening = false;
      this.resumeScheduled = false;
      this.paused = true;
      this.emitClose = options.emitClose !== false;
      this.autoDestroy = !!options.autoDestroy;
      this.destroyed = false;
      this.defaultEncoding = options.defaultEncoding || "utf8";
      this.awaitDrain = 0;
      this.readingMore = false;
      this.decoder = null;
      this.encoding = null;
      if (options.encoding) {
        if (!StringDecoder)
          StringDecoder = require_string_decoder().StringDecoder;
        this.decoder = new StringDecoder(options.encoding);
        this.encoding = options.encoding;
      }
    }
    function Readable(options) {
      Duplex = Duplex || require_stream_duplex();
      if (!(this instanceof Readable))
        return new Readable(options);
      var isDuplex = this instanceof Duplex;
      this._readableState = new ReadableState(options, this, isDuplex);
      this.readable = true;
      if (options) {
        if (typeof options.read === "function")
          this._read = options.read;
        if (typeof options.destroy === "function")
          this._destroy = options.destroy;
      }
      Stream.call(this);
    }
    Object.defineProperty(Readable.prototype, "destroyed", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get5() {
        if (this._readableState === void 0) {
          return false;
        }
        return this._readableState.destroyed;
      },
      set: function set6(value) {
        if (!this._readableState) {
          return;
        }
        this._readableState.destroyed = value;
      }
    });
    Readable.prototype.destroy = destroyImpl.destroy;
    Readable.prototype._undestroy = destroyImpl.undestroy;
    Readable.prototype._destroy = function(err, cb) {
      cb(err);
    };
    Readable.prototype.push = function(chunk, encoding) {
      var state = this._readableState;
      var skipChunkCheck;
      if (!state.objectMode) {
        if (typeof chunk === "string") {
          encoding = encoding || state.defaultEncoding;
          if (encoding !== state.encoding) {
            chunk = Buffer2.from(chunk, encoding);
            encoding = "";
          }
          skipChunkCheck = true;
        }
      } else {
        skipChunkCheck = true;
      }
      return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
    };
    Readable.prototype.unshift = function(chunk) {
      return readableAddChunk(this, chunk, null, true, false);
    };
    function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
      debug("readableAddChunk", chunk);
      var state = stream._readableState;
      if (chunk === null) {
        state.reading = false;
        onEofChunk(stream, state);
      } else {
        var er;
        if (!skipChunkCheck)
          er = chunkInvalid(state, chunk);
        if (er) {
          errorOrDestroy(stream, er);
        } else if (state.objectMode || chunk && chunk.length > 0) {
          if (typeof chunk !== "string" && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer2.prototype) {
            chunk = _uint8ArrayToBuffer(chunk);
          }
          if (addToFront) {
            if (state.endEmitted)
              errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());
            else
              addChunk(stream, state, chunk, true);
          } else if (state.ended) {
            errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
          } else if (state.destroyed) {
            return false;
          } else {
            state.reading = false;
            if (state.decoder && !encoding) {
              chunk = state.decoder.write(chunk);
              if (state.objectMode || chunk.length !== 0)
                addChunk(stream, state, chunk, false);
              else
                maybeReadMore(stream, state);
            } else {
              addChunk(stream, state, chunk, false);
            }
          }
        } else if (!addToFront) {
          state.reading = false;
          maybeReadMore(stream, state);
        }
      }
      return !state.ended && (state.length < state.highWaterMark || state.length === 0);
    }
    function addChunk(stream, state, chunk, addToFront) {
      if (state.flowing && state.length === 0 && !state.sync) {
        state.awaitDrain = 0;
        stream.emit("data", chunk);
      } else {
        state.length += state.objectMode ? 1 : chunk.length;
        if (addToFront)
          state.buffer.unshift(chunk);
        else
          state.buffer.push(chunk);
        if (state.needReadable)
          emitReadable(stream);
      }
      maybeReadMore(stream, state);
    }
    function chunkInvalid(state, chunk) {
      var er;
      if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
        er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer", "Uint8Array"], chunk);
      }
      return er;
    }
    Readable.prototype.isPaused = function() {
      return this._readableState.flowing === false;
    };
    Readable.prototype.setEncoding = function(enc) {
      if (!StringDecoder)
        StringDecoder = require_string_decoder().StringDecoder;
      var decoder = new StringDecoder(enc);
      this._readableState.decoder = decoder;
      this._readableState.encoding = this._readableState.decoder.encoding;
      var p4 = this._readableState.buffer.head;
      var content = "";
      while (p4 !== null) {
        content += decoder.write(p4.data);
        p4 = p4.next;
      }
      this._readableState.buffer.clear();
      if (content !== "")
        this._readableState.buffer.push(content);
      this._readableState.length = content.length;
      return this;
    };
    var MAX_HWM = 1073741824;
    function computeNewHighWaterMark(n5) {
      if (n5 >= MAX_HWM) {
        n5 = MAX_HWM;
      } else {
        n5--;
        n5 |= n5 >>> 1;
        n5 |= n5 >>> 2;
        n5 |= n5 >>> 4;
        n5 |= n5 >>> 8;
        n5 |= n5 >>> 16;
        n5++;
      }
      return n5;
    }
    function howMuchToRead(n5, state) {
      if (n5 <= 0 || state.length === 0 && state.ended)
        return 0;
      if (state.objectMode)
        return 1;
      if (n5 !== n5) {
        if (state.flowing && state.length)
          return state.buffer.head.data.length;
        else
          return state.length;
      }
      if (n5 > state.highWaterMark)
        state.highWaterMark = computeNewHighWaterMark(n5);
      if (n5 <= state.length)
        return n5;
      if (!state.ended) {
        state.needReadable = true;
        return 0;
      }
      return state.length;
    }
    Readable.prototype.read = function(n5) {
      debug("read", n5);
      n5 = parseInt(n5, 10);
      var state = this._readableState;
      var nOrig = n5;
      if (n5 !== 0)
        state.emittedReadable = false;
      if (n5 === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
        debug("read: emitReadable", state.length, state.ended);
        if (state.length === 0 && state.ended)
          endReadable(this);
        else
          emitReadable(this);
        return null;
      }
      n5 = howMuchToRead(n5, state);
      if (n5 === 0 && state.ended) {
        if (state.length === 0)
          endReadable(this);
        return null;
      }
      var doRead = state.needReadable;
      debug("need readable", doRead);
      if (state.length === 0 || state.length - n5 < state.highWaterMark) {
        doRead = true;
        debug("length less than watermark", doRead);
      }
      if (state.ended || state.reading) {
        doRead = false;
        debug("reading or ended", doRead);
      } else if (doRead) {
        debug("do read");
        state.reading = true;
        state.sync = true;
        if (state.length === 0)
          state.needReadable = true;
        this._read(state.highWaterMark);
        state.sync = false;
        if (!state.reading)
          n5 = howMuchToRead(nOrig, state);
      }
      var ret;
      if (n5 > 0)
        ret = fromList(n5, state);
      else
        ret = null;
      if (ret === null) {
        state.needReadable = state.length <= state.highWaterMark;
        n5 = 0;
      } else {
        state.length -= n5;
        state.awaitDrain = 0;
      }
      if (state.length === 0) {
        if (!state.ended)
          state.needReadable = true;
        if (nOrig !== n5 && state.ended)
          endReadable(this);
      }
      if (ret !== null)
        this.emit("data", ret);
      return ret;
    };
    function onEofChunk(stream, state) {
      debug("onEofChunk");
      if (state.ended)
        return;
      if (state.decoder) {
        var chunk = state.decoder.end();
        if (chunk && chunk.length) {
          state.buffer.push(chunk);
          state.length += state.objectMode ? 1 : chunk.length;
        }
      }
      state.ended = true;
      if (state.sync) {
        emitReadable(stream);
      } else {
        state.needReadable = false;
        if (!state.emittedReadable) {
          state.emittedReadable = true;
          emitReadable_(stream);
        }
      }
    }
    function emitReadable(stream) {
      var state = stream._readableState;
      debug("emitReadable", state.needReadable, state.emittedReadable);
      state.needReadable = false;
      if (!state.emittedReadable) {
        debug("emitReadable", state.flowing);
        state.emittedReadable = true;
        process.nextTick(emitReadable_, stream);
      }
    }
    function emitReadable_(stream) {
      var state = stream._readableState;
      debug("emitReadable_", state.destroyed, state.length, state.ended);
      if (!state.destroyed && (state.length || state.ended)) {
        stream.emit("readable");
        state.emittedReadable = false;
      }
      state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
      flow3(stream);
    }
    function maybeReadMore(stream, state) {
      if (!state.readingMore) {
        state.readingMore = true;
        process.nextTick(maybeReadMore_, stream, state);
      }
    }
    function maybeReadMore_(stream, state) {
      while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
        var len = state.length;
        debug("maybeReadMore read 0");
        stream.read(0);
        if (len === state.length)
          break;
      }
      state.readingMore = false;
    }
    Readable.prototype._read = function(n5) {
      errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED("_read()"));
    };
    Readable.prototype.pipe = function(dest, pipeOpts) {
      var src = this;
      var state = this._readableState;
      switch (state.pipesCount) {
        case 0:
          state.pipes = dest;
          break;
        case 1:
          state.pipes = [state.pipes, dest];
          break;
        default:
          state.pipes.push(dest);
          break;
      }
      state.pipesCount += 1;
      debug("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
      var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
      var endFn = doEnd ? onend : unpipe;
      if (state.endEmitted)
        process.nextTick(endFn);
      else
        src.once("end", endFn);
      dest.on("unpipe", onunpipe);
      function onunpipe(readable, unpipeInfo) {
        debug("onunpipe");
        if (readable === src) {
          if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
            unpipeInfo.hasUnpiped = true;
            cleanup();
          }
        }
      }
      function onend() {
        debug("onend");
        dest.end();
      }
      var ondrain = pipeOnDrain(src);
      dest.on("drain", ondrain);
      var cleanedUp = false;
      function cleanup() {
        debug("cleanup");
        dest.removeListener("close", onclose);
        dest.removeListener("finish", onfinish);
        dest.removeListener("drain", ondrain);
        dest.removeListener("error", onerror);
        dest.removeListener("unpipe", onunpipe);
        src.removeListener("end", onend);
        src.removeListener("end", unpipe);
        src.removeListener("data", ondata);
        cleanedUp = true;
        if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain))
          ondrain();
      }
      src.on("data", ondata);
      function ondata(chunk) {
        debug("ondata");
        var ret = dest.write(chunk);
        debug("dest.write", ret);
        if (ret === false) {
          if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
            debug("false write response, pause", state.awaitDrain);
            state.awaitDrain++;
          }
          src.pause();
        }
      }
      function onerror(er) {
        debug("onerror", er);
        unpipe();
        dest.removeListener("error", onerror);
        if (EElistenerCount(dest, "error") === 0)
          errorOrDestroy(dest, er);
      }
      prependListener(dest, "error", onerror);
      function onclose() {
        dest.removeListener("finish", onfinish);
        unpipe();
      }
      dest.once("close", onclose);
      function onfinish() {
        debug("onfinish");
        dest.removeListener("close", onclose);
        unpipe();
      }
      dest.once("finish", onfinish);
      function unpipe() {
        debug("unpipe");
        src.unpipe(dest);
      }
      dest.emit("pipe", src);
      if (!state.flowing) {
        debug("pipe resume");
        src.resume();
      }
      return dest;
    };
    function pipeOnDrain(src) {
      return function pipeOnDrainFunctionResult() {
        var state = src._readableState;
        debug("pipeOnDrain", state.awaitDrain);
        if (state.awaitDrain)
          state.awaitDrain--;
        if (state.awaitDrain === 0 && EElistenerCount(src, "data")) {
          state.flowing = true;
          flow3(src);
        }
      };
    }
    Readable.prototype.unpipe = function(dest) {
      var state = this._readableState;
      var unpipeInfo = {
        hasUnpiped: false
      };
      if (state.pipesCount === 0)
        return this;
      if (state.pipesCount === 1) {
        if (dest && dest !== state.pipes)
          return this;
        if (!dest)
          dest = state.pipes;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        if (dest)
          dest.emit("unpipe", this, unpipeInfo);
        return this;
      }
      if (!dest) {
        var dests = state.pipes;
        var len = state.pipesCount;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        for (var i4 = 0; i4 < len; i4++)
          dests[i4].emit("unpipe", this, {
            hasUnpiped: false
          });
        return this;
      }
      var index = indexOf(state.pipes, dest);
      if (index === -1)
        return this;
      state.pipes.splice(index, 1);
      state.pipesCount -= 1;
      if (state.pipesCount === 1)
        state.pipes = state.pipes[0];
      dest.emit("unpipe", this, unpipeInfo);
      return this;
    };
    Readable.prototype.on = function(ev, fn2) {
      var res = Stream.prototype.on.call(this, ev, fn2);
      var state = this._readableState;
      if (ev === "data") {
        state.readableListening = this.listenerCount("readable") > 0;
        if (state.flowing !== false)
          this.resume();
      } else if (ev === "readable") {
        if (!state.endEmitted && !state.readableListening) {
          state.readableListening = state.needReadable = true;
          state.flowing = false;
          state.emittedReadable = false;
          debug("on readable", state.length, state.reading);
          if (state.length) {
            emitReadable(this);
          } else if (!state.reading) {
            process.nextTick(nReadingNextTick, this);
          }
        }
      }
      return res;
    };
    Readable.prototype.addListener = Readable.prototype.on;
    Readable.prototype.removeListener = function(ev, fn2) {
      var res = Stream.prototype.removeListener.call(this, ev, fn2);
      if (ev === "readable") {
        process.nextTick(updateReadableListening, this);
      }
      return res;
    };
    Readable.prototype.removeAllListeners = function(ev) {
      var res = Stream.prototype.removeAllListeners.apply(this, arguments);
      if (ev === "readable" || ev === void 0) {
        process.nextTick(updateReadableListening, this);
      }
      return res;
    };
    function updateReadableListening(self2) {
      var state = self2._readableState;
      state.readableListening = self2.listenerCount("readable") > 0;
      if (state.resumeScheduled && !state.paused) {
        state.flowing = true;
      } else if (self2.listenerCount("data") > 0) {
        self2.resume();
      }
    }
    function nReadingNextTick(self2) {
      debug("readable nexttick read 0");
      self2.read(0);
    }
    Readable.prototype.resume = function() {
      var state = this._readableState;
      if (!state.flowing) {
        debug("resume");
        state.flowing = !state.readableListening;
        resume(this, state);
      }
      state.paused = false;
      return this;
    };
    function resume(stream, state) {
      if (!state.resumeScheduled) {
        state.resumeScheduled = true;
        process.nextTick(resume_, stream, state);
      }
    }
    function resume_(stream, state) {
      debug("resume", state.reading);
      if (!state.reading) {
        stream.read(0);
      }
      state.resumeScheduled = false;
      stream.emit("resume");
      flow3(stream);
      if (state.flowing && !state.reading)
        stream.read(0);
    }
    Readable.prototype.pause = function() {
      debug("call pause flowing=%j", this._readableState.flowing);
      if (this._readableState.flowing !== false) {
        debug("pause");
        this._readableState.flowing = false;
        this.emit("pause");
      }
      this._readableState.paused = true;
      return this;
    };
    function flow3(stream) {
      var state = stream._readableState;
      debug("flow", state.flowing);
      while (state.flowing && stream.read() !== null)
        ;
    }
    Readable.prototype.wrap = function(stream) {
      var _this = this;
      var state = this._readableState;
      var paused = false;
      stream.on("end", function() {
        debug("wrapped end");
        if (state.decoder && !state.ended) {
          var chunk = state.decoder.end();
          if (chunk && chunk.length)
            _this.push(chunk);
        }
        _this.push(null);
      });
      stream.on("data", function(chunk) {
        debug("wrapped data");
        if (state.decoder)
          chunk = state.decoder.write(chunk);
        if (state.objectMode && (chunk === null || chunk === void 0))
          return;
        else if (!state.objectMode && (!chunk || !chunk.length))
          return;
        var ret = _this.push(chunk);
        if (!ret) {
          paused = true;
          stream.pause();
        }
      });
      for (var i4 in stream) {
        if (this[i4] === void 0 && typeof stream[i4] === "function") {
          this[i4] = function methodWrap(method) {
            return function methodWrapReturnFunction() {
              return stream[method].apply(stream, arguments);
            };
          }(i4);
        }
      }
      for (var n5 = 0; n5 < kProxyEvents.length; n5++) {
        stream.on(kProxyEvents[n5], this.emit.bind(this, kProxyEvents[n5]));
      }
      this._read = function(n6) {
        debug("wrapped _read", n6);
        if (paused) {
          paused = false;
          stream.resume();
        }
      };
      return this;
    };
    if (typeof Symbol === "function") {
      Readable.prototype[Symbol.asyncIterator] = function() {
        if (createReadableStreamAsyncIterator === void 0) {
          createReadableStreamAsyncIterator = require_async_iterator();
        }
        return createReadableStreamAsyncIterator(this);
      };
    }
    Object.defineProperty(Readable.prototype, "readableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get5() {
        return this._readableState.highWaterMark;
      }
    });
    Object.defineProperty(Readable.prototype, "readableBuffer", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get5() {
        return this._readableState && this._readableState.buffer;
      }
    });
    Object.defineProperty(Readable.prototype, "readableFlowing", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get5() {
        return this._readableState.flowing;
      },
      set: function set6(state) {
        if (this._readableState) {
          this._readableState.flowing = state;
        }
      }
    });
    Readable._fromList = fromList;
    Object.defineProperty(Readable.prototype, "readableLength", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get5() {
        return this._readableState.length;
      }
    });
    function fromList(n5, state) {
      if (state.length === 0)
        return null;
      var ret;
      if (state.objectMode)
        ret = state.buffer.shift();
      else if (!n5 || n5 >= state.length) {
        if (state.decoder)
          ret = state.buffer.join("");
        else if (state.buffer.length === 1)
          ret = state.buffer.first();
        else
          ret = state.buffer.concat(state.length);
        state.buffer.clear();
      } else {
        ret = state.buffer.consume(n5, state.decoder);
      }
      return ret;
    }
    function endReadable(stream) {
      var state = stream._readableState;
      debug("endReadable", state.endEmitted);
      if (!state.endEmitted) {
        state.ended = true;
        process.nextTick(endReadableNT, state, stream);
      }
    }
    function endReadableNT(state, stream) {
      debug("endReadableNT", state.endEmitted, state.length);
      if (!state.endEmitted && state.length === 0) {
        state.endEmitted = true;
        stream.readable = false;
        stream.emit("end");
        if (state.autoDestroy) {
          var wState = stream._writableState;
          if (!wState || wState.autoDestroy && wState.finished) {
            stream.destroy();
          }
        }
      }
    }
    if (typeof Symbol === "function") {
      Readable.from = function(iterable, opts) {
        if (from === void 0) {
          from = require_from_browser();
        }
        return from(Readable, iterable, opts);
      };
    }
    function indexOf(xs2, x4) {
      for (var i4 = 0, l6 = xs2.length; i4 < l6; i4++) {
        if (xs2[i4] === x4)
          return i4;
      }
      return -1;
    }
  }
});

// ../../node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/_stream_transform.js
var require_stream_transform = __commonJS({
  "../../node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/_stream_transform.js"(exports, module) {
    "use strict";
    module.exports = Transform;
    var _require$codes = require_errors_browser().codes;
    var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
    var ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK;
    var ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING;
    var ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;
    var Duplex = require_stream_duplex();
    require_inherits_browser()(Transform, Duplex);
    function afterTransform(er, data) {
      var ts = this._transformState;
      ts.transforming = false;
      var cb = ts.writecb;
      if (cb === null) {
        return this.emit("error", new ERR_MULTIPLE_CALLBACK());
      }
      ts.writechunk = null;
      ts.writecb = null;
      if (data != null)
        this.push(data);
      cb(er);
      var rs = this._readableState;
      rs.reading = false;
      if (rs.needReadable || rs.length < rs.highWaterMark) {
        this._read(rs.highWaterMark);
      }
    }
    function Transform(options) {
      if (!(this instanceof Transform))
        return new Transform(options);
      Duplex.call(this, options);
      this._transformState = {
        afterTransform: afterTransform.bind(this),
        needTransform: false,
        transforming: false,
        writecb: null,
        writechunk: null,
        writeencoding: null
      };
      this._readableState.needReadable = true;
      this._readableState.sync = false;
      if (options) {
        if (typeof options.transform === "function")
          this._transform = options.transform;
        if (typeof options.flush === "function")
          this._flush = options.flush;
      }
      this.on("prefinish", prefinish);
    }
    function prefinish() {
      var _this = this;
      if (typeof this._flush === "function" && !this._readableState.destroyed) {
        this._flush(function(er, data) {
          done(_this, er, data);
        });
      } else {
        done(this, null, null);
      }
    }
    Transform.prototype.push = function(chunk, encoding) {
      this._transformState.needTransform = false;
      return Duplex.prototype.push.call(this, chunk, encoding);
    };
    Transform.prototype._transform = function(chunk, encoding, cb) {
      cb(new ERR_METHOD_NOT_IMPLEMENTED("_transform()"));
    };
    Transform.prototype._write = function(chunk, encoding, cb) {
      var ts = this._transformState;
      ts.writecb = cb;
      ts.writechunk = chunk;
      ts.writeencoding = encoding;
      if (!ts.transforming) {
        var rs = this._readableState;
        if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark)
          this._read(rs.highWaterMark);
      }
    };
    Transform.prototype._read = function(n5) {
      var ts = this._transformState;
      if (ts.writechunk !== null && !ts.transforming) {
        ts.transforming = true;
        this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
      } else {
        ts.needTransform = true;
      }
    };
    Transform.prototype._destroy = function(err, cb) {
      Duplex.prototype._destroy.call(this, err, function(err2) {
        cb(err2);
      });
    };
    function done(stream, er, data) {
      if (er)
        return stream.emit("error", er);
      if (data != null)
        stream.push(data);
      if (stream._writableState.length)
        throw new ERR_TRANSFORM_WITH_LENGTH_0();
      if (stream._transformState.transforming)
        throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
      return stream.push(null);
    }
  }
});

// ../../node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/_stream_passthrough.js
var require_stream_passthrough = __commonJS({
  "../../node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/_stream_passthrough.js"(exports, module) {
    "use strict";
    module.exports = PassThrough;
    var Transform = require_stream_transform();
    require_inherits_browser()(PassThrough, Transform);
    function PassThrough(options) {
      if (!(this instanceof PassThrough))
        return new PassThrough(options);
      Transform.call(this, options);
    }
    PassThrough.prototype._transform = function(chunk, encoding, cb) {
      cb(null, chunk);
    };
  }
});

// ../../node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/pipeline.js
var require_pipeline = __commonJS({
  "../../node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/pipeline.js"(exports, module) {
    "use strict";
    var eos;
    function once2(callback) {
      var called = false;
      return function() {
        if (called)
          return;
        called = true;
        callback.apply(void 0, arguments);
      };
    }
    var _require$codes = require_errors_browser().codes;
    var ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS;
    var ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
    function noop3(err) {
      if (err)
        throw err;
    }
    function isRequest(stream) {
      return stream.setHeader && typeof stream.abort === "function";
    }
    function destroyer(stream, reading, writing, callback) {
      callback = once2(callback);
      var closed = false;
      stream.on("close", function() {
        closed = true;
      });
      if (eos === void 0)
        eos = require_end_of_stream();
      eos(stream, {
        readable: reading,
        writable: writing
      }, function(err) {
        if (err)
          return callback(err);
        closed = true;
        callback();
      });
      var destroyed = false;
      return function(err) {
        if (closed)
          return;
        if (destroyed)
          return;
        destroyed = true;
        if (isRequest(stream))
          return stream.abort();
        if (typeof stream.destroy === "function")
          return stream.destroy();
        callback(err || new ERR_STREAM_DESTROYED("pipe"));
      };
    }
    function call(fn2) {
      fn2();
    }
    function pipe(from, to2) {
      return from.pipe(to2);
    }
    function popCallback(streams) {
      if (!streams.length)
        return noop3;
      if (typeof streams[streams.length - 1] !== "function")
        return noop3;
      return streams.pop();
    }
    function pipeline() {
      for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
        streams[_key] = arguments[_key];
      }
      var callback = popCallback(streams);
      if (Array.isArray(streams[0]))
        streams = streams[0];
      if (streams.length < 2) {
        throw new ERR_MISSING_ARGS("streams");
      }
      var error;
      var destroys = streams.map(function(stream, i4) {
        var reading = i4 < streams.length - 1;
        var writing = i4 > 0;
        return destroyer(stream, reading, writing, function(err) {
          if (!error)
            error = err;
          if (err)
            destroys.forEach(call);
          if (reading)
            return;
          destroys.forEach(call);
          callback(error);
        });
      });
      return streams.reduce(pipe);
    }
    module.exports = pipeline;
  }
});

// ../../node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/readable-browser.js
var require_readable_browser = __commonJS({
  "../../node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/readable-browser.js"(exports, module) {
    exports = module.exports = require_stream_readable();
    exports.Stream = exports;
    exports.Readable = exports;
    exports.Writable = require_stream_writable();
    exports.Duplex = require_stream_duplex();
    exports.Transform = require_stream_transform();
    exports.PassThrough = require_stream_passthrough();
    exports.finished = require_end_of_stream();
    exports.pipeline = require_pipeline();
  }
});

// ../../node_modules/.pnpm/hash-base@3.1.0/node_modules/hash-base/index.js
var require_hash_base = __commonJS({
  "../../node_modules/.pnpm/hash-base@3.1.0/node_modules/hash-base/index.js"(exports, module) {
    "use strict";
    var Buffer2 = require_safe_buffer().Buffer;
    var Transform = require_readable_browser().Transform;
    var inherits = require_inherits_browser();
    function throwIfNotStringOrBuffer(val, prefix) {
      if (!Buffer2.isBuffer(val) && typeof val !== "string") {
        throw new TypeError(prefix + " must be a string or a buffer");
      }
    }
    function HashBase(blockSize) {
      Transform.call(this);
      this._block = Buffer2.allocUnsafe(blockSize);
      this._blockSize = blockSize;
      this._blockOffset = 0;
      this._length = [0, 0, 0, 0];
      this._finalized = false;
    }
    inherits(HashBase, Transform);
    HashBase.prototype._transform = function(chunk, encoding, callback) {
      var error = null;
      try {
        this.update(chunk, encoding);
      } catch (err) {
        error = err;
      }
      callback(error);
    };
    HashBase.prototype._flush = function(callback) {
      var error = null;
      try {
        this.push(this.digest());
      } catch (err) {
        error = err;
      }
      callback(error);
    };
    HashBase.prototype.update = function(data, encoding) {
      throwIfNotStringOrBuffer(data, "Data");
      if (this._finalized)
        throw new Error("Digest already called");
      if (!Buffer2.isBuffer(data))
        data = Buffer2.from(data, encoding);
      var block = this._block;
      var offset = 0;
      while (this._blockOffset + data.length - offset >= this._blockSize) {
        for (var i4 = this._blockOffset; i4 < this._blockSize; )
          block[i4++] = data[offset++];
        this._update();
        this._blockOffset = 0;
      }
      while (offset < data.length)
        block[this._blockOffset++] = data[offset++];
      for (var j2 = 0, carry = data.length * 8; carry > 0; ++j2) {
        this._length[j2] += carry;
        carry = this._length[j2] / 4294967296 | 0;
        if (carry > 0)
          this._length[j2] -= 4294967296 * carry;
      }
      return this;
    };
    HashBase.prototype._update = function() {
      throw new Error("_update is not implemented");
    };
    HashBase.prototype.digest = function(encoding) {
      if (this._finalized)
        throw new Error("Digest already called");
      this._finalized = true;
      var digest = this._digest();
      if (encoding !== void 0)
        digest = digest.toString(encoding);
      this._block.fill(0);
      this._blockOffset = 0;
      for (var i4 = 0; i4 < 4; ++i4)
        this._length[i4] = 0;
      return digest;
    };
    HashBase.prototype._digest = function() {
      throw new Error("_digest is not implemented");
    };
    module.exports = HashBase;
  }
});

// ../../node_modules/.pnpm/md5.js@1.3.5/node_modules/md5.js/index.js
var require_md5 = __commonJS({
  "../../node_modules/.pnpm/md5.js@1.3.5/node_modules/md5.js/index.js"(exports, module) {
    "use strict";
    var inherits = require_inherits_browser();
    var HashBase = require_hash_base();
    var Buffer2 = require_safe_buffer().Buffer;
    var ARRAY16 = new Array(16);
    function MD5() {
      HashBase.call(this, 64);
      this._a = 1732584193;
      this._b = 4023233417;
      this._c = 2562383102;
      this._d = 271733878;
    }
    inherits(MD5, HashBase);
    MD5.prototype._update = function() {
      var M3 = ARRAY16;
      for (var i4 = 0; i4 < 16; ++i4)
        M3[i4] = this._block.readInt32LE(i4 * 4);
      var a3 = this._a;
      var b4 = this._b;
      var c6 = this._c;
      var d4 = this._d;
      a3 = fnF(a3, b4, c6, d4, M3[0], 3614090360, 7);
      d4 = fnF(d4, a3, b4, c6, M3[1], 3905402710, 12);
      c6 = fnF(c6, d4, a3, b4, M3[2], 606105819, 17);
      b4 = fnF(b4, c6, d4, a3, M3[3], 3250441966, 22);
      a3 = fnF(a3, b4, c6, d4, M3[4], 4118548399, 7);
      d4 = fnF(d4, a3, b4, c6, M3[5], 1200080426, 12);
      c6 = fnF(c6, d4, a3, b4, M3[6], 2821735955, 17);
      b4 = fnF(b4, c6, d4, a3, M3[7], 4249261313, 22);
      a3 = fnF(a3, b4, c6, d4, M3[8], 1770035416, 7);
      d4 = fnF(d4, a3, b4, c6, M3[9], 2336552879, 12);
      c6 = fnF(c6, d4, a3, b4, M3[10], 4294925233, 17);
      b4 = fnF(b4, c6, d4, a3, M3[11], 2304563134, 22);
      a3 = fnF(a3, b4, c6, d4, M3[12], 1804603682, 7);
      d4 = fnF(d4, a3, b4, c6, M3[13], 4254626195, 12);
      c6 = fnF(c6, d4, a3, b4, M3[14], 2792965006, 17);
      b4 = fnF(b4, c6, d4, a3, M3[15], 1236535329, 22);
      a3 = fnG(a3, b4, c6, d4, M3[1], 4129170786, 5);
      d4 = fnG(d4, a3, b4, c6, M3[6], 3225465664, 9);
      c6 = fnG(c6, d4, a3, b4, M3[11], 643717713, 14);
      b4 = fnG(b4, c6, d4, a3, M3[0], 3921069994, 20);
      a3 = fnG(a3, b4, c6, d4, M3[5], 3593408605, 5);
      d4 = fnG(d4, a3, b4, c6, M3[10], 38016083, 9);
      c6 = fnG(c6, d4, a3, b4, M3[15], 3634488961, 14);
      b4 = fnG(b4, c6, d4, a3, M3[4], 3889429448, 20);
      a3 = fnG(a3, b4, c6, d4, M3[9], 568446438, 5);
      d4 = fnG(d4, a3, b4, c6, M3[14], 3275163606, 9);
      c6 = fnG(c6, d4, a3, b4, M3[3], 4107603335, 14);
      b4 = fnG(b4, c6, d4, a3, M3[8], 1163531501, 20);
      a3 = fnG(a3, b4, c6, d4, M3[13], 2850285829, 5);
      d4 = fnG(d4, a3, b4, c6, M3[2], 4243563512, 9);
      c6 = fnG(c6, d4, a3, b4, M3[7], 1735328473, 14);
      b4 = fnG(b4, c6, d4, a3, M3[12], 2368359562, 20);
      a3 = fnH(a3, b4, c6, d4, M3[5], 4294588738, 4);
      d4 = fnH(d4, a3, b4, c6, M3[8], 2272392833, 11);
      c6 = fnH(c6, d4, a3, b4, M3[11], 1839030562, 16);
      b4 = fnH(b4, c6, d4, a3, M3[14], 4259657740, 23);
      a3 = fnH(a3, b4, c6, d4, M3[1], 2763975236, 4);
      d4 = fnH(d4, a3, b4, c6, M3[4], 1272893353, 11);
      c6 = fnH(c6, d4, a3, b4, M3[7], 4139469664, 16);
      b4 = fnH(b4, c6, d4, a3, M3[10], 3200236656, 23);
      a3 = fnH(a3, b4, c6, d4, M3[13], 681279174, 4);
      d4 = fnH(d4, a3, b4, c6, M3[0], 3936430074, 11);
      c6 = fnH(c6, d4, a3, b4, M3[3], 3572445317, 16);
      b4 = fnH(b4, c6, d4, a3, M3[6], 76029189, 23);
      a3 = fnH(a3, b4, c6, d4, M3[9], 3654602809, 4);
      d4 = fnH(d4, a3, b4, c6, M3[12], 3873151461, 11);
      c6 = fnH(c6, d4, a3, b4, M3[15], 530742520, 16);
      b4 = fnH(b4, c6, d4, a3, M3[2], 3299628645, 23);
      a3 = fnI(a3, b4, c6, d4, M3[0], 4096336452, 6);
      d4 = fnI(d4, a3, b4, c6, M3[7], 1126891415, 10);
      c6 = fnI(c6, d4, a3, b4, M3[14], 2878612391, 15);
      b4 = fnI(b4, c6, d4, a3, M3[5], 4237533241, 21);
      a3 = fnI(a3, b4, c6, d4, M3[12], 1700485571, 6);
      d4 = fnI(d4, a3, b4, c6, M3[3], 2399980690, 10);
      c6 = fnI(c6, d4, a3, b4, M3[10], 4293915773, 15);
      b4 = fnI(b4, c6, d4, a3, M3[1], 2240044497, 21);
      a3 = fnI(a3, b4, c6, d4, M3[8], 1873313359, 6);
      d4 = fnI(d4, a3, b4, c6, M3[15], 4264355552, 10);
      c6 = fnI(c6, d4, a3, b4, M3[6], 2734768916, 15);
      b4 = fnI(b4, c6, d4, a3, M3[13], 1309151649, 21);
      a3 = fnI(a3, b4, c6, d4, M3[4], 4149444226, 6);
      d4 = fnI(d4, a3, b4, c6, M3[11], 3174756917, 10);
      c6 = fnI(c6, d4, a3, b4, M3[2], 718787259, 15);
      b4 = fnI(b4, c6, d4, a3, M3[9], 3951481745, 21);
      this._a = this._a + a3 | 0;
      this._b = this._b + b4 | 0;
      this._c = this._c + c6 | 0;
      this._d = this._d + d4 | 0;
    };
    MD5.prototype._digest = function() {
      this._block[this._blockOffset++] = 128;
      if (this._blockOffset > 56) {
        this._block.fill(0, this._blockOffset, 64);
        this._update();
        this._blockOffset = 0;
      }
      this._block.fill(0, this._blockOffset, 56);
      this._block.writeUInt32LE(this._length[0], 56);
      this._block.writeUInt32LE(this._length[1], 60);
      this._update();
      var buffer = Buffer2.allocUnsafe(16);
      buffer.writeInt32LE(this._a, 0);
      buffer.writeInt32LE(this._b, 4);
      buffer.writeInt32LE(this._c, 8);
      buffer.writeInt32LE(this._d, 12);
      return buffer;
    };
    function rotl(x4, n5) {
      return x4 << n5 | x4 >>> 32 - n5;
    }
    function fnF(a3, b4, c6, d4, m3, k5, s3) {
      return rotl(a3 + (b4 & c6 | ~b4 & d4) + m3 + k5 | 0, s3) + b4 | 0;
    }
    function fnG(a3, b4, c6, d4, m3, k5, s3) {
      return rotl(a3 + (b4 & d4 | c6 & ~d4) + m3 + k5 | 0, s3) + b4 | 0;
    }
    function fnH(a3, b4, c6, d4, m3, k5, s3) {
      return rotl(a3 + (b4 ^ c6 ^ d4) + m3 + k5 | 0, s3) + b4 | 0;
    }
    function fnI(a3, b4, c6, d4, m3, k5, s3) {
      return rotl(a3 + (c6 ^ (b4 | ~d4)) + m3 + k5 | 0, s3) + b4 | 0;
    }
    module.exports = MD5;
  }
});

// ../../node_modules/.pnpm/ripemd160@2.0.2/node_modules/ripemd160/index.js
var require_ripemd160 = __commonJS({
  "../../node_modules/.pnpm/ripemd160@2.0.2/node_modules/ripemd160/index.js"(exports, module) {
    "use strict";
    var Buffer2 = require_buffer().Buffer;
    var inherits = require_inherits_browser();
    var HashBase = require_hash_base();
    var ARRAY16 = new Array(16);
    var zl = [
      0,
      1,
      2,
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      10,
      11,
      12,
      13,
      14,
      15,
      7,
      4,
      13,
      1,
      10,
      6,
      15,
      3,
      12,
      0,
      9,
      5,
      2,
      14,
      11,
      8,
      3,
      10,
      14,
      4,
      9,
      15,
      8,
      1,
      2,
      7,
      0,
      6,
      13,
      11,
      5,
      12,
      1,
      9,
      11,
      10,
      0,
      8,
      12,
      4,
      13,
      3,
      7,
      15,
      14,
      5,
      6,
      2,
      4,
      0,
      5,
      9,
      7,
      12,
      2,
      10,
      14,
      1,
      3,
      8,
      11,
      6,
      15,
      13
    ];
    var zr2 = [
      5,
      14,
      7,
      0,
      9,
      2,
      11,
      4,
      13,
      6,
      15,
      8,
      1,
      10,
      3,
      12,
      6,
      11,
      3,
      7,
      0,
      13,
      5,
      10,
      14,
      15,
      8,
      12,
      4,
      9,
      1,
      2,
      15,
      5,
      1,
      3,
      7,
      14,
      6,
      9,
      11,
      8,
      12,
      2,
      10,
      0,
      4,
      13,
      8,
      6,
      4,
      1,
      3,
      11,
      15,
      0,
      5,
      12,
      2,
      13,
      9,
      7,
      10,
      14,
      12,
      15,
      10,
      4,
      1,
      5,
      8,
      7,
      6,
      2,
      13,
      14,
      0,
      3,
      9,
      11
    ];
    var sl = [
      11,
      14,
      15,
      12,
      5,
      8,
      7,
      9,
      11,
      13,
      14,
      15,
      6,
      7,
      9,
      8,
      7,
      6,
      8,
      13,
      11,
      9,
      7,
      15,
      7,
      12,
      15,
      9,
      11,
      7,
      13,
      12,
      11,
      13,
      6,
      7,
      14,
      9,
      13,
      15,
      14,
      8,
      13,
      6,
      5,
      12,
      7,
      5,
      11,
      12,
      14,
      15,
      14,
      15,
      9,
      8,
      9,
      14,
      5,
      6,
      8,
      6,
      5,
      12,
      9,
      15,
      5,
      11,
      6,
      8,
      13,
      12,
      5,
      12,
      13,
      14,
      11,
      8,
      5,
      6
    ];
    var sr3 = [
      8,
      9,
      9,
      11,
      13,
      15,
      15,
      5,
      7,
      7,
      8,
      11,
      14,
      14,
      12,
      6,
      9,
      13,
      15,
      7,
      12,
      8,
      9,
      11,
      7,
      7,
      12,
      7,
      6,
      15,
      13,
      11,
      9,
      7,
      15,
      11,
      8,
      6,
      6,
      14,
      12,
      13,
      5,
      14,
      13,
      13,
      7,
      5,
      15,
      5,
      8,
      11,
      14,
      14,
      6,
      14,
      6,
      9,
      12,
      9,
      12,
      5,
      15,
      8,
      8,
      5,
      12,
      9,
      12,
      5,
      14,
      6,
      8,
      13,
      6,
      5,
      15,
      13,
      11,
      11
    ];
    var hl = [0, 1518500249, 1859775393, 2400959708, 2840853838];
    var hr2 = [1352829926, 1548603684, 1836072691, 2053994217, 0];
    function RIPEMD160() {
      HashBase.call(this, 64);
      this._a = 1732584193;
      this._b = 4023233417;
      this._c = 2562383102;
      this._d = 271733878;
      this._e = 3285377520;
    }
    inherits(RIPEMD160, HashBase);
    RIPEMD160.prototype._update = function() {
      var words = ARRAY16;
      for (var j2 = 0; j2 < 16; ++j2)
        words[j2] = this._block.readInt32LE(j2 * 4);
      var al = this._a | 0;
      var bl = this._b | 0;
      var cl = this._c | 0;
      var dl = this._d | 0;
      var el = this._e | 0;
      var ar2 = this._a | 0;
      var br2 = this._b | 0;
      var cr3 = this._c | 0;
      var dr2 = this._d | 0;
      var er = this._e | 0;
      for (var i4 = 0; i4 < 80; i4 += 1) {
        var tl;
        var tr2;
        if (i4 < 16) {
          tl = fn1(al, bl, cl, dl, el, words[zl[i4]], hl[0], sl[i4]);
          tr2 = fn5(ar2, br2, cr3, dr2, er, words[zr2[i4]], hr2[0], sr3[i4]);
        } else if (i4 < 32) {
          tl = fn2(al, bl, cl, dl, el, words[zl[i4]], hl[1], sl[i4]);
          tr2 = fn4(ar2, br2, cr3, dr2, er, words[zr2[i4]], hr2[1], sr3[i4]);
        } else if (i4 < 48) {
          tl = fn3(al, bl, cl, dl, el, words[zl[i4]], hl[2], sl[i4]);
          tr2 = fn3(ar2, br2, cr3, dr2, er, words[zr2[i4]], hr2[2], sr3[i4]);
        } else if (i4 < 64) {
          tl = fn4(al, bl, cl, dl, el, words[zl[i4]], hl[3], sl[i4]);
          tr2 = fn2(ar2, br2, cr3, dr2, er, words[zr2[i4]], hr2[3], sr3[i4]);
        } else {
          tl = fn5(al, bl, cl, dl, el, words[zl[i4]], hl[4], sl[i4]);
          tr2 = fn1(ar2, br2, cr3, dr2, er, words[zr2[i4]], hr2[4], sr3[i4]);
        }
        al = el;
        el = dl;
        dl = rotl(cl, 10);
        cl = bl;
        bl = tl;
        ar2 = er;
        er = dr2;
        dr2 = rotl(cr3, 10);
        cr3 = br2;
        br2 = tr2;
      }
      var t = this._b + cl + dr2 | 0;
      this._b = this._c + dl + er | 0;
      this._c = this._d + el + ar2 | 0;
      this._d = this._e + al + br2 | 0;
      this._e = this._a + bl + cr3 | 0;
      this._a = t;
    };
    RIPEMD160.prototype._digest = function() {
      this._block[this._blockOffset++] = 128;
      if (this._blockOffset > 56) {
        this._block.fill(0, this._blockOffset, 64);
        this._update();
        this._blockOffset = 0;
      }
      this._block.fill(0, this._blockOffset, 56);
      this._block.writeUInt32LE(this._length[0], 56);
      this._block.writeUInt32LE(this._length[1], 60);
      this._update();
      var buffer = Buffer2.alloc ? Buffer2.alloc(20) : new Buffer2(20);
      buffer.writeInt32LE(this._a, 0);
      buffer.writeInt32LE(this._b, 4);
      buffer.writeInt32LE(this._c, 8);
      buffer.writeInt32LE(this._d, 12);
      buffer.writeInt32LE(this._e, 16);
      return buffer;
    };
    function rotl(x4, n5) {
      return x4 << n5 | x4 >>> 32 - n5;
    }
    function fn1(a3, b4, c6, d4, e2, m3, k5, s3) {
      return rotl(a3 + (b4 ^ c6 ^ d4) + m3 + k5 | 0, s3) + e2 | 0;
    }
    function fn2(a3, b4, c6, d4, e2, m3, k5, s3) {
      return rotl(a3 + (b4 & c6 | ~b4 & d4) + m3 + k5 | 0, s3) + e2 | 0;
    }
    function fn3(a3, b4, c6, d4, e2, m3, k5, s3) {
      return rotl(a3 + ((b4 | ~c6) ^ d4) + m3 + k5 | 0, s3) + e2 | 0;
    }
    function fn4(a3, b4, c6, d4, e2, m3, k5, s3) {
      return rotl(a3 + (b4 & d4 | c6 & ~d4) + m3 + k5 | 0, s3) + e2 | 0;
    }
    function fn5(a3, b4, c6, d4, e2, m3, k5, s3) {
      return rotl(a3 + (b4 ^ (c6 | ~d4)) + m3 + k5 | 0, s3) + e2 | 0;
    }
    module.exports = RIPEMD160;
  }
});

// browser-external:stream
var require_stream = __commonJS({
  "browser-external:stream"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_16, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "stream" has been externalized for browser compatibility. Cannot access "stream.${key}" in client code. See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// ../../node_modules/.pnpm/cipher-base@1.0.6/node_modules/cipher-base/index.js
var require_cipher_base = __commonJS({
  "../../node_modules/.pnpm/cipher-base@1.0.6/node_modules/cipher-base/index.js"(exports, module) {
    "use strict";
    var Buffer2 = require_safe_buffer().Buffer;
    var Transform = require_stream().Transform;
    var StringDecoder = require_string_decoder().StringDecoder;
    var inherits = require_inherits_browser();
    function CipherBase(hashMode) {
      Transform.call(this);
      this.hashMode = typeof hashMode === "string";
      if (this.hashMode) {
        this[hashMode] = this._finalOrDigest;
      } else {
        this["final"] = this._finalOrDigest;
      }
      if (this._final) {
        this.__final = this._final;
        this._final = null;
      }
      this._decoder = null;
      this._encoding = null;
    }
    inherits(CipherBase, Transform);
    var useUint8Array = typeof Uint8Array !== "undefined";
    var useArrayBuffer = typeof ArrayBuffer !== "undefined" && typeof Uint8Array !== "undefined" && ArrayBuffer.isView && (Buffer2.prototype instanceof Uint8Array || Buffer2.TYPED_ARRAY_SUPPORT);
    function toBuffer(data, encoding) {
      if (data instanceof Buffer2) {
        return data;
      }
      if (typeof data === "string") {
        return Buffer2.from(data, encoding);
      }
      if (useArrayBuffer && ArrayBuffer.isView(data)) {
        if (data.byteLength === 0) {
          return Buffer2.alloc(0);
        }
        var res = Buffer2.from(data.buffer, data.byteOffset, data.byteLength);
        if (res.byteLength === data.byteLength) {
          return res;
        }
      }
      if (useUint8Array && data instanceof Uint8Array) {
        return Buffer2.from(data);
      }
      if (Buffer2.isBuffer(data) && data.constructor && typeof data.constructor.isBuffer === "function" && data.constructor.isBuffer(data)) {
        return Buffer2.from(data);
      }
      throw new TypeError('The "data" argument must be of type string or an instance of Buffer, TypedArray, or DataView.');
    }
    CipherBase.prototype.update = function(data, inputEnc, outputEnc) {
      var bufferData = toBuffer(data, inputEnc);
      var outData = this._update(bufferData);
      if (this.hashMode) {
        return this;
      }
      if (outputEnc) {
        outData = this._toString(outData, outputEnc);
      }
      return outData;
    };
    CipherBase.prototype.setAutoPadding = function() {
    };
    CipherBase.prototype.getAuthTag = function() {
      throw new Error("trying to get auth tag in unsupported state");
    };
    CipherBase.prototype.setAuthTag = function() {
      throw new Error("trying to set auth tag in unsupported state");
    };
    CipherBase.prototype.setAAD = function() {
      throw new Error("trying to set aad in unsupported state");
    };
    CipherBase.prototype._transform = function(data, _16, next) {
      var err;
      try {
        if (this.hashMode) {
          this._update(data);
        } else {
          this.push(this._update(data));
        }
      } catch (e2) {
        err = e2;
      } finally {
        next(err);
      }
    };
    CipherBase.prototype._flush = function(done) {
      var err;
      try {
        this.push(this.__final());
      } catch (e2) {
        err = e2;
      }
      done(err);
    };
    CipherBase.prototype._finalOrDigest = function(outputEnc) {
      var outData = this.__final() || Buffer2.alloc(0);
      if (outputEnc) {
        outData = this._toString(outData, outputEnc, true);
      }
      return outData;
    };
    CipherBase.prototype._toString = function(value, enc, fin) {
      if (!this._decoder) {
        this._decoder = new StringDecoder(enc);
        this._encoding = enc;
      }
      if (this._encoding !== enc) {
        throw new Error("cant switch encodings");
      }
      var out = this._decoder.write(value);
      if (fin) {
        out += this._decoder.end();
      }
      return out;
    };
    module.exports = CipherBase;
  }
});

// ../../node_modules/.pnpm/create-hash@1.2.0/node_modules/create-hash/browser.js
var require_browser2 = __commonJS({
  "../../node_modules/.pnpm/create-hash@1.2.0/node_modules/create-hash/browser.js"(exports, module) {
    "use strict";
    var inherits = require_inherits_browser();
    var MD5 = require_md5();
    var RIPEMD160 = require_ripemd160();
    var sha = require_sha();
    var Base = require_cipher_base();
    function Hash(hash) {
      Base.call(this, "digest");
      this._hash = hash;
    }
    inherits(Hash, Base);
    Hash.prototype._update = function(data) {
      this._hash.update(data);
    };
    Hash.prototype._final = function() {
      return this._hash.digest();
    };
    module.exports = function createHash(alg) {
      alg = alg.toLowerCase();
      if (alg === "md5")
        return new MD5();
      if (alg === "rmd160" || alg === "ripemd160")
        return new RIPEMD160();
      return new Hash(sha(alg));
    };
  }
});

// ../../node_modules/.pnpm/create-hmac@1.1.7/node_modules/create-hmac/legacy.js
var require_legacy = __commonJS({
  "../../node_modules/.pnpm/create-hmac@1.1.7/node_modules/create-hmac/legacy.js"(exports, module) {
    "use strict";
    var inherits = require_inherits_browser();
    var Buffer2 = require_safe_buffer().Buffer;
    var Base = require_cipher_base();
    var ZEROS = Buffer2.alloc(128);
    var blocksize = 64;
    function Hmac(alg, key) {
      Base.call(this, "digest");
      if (typeof key === "string") {
        key = Buffer2.from(key);
      }
      this._alg = alg;
      this._key = key;
      if (key.length > blocksize) {
        key = alg(key);
      } else if (key.length < blocksize) {
        key = Buffer2.concat([key, ZEROS], blocksize);
      }
      var ipad = this._ipad = Buffer2.allocUnsafe(blocksize);
      var opad = this._opad = Buffer2.allocUnsafe(blocksize);
      for (var i4 = 0; i4 < blocksize; i4++) {
        ipad[i4] = key[i4] ^ 54;
        opad[i4] = key[i4] ^ 92;
      }
      this._hash = [ipad];
    }
    inherits(Hmac, Base);
    Hmac.prototype._update = function(data) {
      this._hash.push(data);
    };
    Hmac.prototype._final = function() {
      var h5 = this._alg(Buffer2.concat(this._hash));
      return this._alg(Buffer2.concat([this._opad, h5]));
    };
    module.exports = Hmac;
  }
});

// ../../node_modules/.pnpm/create-hash@1.2.0/node_modules/create-hash/md5.js
var require_md52 = __commonJS({
  "../../node_modules/.pnpm/create-hash@1.2.0/node_modules/create-hash/md5.js"(exports, module) {
    var MD5 = require_md5();
    module.exports = function(buffer) {
      return new MD5().update(buffer).digest();
    };
  }
});

// ../../node_modules/.pnpm/create-hmac@1.1.7/node_modules/create-hmac/browser.js
var require_browser3 = __commonJS({
  "../../node_modules/.pnpm/create-hmac@1.1.7/node_modules/create-hmac/browser.js"(exports, module) {
    "use strict";
    var inherits = require_inherits_browser();
    var Legacy = require_legacy();
    var Base = require_cipher_base();
    var Buffer2 = require_safe_buffer().Buffer;
    var md5 = require_md52();
    var RIPEMD160 = require_ripemd160();
    var sha = require_sha();
    var ZEROS = Buffer2.alloc(128);
    function Hmac(alg, key) {
      Base.call(this, "digest");
      if (typeof key === "string") {
        key = Buffer2.from(key);
      }
      var blocksize = alg === "sha512" || alg === "sha384" ? 128 : 64;
      this._alg = alg;
      this._key = key;
      if (key.length > blocksize) {
        var hash = alg === "rmd160" ? new RIPEMD160() : sha(alg);
        key = hash.update(key).digest();
      } else if (key.length < blocksize) {
        key = Buffer2.concat([key, ZEROS], blocksize);
      }
      var ipad = this._ipad = Buffer2.allocUnsafe(blocksize);
      var opad = this._opad = Buffer2.allocUnsafe(blocksize);
      for (var i4 = 0; i4 < blocksize; i4++) {
        ipad[i4] = key[i4] ^ 54;
        opad[i4] = key[i4] ^ 92;
      }
      this._hash = alg === "rmd160" ? new RIPEMD160() : sha(alg);
      this._hash.update(ipad);
    }
    inherits(Hmac, Base);
    Hmac.prototype._update = function(data) {
      this._hash.update(data);
    };
    Hmac.prototype._final = function() {
      var h5 = this._hash.digest();
      var hash = this._alg === "rmd160" ? new RIPEMD160() : sha(this._alg);
      return hash.update(this._opad).update(h5).digest();
    };
    module.exports = function createHmac(alg, key) {
      alg = alg.toLowerCase();
      if (alg === "rmd160" || alg === "ripemd160") {
        return new Hmac("rmd160", key);
      }
      if (alg === "md5") {
        return new Legacy(md5, key);
      }
      return new Hmac(alg, key);
    };
  }
});

// ../../node_modules/.pnpm/bip32@2.0.6/node_modules/bip32/src/crypto.js
var require_crypto2 = __commonJS({
  "../../node_modules/.pnpm/bip32@2.0.6/node_modules/bip32/src/crypto.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var createHash = require_browser2();
    var createHmac = require_browser3();
    function hash160(buffer) {
      const sha256Hash = createHash("sha256").update(buffer).digest();
      try {
        return createHash("rmd160").update(sha256Hash).digest();
      } catch (err) {
        return createHash("ripemd160").update(sha256Hash).digest();
      }
    }
    exports.hash160 = hash160;
    function hmacSHA512(key, data) {
      return createHmac("sha512", key).update(data).digest();
    }
    exports.hmacSHA512 = hmacSHA512;
  }
});

// ../../node_modules/.pnpm/base-x@3.0.11/node_modules/base-x/src/index.js
var require_src2 = __commonJS({
  "../../node_modules/.pnpm/base-x@3.0.11/node_modules/base-x/src/index.js"(exports, module) {
    "use strict";
    var _Buffer = require_safe_buffer().Buffer;
    function base(ALPHABET) {
      if (ALPHABET.length >= 255) {
        throw new TypeError("Alphabet too long");
      }
      var BASE_MAP = new Uint8Array(256);
      for (var j2 = 0; j2 < BASE_MAP.length; j2++) {
        BASE_MAP[j2] = 255;
      }
      for (var i4 = 0; i4 < ALPHABET.length; i4++) {
        var x4 = ALPHABET.charAt(i4);
        var xc = x4.charCodeAt(0);
        if (BASE_MAP[xc] !== 255) {
          throw new TypeError(x4 + " is ambiguous");
        }
        BASE_MAP[xc] = i4;
      }
      var BASE = ALPHABET.length;
      var LEADER = ALPHABET.charAt(0);
      var FACTOR = Math.log(BASE) / Math.log(256);
      var iFACTOR = Math.log(256) / Math.log(BASE);
      function encode2(source) {
        if (Array.isArray(source) || source instanceof Uint8Array) {
          source = _Buffer.from(source);
        }
        if (!_Buffer.isBuffer(source)) {
          throw new TypeError("Expected Buffer");
        }
        if (source.length === 0) {
          return "";
        }
        var zeroes = 0;
        var length = 0;
        var pbegin = 0;
        var pend = source.length;
        while (pbegin !== pend && source[pbegin] === 0) {
          pbegin++;
          zeroes++;
        }
        var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
        var b58 = new Uint8Array(size);
        while (pbegin !== pend) {
          var carry = source[pbegin];
          var i5 = 0;
          for (var it1 = size - 1; (carry !== 0 || i5 < length) && it1 !== -1; it1--, i5++) {
            carry += 256 * b58[it1] >>> 0;
            b58[it1] = carry % BASE >>> 0;
            carry = carry / BASE >>> 0;
          }
          if (carry !== 0) {
            throw new Error("Non-zero carry");
          }
          length = i5;
          pbegin++;
        }
        var it22 = size - length;
        while (it22 !== size && b58[it22] === 0) {
          it22++;
        }
        var str = LEADER.repeat(zeroes);
        for (; it22 < size; ++it22) {
          str += ALPHABET.charAt(b58[it22]);
        }
        return str;
      }
      function decodeUnsafe(source) {
        if (typeof source !== "string") {
          throw new TypeError("Expected String");
        }
        if (source.length === 0) {
          return _Buffer.alloc(0);
        }
        var psz = 0;
        var zeroes = 0;
        var length = 0;
        while (source[psz] === LEADER) {
          zeroes++;
          psz++;
        }
        var size = (source.length - psz) * FACTOR + 1 >>> 0;
        var b256 = new Uint8Array(size);
        while (psz < source.length) {
          var charCode = source.charCodeAt(psz);
          if (charCode > 255) {
            return;
          }
          var carry = BASE_MAP[charCode];
          if (carry === 255) {
            return;
          }
          var i5 = 0;
          for (var it3 = size - 1; (carry !== 0 || i5 < length) && it3 !== -1; it3--, i5++) {
            carry += BASE * b256[it3] >>> 0;
            b256[it3] = carry % 256 >>> 0;
            carry = carry / 256 >>> 0;
          }
          if (carry !== 0) {
            throw new Error("Non-zero carry");
          }
          length = i5;
          psz++;
        }
        var it4 = size - length;
        while (it4 !== size && b256[it4] === 0) {
          it4++;
        }
        var vch = _Buffer.allocUnsafe(zeroes + (size - it4));
        vch.fill(0, 0, zeroes);
        var j3 = zeroes;
        while (it4 !== size) {
          vch[j3++] = b256[it4++];
        }
        return vch;
      }
      function decode(string) {
        var buffer = decodeUnsafe(string);
        if (buffer) {
          return buffer;
        }
        throw new Error("Non-base" + BASE + " character");
      }
      return {
        encode: encode2,
        decodeUnsafe,
        decode
      };
    }
    module.exports = base;
  }
});

// ../../node_modules/.pnpm/bs58@4.0.1/node_modules/bs58/index.js
var require_bs58 = __commonJS({
  "../../node_modules/.pnpm/bs58@4.0.1/node_modules/bs58/index.js"(exports, module) {
    var basex = require_src2();
    var ALPHABET = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
    module.exports = basex(ALPHABET);
  }
});

// ../../node_modules/.pnpm/bs58check@2.1.2/node_modules/bs58check/base.js
var require_base2 = __commonJS({
  "../../node_modules/.pnpm/bs58check@2.1.2/node_modules/bs58check/base.js"(exports, module) {
    "use strict";
    var base58 = require_bs58();
    var Buffer2 = require_safe_buffer().Buffer;
    module.exports = function(checksumFn) {
      function encode2(payload) {
        var checksum = checksumFn(payload);
        return base58.encode(Buffer2.concat([
          payload,
          checksum
        ], payload.length + 4));
      }
      function decodeRaw(buffer) {
        var payload = buffer.slice(0, -4);
        var checksum = buffer.slice(-4);
        var newChecksum = checksumFn(payload);
        if (checksum[0] ^ newChecksum[0] | checksum[1] ^ newChecksum[1] | checksum[2] ^ newChecksum[2] | checksum[3] ^ newChecksum[3])
          return;
        return payload;
      }
      function decodeUnsafe(string) {
        var buffer = base58.decodeUnsafe(string);
        if (!buffer)
          return;
        return decodeRaw(buffer);
      }
      function decode(string) {
        var buffer = base58.decode(string);
        var payload = decodeRaw(buffer, checksumFn);
        if (!payload)
          throw new Error("Invalid checksum");
        return payload;
      }
      return {
        encode: encode2,
        decode,
        decodeUnsafe
      };
    };
  }
});

// ../../node_modules/.pnpm/bs58check@2.1.2/node_modules/bs58check/index.js
var require_bs58check = __commonJS({
  "../../node_modules/.pnpm/bs58check@2.1.2/node_modules/bs58check/index.js"(exports, module) {
    "use strict";
    var createHash = require_browser2();
    var bs58checkBase = require_base2();
    function sha256x2(buffer) {
      var tmp = createHash("sha256").update(buffer).digest();
      return createHash("sha256").update(tmp).digest();
    }
    module.exports = bs58checkBase(sha256x2);
  }
});

// ../../node_modules/.pnpm/tiny-secp256k1@1.1.7/node_modules/tiny-secp256k1/rfc6979.js
var require_rfc6979 = __commonJS({
  "../../node_modules/.pnpm/tiny-secp256k1@1.1.7/node_modules/tiny-secp256k1/rfc6979.js"(exports, module) {
    var createHmac = require_browser3();
    var ONE1 = Buffer.alloc(1, 1);
    var ZERO1 = Buffer.alloc(1, 0);
    function deterministicGenerateK(hash, x4, checkSig, isPrivate, extraEntropy) {
      let k5 = Buffer.alloc(32, 0);
      let v5 = Buffer.alloc(32, 1);
      k5 = createHmac("sha256", k5).update(v5).update(ZERO1).update(x4).update(hash).update(extraEntropy || "").digest();
      v5 = createHmac("sha256", k5).update(v5).digest();
      k5 = createHmac("sha256", k5).update(v5).update(ONE1).update(x4).update(hash).update(extraEntropy || "").digest();
      v5 = createHmac("sha256", k5).update(v5).digest();
      v5 = createHmac("sha256", k5).update(v5).digest();
      let T3 = v5;
      while (!isPrivate(T3) || !checkSig(T3)) {
        k5 = createHmac("sha256", k5).update(v5).update(ZERO1).digest();
        v5 = createHmac("sha256", k5).update(v5).digest();
        v5 = createHmac("sha256", k5).update(v5).digest();
        T3 = v5;
      }
      return T3;
    }
    module.exports = deterministicGenerateK;
  }
});

// ../../node_modules/.pnpm/tiny-secp256k1@1.1.7/node_modules/tiny-secp256k1/js.js
var require_js = __commonJS({
  "../../node_modules/.pnpm/tiny-secp256k1@1.1.7/node_modules/tiny-secp256k1/js.js"(exports, module) {
    var BN2 = require_bn2();
    var EC = require_elliptic().ec;
    var secp256k1 = new EC("secp256k1");
    var deterministicGenerateK = require_rfc6979();
    var ZERO32 = Buffer.alloc(32, 0);
    var EC_GROUP_ORDER = Buffer.from("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141", "hex");
    var EC_P = Buffer.from("fffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f", "hex");
    var n5 = secp256k1.curve.n;
    var nDiv2 = n5.shrn(1);
    var G2 = secp256k1.curve.g;
    var THROW_BAD_PRIVATE = "Expected Private";
    var THROW_BAD_POINT = "Expected Point";
    var THROW_BAD_TWEAK = "Expected Tweak";
    var THROW_BAD_HASH = "Expected Hash";
    var THROW_BAD_SIGNATURE = "Expected Signature";
    var THROW_BAD_EXTRA_DATA = "Expected Extra Data (32 bytes)";
    function isScalar(x4) {
      return x4 instanceof Uint8Array && x4.length === 32;
    }
    function isOrderScalar(x4) {
      if (!isScalar(x4))
        return false;
      return EC_GROUP_ORDER.compare(x4) > 0;
    }
    function isPoint(p4) {
      if (!(p4 instanceof Uint8Array))
        return false;
      if (p4.length < 33)
        return false;
      const t = p4[0];
      const x4 = p4.subarray(1, 33);
      if (ZERO32.compare(x4) === 0)
        return false;
      if (EC_P.compare(x4) <= 0)
        return false;
      if ((t === 2 || t === 3) && p4.length === 33) {
        try {
          decodeFrom(p4);
        } catch (e2) {
          return false;
        }
        return true;
      }
      const y5 = p4.subarray(33);
      if (ZERO32.compare(y5) === 0)
        return false;
      if (EC_P.compare(y5) <= 0)
        return false;
      if (t === 4 && p4.length === 65)
        return true;
      return false;
    }
    function __isPointCompressed(p4) {
      return p4[0] !== 4;
    }
    function isPointCompressed(p4) {
      if (!isPoint(p4))
        return false;
      return __isPointCompressed(p4);
    }
    function isPrivate(x4) {
      if (!isScalar(x4))
        return false;
      return ZERO32.compare(x4) < 0 && // > 0
      EC_GROUP_ORDER.compare(x4) > 0;
    }
    function isSignature(value) {
      const r3 = value.subarray(0, 32);
      const s3 = value.subarray(32, 64);
      return value instanceof Uint8Array && value.length === 64 && EC_GROUP_ORDER.compare(r3) > 0 && EC_GROUP_ORDER.compare(s3) > 0;
    }
    function assumeCompression(value, pubkey) {
      if (value === void 0 && pubkey !== void 0)
        return __isPointCompressed(pubkey);
      if (value === void 0)
        return true;
      return value;
    }
    function fromBuffer(d4) {
      return new BN2(d4);
    }
    function toBuffer(d4) {
      return d4.toArrayLike(Buffer, "be", 32);
    }
    function decodeFrom(P3) {
      return secp256k1.curve.decodePoint(P3);
    }
    function getEncoded(P3, compressed) {
      return Buffer.from(P3._encode(compressed));
    }
    function pointAdd(pA, pB, __compressed) {
      if (!isPoint(pA))
        throw new TypeError(THROW_BAD_POINT);
      if (!isPoint(pB))
        throw new TypeError(THROW_BAD_POINT);
      const a3 = decodeFrom(pA);
      const b4 = decodeFrom(pB);
      const pp = a3.add(b4);
      if (pp.isInfinity())
        return null;
      const compressed = assumeCompression(__compressed, pA);
      return getEncoded(pp, compressed);
    }
    function pointAddScalar(p4, tweak, __compressed) {
      if (!isPoint(p4))
        throw new TypeError(THROW_BAD_POINT);
      if (!isOrderScalar(tweak))
        throw new TypeError(THROW_BAD_TWEAK);
      const compressed = assumeCompression(__compressed, p4);
      const pp = decodeFrom(p4);
      if (ZERO32.compare(tweak) === 0)
        return getEncoded(pp, compressed);
      const tt3 = fromBuffer(tweak);
      const qq = G2.mul(tt3);
      const uu = pp.add(qq);
      if (uu.isInfinity())
        return null;
      return getEncoded(uu, compressed);
    }
    function pointCompress(p4, __compressed) {
      if (!isPoint(p4))
        throw new TypeError(THROW_BAD_POINT);
      const pp = decodeFrom(p4);
      if (pp.isInfinity())
        throw new TypeError(THROW_BAD_POINT);
      const compressed = assumeCompression(__compressed, p4);
      return getEncoded(pp, compressed);
    }
    function pointFromScalar(d4, __compressed) {
      if (!isPrivate(d4))
        throw new TypeError(THROW_BAD_PRIVATE);
      const dd = fromBuffer(d4);
      const pp = G2.mul(dd);
      if (pp.isInfinity())
        return null;
      const compressed = assumeCompression(__compressed);
      return getEncoded(pp, compressed);
    }
    function pointMultiply(p4, tweak, __compressed) {
      if (!isPoint(p4))
        throw new TypeError(THROW_BAD_POINT);
      if (!isOrderScalar(tweak))
        throw new TypeError(THROW_BAD_TWEAK);
      const compressed = assumeCompression(__compressed, p4);
      const pp = decodeFrom(p4);
      const tt3 = fromBuffer(tweak);
      const qq = pp.mul(tt3);
      if (qq.isInfinity())
        return null;
      return getEncoded(qq, compressed);
    }
    function privateAdd(d4, tweak) {
      if (!isPrivate(d4))
        throw new TypeError(THROW_BAD_PRIVATE);
      if (!isOrderScalar(tweak))
        throw new TypeError(THROW_BAD_TWEAK);
      const dd = fromBuffer(d4);
      const tt3 = fromBuffer(tweak);
      const dt2 = toBuffer(dd.add(tt3).umod(n5));
      if (!isPrivate(dt2))
        return null;
      return dt2;
    }
    function privateSub(d4, tweak) {
      if (!isPrivate(d4))
        throw new TypeError(THROW_BAD_PRIVATE);
      if (!isOrderScalar(tweak))
        throw new TypeError(THROW_BAD_TWEAK);
      const dd = fromBuffer(d4);
      const tt3 = fromBuffer(tweak);
      const dt2 = toBuffer(dd.sub(tt3).umod(n5));
      if (!isPrivate(dt2))
        return null;
      return dt2;
    }
    function sign(hash, x4) {
      return __sign(hash, x4);
    }
    function signWithEntropy(hash, x4, addData) {
      return __sign(hash, x4, addData);
    }
    function __sign(hash, x4, addData) {
      if (!isScalar(hash))
        throw new TypeError(THROW_BAD_HASH);
      if (!isPrivate(x4))
        throw new TypeError(THROW_BAD_PRIVATE);
      if (addData !== void 0 && !isScalar(addData))
        throw new TypeError(THROW_BAD_EXTRA_DATA);
      const d4 = fromBuffer(x4);
      const e2 = fromBuffer(hash);
      let r3, s3;
      const checkSig = function(k5) {
        const kI = fromBuffer(k5);
        const Q2 = G2.mul(kI);
        if (Q2.isInfinity())
          return false;
        r3 = Q2.x.umod(n5);
        if (r3.isZero() === 0)
          return false;
        s3 = kI.invm(n5).mul(e2.add(d4.mul(r3))).umod(n5);
        if (s3.isZero() === 0)
          return false;
        return true;
      };
      deterministicGenerateK(hash, x4, checkSig, isPrivate, addData);
      if (s3.cmp(nDiv2) > 0) {
        s3 = n5.sub(s3);
      }
      const buffer = Buffer.allocUnsafe(64);
      toBuffer(r3).copy(buffer, 0);
      toBuffer(s3).copy(buffer, 32);
      return buffer;
    }
    function verify(hash, q, signature, strict) {
      if (!isScalar(hash))
        throw new TypeError(THROW_BAD_HASH);
      if (!isPoint(q))
        throw new TypeError(THROW_BAD_POINT);
      if (!isSignature(signature))
        throw new TypeError(THROW_BAD_SIGNATURE);
      const Q2 = decodeFrom(q);
      const r3 = fromBuffer(signature.subarray(0, 32));
      const s3 = fromBuffer(signature.subarray(32, 64));
      if (strict && s3.cmp(nDiv2) > 0) {
        return false;
      }
      if (r3.gtn(0) <= 0)
        return false;
      if (s3.gtn(0) <= 0)
        return false;
      const e2 = fromBuffer(hash);
      const sInv = s3.invm(n5);
      const u1 = e2.mul(sInv).umod(n5);
      const u2 = r3.mul(sInv).umod(n5);
      const R3 = G2.mulAdd(u1, Q2, u2);
      if (R3.isInfinity())
        return false;
      const xR = R3.x;
      const v5 = xR.umod(n5);
      return v5.eq(r3);
    }
    module.exports = {
      isPoint,
      isPointCompressed,
      isPrivate,
      pointAdd,
      pointAddScalar,
      pointCompress,
      pointFromScalar,
      pointMultiply,
      privateAdd,
      privateSub,
      sign,
      signWithEntropy,
      verify
    };
  }
});

// ../../node_modules/.pnpm/typeforce@1.18.0/node_modules/typeforce/native.js
var require_native = __commonJS({
  "../../node_modules/.pnpm/typeforce@1.18.0/node_modules/typeforce/native.js"(exports, module) {
    var types = {
      Array: function(value) {
        return value !== null && value !== void 0 && value.constructor === Array;
      },
      Boolean: function(value) {
        return typeof value === "boolean";
      },
      Function: function(value) {
        return typeof value === "function";
      },
      Nil: function(value) {
        return value === void 0 || value === null;
      },
      Number: function(value) {
        return typeof value === "number";
      },
      Object: function(value) {
        return typeof value === "object";
      },
      String: function(value) {
        return typeof value === "string";
      },
      "": function() {
        return true;
      }
    };
    types.Null = types.Nil;
    for (typeName in types) {
      types[typeName].toJSON = (function(t) {
        return t;
      }).bind(null, typeName);
    }
    var typeName;
    module.exports = types;
  }
});

// ../../node_modules/.pnpm/typeforce@1.18.0/node_modules/typeforce/errors.js
var require_errors = __commonJS({
  "../../node_modules/.pnpm/typeforce@1.18.0/node_modules/typeforce/errors.js"(exports, module) {
    var native = require_native();
    function getTypeName(fn2) {
      return fn2.name || fn2.toString().match(/function (.*?)\s*\(/)[1];
    }
    function getValueTypeName(value) {
      return native.Nil(value) ? "" : getTypeName(value.constructor);
    }
    function getValue(value) {
      if (native.Function(value))
        return "";
      if (native.String(value))
        return JSON.stringify(value);
      if (value && native.Object(value))
        return "";
      return value;
    }
    function captureStackTrace(e2, t) {
      if (Error.captureStackTrace) {
        Error.captureStackTrace(e2, t);
      }
    }
    function tfJSON(type) {
      if (native.Function(type))
        return type.toJSON ? type.toJSON() : getTypeName(type);
      if (native.Array(type))
        return "Array";
      if (type && native.Object(type))
        return "Object";
      return type !== void 0 ? type : "";
    }
    function tfErrorString(type, value, valueTypeName) {
      var valueJson = getValue(value);
      return "Expected " + tfJSON(type) + ", got" + (valueTypeName !== "" ? " " + valueTypeName : "") + (valueJson !== "" ? " " + valueJson : "");
    }
    function TfTypeError(type, value, valueTypeName) {
      valueTypeName = valueTypeName || getValueTypeName(value);
      this.message = tfErrorString(type, value, valueTypeName);
      captureStackTrace(this, TfTypeError);
      this.__type = type;
      this.__value = value;
      this.__valueTypeName = valueTypeName;
    }
    TfTypeError.prototype = Object.create(Error.prototype);
    TfTypeError.prototype.constructor = TfTypeError;
    function tfPropertyErrorString(type, label, name, value, valueTypeName) {
      var description = '" of type ';
      if (label === "key")
        description = '" with key type ';
      return tfErrorString('property "' + tfJSON(name) + description + tfJSON(type), value, valueTypeName);
    }
    function TfPropertyTypeError(type, property, label, value, valueTypeName) {
      if (type) {
        valueTypeName = valueTypeName || getValueTypeName(value);
        this.message = tfPropertyErrorString(type, label, property, value, valueTypeName);
      } else {
        this.message = 'Unexpected property "' + property + '"';
      }
      captureStackTrace(this, TfTypeError);
      this.__label = label;
      this.__property = property;
      this.__type = type;
      this.__value = value;
      this.__valueTypeName = valueTypeName;
    }
    TfPropertyTypeError.prototype = Object.create(Error.prototype);
    TfPropertyTypeError.prototype.constructor = TfTypeError;
    function tfCustomError(expected, actual) {
      return new TfTypeError(expected, {}, actual);
    }
    function tfSubError(e2, property, label) {
      if (e2 instanceof TfPropertyTypeError) {
        property = property + "." + e2.__property;
        e2 = new TfPropertyTypeError(
          e2.__type,
          property,
          e2.__label,
          e2.__value,
          e2.__valueTypeName
        );
      } else if (e2 instanceof TfTypeError) {
        e2 = new TfPropertyTypeError(
          e2.__type,
          property,
          label,
          e2.__value,
          e2.__valueTypeName
        );
      }
      captureStackTrace(e2);
      return e2;
    }
    module.exports = {
      TfTypeError,
      TfPropertyTypeError,
      tfCustomError,
      tfSubError,
      tfJSON,
      getValueTypeName
    };
  }
});

// ../../node_modules/.pnpm/typeforce@1.18.0/node_modules/typeforce/extra.js
var require_extra = __commonJS({
  "../../node_modules/.pnpm/typeforce@1.18.0/node_modules/typeforce/extra.js"(exports, module) {
    var NATIVE = require_native();
    var ERRORS = require_errors();
    function _Buffer(value) {
      return Buffer.isBuffer(value);
    }
    function Hex(value) {
      return typeof value === "string" && /^([0-9a-f]{2})+$/i.test(value);
    }
    function _LengthN(type, length) {
      var name = type.toJSON();
      function Length(value) {
        if (!type(value))
          return false;
        if (value.length === length)
          return true;
        throw ERRORS.tfCustomError(name + "(Length: " + length + ")", name + "(Length: " + value.length + ")");
      }
      Length.toJSON = function() {
        return name;
      };
      return Length;
    }
    var _ArrayN = _LengthN.bind(null, NATIVE.Array);
    var _BufferN = _LengthN.bind(null, _Buffer);
    var _HexN = _LengthN.bind(null, Hex);
    var _StringN = _LengthN.bind(null, NATIVE.String);
    function Range(a3, b4, f6) {
      f6 = f6 || NATIVE.Number;
      function _range(value, strict) {
        return f6(value, strict) && value > a3 && value < b4;
      }
      _range.toJSON = function() {
        return `${f6.toJSON()} between [${a3}, ${b4}]`;
      };
      return _range;
    }
    var INT53_MAX = Math.pow(2, 53) - 1;
    function Finite(value) {
      return typeof value === "number" && isFinite(value);
    }
    function Int8(value) {
      return value << 24 >> 24 === value;
    }
    function Int16(value) {
      return value << 16 >> 16 === value;
    }
    function Int32(value) {
      return (value | 0) === value;
    }
    function Int53(value) {
      return typeof value === "number" && value >= -INT53_MAX && value <= INT53_MAX && Math.floor(value) === value;
    }
    function UInt8(value) {
      return (value & 255) === value;
    }
    function UInt16(value) {
      return (value & 65535) === value;
    }
    function UInt32(value) {
      return value >>> 0 === value;
    }
    function UInt53(value) {
      return typeof value === "number" && value >= 0 && value <= INT53_MAX && Math.floor(value) === value;
    }
    var types = {
      ArrayN: _ArrayN,
      Buffer: _Buffer,
      BufferN: _BufferN,
      Finite,
      Hex,
      HexN: _HexN,
      Int8,
      Int16,
      Int32,
      Int53,
      Range,
      StringN: _StringN,
      UInt8,
      UInt16,
      UInt32,
      UInt53
    };
    for (typeName in types) {
      types[typeName].toJSON = (function(t) {
        return t;
      }).bind(null, typeName);
    }
    var typeName;
    module.exports = types;
  }
});

// ../../node_modules/.pnpm/typeforce@1.18.0/node_modules/typeforce/index.js
var require_typeforce = __commonJS({
  "../../node_modules/.pnpm/typeforce@1.18.0/node_modules/typeforce/index.js"(exports, module) {
    var ERRORS = require_errors();
    var NATIVE = require_native();
    var tfJSON = ERRORS.tfJSON;
    var TfTypeError = ERRORS.TfTypeError;
    var TfPropertyTypeError = ERRORS.TfPropertyTypeError;
    var tfSubError = ERRORS.tfSubError;
    var getValueTypeName = ERRORS.getValueTypeName;
    var TYPES = {
      arrayOf: function arrayOf(type, options) {
        type = compile(type);
        options = options || {};
        function _arrayOf(array2, strict) {
          if (!NATIVE.Array(array2))
            return false;
          if (NATIVE.Nil(array2))
            return false;
          if (options.minLength !== void 0 && array2.length < options.minLength)
            return false;
          if (options.maxLength !== void 0 && array2.length > options.maxLength)
            return false;
          if (options.length !== void 0 && array2.length !== options.length)
            return false;
          return array2.every(function(value, i4) {
            try {
              return typeforce(type, value, strict);
            } catch (e2) {
              throw tfSubError(e2, i4);
            }
          });
        }
        _arrayOf.toJSON = function() {
          var str = "[" + tfJSON(type) + "]";
          if (options.length !== void 0) {
            str += "{" + options.length + "}";
          } else if (options.minLength !== void 0 || options.maxLength !== void 0) {
            str += "{" + (options.minLength === void 0 ? 0 : options.minLength) + "," + (options.maxLength === void 0 ? Infinity : options.maxLength) + "}";
          }
          return str;
        };
        return _arrayOf;
      },
      maybe: function maybe(type) {
        type = compile(type);
        function _maybe(value, strict) {
          return NATIVE.Nil(value) || type(value, strict, maybe);
        }
        _maybe.toJSON = function() {
          return "?" + tfJSON(type);
        };
        return _maybe;
      },
      map: function map2(propertyType, propertyKeyType) {
        propertyType = compile(propertyType);
        if (propertyKeyType)
          propertyKeyType = compile(propertyKeyType);
        function _map(value, strict) {
          if (!NATIVE.Object(value))
            return false;
          if (NATIVE.Nil(value))
            return false;
          for (var propertyName in value) {
            try {
              if (propertyKeyType) {
                typeforce(propertyKeyType, propertyName, strict);
              }
            } catch (e2) {
              throw tfSubError(e2, propertyName, "key");
            }
            try {
              var propertyValue = value[propertyName];
              typeforce(propertyType, propertyValue, strict);
            } catch (e2) {
              throw tfSubError(e2, propertyName);
            }
          }
          return true;
        }
        if (propertyKeyType) {
          _map.toJSON = function() {
            return "{" + tfJSON(propertyKeyType) + ": " + tfJSON(propertyType) + "}";
          };
        } else {
          _map.toJSON = function() {
            return "{" + tfJSON(propertyType) + "}";
          };
        }
        return _map;
      },
      object: function object2(uncompiled) {
        var type = {};
        for (var typePropertyName in uncompiled) {
          type[typePropertyName] = compile(uncompiled[typePropertyName]);
        }
        function _object(value, strict) {
          if (!NATIVE.Object(value))
            return false;
          if (NATIVE.Nil(value))
            return false;
          var propertyName;
          try {
            for (propertyName in type) {
              var propertyType = type[propertyName];
              var propertyValue = value[propertyName];
              typeforce(propertyType, propertyValue, strict);
            }
          } catch (e2) {
            throw tfSubError(e2, propertyName);
          }
          if (strict) {
            for (propertyName in value) {
              if (type[propertyName])
                continue;
              throw new TfPropertyTypeError(void 0, propertyName);
            }
          }
          return true;
        }
        _object.toJSON = function() {
          return tfJSON(type);
        };
        return _object;
      },
      anyOf: function anyOf() {
        var types = [].slice.call(arguments).map(compile);
        function _anyOf(value, strict) {
          return types.some(function(type) {
            try {
              return typeforce(type, value, strict);
            } catch (e2) {
              return false;
            }
          });
        }
        _anyOf.toJSON = function() {
          return types.map(tfJSON).join("|");
        };
        return _anyOf;
      },
      allOf: function allOf() {
        var types = [].slice.call(arguments).map(compile);
        function _allOf(value, strict) {
          return types.every(function(type) {
            try {
              return typeforce(type, value, strict);
            } catch (e2) {
              return false;
            }
          });
        }
        _allOf.toJSON = function() {
          return types.map(tfJSON).join(" & ");
        };
        return _allOf;
      },
      quacksLike: function quacksLike(type) {
        function _quacksLike(value) {
          return type === getValueTypeName(value);
        }
        _quacksLike.toJSON = function() {
          return type;
        };
        return _quacksLike;
      },
      tuple: function tuple() {
        var types = [].slice.call(arguments).map(compile);
        function _tuple(values2, strict) {
          if (NATIVE.Nil(values2))
            return false;
          if (NATIVE.Nil(values2.length))
            return false;
          if (strict && values2.length !== types.length)
            return false;
          return types.every(function(type, i4) {
            try {
              return typeforce(type, values2[i4], strict);
            } catch (e2) {
              throw tfSubError(e2, i4);
            }
          });
        }
        _tuple.toJSON = function() {
          return "(" + types.map(tfJSON).join(", ") + ")";
        };
        return _tuple;
      },
      value: function value(expected) {
        function _value(actual) {
          return actual === expected;
        }
        _value.toJSON = function() {
          return expected;
        };
        return _value;
      }
    };
    TYPES.oneOf = TYPES.anyOf;
    function compile(type) {
      if (NATIVE.String(type)) {
        if (type[0] === "?")
          return TYPES.maybe(type.slice(1));
        return NATIVE[type] || TYPES.quacksLike(type);
      } else if (type && NATIVE.Object(type)) {
        if (NATIVE.Array(type)) {
          if (type.length !== 1)
            throw new TypeError("Expected compile() parameter of type Array of length 1");
          return TYPES.arrayOf(type[0]);
        }
        return TYPES.object(type);
      } else if (NATIVE.Function(type)) {
        return type;
      }
      return TYPES.value(type);
    }
    function typeforce(type, value, strict, surrogate) {
      if (NATIVE.Function(type)) {
        if (type(value, strict))
          return true;
        throw new TfTypeError(surrogate || type, value);
      }
      return typeforce(compile(type), value, strict);
    }
    for (typeName in NATIVE) {
      typeforce[typeName] = NATIVE[typeName];
    }
    var typeName;
    for (typeName in TYPES) {
      typeforce[typeName] = TYPES[typeName];
    }
    var EXTRA = require_extra();
    for (typeName in EXTRA) {
      typeforce[typeName] = EXTRA[typeName];
    }
    typeforce.compile = compile;
    typeforce.TfTypeError = TfTypeError;
    typeforce.TfPropertyTypeError = TfPropertyTypeError;
    module.exports = typeforce;
  }
});

// ../../node_modules/.pnpm/wif@2.0.6/node_modules/wif/index.js
var require_wif = __commonJS({
  "../../node_modules/.pnpm/wif@2.0.6/node_modules/wif/index.js"(exports, module) {
    var bs58check = require_bs58check();
    function decodeRaw(buffer, version6) {
      if (version6 !== void 0 && buffer[0] !== version6)
        throw new Error("Invalid network version");
      if (buffer.length === 33) {
        return {
          version: buffer[0],
          privateKey: buffer.slice(1, 33),
          compressed: false
        };
      }
      if (buffer.length !== 34)
        throw new Error("Invalid WIF length");
      if (buffer[33] !== 1)
        throw new Error("Invalid compression flag");
      return {
        version: buffer[0],
        privateKey: buffer.slice(1, 33),
        compressed: true
      };
    }
    function encodeRaw(version6, privateKey, compressed) {
      var result = new Buffer(compressed ? 34 : 33);
      result.writeUInt8(version6, 0);
      privateKey.copy(result, 1);
      if (compressed) {
        result[33] = 1;
      }
      return result;
    }
    function decode(string, version6) {
      return decodeRaw(bs58check.decode(string), version6);
    }
    function encode2(version6, privateKey, compressed) {
      if (typeof version6 === "number")
        return bs58check.encode(encodeRaw(version6, privateKey, compressed));
      return bs58check.encode(
        encodeRaw(
          version6.version,
          version6.privateKey,
          version6.compressed
        )
      );
    }
    module.exports = {
      decode,
      decodeRaw,
      encode: encode2,
      encodeRaw
    };
  }
});

// ../../node_modules/.pnpm/bip32@2.0.6/node_modules/bip32/src/bip32.js
var require_bip32 = __commonJS({
  "../../node_modules/.pnpm/bip32@2.0.6/node_modules/bip32/src/bip32.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var crypto2 = require_crypto2();
    var bs58check = require_bs58check();
    var ecc = require_js();
    var typeforce = require_typeforce();
    var wif = require_wif();
    var UINT256_TYPE = typeforce.BufferN(32);
    var NETWORK_TYPE = typeforce.compile({
      wif: typeforce.UInt8,
      bip32: {
        public: typeforce.UInt32,
        private: typeforce.UInt32
      }
    });
    var BITCOIN = {
      messagePrefix: "Bitcoin Signed Message:\n",
      bech32: "bc",
      bip32: {
        public: 76067358,
        private: 76066276
      },
      pubKeyHash: 0,
      scriptHash: 5,
      wif: 128
    };
    var HIGHEST_BIT = 2147483648;
    var UINT31_MAX = Math.pow(2, 31) - 1;
    function BIP32Path(value) {
      return typeforce.String(value) && value.match(/^(m\/)?(\d+'?\/)*\d+'?$/) !== null;
    }
    function UInt31(value) {
      return typeforce.UInt32(value) && value <= UINT31_MAX;
    }
    var BIP32 = class {
      constructor(__D, __Q, chainCode, network, __DEPTH = 0, __INDEX = 0, __PARENT_FINGERPRINT = 0) {
        this.__D = __D;
        this.__Q = __Q;
        this.chainCode = chainCode;
        this.network = network;
        this.__DEPTH = __DEPTH;
        this.__INDEX = __INDEX;
        this.__PARENT_FINGERPRINT = __PARENT_FINGERPRINT;
        typeforce(NETWORK_TYPE, network);
        this.lowR = false;
      }
      get depth() {
        return this.__DEPTH;
      }
      get index() {
        return this.__INDEX;
      }
      get parentFingerprint() {
        return this.__PARENT_FINGERPRINT;
      }
      get publicKey() {
        if (this.__Q === void 0)
          this.__Q = ecc.pointFromScalar(this.__D, true);
        return this.__Q;
      }
      get privateKey() {
        return this.__D;
      }
      get identifier() {
        return crypto2.hash160(this.publicKey);
      }
      get fingerprint() {
        return this.identifier.slice(0, 4);
      }
      get compressed() {
        return true;
      }
      // Private === not neutered
      // Public === neutered
      isNeutered() {
        return this.__D === void 0;
      }
      neutered() {
        return fromPublicKeyLocal(this.publicKey, this.chainCode, this.network, this.depth, this.index, this.parentFingerprint);
      }
      toBase58() {
        const network = this.network;
        const version6 = !this.isNeutered() ? network.bip32.private : network.bip32.public;
        const buffer = Buffer.allocUnsafe(78);
        buffer.writeUInt32BE(version6, 0);
        buffer.writeUInt8(this.depth, 4);
        buffer.writeUInt32BE(this.parentFingerprint, 5);
        buffer.writeUInt32BE(this.index, 9);
        this.chainCode.copy(buffer, 13);
        if (!this.isNeutered()) {
          buffer.writeUInt8(0, 45);
          this.privateKey.copy(buffer, 46);
        } else {
          this.publicKey.copy(buffer, 45);
        }
        return bs58check.encode(buffer);
      }
      toWIF() {
        if (!this.privateKey)
          throw new TypeError("Missing private key");
        return wif.encode(this.network.wif, this.privateKey, true);
      }
      // https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki#child-key-derivation-ckd-functions
      derive(index) {
        typeforce(typeforce.UInt32, index);
        const isHardened = index >= HIGHEST_BIT;
        const data = Buffer.allocUnsafe(37);
        if (isHardened) {
          if (this.isNeutered())
            throw new TypeError("Missing private key for hardened child key");
          data[0] = 0;
          this.privateKey.copy(data, 1);
          data.writeUInt32BE(index, 33);
        } else {
          this.publicKey.copy(data, 0);
          data.writeUInt32BE(index, 33);
        }
        const I4 = crypto2.hmacSHA512(this.chainCode, data);
        const IL = I4.slice(0, 32);
        const IR = I4.slice(32);
        if (!ecc.isPrivate(IL))
          return this.derive(index + 1);
        let hd;
        if (!this.isNeutered()) {
          const ki2 = ecc.privateAdd(this.privateKey, IL);
          if (ki2 == null)
            return this.derive(index + 1);
          hd = fromPrivateKeyLocal(ki2, IR, this.network, this.depth + 1, index, this.fingerprint.readUInt32BE(0));
        } else {
          const Ki2 = ecc.pointAddScalar(this.publicKey, IL, true);
          if (Ki2 === null)
            return this.derive(index + 1);
          hd = fromPublicKeyLocal(Ki2, IR, this.network, this.depth + 1, index, this.fingerprint.readUInt32BE(0));
        }
        return hd;
      }
      deriveHardened(index) {
        typeforce(UInt31, index);
        return this.derive(index + HIGHEST_BIT);
      }
      derivePath(path) {
        typeforce(BIP32Path, path);
        let splitPath = path.split("/");
        if (splitPath[0] === "m") {
          if (this.parentFingerprint)
            throw new TypeError("Expected master, got child");
          splitPath = splitPath.slice(1);
        }
        return splitPath.reduce((prevHd, indexStr) => {
          let index;
          if (indexStr.slice(-1) === `'`) {
            index = parseInt(indexStr.slice(0, -1), 10);
            return prevHd.deriveHardened(index);
          } else {
            index = parseInt(indexStr, 10);
            return prevHd.derive(index);
          }
        }, this);
      }
      sign(hash, lowR) {
        if (!this.privateKey)
          throw new Error("Missing private key");
        if (lowR === void 0)
          lowR = this.lowR;
        if (lowR === false) {
          return ecc.sign(hash, this.privateKey);
        } else {
          let sig = ecc.sign(hash, this.privateKey);
          const extraData = Buffer.alloc(32, 0);
          let counter = 0;
          while (sig[0] > 127) {
            counter++;
            extraData.writeUIntLE(counter, 0, 6);
            sig = ecc.signWithEntropy(hash, this.privateKey, extraData);
          }
          return sig;
        }
      }
      verify(hash, signature) {
        return ecc.verify(hash, this.publicKey, signature);
      }
    };
    function fromBase58(inString, network) {
      const buffer = bs58check.decode(inString);
      if (buffer.length !== 78)
        throw new TypeError("Invalid buffer length");
      network = network || BITCOIN;
      const version6 = buffer.readUInt32BE(0);
      if (version6 !== network.bip32.private && version6 !== network.bip32.public)
        throw new TypeError("Invalid network version");
      const depth = buffer[4];
      const parentFingerprint = buffer.readUInt32BE(5);
      if (depth === 0) {
        if (parentFingerprint !== 0)
          throw new TypeError("Invalid parent fingerprint");
      }
      const index = buffer.readUInt32BE(9);
      if (depth === 0 && index !== 0)
        throw new TypeError("Invalid index");
      const chainCode = buffer.slice(13, 45);
      let hd;
      if (version6 === network.bip32.private) {
        if (buffer.readUInt8(45) !== 0)
          throw new TypeError("Invalid private key");
        const k5 = buffer.slice(46, 78);
        hd = fromPrivateKeyLocal(k5, chainCode, network, depth, index, parentFingerprint);
      } else {
        const X2 = buffer.slice(45, 78);
        hd = fromPublicKeyLocal(X2, chainCode, network, depth, index, parentFingerprint);
      }
      return hd;
    }
    exports.fromBase58 = fromBase58;
    function fromPrivateKey(privateKey, chainCode, network) {
      return fromPrivateKeyLocal(privateKey, chainCode, network);
    }
    exports.fromPrivateKey = fromPrivateKey;
    function fromPrivateKeyLocal(privateKey, chainCode, network, depth, index, parentFingerprint) {
      typeforce({
        privateKey: UINT256_TYPE,
        chainCode: UINT256_TYPE
      }, { privateKey, chainCode });
      network = network || BITCOIN;
      if (!ecc.isPrivate(privateKey))
        throw new TypeError("Private key not in range [1, n)");
      return new BIP32(privateKey, void 0, chainCode, network, depth, index, parentFingerprint);
    }
    function fromPublicKey(publicKey, chainCode, network) {
      return fromPublicKeyLocal(publicKey, chainCode, network);
    }
    exports.fromPublicKey = fromPublicKey;
    function fromPublicKeyLocal(publicKey, chainCode, network, depth, index, parentFingerprint) {
      typeforce({
        publicKey: typeforce.BufferN(33),
        chainCode: UINT256_TYPE
      }, { publicKey, chainCode });
      network = network || BITCOIN;
      if (!ecc.isPoint(publicKey))
        throw new TypeError("Point is not on the curve");
      return new BIP32(void 0, publicKey, chainCode, network, depth, index, parentFingerprint);
    }
    function fromSeed(seed, network) {
      typeforce(typeforce.Buffer, seed);
      if (seed.length < 16)
        throw new TypeError("Seed should be at least 128 bits");
      if (seed.length > 64)
        throw new TypeError("Seed should be at most 512 bits");
      network = network || BITCOIN;
      const I4 = crypto2.hmacSHA512(Buffer.from("Bitcoin seed", "utf8"), seed);
      const IL = I4.slice(0, 32);
      const IR = I4.slice(32);
      return fromPrivateKey(IL, IR, network);
    }
    exports.fromSeed = fromSeed;
  }
});

// ../../node_modules/.pnpm/bip32@2.0.6/node_modules/bip32/src/index.js
var require_src3 = __commonJS({
  "../../node_modules/.pnpm/bip32@2.0.6/node_modules/bip32/src/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var bip32_1 = require_bip32();
    exports.fromSeed = bip32_1.fromSeed;
    exports.fromBase58 = bip32_1.fromBase58;
    exports.fromPublicKey = bip32_1.fromPublicKey;
    exports.fromPrivateKey = bip32_1.fromPrivateKey;
  }
});

// ../../node_modules/.pnpm/@keplr-wallet+crypto@0.12.28/node_modules/@keplr-wallet/crypto/build/mnemonic.js
var require_mnemonic = __commonJS({
  "../../node_modules/.pnpm/@keplr-wallet+crypto@0.12.28/node_modules/@keplr-wallet/crypto/build/mnemonic.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P3, generator) {
      function adopt(value) {
        return value instanceof P3 ? value : new P3(function(resolve) {
          resolve(value);
        });
      }
      return new (P3 || (P3 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e2) {
            reject(e2);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e2) {
            reject(e2);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Mnemonic = void 0;
    var bip39 = require_src();
    var bip32 = require_src3();
    var bs58check = require_bs58check();
    var buffer_1 = require_buffer();
    var Mnemonic = class _Mnemonic {
      static generateWallet(rng, path = `m/44'/118'/0'/0/0`, password = "", strength = 256) {
        return __awaiter(this, void 0, void 0, function* () {
          const mnemonic = yield _Mnemonic.generateSeed(rng, strength);
          const privKey = _Mnemonic.generateWalletFromMnemonic(mnemonic, path, password);
          return {
            privKey,
            mnemonic
          };
        });
      }
      static validateMnemonic(mnemonic) {
        return bip39.validateMnemonic(mnemonic);
      }
      static generateSeed(rng, strength = 128) {
        return __awaiter(this, void 0, void 0, function* () {
          if (strength % 32 !== 0) {
            throw new TypeError("invalid entropy");
          }
          let bytes = new Uint8Array(strength / 8);
          bytes = yield rng(bytes);
          return bip39.entropyToMnemonic(buffer_1.Buffer.from(bytes).toString("hex"));
        });
      }
      static generateWalletFromMnemonic(mnemonic, path = `m/44'/118'/0'/0/0`, password = "") {
        const seed = bip39.mnemonicToSeedSync(mnemonic, password);
        const masterSeed = bip32.fromSeed(seed);
        const hd = masterSeed.derivePath(path);
        const privateKey = hd.privateKey;
        if (!privateKey) {
          throw new Error("null hd key");
        }
        return privateKey;
      }
      static generateMasterSeedFromMnemonic(mnemonic, password = "") {
        const seed = bip39.mnemonicToSeedSync(mnemonic, password);
        const masterKey = bip32.fromSeed(seed);
        return buffer_1.Buffer.from(bs58check.decode(masterKey.toBase58()));
      }
      static generatePrivateKeyFromMasterSeed(seed, path = `m/44'/118'/0'/0/0`) {
        const masterSeed = bip32.fromBase58(bs58check.encode(seed));
        const hd = masterSeed.derivePath(path);
        const privateKey = hd.privateKey;
        if (!privateKey) {
          throw new Error("null hd key");
        }
        return privateKey;
      }
    };
    exports.Mnemonic = Mnemonic;
  }
});

// ../../node_modules/.pnpm/crypto-js@4.2.0/node_modules/crypto-js/core.js
var require_core = __commonJS({
  "../../node_modules/.pnpm/crypto-js@4.2.0/node_modules/crypto-js/core.js"(exports, module) {
    (function(root, factory) {
      if (typeof exports === "object") {
        module.exports = exports = factory();
      } else if (typeof define === "function" && define.amd) {
        define([], factory);
      } else {
        root.CryptoJS = factory();
      }
    })(exports, function() {
      var CryptoJS = CryptoJS || function(Math2, undefined2) {
        var crypto2;
        if (typeof window !== "undefined" && window.crypto) {
          crypto2 = window.crypto;
        }
        if (typeof self !== "undefined" && self.crypto) {
          crypto2 = self.crypto;
        }
        if (typeof globalThis !== "undefined" && globalThis.crypto) {
          crypto2 = globalThis.crypto;
        }
        if (!crypto2 && typeof window !== "undefined" && window.msCrypto) {
          crypto2 = window.msCrypto;
        }
        if (!crypto2 && typeof global !== "undefined" && global.crypto) {
          crypto2 = global.crypto;
        }
        if (!crypto2 && typeof __require === "function") {
          try {
            crypto2 = require_crypto();
          } catch (err) {
          }
        }
        var cryptoSecureRandomInt = function() {
          if (crypto2) {
            if (typeof crypto2.getRandomValues === "function") {
              try {
                return crypto2.getRandomValues(new Uint32Array(1))[0];
              } catch (err) {
              }
            }
            if (typeof crypto2.randomBytes === "function") {
              try {
                return crypto2.randomBytes(4).readInt32LE();
              } catch (err) {
              }
            }
          }
          throw new Error("Native crypto module could not be used to get secure random number.");
        };
        var create = Object.create || function() {
          function F2() {
          }
          return function(obj) {
            var subtype;
            F2.prototype = obj;
            subtype = new F2();
            F2.prototype = null;
            return subtype;
          };
        }();
        var C3 = {};
        var C_lib = C3.lib = {};
        var Base = C_lib.Base = function() {
          return {
            /**
             * Creates a new object that inherits from this object.
             *
             * @param {Object} overrides Properties to copy into the new object.
             *
             * @return {Object} The new object.
             *
             * @static
             *
             * @example
             *
             *     var MyType = CryptoJS.lib.Base.extend({
             *         field: 'value',
             *
             *         method: function () {
             *         }
             *     });
             */
            extend: function(overrides) {
              var subtype = create(this);
              if (overrides) {
                subtype.mixIn(overrides);
              }
              if (!subtype.hasOwnProperty("init") || this.init === subtype.init) {
                subtype.init = function() {
                  subtype.$super.init.apply(this, arguments);
                };
              }
              subtype.init.prototype = subtype;
              subtype.$super = this;
              return subtype;
            },
            /**
             * Extends this object and runs the init method.
             * Arguments to create() will be passed to init().
             *
             * @return {Object} The new object.
             *
             * @static
             *
             * @example
             *
             *     var instance = MyType.create();
             */
            create: function() {
              var instance = this.extend();
              instance.init.apply(instance, arguments);
              return instance;
            },
            /**
             * Initializes a newly created object.
             * Override this method to add some logic when your objects are created.
             *
             * @example
             *
             *     var MyType = CryptoJS.lib.Base.extend({
             *         init: function () {
             *             // ...
             *         }
             *     });
             */
            init: function() {
            },
            /**
             * Copies properties into this object.
             *
             * @param {Object} properties The properties to mix in.
             *
             * @example
             *
             *     MyType.mixIn({
             *         field: 'value'
             *     });
             */
            mixIn: function(properties) {
              for (var propertyName in properties) {
                if (properties.hasOwnProperty(propertyName)) {
                  this[propertyName] = properties[propertyName];
                }
              }
              if (properties.hasOwnProperty("toString")) {
                this.toString = properties.toString;
              }
            },
            /**
             * Creates a copy of this object.
             *
             * @return {Object} The clone.
             *
             * @example
             *
             *     var clone = instance.clone();
             */
            clone: function() {
              return this.init.prototype.extend(this);
            }
          };
        }();
        var WordArray = C_lib.WordArray = Base.extend({
          /**
           * Initializes a newly created word array.
           *
           * @param {Array} words (Optional) An array of 32-bit words.
           * @param {number} sigBytes (Optional) The number of significant bytes in the words.
           *
           * @example
           *
           *     var wordArray = CryptoJS.lib.WordArray.create();
           *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607]);
           *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607], 6);
           */
          init: function(words, sigBytes) {
            words = this.words = words || [];
            if (sigBytes != undefined2) {
              this.sigBytes = sigBytes;
            } else {
              this.sigBytes = words.length * 4;
            }
          },
          /**
           * Converts this word array to a string.
           *
           * @param {Encoder} encoder (Optional) The encoding strategy to use. Default: CryptoJS.enc.Hex
           *
           * @return {string} The stringified word array.
           *
           * @example
           *
           *     var string = wordArray + '';
           *     var string = wordArray.toString();
           *     var string = wordArray.toString(CryptoJS.enc.Utf8);
           */
          toString: function(encoder) {
            return (encoder || Hex).stringify(this);
          },
          /**
           * Concatenates a word array to this word array.
           *
           * @param {WordArray} wordArray The word array to append.
           *
           * @return {WordArray} This word array.
           *
           * @example
           *
           *     wordArray1.concat(wordArray2);
           */
          concat: function(wordArray) {
            var thisWords = this.words;
            var thatWords = wordArray.words;
            var thisSigBytes = this.sigBytes;
            var thatSigBytes = wordArray.sigBytes;
            this.clamp();
            if (thisSigBytes % 4) {
              for (var i4 = 0; i4 < thatSigBytes; i4++) {
                var thatByte = thatWords[i4 >>> 2] >>> 24 - i4 % 4 * 8 & 255;
                thisWords[thisSigBytes + i4 >>> 2] |= thatByte << 24 - (thisSigBytes + i4) % 4 * 8;
              }
            } else {
              for (var j2 = 0; j2 < thatSigBytes; j2 += 4) {
                thisWords[thisSigBytes + j2 >>> 2] = thatWords[j2 >>> 2];
              }
            }
            this.sigBytes += thatSigBytes;
            return this;
          },
          /**
           * Removes insignificant bits.
           *
           * @example
           *
           *     wordArray.clamp();
           */
          clamp: function() {
            var words = this.words;
            var sigBytes = this.sigBytes;
            words[sigBytes >>> 2] &= 4294967295 << 32 - sigBytes % 4 * 8;
            words.length = Math2.ceil(sigBytes / 4);
          },
          /**
           * Creates a copy of this word array.
           *
           * @return {WordArray} The clone.
           *
           * @example
           *
           *     var clone = wordArray.clone();
           */
          clone: function() {
            var clone = Base.clone.call(this);
            clone.words = this.words.slice(0);
            return clone;
          },
          /**
           * Creates a word array filled with random bytes.
           *
           * @param {number} nBytes The number of random bytes to generate.
           *
           * @return {WordArray} The random word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.lib.WordArray.random(16);
           */
          random: function(nBytes) {
            var words = [];
            for (var i4 = 0; i4 < nBytes; i4 += 4) {
              words.push(cryptoSecureRandomInt());
            }
            return new WordArray.init(words, nBytes);
          }
        });
        var C_enc = C3.enc = {};
        var Hex = C_enc.Hex = {
          /**
           * Converts a word array to a hex string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @return {string} The hex string.
           *
           * @static
           *
           * @example
           *
           *     var hexString = CryptoJS.enc.Hex.stringify(wordArray);
           */
          stringify: function(wordArray) {
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            var hexChars = [];
            for (var i4 = 0; i4 < sigBytes; i4++) {
              var bite = words[i4 >>> 2] >>> 24 - i4 % 4 * 8 & 255;
              hexChars.push((bite >>> 4).toString(16));
              hexChars.push((bite & 15).toString(16));
            }
            return hexChars.join("");
          },
          /**
           * Converts a hex string to a word array.
           *
           * @param {string} hexStr The hex string.
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Hex.parse(hexString);
           */
          parse: function(hexStr) {
            var hexStrLength = hexStr.length;
            var words = [];
            for (var i4 = 0; i4 < hexStrLength; i4 += 2) {
              words[i4 >>> 3] |= parseInt(hexStr.substr(i4, 2), 16) << 24 - i4 % 8 * 4;
            }
            return new WordArray.init(words, hexStrLength / 2);
          }
        };
        var Latin1 = C_enc.Latin1 = {
          /**
           * Converts a word array to a Latin1 string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @return {string} The Latin1 string.
           *
           * @static
           *
           * @example
           *
           *     var latin1String = CryptoJS.enc.Latin1.stringify(wordArray);
           */
          stringify: function(wordArray) {
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            var latin1Chars = [];
            for (var i4 = 0; i4 < sigBytes; i4++) {
              var bite = words[i4 >>> 2] >>> 24 - i4 % 4 * 8 & 255;
              latin1Chars.push(String.fromCharCode(bite));
            }
            return latin1Chars.join("");
          },
          /**
           * Converts a Latin1 string to a word array.
           *
           * @param {string} latin1Str The Latin1 string.
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Latin1.parse(latin1String);
           */
          parse: function(latin1Str) {
            var latin1StrLength = latin1Str.length;
            var words = [];
            for (var i4 = 0; i4 < latin1StrLength; i4++) {
              words[i4 >>> 2] |= (latin1Str.charCodeAt(i4) & 255) << 24 - i4 % 4 * 8;
            }
            return new WordArray.init(words, latin1StrLength);
          }
        };
        var Utf8 = C_enc.Utf8 = {
          /**
           * Converts a word array to a UTF-8 string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @return {string} The UTF-8 string.
           *
           * @static
           *
           * @example
           *
           *     var utf8String = CryptoJS.enc.Utf8.stringify(wordArray);
           */
          stringify: function(wordArray) {
            try {
              return decodeURIComponent(escape(Latin1.stringify(wordArray)));
            } catch (e2) {
              throw new Error("Malformed UTF-8 data");
            }
          },
          /**
           * Converts a UTF-8 string to a word array.
           *
           * @param {string} utf8Str The UTF-8 string.
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Utf8.parse(utf8String);
           */
          parse: function(utf8Str) {
            return Latin1.parse(unescape(encodeURIComponent(utf8Str)));
          }
        };
        var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm = Base.extend({
          /**
           * Resets this block algorithm's data buffer to its initial state.
           *
           * @example
           *
           *     bufferedBlockAlgorithm.reset();
           */
          reset: function() {
            this._data = new WordArray.init();
            this._nDataBytes = 0;
          },
          /**
           * Adds new data to this block algorithm's buffer.
           *
           * @param {WordArray|string} data The data to append. Strings are converted to a WordArray using UTF-8.
           *
           * @example
           *
           *     bufferedBlockAlgorithm._append('data');
           *     bufferedBlockAlgorithm._append(wordArray);
           */
          _append: function(data) {
            if (typeof data == "string") {
              data = Utf8.parse(data);
            }
            this._data.concat(data);
            this._nDataBytes += data.sigBytes;
          },
          /**
           * Processes available data blocks.
           *
           * This method invokes _doProcessBlock(offset), which must be implemented by a concrete subtype.
           *
           * @param {boolean} doFlush Whether all blocks and partial blocks should be processed.
           *
           * @return {WordArray} The processed data.
           *
           * @example
           *
           *     var processedData = bufferedBlockAlgorithm._process();
           *     var processedData = bufferedBlockAlgorithm._process(!!'flush');
           */
          _process: function(doFlush) {
            var processedWords;
            var data = this._data;
            var dataWords = data.words;
            var dataSigBytes = data.sigBytes;
            var blockSize = this.blockSize;
            var blockSizeBytes = blockSize * 4;
            var nBlocksReady = dataSigBytes / blockSizeBytes;
            if (doFlush) {
              nBlocksReady = Math2.ceil(nBlocksReady);
            } else {
              nBlocksReady = Math2.max((nBlocksReady | 0) - this._minBufferSize, 0);
            }
            var nWordsReady = nBlocksReady * blockSize;
            var nBytesReady = Math2.min(nWordsReady * 4, dataSigBytes);
            if (nWordsReady) {
              for (var offset = 0; offset < nWordsReady; offset += blockSize) {
                this._doProcessBlock(dataWords, offset);
              }
              processedWords = dataWords.splice(0, nWordsReady);
              data.sigBytes -= nBytesReady;
            }
            return new WordArray.init(processedWords, nBytesReady);
          },
          /**
           * Creates a copy of this object.
           *
           * @return {Object} The clone.
           *
           * @example
           *
           *     var clone = bufferedBlockAlgorithm.clone();
           */
          clone: function() {
            var clone = Base.clone.call(this);
            clone._data = this._data.clone();
            return clone;
          },
          _minBufferSize: 0
        });
        var Hasher = C_lib.Hasher = BufferedBlockAlgorithm.extend({
          /**
           * Configuration options.
           */
          cfg: Base.extend(),
          /**
           * Initializes a newly created hasher.
           *
           * @param {Object} cfg (Optional) The configuration options to use for this hash computation.
           *
           * @example
           *
           *     var hasher = CryptoJS.algo.SHA256.create();
           */
          init: function(cfg) {
            this.cfg = this.cfg.extend(cfg);
            this.reset();
          },
          /**
           * Resets this hasher to its initial state.
           *
           * @example
           *
           *     hasher.reset();
           */
          reset: function() {
            BufferedBlockAlgorithm.reset.call(this);
            this._doReset();
          },
          /**
           * Updates this hasher with a message.
           *
           * @param {WordArray|string} messageUpdate The message to append.
           *
           * @return {Hasher} This hasher.
           *
           * @example
           *
           *     hasher.update('message');
           *     hasher.update(wordArray);
           */
          update: function(messageUpdate) {
            this._append(messageUpdate);
            this._process();
            return this;
          },
          /**
           * Finalizes the hash computation.
           * Note that the finalize operation is effectively a destructive, read-once operation.
           *
           * @param {WordArray|string} messageUpdate (Optional) A final message update.
           *
           * @return {WordArray} The hash.
           *
           * @example
           *
           *     var hash = hasher.finalize();
           *     var hash = hasher.finalize('message');
           *     var hash = hasher.finalize(wordArray);
           */
          finalize: function(messageUpdate) {
            if (messageUpdate) {
              this._append(messageUpdate);
            }
            var hash = this._doFinalize();
            return hash;
          },
          blockSize: 512 / 32,
          /**
           * Creates a shortcut function to a hasher's object interface.
           *
           * @param {Hasher} hasher The hasher to create a helper for.
           *
           * @return {Function} The shortcut function.
           *
           * @static
           *
           * @example
           *
           *     var SHA256 = CryptoJS.lib.Hasher._createHelper(CryptoJS.algo.SHA256);
           */
          _createHelper: function(hasher) {
            return function(message, cfg) {
              return new hasher.init(cfg).finalize(message);
            };
          },
          /**
           * Creates a shortcut function to the HMAC's object interface.
           *
           * @param {Hasher} hasher The hasher to use in this HMAC helper.
           *
           * @return {Function} The shortcut function.
           *
           * @static
           *
           * @example
           *
           *     var HmacSHA256 = CryptoJS.lib.Hasher._createHmacHelper(CryptoJS.algo.SHA256);
           */
          _createHmacHelper: function(hasher) {
            return function(message, key) {
              return new C_algo.HMAC.init(hasher, key).finalize(message);
            };
          }
        });
        var C_algo = C3.algo = {};
        return C3;
      }(Math);
      return CryptoJS;
    });
  }
});

// ../../node_modules/.pnpm/crypto-js@4.2.0/node_modules/crypto-js/x64-core.js
var require_x64_core = __commonJS({
  "../../node_modules/.pnpm/crypto-js@4.2.0/node_modules/crypto-js/x64-core.js"(exports, module) {
    (function(root, factory) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function(undefined2) {
        var C3 = CryptoJS;
        var C_lib = C3.lib;
        var Base = C_lib.Base;
        var X32WordArray = C_lib.WordArray;
        var C_x64 = C3.x64 = {};
        var X64Word = C_x64.Word = Base.extend({
          /**
           * Initializes a newly created 64-bit word.
           *
           * @param {number} high The high 32 bits.
           * @param {number} low The low 32 bits.
           *
           * @example
           *
           *     var x64Word = CryptoJS.x64.Word.create(0x00010203, 0x04050607);
           */
          init: function(high, low) {
            this.high = high;
            this.low = low;
          }
          /**
           * Bitwise NOTs this word.
           *
           * @return {X64Word} A new x64-Word object after negating.
           *
           * @example
           *
           *     var negated = x64Word.not();
           */
          // not: function () {
          // var high = ~this.high;
          // var low = ~this.low;
          // return X64Word.create(high, low);
          // },
          /**
           * Bitwise ANDs this word with the passed word.
           *
           * @param {X64Word} word The x64-Word to AND with this word.
           *
           * @return {X64Word} A new x64-Word object after ANDing.
           *
           * @example
           *
           *     var anded = x64Word.and(anotherX64Word);
           */
          // and: function (word) {
          // var high = this.high & word.high;
          // var low = this.low & word.low;
          // return X64Word.create(high, low);
          // },
          /**
           * Bitwise ORs this word with the passed word.
           *
           * @param {X64Word} word The x64-Word to OR with this word.
           *
           * @return {X64Word} A new x64-Word object after ORing.
           *
           * @example
           *
           *     var ored = x64Word.or(anotherX64Word);
           */
          // or: function (word) {
          // var high = this.high | word.high;
          // var low = this.low | word.low;
          // return X64Word.create(high, low);
          // },
          /**
           * Bitwise XORs this word with the passed word.
           *
           * @param {X64Word} word The x64-Word to XOR with this word.
           *
           * @return {X64Word} A new x64-Word object after XORing.
           *
           * @example
           *
           *     var xored = x64Word.xor(anotherX64Word);
           */
          // xor: function (word) {
          // var high = this.high ^ word.high;
          // var low = this.low ^ word.low;
          // return X64Word.create(high, low);
          // },
          /**
           * Shifts this word n bits to the left.
           *
           * @param {number} n The number of bits to shift.
           *
           * @return {X64Word} A new x64-Word object after shifting.
           *
           * @example
           *
           *     var shifted = x64Word.shiftL(25);
           */
          // shiftL: function (n) {
          // if (n < 32) {
          // var high = (this.high << n) | (this.low >>> (32 - n));
          // var low = this.low << n;
          // } else {
          // var high = this.low << (n - 32);
          // var low = 0;
          // }
          // return X64Word.create(high, low);
          // },
          /**
           * Shifts this word n bits to the right.
           *
           * @param {number} n The number of bits to shift.
           *
           * @return {X64Word} A new x64-Word object after shifting.
           *
           * @example
           *
           *     var shifted = x64Word.shiftR(7);
           */
          // shiftR: function (n) {
          // if (n < 32) {
          // var low = (this.low >>> n) | (this.high << (32 - n));
          // var high = this.high >>> n;
          // } else {
          // var low = this.high >>> (n - 32);
          // var high = 0;
          // }
          // return X64Word.create(high, low);
          // },
          /**
           * Rotates this word n bits to the left.
           *
           * @param {number} n The number of bits to rotate.
           *
           * @return {X64Word} A new x64-Word object after rotating.
           *
           * @example
           *
           *     var rotated = x64Word.rotL(25);
           */
          // rotL: function (n) {
          // return this.shiftL(n).or(this.shiftR(64 - n));
          // },
          /**
           * Rotates this word n bits to the right.
           *
           * @param {number} n The number of bits to rotate.
           *
           * @return {X64Word} A new x64-Word object after rotating.
           *
           * @example
           *
           *     var rotated = x64Word.rotR(7);
           */
          // rotR: function (n) {
          // return this.shiftR(n).or(this.shiftL(64 - n));
          // },
          /**
           * Adds this word with the passed word.
           *
           * @param {X64Word} word The x64-Word to add with this word.
           *
           * @return {X64Word} A new x64-Word object after adding.
           *
           * @example
           *
           *     var added = x64Word.add(anotherX64Word);
           */
          // add: function (word) {
          // var low = (this.low + word.low) | 0;
          // var carry = (low >>> 0) < (this.low >>> 0) ? 1 : 0;
          // var high = (this.high + word.high + carry) | 0;
          // return X64Word.create(high, low);
          // }
        });
        var X64WordArray = C_x64.WordArray = Base.extend({
          /**
           * Initializes a newly created word array.
           *
           * @param {Array} words (Optional) An array of CryptoJS.x64.Word objects.
           * @param {number} sigBytes (Optional) The number of significant bytes in the words.
           *
           * @example
           *
           *     var wordArray = CryptoJS.x64.WordArray.create();
           *
           *     var wordArray = CryptoJS.x64.WordArray.create([
           *         CryptoJS.x64.Word.create(0x00010203, 0x04050607),
           *         CryptoJS.x64.Word.create(0x18191a1b, 0x1c1d1e1f)
           *     ]);
           *
           *     var wordArray = CryptoJS.x64.WordArray.create([
           *         CryptoJS.x64.Word.create(0x00010203, 0x04050607),
           *         CryptoJS.x64.Word.create(0x18191a1b, 0x1c1d1e1f)
           *     ], 10);
           */
          init: function(words, sigBytes) {
            words = this.words = words || [];
            if (sigBytes != undefined2) {
              this.sigBytes = sigBytes;
            } else {
              this.sigBytes = words.length * 8;
            }
          },
          /**
           * Converts this 64-bit word array to a 32-bit word array.
           *
           * @return {CryptoJS.lib.WordArray} This word array's data as a 32-bit word array.
           *
           * @example
           *
           *     var x32WordArray = x64WordArray.toX32();
           */
          toX32: function() {
            var x64Words = this.words;
            var x64WordsLength = x64Words.length;
            var x32Words = [];
            for (var i4 = 0; i4 < x64WordsLength; i4++) {
              var x64Word = x64Words[i4];
              x32Words.push(x64Word.high);
              x32Words.push(x64Word.low);
            }
            return X32WordArray.create(x32Words, this.sigBytes);
          },
          /**
           * Creates a copy of this word array.
           *
           * @return {X64WordArray} The clone.
           *
           * @example
           *
           *     var clone = x64WordArray.clone();
           */
          clone: function() {
            var clone = Base.clone.call(this);
            var words = clone.words = this.words.slice(0);
            var wordsLength = words.length;
            for (var i4 = 0; i4 < wordsLength; i4++) {
              words[i4] = words[i4].clone();
            }
            return clone;
          }
        });
      })();
      return CryptoJS;
    });
  }
});

// ../../node_modules/.pnpm/crypto-js@4.2.0/node_modules/crypto-js/lib-typedarrays.js
var require_lib_typedarrays = __commonJS({
  "../../node_modules/.pnpm/crypto-js@4.2.0/node_modules/crypto-js/lib-typedarrays.js"(exports, module) {
    (function(root, factory) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function() {
        if (typeof ArrayBuffer != "function") {
          return;
        }
        var C3 = CryptoJS;
        var C_lib = C3.lib;
        var WordArray = C_lib.WordArray;
        var superInit = WordArray.init;
        var subInit = WordArray.init = function(typedArray) {
          if (typedArray instanceof ArrayBuffer) {
            typedArray = new Uint8Array(typedArray);
          }
          if (typedArray instanceof Int8Array || typeof Uint8ClampedArray !== "undefined" && typedArray instanceof Uint8ClampedArray || typedArray instanceof Int16Array || typedArray instanceof Uint16Array || typedArray instanceof Int32Array || typedArray instanceof Uint32Array || typedArray instanceof Float32Array || typedArray instanceof Float64Array) {
            typedArray = new Uint8Array(typedArray.buffer, typedArray.byteOffset, typedArray.byteLength);
          }
          if (typedArray instanceof Uint8Array) {
            var typedArrayByteLength = typedArray.byteLength;
            var words = [];
            for (var i4 = 0; i4 < typedArrayByteLength; i4++) {
              words[i4 >>> 2] |= typedArray[i4] << 24 - i4 % 4 * 8;
            }
            superInit.call(this, words, typedArrayByteLength);
          } else {
            superInit.apply(this, arguments);
          }
        };
        subInit.prototype = WordArray;
      })();
      return CryptoJS.lib.WordArray;
    });
  }
});

// ../../node_modules/.pnpm/crypto-js@4.2.0/node_modules/crypto-js/enc-utf16.js
var require_enc_utf16 = __commonJS({
  "../../node_modules/.pnpm/crypto-js@4.2.0/node_modules/crypto-js/enc-utf16.js"(exports, module) {
    (function(root, factory) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function() {
        var C3 = CryptoJS;
        var C_lib = C3.lib;
        var WordArray = C_lib.WordArray;
        var C_enc = C3.enc;
        var Utf16BE = C_enc.Utf16 = C_enc.Utf16BE = {
          /**
           * Converts a word array to a UTF-16 BE string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @return {string} The UTF-16 BE string.
           *
           * @static
           *
           * @example
           *
           *     var utf16String = CryptoJS.enc.Utf16.stringify(wordArray);
           */
          stringify: function(wordArray) {
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            var utf16Chars = [];
            for (var i4 = 0; i4 < sigBytes; i4 += 2) {
              var codePoint = words[i4 >>> 2] >>> 16 - i4 % 4 * 8 & 65535;
              utf16Chars.push(String.fromCharCode(codePoint));
            }
            return utf16Chars.join("");
          },
          /**
           * Converts a UTF-16 BE string to a word array.
           *
           * @param {string} utf16Str The UTF-16 BE string.
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Utf16.parse(utf16String);
           */
          parse: function(utf16Str) {
            var utf16StrLength = utf16Str.length;
            var words = [];
            for (var i4 = 0; i4 < utf16StrLength; i4++) {
              words[i4 >>> 1] |= utf16Str.charCodeAt(i4) << 16 - i4 % 2 * 16;
            }
            return WordArray.create(words, utf16StrLength * 2);
          }
        };
        C_enc.Utf16LE = {
          /**
           * Converts a word array to a UTF-16 LE string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @return {string} The UTF-16 LE string.
           *
           * @static
           *
           * @example
           *
           *     var utf16Str = CryptoJS.enc.Utf16LE.stringify(wordArray);
           */
          stringify: function(wordArray) {
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            var utf16Chars = [];
            for (var i4 = 0; i4 < sigBytes; i4 += 2) {
              var codePoint = swapEndian(words[i4 >>> 2] >>> 16 - i4 % 4 * 8 & 65535);
              utf16Chars.push(String.fromCharCode(codePoint));
            }
            return utf16Chars.join("");
          },
          /**
           * Converts a UTF-16 LE string to a word array.
           *
           * @param {string} utf16Str The UTF-16 LE string.
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Utf16LE.parse(utf16Str);
           */
          parse: function(utf16Str) {
            var utf16StrLength = utf16Str.length;
            var words = [];
            for (var i4 = 0; i4 < utf16StrLength; i4++) {
              words[i4 >>> 1] |= swapEndian(utf16Str.charCodeAt(i4) << 16 - i4 % 2 * 16);
            }
            return WordArray.create(words, utf16StrLength * 2);
          }
        };
        function swapEndian(word) {
          return word << 8 & 4278255360 | word >>> 8 & 16711935;
        }
      })();
      return CryptoJS.enc.Utf16;
    });
  }
});

// ../../node_modules/.pnpm/crypto-js@4.2.0/node_modules/crypto-js/enc-base64.js
var require_enc_base64 = __commonJS({
  "../../node_modules/.pnpm/crypto-js@4.2.0/node_modules/crypto-js/enc-base64.js"(exports, module) {
    (function(root, factory) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function() {
        var C3 = CryptoJS;
        var C_lib = C3.lib;
        var WordArray = C_lib.WordArray;
        var C_enc = C3.enc;
        var Base64 = C_enc.Base64 = {
          /**
           * Converts a word array to a Base64 string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @return {string} The Base64 string.
           *
           * @static
           *
           * @example
           *
           *     var base64String = CryptoJS.enc.Base64.stringify(wordArray);
           */
          stringify: function(wordArray) {
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            var map2 = this._map;
            wordArray.clamp();
            var base64Chars = [];
            for (var i4 = 0; i4 < sigBytes; i4 += 3) {
              var byte1 = words[i4 >>> 2] >>> 24 - i4 % 4 * 8 & 255;
              var byte2 = words[i4 + 1 >>> 2] >>> 24 - (i4 + 1) % 4 * 8 & 255;
              var byte3 = words[i4 + 2 >>> 2] >>> 24 - (i4 + 2) % 4 * 8 & 255;
              var triplet = byte1 << 16 | byte2 << 8 | byte3;
              for (var j2 = 0; j2 < 4 && i4 + j2 * 0.75 < sigBytes; j2++) {
                base64Chars.push(map2.charAt(triplet >>> 6 * (3 - j2) & 63));
              }
            }
            var paddingChar = map2.charAt(64);
            if (paddingChar) {
              while (base64Chars.length % 4) {
                base64Chars.push(paddingChar);
              }
            }
            return base64Chars.join("");
          },
          /**
           * Converts a Base64 string to a word array.
           *
           * @param {string} base64Str The Base64 string.
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Base64.parse(base64String);
           */
          parse: function(base64Str) {
            var base64StrLength = base64Str.length;
            var map2 = this._map;
            var reverseMap = this._reverseMap;
            if (!reverseMap) {
              reverseMap = this._reverseMap = [];
              for (var j2 = 0; j2 < map2.length; j2++) {
                reverseMap[map2.charCodeAt(j2)] = j2;
              }
            }
            var paddingChar = map2.charAt(64);
            if (paddingChar) {
              var paddingIndex = base64Str.indexOf(paddingChar);
              if (paddingIndex !== -1) {
                base64StrLength = paddingIndex;
              }
            }
            return parseLoop(base64Str, base64StrLength, reverseMap);
          },
          _map: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="
        };
        function parseLoop(base64Str, base64StrLength, reverseMap) {
          var words = [];
          var nBytes = 0;
          for (var i4 = 0; i4 < base64StrLength; i4++) {
            if (i4 % 4) {
              var bits1 = reverseMap[base64Str.charCodeAt(i4 - 1)] << i4 % 4 * 2;
              var bits2 = reverseMap[base64Str.charCodeAt(i4)] >>> 6 - i4 % 4 * 2;
              var bitsCombined = bits1 | bits2;
              words[nBytes >>> 2] |= bitsCombined << 24 - nBytes % 4 * 8;
              nBytes++;
            }
          }
          return WordArray.create(words, nBytes);
        }
      })();
      return CryptoJS.enc.Base64;
    });
  }
});

// ../../node_modules/.pnpm/crypto-js@4.2.0/node_modules/crypto-js/enc-base64url.js
var require_enc_base64url = __commonJS({
  "../../node_modules/.pnpm/crypto-js@4.2.0/node_modules/crypto-js/enc-base64url.js"(exports, module) {
    (function(root, factory) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function() {
        var C3 = CryptoJS;
        var C_lib = C3.lib;
        var WordArray = C_lib.WordArray;
        var C_enc = C3.enc;
        var Base64url = C_enc.Base64url = {
          /**
           * Converts a word array to a Base64url string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @param {boolean} urlSafe Whether to use url safe
           *
           * @return {string} The Base64url string.
           *
           * @static
           *
           * @example
           *
           *     var base64String = CryptoJS.enc.Base64url.stringify(wordArray);
           */
          stringify: function(wordArray, urlSafe) {
            if (urlSafe === void 0) {
              urlSafe = true;
            }
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            var map2 = urlSafe ? this._safe_map : this._map;
            wordArray.clamp();
            var base64Chars = [];
            for (var i4 = 0; i4 < sigBytes; i4 += 3) {
              var byte1 = words[i4 >>> 2] >>> 24 - i4 % 4 * 8 & 255;
              var byte2 = words[i4 + 1 >>> 2] >>> 24 - (i4 + 1) % 4 * 8 & 255;
              var byte3 = words[i4 + 2 >>> 2] >>> 24 - (i4 + 2) % 4 * 8 & 255;
              var triplet = byte1 << 16 | byte2 << 8 | byte3;
              for (var j2 = 0; j2 < 4 && i4 + j2 * 0.75 < sigBytes; j2++) {
                base64Chars.push(map2.charAt(triplet >>> 6 * (3 - j2) & 63));
              }
            }
            var paddingChar = map2.charAt(64);
            if (paddingChar) {
              while (base64Chars.length % 4) {
                base64Chars.push(paddingChar);
              }
            }
            return base64Chars.join("");
          },
          /**
           * Converts a Base64url string to a word array.
           *
           * @param {string} base64Str The Base64url string.
           *
           * @param {boolean} urlSafe Whether to use url safe
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Base64url.parse(base64String);
           */
          parse: function(base64Str, urlSafe) {
            if (urlSafe === void 0) {
              urlSafe = true;
            }
            var base64StrLength = base64Str.length;
            var map2 = urlSafe ? this._safe_map : this._map;
            var reverseMap = this._reverseMap;
            if (!reverseMap) {
              reverseMap = this._reverseMap = [];
              for (var j2 = 0; j2 < map2.length; j2++) {
                reverseMap[map2.charCodeAt(j2)] = j2;
              }
            }
            var paddingChar = map2.charAt(64);
            if (paddingChar) {
              var paddingIndex = base64Str.indexOf(paddingChar);
              if (paddingIndex !== -1) {
                base64StrLength = paddingIndex;
              }
            }
            return parseLoop(base64Str, base64StrLength, reverseMap);
          },
          _map: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
          _safe_map: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"
        };
        function parseLoop(base64Str, base64StrLength, reverseMap) {
          var words = [];
          var nBytes = 0;
          for (var i4 = 0; i4 < base64StrLength; i4++) {
            if (i4 % 4) {
              var bits1 = reverseMap[base64Str.charCodeAt(i4 - 1)] << i4 % 4 * 2;
              var bits2 = reverseMap[base64Str.charCodeAt(i4)] >>> 6 - i4 % 4 * 2;
              var bitsCombined = bits1 | bits2;
              words[nBytes >>> 2] |= bitsCombined << 24 - nBytes % 4 * 8;
              nBytes++;
            }
          }
          return WordArray.create(words, nBytes);
        }
      })();
      return CryptoJS.enc.Base64url;
    });
  }
});

// ../../node_modules/.pnpm/crypto-js@4.2.0/node_modules/crypto-js/md5.js
var require_md53 = __commonJS({
  "../../node_modules/.pnpm/crypto-js@4.2.0/node_modules/crypto-js/md5.js"(exports, module) {
    (function(root, factory) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function(Math2) {
        var C3 = CryptoJS;
        var C_lib = C3.lib;
        var WordArray = C_lib.WordArray;
        var Hasher = C_lib.Hasher;
        var C_algo = C3.algo;
        var T3 = [];
        (function() {
          for (var i4 = 0; i4 < 64; i4++) {
            T3[i4] = Math2.abs(Math2.sin(i4 + 1)) * 4294967296 | 0;
          }
        })();
        var MD5 = C_algo.MD5 = Hasher.extend({
          _doReset: function() {
            this._hash = new WordArray.init([
              1732584193,
              4023233417,
              2562383102,
              271733878
            ]);
          },
          _doProcessBlock: function(M3, offset) {
            for (var i4 = 0; i4 < 16; i4++) {
              var offset_i = offset + i4;
              var M_offset_i = M3[offset_i];
              M3[offset_i] = (M_offset_i << 8 | M_offset_i >>> 24) & 16711935 | (M_offset_i << 24 | M_offset_i >>> 8) & 4278255360;
            }
            var H = this._hash.words;
            var M_offset_0 = M3[offset + 0];
            var M_offset_1 = M3[offset + 1];
            var M_offset_2 = M3[offset + 2];
            var M_offset_3 = M3[offset + 3];
            var M_offset_4 = M3[offset + 4];
            var M_offset_5 = M3[offset + 5];
            var M_offset_6 = M3[offset + 6];
            var M_offset_7 = M3[offset + 7];
            var M_offset_8 = M3[offset + 8];
            var M_offset_9 = M3[offset + 9];
            var M_offset_10 = M3[offset + 10];
            var M_offset_11 = M3[offset + 11];
            var M_offset_12 = M3[offset + 12];
            var M_offset_13 = M3[offset + 13];
            var M_offset_14 = M3[offset + 14];
            var M_offset_15 = M3[offset + 15];
            var a3 = H[0];
            var b4 = H[1];
            var c6 = H[2];
            var d4 = H[3];
            a3 = FF(a3, b4, c6, d4, M_offset_0, 7, T3[0]);
            d4 = FF(d4, a3, b4, c6, M_offset_1, 12, T3[1]);
            c6 = FF(c6, d4, a3, b4, M_offset_2, 17, T3[2]);
            b4 = FF(b4, c6, d4, a3, M_offset_3, 22, T3[3]);
            a3 = FF(a3, b4, c6, d4, M_offset_4, 7, T3[4]);
            d4 = FF(d4, a3, b4, c6, M_offset_5, 12, T3[5]);
            c6 = FF(c6, d4, a3, b4, M_offset_6, 17, T3[6]);
            b4 = FF(b4, c6, d4, a3, M_offset_7, 22, T3[7]);
            a3 = FF(a3, b4, c6, d4, M_offset_8, 7, T3[8]);
            d4 = FF(d4, a3, b4, c6, M_offset_9, 12, T3[9]);
            c6 = FF(c6, d4, a3, b4, M_offset_10, 17, T3[10]);
            b4 = FF(b4, c6, d4, a3, M_offset_11, 22, T3[11]);
            a3 = FF(a3, b4, c6, d4, M_offset_12, 7, T3[12]);
            d4 = FF(d4, a3, b4, c6, M_offset_13, 12, T3[13]);
            c6 = FF(c6, d4, a3, b4, M_offset_14, 17, T3[14]);
            b4 = FF(b4, c6, d4, a3, M_offset_15, 22, T3[15]);
            a3 = GG(a3, b4, c6, d4, M_offset_1, 5, T3[16]);
            d4 = GG(d4, a3, b4, c6, M_offset_6, 9, T3[17]);
            c6 = GG(c6, d4, a3, b4, M_offset_11, 14, T3[18]);
            b4 = GG(b4, c6, d4, a3, M_offset_0, 20, T3[19]);
            a3 = GG(a3, b4, c6, d4, M_offset_5, 5, T3[20]);
            d4 = GG(d4, a3, b4, c6, M_offset_10, 9, T3[21]);
            c6 = GG(c6, d4, a3, b4, M_offset_15, 14, T3[22]);
            b4 = GG(b4, c6, d4, a3, M_offset_4, 20, T3[23]);
            a3 = GG(a3, b4, c6, d4, M_offset_9, 5, T3[24]);
            d4 = GG(d4, a3, b4, c6, M_offset_14, 9, T3[25]);
            c6 = GG(c6, d4, a3, b4, M_offset_3, 14, T3[26]);
            b4 = GG(b4, c6, d4, a3, M_offset_8, 20, T3[27]);
            a3 = GG(a3, b4, c6, d4, M_offset_13, 5, T3[28]);
            d4 = GG(d4, a3, b4, c6, M_offset_2, 9, T3[29]);
            c6 = GG(c6, d4, a3, b4, M_offset_7, 14, T3[30]);
            b4 = GG(b4, c6, d4, a3, M_offset_12, 20, T3[31]);
            a3 = HH(a3, b4, c6, d4, M_offset_5, 4, T3[32]);
            d4 = HH(d4, a3, b4, c6, M_offset_8, 11, T3[33]);
            c6 = HH(c6, d4, a3, b4, M_offset_11, 16, T3[34]);
            b4 = HH(b4, c6, d4, a3, M_offset_14, 23, T3[35]);
            a3 = HH(a3, b4, c6, d4, M_offset_1, 4, T3[36]);
            d4 = HH(d4, a3, b4, c6, M_offset_4, 11, T3[37]);
            c6 = HH(c6, d4, a3, b4, M_offset_7, 16, T3[38]);
            b4 = HH(b4, c6, d4, a3, M_offset_10, 23, T3[39]);
            a3 = HH(a3, b4, c6, d4, M_offset_13, 4, T3[40]);
            d4 = HH(d4, a3, b4, c6, M_offset_0, 11, T3[41]);
            c6 = HH(c6, d4, a3, b4, M_offset_3, 16, T3[42]);
            b4 = HH(b4, c6, d4, a3, M_offset_6, 23, T3[43]);
            a3 = HH(a3, b4, c6, d4, M_offset_9, 4, T3[44]);
            d4 = HH(d4, a3, b4, c6, M_offset_12, 11, T3[45]);
            c6 = HH(c6, d4, a3, b4, M_offset_15, 16, T3[46]);
            b4 = HH(b4, c6, d4, a3, M_offset_2, 23, T3[47]);
            a3 = II(a3, b4, c6, d4, M_offset_0, 6, T3[48]);
            d4 = II(d4, a3, b4, c6, M_offset_7, 10, T3[49]);
            c6 = II(c6, d4, a3, b4, M_offset_14, 15, T3[50]);
            b4 = II(b4, c6, d4, a3, M_offset_5, 21, T3[51]);
            a3 = II(a3, b4, c6, d4, M_offset_12, 6, T3[52]);
            d4 = II(d4, a3, b4, c6, M_offset_3, 10, T3[53]);
            c6 = II(c6, d4, a3, b4, M_offset_10, 15, T3[54]);
            b4 = II(b4, c6, d4, a3, M_offset_1, 21, T3[55]);
            a3 = II(a3, b4, c6, d4, M_offset_8, 6, T3[56]);
            d4 = II(d4, a3, b4, c6, M_offset_15, 10, T3[57]);
            c6 = II(c6, d4, a3, b4, M_offset_6, 15, T3[58]);
            b4 = II(b4, c6, d4, a3, M_offset_13, 21, T3[59]);
            a3 = II(a3, b4, c6, d4, M_offset_4, 6, T3[60]);
            d4 = II(d4, a3, b4, c6, M_offset_11, 10, T3[61]);
            c6 = II(c6, d4, a3, b4, M_offset_2, 15, T3[62]);
            b4 = II(b4, c6, d4, a3, M_offset_9, 21, T3[63]);
            H[0] = H[0] + a3 | 0;
            H[1] = H[1] + b4 | 0;
            H[2] = H[2] + c6 | 0;
            H[3] = H[3] + d4 | 0;
          },
          _doFinalize: function() {
            var data = this._data;
            var dataWords = data.words;
            var nBitsTotal = this._nDataBytes * 8;
            var nBitsLeft = data.sigBytes * 8;
            dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
            var nBitsTotalH = Math2.floor(nBitsTotal / 4294967296);
            var nBitsTotalL = nBitsTotal;
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 15] = (nBitsTotalH << 8 | nBitsTotalH >>> 24) & 16711935 | (nBitsTotalH << 24 | nBitsTotalH >>> 8) & 4278255360;
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = (nBitsTotalL << 8 | nBitsTotalL >>> 24) & 16711935 | (nBitsTotalL << 24 | nBitsTotalL >>> 8) & 4278255360;
            data.sigBytes = (dataWords.length + 1) * 4;
            this._process();
            var hash = this._hash;
            var H = hash.words;
            for (var i4 = 0; i4 < 4; i4++) {
              var H_i = H[i4];
              H[i4] = (H_i << 8 | H_i >>> 24) & 16711935 | (H_i << 24 | H_i >>> 8) & 4278255360;
            }
            return hash;
          },
          clone: function() {
            var clone = Hasher.clone.call(this);
            clone._hash = this._hash.clone();
            return clone;
          }
        });
        function FF(a3, b4, c6, d4, x4, s3, t) {
          var n5 = a3 + (b4 & c6 | ~b4 & d4) + x4 + t;
          return (n5 << s3 | n5 >>> 32 - s3) + b4;
        }
        function GG(a3, b4, c6, d4, x4, s3, t) {
          var n5 = a3 + (b4 & d4 | c6 & ~d4) + x4 + t;
          return (n5 << s3 | n5 >>> 32 - s3) + b4;
        }
        function HH(a3, b4, c6, d4, x4, s3, t) {
          var n5 = a3 + (b4 ^ c6 ^ d4) + x4 + t;
          return (n5 << s3 | n5 >>> 32 - s3) + b4;
        }
        function II(a3, b4, c6, d4, x4, s3, t) {
          var n5 = a3 + (c6 ^ (b4 | ~d4)) + x4 + t;
          return (n5 << s3 | n5 >>> 32 - s3) + b4;
        }
        C3.MD5 = Hasher._createHelper(MD5);
        C3.HmacMD5 = Hasher._createHmacHelper(MD5);
      })(Math);
      return CryptoJS.MD5;
    });
  }
});

// ../../node_modules/.pnpm/crypto-js@4.2.0/node_modules/crypto-js/sha1.js
var require_sha1 = __commonJS({
  "../../node_modules/.pnpm/crypto-js@4.2.0/node_modules/crypto-js/sha1.js"(exports, module) {
    (function(root, factory) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function() {
        var C3 = CryptoJS;
        var C_lib = C3.lib;
        var WordArray = C_lib.WordArray;
        var Hasher = C_lib.Hasher;
        var C_algo = C3.algo;
        var W2 = [];
        var SHA1 = C_algo.SHA1 = Hasher.extend({
          _doReset: function() {
            this._hash = new WordArray.init([
              1732584193,
              4023233417,
              2562383102,
              271733878,
              3285377520
            ]);
          },
          _doProcessBlock: function(M3, offset) {
            var H = this._hash.words;
            var a3 = H[0];
            var b4 = H[1];
            var c6 = H[2];
            var d4 = H[3];
            var e2 = H[4];
            for (var i4 = 0; i4 < 80; i4++) {
              if (i4 < 16) {
                W2[i4] = M3[offset + i4] | 0;
              } else {
                var n5 = W2[i4 - 3] ^ W2[i4 - 8] ^ W2[i4 - 14] ^ W2[i4 - 16];
                W2[i4] = n5 << 1 | n5 >>> 31;
              }
              var t = (a3 << 5 | a3 >>> 27) + e2 + W2[i4];
              if (i4 < 20) {
                t += (b4 & c6 | ~b4 & d4) + 1518500249;
              } else if (i4 < 40) {
                t += (b4 ^ c6 ^ d4) + 1859775393;
              } else if (i4 < 60) {
                t += (b4 & c6 | b4 & d4 | c6 & d4) - 1894007588;
              } else {
                t += (b4 ^ c6 ^ d4) - 899497514;
              }
              e2 = d4;
              d4 = c6;
              c6 = b4 << 30 | b4 >>> 2;
              b4 = a3;
              a3 = t;
            }
            H[0] = H[0] + a3 | 0;
            H[1] = H[1] + b4 | 0;
            H[2] = H[2] + c6 | 0;
            H[3] = H[3] + d4 | 0;
            H[4] = H[4] + e2 | 0;
          },
          _doFinalize: function() {
            var data = this._data;
            var dataWords = data.words;
            var nBitsTotal = this._nDataBytes * 8;
            var nBitsLeft = data.sigBytes * 8;
            dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = Math.floor(nBitsTotal / 4294967296);
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 15] = nBitsTotal;
            data.sigBytes = dataWords.length * 4;
            this._process();
            return this._hash;
          },
          clone: function() {
            var clone = Hasher.clone.call(this);
            clone._hash = this._hash.clone();
            return clone;
          }
        });
        C3.SHA1 = Hasher._createHelper(SHA1);
        C3.HmacSHA1 = Hasher._createHmacHelper(SHA1);
      })();
      return CryptoJS.SHA1;
    });
  }
});

// ../../node_modules/.pnpm/crypto-js@4.2.0/node_modules/crypto-js/sha256.js
var require_sha2562 = __commonJS({
  "../../node_modules/.pnpm/crypto-js@4.2.0/node_modules/crypto-js/sha256.js"(exports, module) {
    (function(root, factory) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function(Math2) {
        var C3 = CryptoJS;
        var C_lib = C3.lib;
        var WordArray = C_lib.WordArray;
        var Hasher = C_lib.Hasher;
        var C_algo = C3.algo;
        var H = [];
        var K2 = [];
        (function() {
          function isPrime(n6) {
            var sqrtN = Math2.sqrt(n6);
            for (var factor = 2; factor <= sqrtN; factor++) {
              if (!(n6 % factor)) {
                return false;
              }
            }
            return true;
          }
          function getFractionalBits(n6) {
            return (n6 - (n6 | 0)) * 4294967296 | 0;
          }
          var n5 = 2;
          var nPrime = 0;
          while (nPrime < 64) {
            if (isPrime(n5)) {
              if (nPrime < 8) {
                H[nPrime] = getFractionalBits(Math2.pow(n5, 1 / 2));
              }
              K2[nPrime] = getFractionalBits(Math2.pow(n5, 1 / 3));
              nPrime++;
            }
            n5++;
          }
        })();
        var W2 = [];
        var SHA256 = C_algo.SHA256 = Hasher.extend({
          _doReset: function() {
            this._hash = new WordArray.init(H.slice(0));
          },
          _doProcessBlock: function(M3, offset) {
            var H2 = this._hash.words;
            var a3 = H2[0];
            var b4 = H2[1];
            var c6 = H2[2];
            var d4 = H2[3];
            var e2 = H2[4];
            var f6 = H2[5];
            var g3 = H2[6];
            var h5 = H2[7];
            for (var i4 = 0; i4 < 64; i4++) {
              if (i4 < 16) {
                W2[i4] = M3[offset + i4] | 0;
              } else {
                var gamma0x = W2[i4 - 15];
                var gamma0 = (gamma0x << 25 | gamma0x >>> 7) ^ (gamma0x << 14 | gamma0x >>> 18) ^ gamma0x >>> 3;
                var gamma1x = W2[i4 - 2];
                var gamma1 = (gamma1x << 15 | gamma1x >>> 17) ^ (gamma1x << 13 | gamma1x >>> 19) ^ gamma1x >>> 10;
                W2[i4] = gamma0 + W2[i4 - 7] + gamma1 + W2[i4 - 16];
              }
              var ch = e2 & f6 ^ ~e2 & g3;
              var maj = a3 & b4 ^ a3 & c6 ^ b4 & c6;
              var sigma0 = (a3 << 30 | a3 >>> 2) ^ (a3 << 19 | a3 >>> 13) ^ (a3 << 10 | a3 >>> 22);
              var sigma1 = (e2 << 26 | e2 >>> 6) ^ (e2 << 21 | e2 >>> 11) ^ (e2 << 7 | e2 >>> 25);
              var t1 = h5 + sigma1 + ch + K2[i4] + W2[i4];
              var t2 = sigma0 + maj;
              h5 = g3;
              g3 = f6;
              f6 = e2;
              e2 = d4 + t1 | 0;
              d4 = c6;
              c6 = b4;
              b4 = a3;
              a3 = t1 + t2 | 0;
            }
            H2[0] = H2[0] + a3 | 0;
            H2[1] = H2[1] + b4 | 0;
            H2[2] = H2[2] + c6 | 0;
            H2[3] = H2[3] + d4 | 0;
            H2[4] = H2[4] + e2 | 0;
            H2[5] = H2[5] + f6 | 0;
            H2[6] = H2[6] + g3 | 0;
            H2[7] = H2[7] + h5 | 0;
          },
          _doFinalize: function() {
            var data = this._data;
            var dataWords = data.words;
            var nBitsTotal = this._nDataBytes * 8;
            var nBitsLeft = data.sigBytes * 8;
            dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = Math2.floor(nBitsTotal / 4294967296);
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 15] = nBitsTotal;
            data.sigBytes = dataWords.length * 4;
            this._process();
            return this._hash;
          },
          clone: function() {
            var clone = Hasher.clone.call(this);
            clone._hash = this._hash.clone();
            return clone;
          }
        });
        C3.SHA256 = Hasher._createHelper(SHA256);
        C3.HmacSHA256 = Hasher._createHmacHelper(SHA256);
      })(Math);
      return CryptoJS.SHA256;
    });
  }
});

// ../../node_modules/.pnpm/crypto-js@4.2.0/node_modules/crypto-js/sha224.js
var require_sha224 = __commonJS({
  "../../node_modules/.pnpm/crypto-js@4.2.0/node_modules/crypto-js/sha224.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_sha2562());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./sha256"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function() {
        var C3 = CryptoJS;
        var C_lib = C3.lib;
        var WordArray = C_lib.WordArray;
        var C_algo = C3.algo;
        var SHA256 = C_algo.SHA256;
        var SHA224 = C_algo.SHA224 = SHA256.extend({
          _doReset: function() {
            this._hash = new WordArray.init([
              3238371032,
              914150663,
              812702999,
              4144912697,
              4290775857,
              1750603025,
              1694076839,
              3204075428
            ]);
          },
          _doFinalize: function() {
            var hash = SHA256._doFinalize.call(this);
            hash.sigBytes -= 4;
            return hash;
          }
        });
        C3.SHA224 = SHA256._createHelper(SHA224);
        C3.HmacSHA224 = SHA256._createHmacHelper(SHA224);
      })();
      return CryptoJS.SHA224;
    });
  }
});

// ../../node_modules/.pnpm/crypto-js@4.2.0/node_modules/crypto-js/sha512.js
var require_sha5122 = __commonJS({
  "../../node_modules/.pnpm/crypto-js@4.2.0/node_modules/crypto-js/sha512.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_x64_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./x64-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function() {
        var C3 = CryptoJS;
        var C_lib = C3.lib;
        var Hasher = C_lib.Hasher;
        var C_x64 = C3.x64;
        var X64Word = C_x64.Word;
        var X64WordArray = C_x64.WordArray;
        var C_algo = C3.algo;
        function X64Word_create() {
          return X64Word.create.apply(X64Word, arguments);
        }
        var K2 = [
          X64Word_create(1116352408, 3609767458),
          X64Word_create(1899447441, 602891725),
          X64Word_create(3049323471, 3964484399),
          X64Word_create(3921009573, 2173295548),
          X64Word_create(961987163, 4081628472),
          X64Word_create(1508970993, 3053834265),
          X64Word_create(2453635748, 2937671579),
          X64Word_create(2870763221, 3664609560),
          X64Word_create(3624381080, 2734883394),
          X64Word_create(310598401, 1164996542),
          X64Word_create(607225278, 1323610764),
          X64Word_create(1426881987, 3590304994),
          X64Word_create(1925078388, 4068182383),
          X64Word_create(2162078206, 991336113),
          X64Word_create(2614888103, 633803317),
          X64Word_create(3248222580, 3479774868),
          X64Word_create(3835390401, 2666613458),
          X64Word_create(4022224774, 944711139),
          X64Word_create(264347078, 2341262773),
          X64Word_create(604807628, 2007800933),
          X64Word_create(770255983, 1495990901),
          X64Word_create(1249150122, 1856431235),
          X64Word_create(1555081692, 3175218132),
          X64Word_create(1996064986, 2198950837),
          X64Word_create(2554220882, 3999719339),
          X64Word_create(2821834349, 766784016),
          X64Word_create(2952996808, 2566594879),
          X64Word_create(3210313671, 3203337956),
          X64Word_create(3336571891, 1034457026),
          X64Word_create(3584528711, 2466948901),
          X64Word_create(113926993, 3758326383),
          X64Word_create(338241895, 168717936),
          X64Word_create(666307205, 1188179964),
          X64Word_create(773529912, 1546045734),
          X64Word_create(1294757372, 1522805485),
          X64Word_create(1396182291, 2643833823),
          X64Word_create(1695183700, 2343527390),
          X64Word_create(1986661051, 1014477480),
          X64Word_create(2177026350, 1206759142),
          X64Word_create(2456956037, 344077627),
          X64Word_create(2730485921, 1290863460),
          X64Word_create(2820302411, 3158454273),
          X64Word_create(3259730800, 3505952657),
          X64Word_create(3345764771, 106217008),
          X64Word_create(3516065817, 3606008344),
          X64Word_create(3600352804, 1432725776),
          X64Word_create(4094571909, 1467031594),
          X64Word_create(275423344, 851169720),
          X64Word_create(430227734, 3100823752),
          X64Word_create(506948616, 1363258195),
          X64Word_create(659060556, 3750685593),
          X64Word_create(883997877, 3785050280),
          X64Word_create(958139571, 3318307427),
          X64Word_create(1322822218, 3812723403),
          X64Word_create(1537002063, 2003034995),
          X64Word_create(1747873779, 3602036899),
          X64Word_create(1955562222, 1575990012),
          X64Word_create(2024104815, 1125592928),
          X64Word_create(2227730452, 2716904306),
          X64Word_create(2361852424, 442776044),
          X64Word_create(2428436474, 593698344),
          X64Word_create(2756734187, 3733110249),
          X64Word_create(3204031479, 2999351573),
          X64Word_create(3329325298, 3815920427),
          X64Word_create(3391569614, 3928383900),
          X64Word_create(3515267271, 566280711),
          X64Word_create(3940187606, 3454069534),
          X64Word_create(4118630271, 4000239992),
          X64Word_create(116418474, 1914138554),
          X64Word_create(174292421, 2731055270),
          X64Word_create(289380356, 3203993006),
          X64Word_create(460393269, 320620315),
          X64Word_create(685471733, 587496836),
          X64Word_create(852142971, 1086792851),
          X64Word_create(1017036298, 365543100),
          X64Word_create(1126000580, 2618297676),
          X64Word_create(1288033470, 3409855158),
          X64Word_create(1501505948, 4234509866),
          X64Word_create(1607167915, 987167468),
          X64Word_create(1816402316, 1246189591)
        ];
        var W2 = [];
        (function() {
          for (var i4 = 0; i4 < 80; i4++) {
            W2[i4] = X64Word_create();
          }
        })();
        var SHA512 = C_algo.SHA512 = Hasher.extend({
          _doReset: function() {
            this._hash = new X64WordArray.init([
              new X64Word.init(1779033703, 4089235720),
              new X64Word.init(3144134277, 2227873595),
              new X64Word.init(1013904242, 4271175723),
              new X64Word.init(2773480762, 1595750129),
              new X64Word.init(1359893119, 2917565137),
              new X64Word.init(2600822924, 725511199),
              new X64Word.init(528734635, 4215389547),
              new X64Word.init(1541459225, 327033209)
            ]);
          },
          _doProcessBlock: function(M3, offset) {
            var H = this._hash.words;
            var H0 = H[0];
            var H1 = H[1];
            var H2 = H[2];
            var H3 = H[3];
            var H4 = H[4];
            var H5 = H[5];
            var H6 = H[6];
            var H7 = H[7];
            var H0h = H0.high;
            var H0l = H0.low;
            var H1h = H1.high;
            var H1l = H1.low;
            var H2h = H2.high;
            var H2l = H2.low;
            var H3h = H3.high;
            var H3l = H3.low;
            var H4h = H4.high;
            var H4l = H4.low;
            var H5h = H5.high;
            var H5l = H5.low;
            var H6h = H6.high;
            var H6l = H6.low;
            var H7h = H7.high;
            var H7l = H7.low;
            var ah = H0h;
            var al = H0l;
            var bh = H1h;
            var bl = H1l;
            var ch = H2h;
            var cl = H2l;
            var dh = H3h;
            var dl = H3l;
            var eh = H4h;
            var el = H4l;
            var fh = H5h;
            var fl = H5l;
            var gh = H6h;
            var gl = H6l;
            var hh = H7h;
            var hl = H7l;
            for (var i4 = 0; i4 < 80; i4++) {
              var Wil;
              var Wih;
              var Wi2 = W2[i4];
              if (i4 < 16) {
                Wih = Wi2.high = M3[offset + i4 * 2] | 0;
                Wil = Wi2.low = M3[offset + i4 * 2 + 1] | 0;
              } else {
                var gamma0x = W2[i4 - 15];
                var gamma0xh = gamma0x.high;
                var gamma0xl = gamma0x.low;
                var gamma0h = (gamma0xh >>> 1 | gamma0xl << 31) ^ (gamma0xh >>> 8 | gamma0xl << 24) ^ gamma0xh >>> 7;
                var gamma0l = (gamma0xl >>> 1 | gamma0xh << 31) ^ (gamma0xl >>> 8 | gamma0xh << 24) ^ (gamma0xl >>> 7 | gamma0xh << 25);
                var gamma1x = W2[i4 - 2];
                var gamma1xh = gamma1x.high;
                var gamma1xl = gamma1x.low;
                var gamma1h = (gamma1xh >>> 19 | gamma1xl << 13) ^ (gamma1xh << 3 | gamma1xl >>> 29) ^ gamma1xh >>> 6;
                var gamma1l = (gamma1xl >>> 19 | gamma1xh << 13) ^ (gamma1xl << 3 | gamma1xh >>> 29) ^ (gamma1xl >>> 6 | gamma1xh << 26);
                var Wi7 = W2[i4 - 7];
                var Wi7h = Wi7.high;
                var Wi7l = Wi7.low;
                var Wi16 = W2[i4 - 16];
                var Wi16h = Wi16.high;
                var Wi16l = Wi16.low;
                Wil = gamma0l + Wi7l;
                Wih = gamma0h + Wi7h + (Wil >>> 0 < gamma0l >>> 0 ? 1 : 0);
                Wil = Wil + gamma1l;
                Wih = Wih + gamma1h + (Wil >>> 0 < gamma1l >>> 0 ? 1 : 0);
                Wil = Wil + Wi16l;
                Wih = Wih + Wi16h + (Wil >>> 0 < Wi16l >>> 0 ? 1 : 0);
                Wi2.high = Wih;
                Wi2.low = Wil;
              }
              var chh = eh & fh ^ ~eh & gh;
              var chl = el & fl ^ ~el & gl;
              var majh = ah & bh ^ ah & ch ^ bh & ch;
              var majl = al & bl ^ al & cl ^ bl & cl;
              var sigma0h = (ah >>> 28 | al << 4) ^ (ah << 30 | al >>> 2) ^ (ah << 25 | al >>> 7);
              var sigma0l = (al >>> 28 | ah << 4) ^ (al << 30 | ah >>> 2) ^ (al << 25 | ah >>> 7);
              var sigma1h = (eh >>> 14 | el << 18) ^ (eh >>> 18 | el << 14) ^ (eh << 23 | el >>> 9);
              var sigma1l = (el >>> 14 | eh << 18) ^ (el >>> 18 | eh << 14) ^ (el << 23 | eh >>> 9);
              var Ki2 = K2[i4];
              var Kih = Ki2.high;
              var Kil = Ki2.low;
              var t1l = hl + sigma1l;
              var t1h = hh + sigma1h + (t1l >>> 0 < hl >>> 0 ? 1 : 0);
              var t1l = t1l + chl;
              var t1h = t1h + chh + (t1l >>> 0 < chl >>> 0 ? 1 : 0);
              var t1l = t1l + Kil;
              var t1h = t1h + Kih + (t1l >>> 0 < Kil >>> 0 ? 1 : 0);
              var t1l = t1l + Wil;
              var t1h = t1h + Wih + (t1l >>> 0 < Wil >>> 0 ? 1 : 0);
              var t2l = sigma0l + majl;
              var t2h = sigma0h + majh + (t2l >>> 0 < sigma0l >>> 0 ? 1 : 0);
              hh = gh;
              hl = gl;
              gh = fh;
              gl = fl;
              fh = eh;
              fl = el;
              el = dl + t1l | 0;
              eh = dh + t1h + (el >>> 0 < dl >>> 0 ? 1 : 0) | 0;
              dh = ch;
              dl = cl;
              ch = bh;
              cl = bl;
              bh = ah;
              bl = al;
              al = t1l + t2l | 0;
              ah = t1h + t2h + (al >>> 0 < t1l >>> 0 ? 1 : 0) | 0;
            }
            H0l = H0.low = H0l + al;
            H0.high = H0h + ah + (H0l >>> 0 < al >>> 0 ? 1 : 0);
            H1l = H1.low = H1l + bl;
            H1.high = H1h + bh + (H1l >>> 0 < bl >>> 0 ? 1 : 0);
            H2l = H2.low = H2l + cl;
            H2.high = H2h + ch + (H2l >>> 0 < cl >>> 0 ? 1 : 0);
            H3l = H3.low = H3l + dl;
            H3.high = H3h + dh + (H3l >>> 0 < dl >>> 0 ? 1 : 0);
            H4l = H4.low = H4l + el;
            H4.high = H4h + eh + (H4l >>> 0 < el >>> 0 ? 1 : 0);
            H5l = H5.low = H5l + fl;
            H5.high = H5h + fh + (H5l >>> 0 < fl >>> 0 ? 1 : 0);
            H6l = H6.low = H6l + gl;
            H6.high = H6h + gh + (H6l >>> 0 < gl >>> 0 ? 1 : 0);
            H7l = H7.low = H7l + hl;
            H7.high = H7h + hh + (H7l >>> 0 < hl >>> 0 ? 1 : 0);
          },
          _doFinalize: function() {
            var data = this._data;
            var dataWords = data.words;
            var nBitsTotal = this._nDataBytes * 8;
            var nBitsLeft = data.sigBytes * 8;
            dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
            dataWords[(nBitsLeft + 128 >>> 10 << 5) + 30] = Math.floor(nBitsTotal / 4294967296);
            dataWords[(nBitsLeft + 128 >>> 10 << 5) + 31] = nBitsTotal;
            data.sigBytes = dataWords.length * 4;
            this._process();
            var hash = this._hash.toX32();
            return hash;
          },
          clone: function() {
            var clone = Hasher.clone.call(this);
            clone._hash = this._hash.clone();
            return clone;
          },
          blockSize: 1024 / 32
        });
        C3.SHA512 = Hasher._createHelper(SHA512);
        C3.HmacSHA512 = Hasher._createHmacHelper(SHA512);
      })();
      return CryptoJS.SHA512;
    });
  }
});

// ../../node_modules/.pnpm/crypto-js@4.2.0/node_modules/crypto-js/sha384.js
var require_sha384 = __commonJS({
  "../../node_modules/.pnpm/crypto-js@4.2.0/node_modules/crypto-js/sha384.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_x64_core(), require_sha5122());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./x64-core", "./sha512"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function() {
        var C3 = CryptoJS;
        var C_x64 = C3.x64;
        var X64Word = C_x64.Word;
        var X64WordArray = C_x64.WordArray;
        var C_algo = C3.algo;
        var SHA512 = C_algo.SHA512;
        var SHA384 = C_algo.SHA384 = SHA512.extend({
          _doReset: function() {
            this._hash = new X64WordArray.init([
              new X64Word.init(3418070365, 3238371032),
              new X64Word.init(1654270250, 914150663),
              new X64Word.init(2438529370, 812702999),
              new X64Word.init(355462360, 4144912697),
              new X64Word.init(1731405415, 4290775857),
              new X64Word.init(2394180231, 1750603025),
              new X64Word.init(3675008525, 1694076839),
              new X64Word.init(1203062813, 3204075428)
            ]);
          },
          _doFinalize: function() {
            var hash = SHA512._doFinalize.call(this);
            hash.sigBytes -= 16;
            return hash;
          }
        });
        C3.SHA384 = SHA512._createHelper(SHA384);
        C3.HmacSHA384 = SHA512._createHmacHelper(SHA384);
      })();
      return CryptoJS.SHA384;
    });
  }
});

// ../../node_modules/.pnpm/crypto-js@4.2.0/node_modules/crypto-js/sha3.js
var require_sha32 = __commonJS({
  "../../node_modules/.pnpm/crypto-js@4.2.0/node_modules/crypto-js/sha3.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_x64_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./x64-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function(Math2) {
        var C3 = CryptoJS;
        var C_lib = C3.lib;
        var WordArray = C_lib.WordArray;
        var Hasher = C_lib.Hasher;
        var C_x64 = C3.x64;
        var X64Word = C_x64.Word;
        var C_algo = C3.algo;
        var RHO_OFFSETS = [];
        var PI_INDEXES = [];
        var ROUND_CONSTANTS = [];
        (function() {
          var x4 = 1, y5 = 0;
          for (var t = 0; t < 24; t++) {
            RHO_OFFSETS[x4 + 5 * y5] = (t + 1) * (t + 2) / 2 % 64;
            var newX = y5 % 5;
            var newY = (2 * x4 + 3 * y5) % 5;
            x4 = newX;
            y5 = newY;
          }
          for (var x4 = 0; x4 < 5; x4++) {
            for (var y5 = 0; y5 < 5; y5++) {
              PI_INDEXES[x4 + 5 * y5] = y5 + (2 * x4 + 3 * y5) % 5 * 5;
            }
          }
          var LFSR = 1;
          for (var i4 = 0; i4 < 24; i4++) {
            var roundConstantMsw = 0;
            var roundConstantLsw = 0;
            for (var j2 = 0; j2 < 7; j2++) {
              if (LFSR & 1) {
                var bitPosition = (1 << j2) - 1;
                if (bitPosition < 32) {
                  roundConstantLsw ^= 1 << bitPosition;
                } else {
                  roundConstantMsw ^= 1 << bitPosition - 32;
                }
              }
              if (LFSR & 128) {
                LFSR = LFSR << 1 ^ 113;
              } else {
                LFSR <<= 1;
              }
            }
            ROUND_CONSTANTS[i4] = X64Word.create(roundConstantMsw, roundConstantLsw);
          }
        })();
        var T3 = [];
        (function() {
          for (var i4 = 0; i4 < 25; i4++) {
            T3[i4] = X64Word.create();
          }
        })();
        var SHA3 = C_algo.SHA3 = Hasher.extend({
          /**
           * Configuration options.
           *
           * @property {number} outputLength
           *   The desired number of bits in the output hash.
           *   Only values permitted are: 224, 256, 384, 512.
           *   Default: 512
           */
          cfg: Hasher.cfg.extend({
            outputLength: 512
          }),
          _doReset: function() {
            var state = this._state = [];
            for (var i4 = 0; i4 < 25; i4++) {
              state[i4] = new X64Word.init();
            }
            this.blockSize = (1600 - 2 * this.cfg.outputLength) / 32;
          },
          _doProcessBlock: function(M3, offset) {
            var state = this._state;
            var nBlockSizeLanes = this.blockSize / 2;
            for (var i4 = 0; i4 < nBlockSizeLanes; i4++) {
              var M2i = M3[offset + 2 * i4];
              var M2i1 = M3[offset + 2 * i4 + 1];
              M2i = (M2i << 8 | M2i >>> 24) & 16711935 | (M2i << 24 | M2i >>> 8) & 4278255360;
              M2i1 = (M2i1 << 8 | M2i1 >>> 24) & 16711935 | (M2i1 << 24 | M2i1 >>> 8) & 4278255360;
              var lane = state[i4];
              lane.high ^= M2i1;
              lane.low ^= M2i;
            }
            for (var round = 0; round < 24; round++) {
              for (var x4 = 0; x4 < 5; x4++) {
                var tMsw = 0, tLsw = 0;
                for (var y5 = 0; y5 < 5; y5++) {
                  var lane = state[x4 + 5 * y5];
                  tMsw ^= lane.high;
                  tLsw ^= lane.low;
                }
                var Tx = T3[x4];
                Tx.high = tMsw;
                Tx.low = tLsw;
              }
              for (var x4 = 0; x4 < 5; x4++) {
                var Tx4 = T3[(x4 + 4) % 5];
                var Tx1 = T3[(x4 + 1) % 5];
                var Tx1Msw = Tx1.high;
                var Tx1Lsw = Tx1.low;
                var tMsw = Tx4.high ^ (Tx1Msw << 1 | Tx1Lsw >>> 31);
                var tLsw = Tx4.low ^ (Tx1Lsw << 1 | Tx1Msw >>> 31);
                for (var y5 = 0; y5 < 5; y5++) {
                  var lane = state[x4 + 5 * y5];
                  lane.high ^= tMsw;
                  lane.low ^= tLsw;
                }
              }
              for (var laneIndex = 1; laneIndex < 25; laneIndex++) {
                var tMsw;
                var tLsw;
                var lane = state[laneIndex];
                var laneMsw = lane.high;
                var laneLsw = lane.low;
                var rhoOffset = RHO_OFFSETS[laneIndex];
                if (rhoOffset < 32) {
                  tMsw = laneMsw << rhoOffset | laneLsw >>> 32 - rhoOffset;
                  tLsw = laneLsw << rhoOffset | laneMsw >>> 32 - rhoOffset;
                } else {
                  tMsw = laneLsw << rhoOffset - 32 | laneMsw >>> 64 - rhoOffset;
                  tLsw = laneMsw << rhoOffset - 32 | laneLsw >>> 64 - rhoOffset;
                }
                var TPiLane = T3[PI_INDEXES[laneIndex]];
                TPiLane.high = tMsw;
                TPiLane.low = tLsw;
              }
              var T0 = T3[0];
              var state0 = state[0];
              T0.high = state0.high;
              T0.low = state0.low;
              for (var x4 = 0; x4 < 5; x4++) {
                for (var y5 = 0; y5 < 5; y5++) {
                  var laneIndex = x4 + 5 * y5;
                  var lane = state[laneIndex];
                  var TLane = T3[laneIndex];
                  var Tx1Lane = T3[(x4 + 1) % 5 + 5 * y5];
                  var Tx2Lane = T3[(x4 + 2) % 5 + 5 * y5];
                  lane.high = TLane.high ^ ~Tx1Lane.high & Tx2Lane.high;
                  lane.low = TLane.low ^ ~Tx1Lane.low & Tx2Lane.low;
                }
              }
              var lane = state[0];
              var roundConstant = ROUND_CONSTANTS[round];
              lane.high ^= roundConstant.high;
              lane.low ^= roundConstant.low;
            }
          },
          _doFinalize: function() {
            var data = this._data;
            var dataWords = data.words;
            var nBitsTotal = this._nDataBytes * 8;
            var nBitsLeft = data.sigBytes * 8;
            var blockSizeBits = this.blockSize * 32;
            dataWords[nBitsLeft >>> 5] |= 1 << 24 - nBitsLeft % 32;
            dataWords[(Math2.ceil((nBitsLeft + 1) / blockSizeBits) * blockSizeBits >>> 5) - 1] |= 128;
            data.sigBytes = dataWords.length * 4;
            this._process();
            var state = this._state;
            var outputLengthBytes = this.cfg.outputLength / 8;
            var outputLengthLanes = outputLengthBytes / 8;
            var hashWords = [];
            for (var i4 = 0; i4 < outputLengthLanes; i4++) {
              var lane = state[i4];
              var laneMsw = lane.high;
              var laneLsw = lane.low;
              laneMsw = (laneMsw << 8 | laneMsw >>> 24) & 16711935 | (laneMsw << 24 | laneMsw >>> 8) & 4278255360;
              laneLsw = (laneLsw << 8 | laneLsw >>> 24) & 16711935 | (laneLsw << 24 | laneLsw >>> 8) & 4278255360;
              hashWords.push(laneLsw);
              hashWords.push(laneMsw);
            }
            return new WordArray.init(hashWords, outputLengthBytes);
          },
          clone: function() {
            var clone = Hasher.clone.call(this);
            var state = clone._state = this._state.slice(0);
            for (var i4 = 0; i4 < 25; i4++) {
              state[i4] = state[i4].clone();
            }
            return clone;
          }
        });
        C3.SHA3 = Hasher._createHelper(SHA3);
        C3.HmacSHA3 = Hasher._createHmacHelper(SHA3);
      })(Math);
      return CryptoJS.SHA3;
    });
  }
});

// ../../node_modules/.pnpm/crypto-js@4.2.0/node_modules/crypto-js/ripemd160.js
var require_ripemd1602 = __commonJS({
  "../../node_modules/.pnpm/crypto-js@4.2.0/node_modules/crypto-js/ripemd160.js"(exports, module) {
    (function(root, factory) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function(Math2) {
        var C3 = CryptoJS;
        var C_lib = C3.lib;
        var WordArray = C_lib.WordArray;
        var Hasher = C_lib.Hasher;
        var C_algo = C3.algo;
        var _zl = WordArray.create([
          0,
          1,
          2,
          3,
          4,
          5,
          6,
          7,
          8,
          9,
          10,
          11,
          12,
          13,
          14,
          15,
          7,
          4,
          13,
          1,
          10,
          6,
          15,
          3,
          12,
          0,
          9,
          5,
          2,
          14,
          11,
          8,
          3,
          10,
          14,
          4,
          9,
          15,
          8,
          1,
          2,
          7,
          0,
          6,
          13,
          11,
          5,
          12,
          1,
          9,
          11,
          10,
          0,
          8,
          12,
          4,
          13,
          3,
          7,
          15,
          14,
          5,
          6,
          2,
          4,
          0,
          5,
          9,
          7,
          12,
          2,
          10,
          14,
          1,
          3,
          8,
          11,
          6,
          15,
          13
        ]);
        var _zr = WordArray.create([
          5,
          14,
          7,
          0,
          9,
          2,
          11,
          4,
          13,
          6,
          15,
          8,
          1,
          10,
          3,
          12,
          6,
          11,
          3,
          7,
          0,
          13,
          5,
          10,
          14,
          15,
          8,
          12,
          4,
          9,
          1,
          2,
          15,
          5,
          1,
          3,
          7,
          14,
          6,
          9,
          11,
          8,
          12,
          2,
          10,
          0,
          4,
          13,
          8,
          6,
          4,
          1,
          3,
          11,
          15,
          0,
          5,
          12,
          2,
          13,
          9,
          7,
          10,
          14,
          12,
          15,
          10,
          4,
          1,
          5,
          8,
          7,
          6,
          2,
          13,
          14,
          0,
          3,
          9,
          11
        ]);
        var _sl = WordArray.create([
          11,
          14,
          15,
          12,
          5,
          8,
          7,
          9,
          11,
          13,
          14,
          15,
          6,
          7,
          9,
          8,
          7,
          6,
          8,
          13,
          11,
          9,
          7,
          15,
          7,
          12,
          15,
          9,
          11,
          7,
          13,
          12,
          11,
          13,
          6,
          7,
          14,
          9,
          13,
          15,
          14,
          8,
          13,
          6,
          5,
          12,
          7,
          5,
          11,
          12,
          14,
          15,
          14,
          15,
          9,
          8,
          9,
          14,
          5,
          6,
          8,
          6,
          5,
          12,
          9,
          15,
          5,
          11,
          6,
          8,
          13,
          12,
          5,
          12,
          13,
          14,
          11,
          8,
          5,
          6
        ]);
        var _sr = WordArray.create([
          8,
          9,
          9,
          11,
          13,
          15,
          15,
          5,
          7,
          7,
          8,
          11,
          14,
          14,
          12,
          6,
          9,
          13,
          15,
          7,
          12,
          8,
          9,
          11,
          7,
          7,
          12,
          7,
          6,
          15,
          13,
          11,
          9,
          7,
          15,
          11,
          8,
          6,
          6,
          14,
          12,
          13,
          5,
          14,
          13,
          13,
          7,
          5,
          15,
          5,
          8,
          11,
          14,
          14,
          6,
          14,
          6,
          9,
          12,
          9,
          12,
          5,
          15,
          8,
          8,
          5,
          12,
          9,
          12,
          5,
          14,
          6,
          8,
          13,
          6,
          5,
          15,
          13,
          11,
          11
        ]);
        var _hl = WordArray.create([0, 1518500249, 1859775393, 2400959708, 2840853838]);
        var _hr = WordArray.create([1352829926, 1548603684, 1836072691, 2053994217, 0]);
        var RIPEMD160 = C_algo.RIPEMD160 = Hasher.extend({
          _doReset: function() {
            this._hash = WordArray.create([1732584193, 4023233417, 2562383102, 271733878, 3285377520]);
          },
          _doProcessBlock: function(M3, offset) {
            for (var i4 = 0; i4 < 16; i4++) {
              var offset_i = offset + i4;
              var M_offset_i = M3[offset_i];
              M3[offset_i] = (M_offset_i << 8 | M_offset_i >>> 24) & 16711935 | (M_offset_i << 24 | M_offset_i >>> 8) & 4278255360;
            }
            var H = this._hash.words;
            var hl = _hl.words;
            var hr2 = _hr.words;
            var zl = _zl.words;
            var zr2 = _zr.words;
            var sl = _sl.words;
            var sr3 = _sr.words;
            var al, bl, cl, dl, el;
            var ar2, br2, cr3, dr2, er;
            ar2 = al = H[0];
            br2 = bl = H[1];
            cr3 = cl = H[2];
            dr2 = dl = H[3];
            er = el = H[4];
            var t;
            for (var i4 = 0; i4 < 80; i4 += 1) {
              t = al + M3[offset + zl[i4]] | 0;
              if (i4 < 16) {
                t += f1(bl, cl, dl) + hl[0];
              } else if (i4 < 32) {
                t += f22(bl, cl, dl) + hl[1];
              } else if (i4 < 48) {
                t += f32(bl, cl, dl) + hl[2];
              } else if (i4 < 64) {
                t += f42(bl, cl, dl) + hl[3];
              } else {
                t += f52(bl, cl, dl) + hl[4];
              }
              t = t | 0;
              t = rotl(t, sl[i4]);
              t = t + el | 0;
              al = el;
              el = dl;
              dl = rotl(cl, 10);
              cl = bl;
              bl = t;
              t = ar2 + M3[offset + zr2[i4]] | 0;
              if (i4 < 16) {
                t += f52(br2, cr3, dr2) + hr2[0];
              } else if (i4 < 32) {
                t += f42(br2, cr3, dr2) + hr2[1];
              } else if (i4 < 48) {
                t += f32(br2, cr3, dr2) + hr2[2];
              } else if (i4 < 64) {
                t += f22(br2, cr3, dr2) + hr2[3];
              } else {
                t += f1(br2, cr3, dr2) + hr2[4];
              }
              t = t | 0;
              t = rotl(t, sr3[i4]);
              t = t + er | 0;
              ar2 = er;
              er = dr2;
              dr2 = rotl(cr3, 10);
              cr3 = br2;
              br2 = t;
            }
            t = H[1] + cl + dr2 | 0;
            H[1] = H[2] + dl + er | 0;
            H[2] = H[3] + el + ar2 | 0;
            H[3] = H[4] + al + br2 | 0;
            H[4] = H[0] + bl + cr3 | 0;
            H[0] = t;
          },
          _doFinalize: function() {
            var data = this._data;
            var dataWords = data.words;
            var nBitsTotal = this._nDataBytes * 8;
            var nBitsLeft = data.sigBytes * 8;
            dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = (nBitsTotal << 8 | nBitsTotal >>> 24) & 16711935 | (nBitsTotal << 24 | nBitsTotal >>> 8) & 4278255360;
            data.sigBytes = (dataWords.length + 1) * 4;
            this._process();
            var hash = this._hash;
            var H = hash.words;
            for (var i4 = 0; i4 < 5; i4++) {
              var H_i = H[i4];
              H[i4] = (H_i << 8 | H_i >>> 24) & 16711935 | (H_i << 24 | H_i >>> 8) & 4278255360;
            }
            return hash;
          },
          clone: function() {
            var clone = Hasher.clone.call(this);
            clone._hash = this._hash.clone();
            return clone;
          }
        });
        function f1(x4, y5, z4) {
          return x4 ^ y5 ^ z4;
        }
        function f22(x4, y5, z4) {
          return x4 & y5 | ~x4 & z4;
        }
        function f32(x4, y5, z4) {
          return (x4 | ~y5) ^ z4;
        }
        function f42(x4, y5, z4) {
          return x4 & z4 | y5 & ~z4;
        }
        function f52(x4, y5, z4) {
          return x4 ^ (y5 | ~z4);
        }
        function rotl(x4, n5) {
          return x4 << n5 | x4 >>> 32 - n5;
        }
        C3.RIPEMD160 = Hasher._createHelper(RIPEMD160);
        C3.HmacRIPEMD160 = Hasher._createHmacHelper(RIPEMD160);
      })(Math);
      return CryptoJS.RIPEMD160;
    });
  }
});

// ../../node_modules/.pnpm/crypto-js@4.2.0/node_modules/crypto-js/hmac.js
var require_hmac = __commonJS({
  "../../node_modules/.pnpm/crypto-js@4.2.0/node_modules/crypto-js/hmac.js"(exports, module) {
    (function(root, factory) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function() {
        var C3 = CryptoJS;
        var C_lib = C3.lib;
        var Base = C_lib.Base;
        var C_enc = C3.enc;
        var Utf8 = C_enc.Utf8;
        var C_algo = C3.algo;
        var HMAC = C_algo.HMAC = Base.extend({
          /**
           * Initializes a newly created HMAC.
           *
           * @param {Hasher} hasher The hash algorithm to use.
           * @param {WordArray|string} key The secret key.
           *
           * @example
           *
           *     var hmacHasher = CryptoJS.algo.HMAC.create(CryptoJS.algo.SHA256, key);
           */
          init: function(hasher, key) {
            hasher = this._hasher = new hasher.init();
            if (typeof key == "string") {
              key = Utf8.parse(key);
            }
            var hasherBlockSize = hasher.blockSize;
            var hasherBlockSizeBytes = hasherBlockSize * 4;
            if (key.sigBytes > hasherBlockSizeBytes) {
              key = hasher.finalize(key);
            }
            key.clamp();
            var oKey = this._oKey = key.clone();
            var iKey = this._iKey = key.clone();
            var oKeyWords = oKey.words;
            var iKeyWords = iKey.words;
            for (var i4 = 0; i4 < hasherBlockSize; i4++) {
              oKeyWords[i4] ^= 1549556828;
              iKeyWords[i4] ^= 909522486;
            }
            oKey.sigBytes = iKey.sigBytes = hasherBlockSizeBytes;
            this.reset();
          },
          /**
           * Resets this HMAC to its initial state.
           *
           * @example
           *
           *     hmacHasher.reset();
           */
          reset: function() {
            var hasher = this._hasher;
            hasher.reset();
            hasher.update(this._iKey);
          },
          /**
           * Updates this HMAC with a message.
           *
           * @param {WordArray|string} messageUpdate The message to append.
           *
           * @return {HMAC} This HMAC instance.
           *
           * @example
           *
           *     hmacHasher.update('message');
           *     hmacHasher.update(wordArray);
           */
          update: function(messageUpdate) {
            this._hasher.update(messageUpdate);
            return this;
          },
          /**
           * Finalizes the HMAC computation.
           * Note that the finalize operation is effectively a destructive, read-once operation.
           *
           * @param {WordArray|string} messageUpdate (Optional) A final message update.
           *
           * @return {WordArray} The HMAC.
           *
           * @example
           *
           *     var hmac = hmacHasher.finalize();
           *     var hmac = hmacHasher.finalize('message');
           *     var hmac = hmacHasher.finalize(wordArray);
           */
          finalize: function(messageUpdate) {
            var hasher = this._hasher;
            var innerHash = hasher.finalize(messageUpdate);
            hasher.reset();
            var hmac = hasher.finalize(this._oKey.clone().concat(innerHash));
            return hmac;
          }
        });
      })();
    });
  }
});

// ../../node_modules/.pnpm/crypto-js@4.2.0/node_modules/crypto-js/pbkdf2.js
var require_pbkdf22 = __commonJS({
  "../../node_modules/.pnpm/crypto-js@4.2.0/node_modules/crypto-js/pbkdf2.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_sha2562(), require_hmac());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./sha256", "./hmac"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function() {
        var C3 = CryptoJS;
        var C_lib = C3.lib;
        var Base = C_lib.Base;
        var WordArray = C_lib.WordArray;
        var C_algo = C3.algo;
        var SHA256 = C_algo.SHA256;
        var HMAC = C_algo.HMAC;
        var PBKDF2 = C_algo.PBKDF2 = Base.extend({
          /**
           * Configuration options.
           *
           * @property {number} keySize The key size in words to generate. Default: 4 (128 bits)
           * @property {Hasher} hasher The hasher to use. Default: SHA256
           * @property {number} iterations The number of iterations to perform. Default: 250000
           */
          cfg: Base.extend({
            keySize: 128 / 32,
            hasher: SHA256,
            iterations: 25e4
          }),
          /**
           * Initializes a newly created key derivation function.
           *
           * @param {Object} cfg (Optional) The configuration options to use for the derivation.
           *
           * @example
           *
           *     var kdf = CryptoJS.algo.PBKDF2.create();
           *     var kdf = CryptoJS.algo.PBKDF2.create({ keySize: 8 });
           *     var kdf = CryptoJS.algo.PBKDF2.create({ keySize: 8, iterations: 1000 });
           */
          init: function(cfg) {
            this.cfg = this.cfg.extend(cfg);
          },
          /**
           * Computes the Password-Based Key Derivation Function 2.
           *
           * @param {WordArray|string} password The password.
           * @param {WordArray|string} salt A salt.
           *
           * @return {WordArray} The derived key.
           *
           * @example
           *
           *     var key = kdf.compute(password, salt);
           */
          compute: function(password, salt) {
            var cfg = this.cfg;
            var hmac = HMAC.create(cfg.hasher, password);
            var derivedKey = WordArray.create();
            var blockIndex = WordArray.create([1]);
            var derivedKeyWords = derivedKey.words;
            var blockIndexWords = blockIndex.words;
            var keySize = cfg.keySize;
            var iterations = cfg.iterations;
            while (derivedKeyWords.length < keySize) {
              var block = hmac.update(salt).finalize(blockIndex);
              hmac.reset();
              var blockWords = block.words;
              var blockWordsLength = blockWords.length;
              var intermediate = block;
              for (var i4 = 1; i4 < iterations; i4++) {
                intermediate = hmac.finalize(intermediate);
                hmac.reset();
                var intermediateWords = intermediate.words;
                for (var j2 = 0; j2 < blockWordsLength; j2++) {
                  blockWords[j2] ^= intermediateWords[j2];
                }
              }
              derivedKey.concat(block);
              blockIndexWords[0]++;
            }
            derivedKey.sigBytes = keySize * 4;
            return derivedKey;
          }
        });
        C3.PBKDF2 = function(password, salt, cfg) {
          return PBKDF2.create(cfg).compute(password, salt);
        };
      })();
      return CryptoJS.PBKDF2;
    });
  }
});

// ../../node_modules/.pnpm/crypto-js@4.2.0/node_modules/crypto-js/evpkdf.js
var require_evpkdf = __commonJS({
  "../../node_modules/.pnpm/crypto-js@4.2.0/node_modules/crypto-js/evpkdf.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_sha1(), require_hmac());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./sha1", "./hmac"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function() {
        var C3 = CryptoJS;
        var C_lib = C3.lib;
        var Base = C_lib.Base;
        var WordArray = C_lib.WordArray;
        var C_algo = C3.algo;
        var MD5 = C_algo.MD5;
        var EvpKDF = C_algo.EvpKDF = Base.extend({
          /**
           * Configuration options.
           *
           * @property {number} keySize The key size in words to generate. Default: 4 (128 bits)
           * @property {Hasher} hasher The hash algorithm to use. Default: MD5
           * @property {number} iterations The number of iterations to perform. Default: 1
           */
          cfg: Base.extend({
            keySize: 128 / 32,
            hasher: MD5,
            iterations: 1
          }),
          /**
           * Initializes a newly created key derivation function.
           *
           * @param {Object} cfg (Optional) The configuration options to use for the derivation.
           *
           * @example
           *
           *     var kdf = CryptoJS.algo.EvpKDF.create();
           *     var kdf = CryptoJS.algo.EvpKDF.create({ keySize: 8 });
           *     var kdf = CryptoJS.algo.EvpKDF.create({ keySize: 8, iterations: 1000 });
           */
          init: function(cfg) {
            this.cfg = this.cfg.extend(cfg);
          },
          /**
           * Derives a key from a password.
           *
           * @param {WordArray|string} password The password.
           * @param {WordArray|string} salt A salt.
           *
           * @return {WordArray} The derived key.
           *
           * @example
           *
           *     var key = kdf.compute(password, salt);
           */
          compute: function(password, salt) {
            var block;
            var cfg = this.cfg;
            var hasher = cfg.hasher.create();
            var derivedKey = WordArray.create();
            var derivedKeyWords = derivedKey.words;
            var keySize = cfg.keySize;
            var iterations = cfg.iterations;
            while (derivedKeyWords.length < keySize) {
              if (block) {
                hasher.update(block);
              }
              block = hasher.update(password).finalize(salt);
              hasher.reset();
              for (var i4 = 1; i4 < iterations; i4++) {
                block = hasher.finalize(block);
                hasher.reset();
              }
              derivedKey.concat(block);
            }
            derivedKey.sigBytes = keySize * 4;
            return derivedKey;
          }
        });
        C3.EvpKDF = function(password, salt, cfg) {
          return EvpKDF.create(cfg).compute(password, salt);
        };
      })();
      return CryptoJS.EvpKDF;
    });
  }
});

// ../../node_modules/.pnpm/crypto-js@4.2.0/node_modules/crypto-js/cipher-core.js
var require_cipher_core = __commonJS({
  "../../node_modules/.pnpm/crypto-js@4.2.0/node_modules/crypto-js/cipher-core.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_evpkdf());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./evpkdf"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      CryptoJS.lib.Cipher || function(undefined2) {
        var C3 = CryptoJS;
        var C_lib = C3.lib;
        var Base = C_lib.Base;
        var WordArray = C_lib.WordArray;
        var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm;
        var C_enc = C3.enc;
        var Utf8 = C_enc.Utf8;
        var Base64 = C_enc.Base64;
        var C_algo = C3.algo;
        var EvpKDF = C_algo.EvpKDF;
        var Cipher = C_lib.Cipher = BufferedBlockAlgorithm.extend({
          /**
           * Configuration options.
           *
           * @property {WordArray} iv The IV to use for this operation.
           */
          cfg: Base.extend(),
          /**
           * Creates this cipher in encryption mode.
           *
           * @param {WordArray} key The key.
           * @param {Object} cfg (Optional) The configuration options to use for this operation.
           *
           * @return {Cipher} A cipher instance.
           *
           * @static
           *
           * @example
           *
           *     var cipher = CryptoJS.algo.AES.createEncryptor(keyWordArray, { iv: ivWordArray });
           */
          createEncryptor: function(key, cfg) {
            return this.create(this._ENC_XFORM_MODE, key, cfg);
          },
          /**
           * Creates this cipher in decryption mode.
           *
           * @param {WordArray} key The key.
           * @param {Object} cfg (Optional) The configuration options to use for this operation.
           *
           * @return {Cipher} A cipher instance.
           *
           * @static
           *
           * @example
           *
           *     var cipher = CryptoJS.algo.AES.createDecryptor(keyWordArray, { iv: ivWordArray });
           */
          createDecryptor: function(key, cfg) {
            return this.create(this._DEC_XFORM_MODE, key, cfg);
          },
          /**
           * Initializes a newly created cipher.
           *
           * @param {number} xformMode Either the encryption or decryption transormation mode constant.
           * @param {WordArray} key The key.
           * @param {Object} cfg (Optional) The configuration options to use for this operation.
           *
           * @example
           *
           *     var cipher = CryptoJS.algo.AES.create(CryptoJS.algo.AES._ENC_XFORM_MODE, keyWordArray, { iv: ivWordArray });
           */
          init: function(xformMode, key, cfg) {
            this.cfg = this.cfg.extend(cfg);
            this._xformMode = xformMode;
            this._key = key;
            this.reset();
          },
          /**
           * Resets this cipher to its initial state.
           *
           * @example
           *
           *     cipher.reset();
           */
          reset: function() {
            BufferedBlockAlgorithm.reset.call(this);
            this._doReset();
          },
          /**
           * Adds data to be encrypted or decrypted.
           *
           * @param {WordArray|string} dataUpdate The data to encrypt or decrypt.
           *
           * @return {WordArray} The data after processing.
           *
           * @example
           *
           *     var encrypted = cipher.process('data');
           *     var encrypted = cipher.process(wordArray);
           */
          process: function(dataUpdate) {
            this._append(dataUpdate);
            return this._process();
          },
          /**
           * Finalizes the encryption or decryption process.
           * Note that the finalize operation is effectively a destructive, read-once operation.
           *
           * @param {WordArray|string} dataUpdate The final data to encrypt or decrypt.
           *
           * @return {WordArray} The data after final processing.
           *
           * @example
           *
           *     var encrypted = cipher.finalize();
           *     var encrypted = cipher.finalize('data');
           *     var encrypted = cipher.finalize(wordArray);
           */
          finalize: function(dataUpdate) {
            if (dataUpdate) {
              this._append(dataUpdate);
            }
            var finalProcessedData = this._doFinalize();
            return finalProcessedData;
          },
          keySize: 128 / 32,
          ivSize: 128 / 32,
          _ENC_XFORM_MODE: 1,
          _DEC_XFORM_MODE: 2,
          /**
           * Creates shortcut functions to a cipher's object interface.
           *
           * @param {Cipher} cipher The cipher to create a helper for.
           *
           * @return {Object} An object with encrypt and decrypt shortcut functions.
           *
           * @static
           *
           * @example
           *
           *     var AES = CryptoJS.lib.Cipher._createHelper(CryptoJS.algo.AES);
           */
          _createHelper: function() {
            function selectCipherStrategy(key) {
              if (typeof key == "string") {
                return PasswordBasedCipher;
              } else {
                return SerializableCipher;
              }
            }
            return function(cipher) {
              return {
                encrypt: function(message, key, cfg) {
                  return selectCipherStrategy(key).encrypt(cipher, message, key, cfg);
                },
                decrypt: function(ciphertext, key, cfg) {
                  return selectCipherStrategy(key).decrypt(cipher, ciphertext, key, cfg);
                }
              };
            };
          }()
        });
        var StreamCipher = C_lib.StreamCipher = Cipher.extend({
          _doFinalize: function() {
            var finalProcessedBlocks = this._process(true);
            return finalProcessedBlocks;
          },
          blockSize: 1
        });
        var C_mode = C3.mode = {};
        var BlockCipherMode = C_lib.BlockCipherMode = Base.extend({
          /**
           * Creates this mode for encryption.
           *
           * @param {Cipher} cipher A block cipher instance.
           * @param {Array} iv The IV words.
           *
           * @static
           *
           * @example
           *
           *     var mode = CryptoJS.mode.CBC.createEncryptor(cipher, iv.words);
           */
          createEncryptor: function(cipher, iv) {
            return this.Encryptor.create(cipher, iv);
          },
          /**
           * Creates this mode for decryption.
           *
           * @param {Cipher} cipher A block cipher instance.
           * @param {Array} iv The IV words.
           *
           * @static
           *
           * @example
           *
           *     var mode = CryptoJS.mode.CBC.createDecryptor(cipher, iv.words);
           */
          createDecryptor: function(cipher, iv) {
            return this.Decryptor.create(cipher, iv);
          },
          /**
           * Initializes a newly created mode.
           *
           * @param {Cipher} cipher A block cipher instance.
           * @param {Array} iv The IV words.
           *
           * @example
           *
           *     var mode = CryptoJS.mode.CBC.Encryptor.create(cipher, iv.words);
           */
          init: function(cipher, iv) {
            this._cipher = cipher;
            this._iv = iv;
          }
        });
        var CBC = C_mode.CBC = function() {
          var CBC2 = BlockCipherMode.extend();
          CBC2.Encryptor = CBC2.extend({
            /**
             * Processes the data block at offset.
             *
             * @param {Array} words The data words to operate on.
             * @param {number} offset The offset where the block starts.
             *
             * @example
             *
             *     mode.processBlock(data.words, offset);
             */
            processBlock: function(words, offset) {
              var cipher = this._cipher;
              var blockSize = cipher.blockSize;
              xorBlock.call(this, words, offset, blockSize);
              cipher.encryptBlock(words, offset);
              this._prevBlock = words.slice(offset, offset + blockSize);
            }
          });
          CBC2.Decryptor = CBC2.extend({
            /**
             * Processes the data block at offset.
             *
             * @param {Array} words The data words to operate on.
             * @param {number} offset The offset where the block starts.
             *
             * @example
             *
             *     mode.processBlock(data.words, offset);
             */
            processBlock: function(words, offset) {
              var cipher = this._cipher;
              var blockSize = cipher.blockSize;
              var thisBlock = words.slice(offset, offset + blockSize);
              cipher.decryptBlock(words, offset);
              xorBlock.call(this, words, offset, blockSize);
              this._prevBlock = thisBlock;
            }
          });
          function xorBlock(words, offset, blockSize) {
            var block;
            var iv = this._iv;
            if (iv) {
              block = iv;
              this._iv = undefined2;
            } else {
              block = this._prevBlock;
            }
            for (var i4 = 0; i4 < blockSize; i4++) {
              words[offset + i4] ^= block[i4];
            }
          }
          return CBC2;
        }();
        var C_pad = C3.pad = {};
        var Pkcs7 = C_pad.Pkcs7 = {
          /**
           * Pads data using the algorithm defined in PKCS #5/7.
           *
           * @param {WordArray} data The data to pad.
           * @param {number} blockSize The multiple that the data should be padded to.
           *
           * @static
           *
           * @example
           *
           *     CryptoJS.pad.Pkcs7.pad(wordArray, 4);
           */
          pad: function(data, blockSize) {
            var blockSizeBytes = blockSize * 4;
            var nPaddingBytes = blockSizeBytes - data.sigBytes % blockSizeBytes;
            var paddingWord = nPaddingBytes << 24 | nPaddingBytes << 16 | nPaddingBytes << 8 | nPaddingBytes;
            var paddingWords = [];
            for (var i4 = 0; i4 < nPaddingBytes; i4 += 4) {
              paddingWords.push(paddingWord);
            }
            var padding = WordArray.create(paddingWords, nPaddingBytes);
            data.concat(padding);
          },
          /**
           * Unpads data that had been padded using the algorithm defined in PKCS #5/7.
           *
           * @param {WordArray} data The data to unpad.
           *
           * @static
           *
           * @example
           *
           *     CryptoJS.pad.Pkcs7.unpad(wordArray);
           */
          unpad: function(data) {
            var nPaddingBytes = data.words[data.sigBytes - 1 >>> 2] & 255;
            data.sigBytes -= nPaddingBytes;
          }
        };
        var BlockCipher = C_lib.BlockCipher = Cipher.extend({
          /**
           * Configuration options.
           *
           * @property {Mode} mode The block mode to use. Default: CBC
           * @property {Padding} padding The padding strategy to use. Default: Pkcs7
           */
          cfg: Cipher.cfg.extend({
            mode: CBC,
            padding: Pkcs7
          }),
          reset: function() {
            var modeCreator;
            Cipher.reset.call(this);
            var cfg = this.cfg;
            var iv = cfg.iv;
            var mode = cfg.mode;
            if (this._xformMode == this._ENC_XFORM_MODE) {
              modeCreator = mode.createEncryptor;
            } else {
              modeCreator = mode.createDecryptor;
              this._minBufferSize = 1;
            }
            if (this._mode && this._mode.__creator == modeCreator) {
              this._mode.init(this, iv && iv.words);
            } else {
              this._mode = modeCreator.call(mode, this, iv && iv.words);
              this._mode.__creator = modeCreator;
            }
          },
          _doProcessBlock: function(words, offset) {
            this._mode.processBlock(words, offset);
          },
          _doFinalize: function() {
            var finalProcessedBlocks;
            var padding = this.cfg.padding;
            if (this._xformMode == this._ENC_XFORM_MODE) {
              padding.pad(this._data, this.blockSize);
              finalProcessedBlocks = this._process(true);
            } else {
              finalProcessedBlocks = this._process(true);
              padding.unpad(finalProcessedBlocks);
            }
            return finalProcessedBlocks;
          },
          blockSize: 128 / 32
        });
        var CipherParams = C_lib.CipherParams = Base.extend({
          /**
           * Initializes a newly created cipher params object.
           *
           * @param {Object} cipherParams An object with any of the possible cipher parameters.
           *
           * @example
           *
           *     var cipherParams = CryptoJS.lib.CipherParams.create({
           *         ciphertext: ciphertextWordArray,
           *         key: keyWordArray,
           *         iv: ivWordArray,
           *         salt: saltWordArray,
           *         algorithm: CryptoJS.algo.AES,
           *         mode: CryptoJS.mode.CBC,
           *         padding: CryptoJS.pad.PKCS7,
           *         blockSize: 4,
           *         formatter: CryptoJS.format.OpenSSL
           *     });
           */
          init: function(cipherParams) {
            this.mixIn(cipherParams);
          },
          /**
           * Converts this cipher params object to a string.
           *
           * @param {Format} formatter (Optional) The formatting strategy to use.
           *
           * @return {string} The stringified cipher params.
           *
           * @throws Error If neither the formatter nor the default formatter is set.
           *
           * @example
           *
           *     var string = cipherParams + '';
           *     var string = cipherParams.toString();
           *     var string = cipherParams.toString(CryptoJS.format.OpenSSL);
           */
          toString: function(formatter) {
            return (formatter || this.formatter).stringify(this);
          }
        });
        var C_format = C3.format = {};
        var OpenSSLFormatter = C_format.OpenSSL = {
          /**
           * Converts a cipher params object to an OpenSSL-compatible string.
           *
           * @param {CipherParams} cipherParams The cipher params object.
           *
           * @return {string} The OpenSSL-compatible string.
           *
           * @static
           *
           * @example
           *
           *     var openSSLString = CryptoJS.format.OpenSSL.stringify(cipherParams);
           */
          stringify: function(cipherParams) {
            var wordArray;
            var ciphertext = cipherParams.ciphertext;
            var salt = cipherParams.salt;
            if (salt) {
              wordArray = WordArray.create([1398893684, 1701076831]).concat(salt).concat(ciphertext);
            } else {
              wordArray = ciphertext;
            }
            return wordArray.toString(Base64);
          },
          /**
           * Converts an OpenSSL-compatible string to a cipher params object.
           *
           * @param {string} openSSLStr The OpenSSL-compatible string.
           *
           * @return {CipherParams} The cipher params object.
           *
           * @static
           *
           * @example
           *
           *     var cipherParams = CryptoJS.format.OpenSSL.parse(openSSLString);
           */
          parse: function(openSSLStr) {
            var salt;
            var ciphertext = Base64.parse(openSSLStr);
            var ciphertextWords = ciphertext.words;
            if (ciphertextWords[0] == 1398893684 && ciphertextWords[1] == 1701076831) {
              salt = WordArray.create(ciphertextWords.slice(2, 4));
              ciphertextWords.splice(0, 4);
              ciphertext.sigBytes -= 16;
            }
            return CipherParams.create({ ciphertext, salt });
          }
        };
        var SerializableCipher = C_lib.SerializableCipher = Base.extend({
          /**
           * Configuration options.
           *
           * @property {Formatter} format The formatting strategy to convert cipher param objects to and from a string. Default: OpenSSL
           */
          cfg: Base.extend({
            format: OpenSSLFormatter
          }),
          /**
           * Encrypts a message.
           *
           * @param {Cipher} cipher The cipher algorithm to use.
           * @param {WordArray|string} message The message to encrypt.
           * @param {WordArray} key The key.
           * @param {Object} cfg (Optional) The configuration options to use for this operation.
           *
           * @return {CipherParams} A cipher params object.
           *
           * @static
           *
           * @example
           *
           *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key);
           *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key, { iv: iv });
           *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key, { iv: iv, format: CryptoJS.format.OpenSSL });
           */
          encrypt: function(cipher, message, key, cfg) {
            cfg = this.cfg.extend(cfg);
            var encryptor = cipher.createEncryptor(key, cfg);
            var ciphertext = encryptor.finalize(message);
            var cipherCfg = encryptor.cfg;
            return CipherParams.create({
              ciphertext,
              key,
              iv: cipherCfg.iv,
              algorithm: cipher,
              mode: cipherCfg.mode,
              padding: cipherCfg.padding,
              blockSize: cipher.blockSize,
              formatter: cfg.format
            });
          },
          /**
           * Decrypts serialized ciphertext.
           *
           * @param {Cipher} cipher The cipher algorithm to use.
           * @param {CipherParams|string} ciphertext The ciphertext to decrypt.
           * @param {WordArray} key The key.
           * @param {Object} cfg (Optional) The configuration options to use for this operation.
           *
           * @return {WordArray} The plaintext.
           *
           * @static
           *
           * @example
           *
           *     var plaintext = CryptoJS.lib.SerializableCipher.decrypt(CryptoJS.algo.AES, formattedCiphertext, key, { iv: iv, format: CryptoJS.format.OpenSSL });
           *     var plaintext = CryptoJS.lib.SerializableCipher.decrypt(CryptoJS.algo.AES, ciphertextParams, key, { iv: iv, format: CryptoJS.format.OpenSSL });
           */
          decrypt: function(cipher, ciphertext, key, cfg) {
            cfg = this.cfg.extend(cfg);
            ciphertext = this._parse(ciphertext, cfg.format);
            var plaintext = cipher.createDecryptor(key, cfg).finalize(ciphertext.ciphertext);
            return plaintext;
          },
          /**
           * Converts serialized ciphertext to CipherParams,
           * else assumed CipherParams already and returns ciphertext unchanged.
           *
           * @param {CipherParams|string} ciphertext The ciphertext.
           * @param {Formatter} format The formatting strategy to use to parse serialized ciphertext.
           *
           * @return {CipherParams} The unserialized ciphertext.
           *
           * @static
           *
           * @example
           *
           *     var ciphertextParams = CryptoJS.lib.SerializableCipher._parse(ciphertextStringOrParams, format);
           */
          _parse: function(ciphertext, format) {
            if (typeof ciphertext == "string") {
              return format.parse(ciphertext, this);
            } else {
              return ciphertext;
            }
          }
        });
        var C_kdf = C3.kdf = {};
        var OpenSSLKdf = C_kdf.OpenSSL = {
          /**
           * Derives a key and IV from a password.
           *
           * @param {string} password The password to derive from.
           * @param {number} keySize The size in words of the key to generate.
           * @param {number} ivSize The size in words of the IV to generate.
           * @param {WordArray|string} salt (Optional) A 64-bit salt to use. If omitted, a salt will be generated randomly.
           *
           * @return {CipherParams} A cipher params object with the key, IV, and salt.
           *
           * @static
           *
           * @example
           *
           *     var derivedParams = CryptoJS.kdf.OpenSSL.execute('Password', 256/32, 128/32);
           *     var derivedParams = CryptoJS.kdf.OpenSSL.execute('Password', 256/32, 128/32, 'saltsalt');
           */
          execute: function(password, keySize, ivSize, salt, hasher) {
            if (!salt) {
              salt = WordArray.random(64 / 8);
            }
            if (!hasher) {
              var key = EvpKDF.create({ keySize: keySize + ivSize }).compute(password, salt);
            } else {
              var key = EvpKDF.create({ keySize: keySize + ivSize, hasher }).compute(password, salt);
            }
            var iv = WordArray.create(key.words.slice(keySize), ivSize * 4);
            key.sigBytes = keySize * 4;
            return CipherParams.create({ key, iv, salt });
          }
        };
        var PasswordBasedCipher = C_lib.PasswordBasedCipher = SerializableCipher.extend({
          /**
           * Configuration options.
           *
           * @property {KDF} kdf The key derivation function to use to generate a key and IV from a password. Default: OpenSSL
           */
          cfg: SerializableCipher.cfg.extend({
            kdf: OpenSSLKdf
          }),
          /**
           * Encrypts a message using a password.
           *
           * @param {Cipher} cipher The cipher algorithm to use.
           * @param {WordArray|string} message The message to encrypt.
           * @param {string} password The password.
           * @param {Object} cfg (Optional) The configuration options to use for this operation.
           *
           * @return {CipherParams} A cipher params object.
           *
           * @static
           *
           * @example
           *
           *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher.encrypt(CryptoJS.algo.AES, message, 'password');
           *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher.encrypt(CryptoJS.algo.AES, message, 'password', { format: CryptoJS.format.OpenSSL });
           */
          encrypt: function(cipher, message, password, cfg) {
            cfg = this.cfg.extend(cfg);
            var derivedParams = cfg.kdf.execute(password, cipher.keySize, cipher.ivSize, cfg.salt, cfg.hasher);
            cfg.iv = derivedParams.iv;
            var ciphertext = SerializableCipher.encrypt.call(this, cipher, message, derivedParams.key, cfg);
            ciphertext.mixIn(derivedParams);
            return ciphertext;
          },
          /**
           * Decrypts serialized ciphertext using a password.
           *
           * @param {Cipher} cipher The cipher algorithm to use.
           * @param {CipherParams|string} ciphertext The ciphertext to decrypt.
           * @param {string} password The password.
           * @param {Object} cfg (Optional) The configuration options to use for this operation.
           *
           * @return {WordArray} The plaintext.
           *
           * @static
           *
           * @example
           *
           *     var plaintext = CryptoJS.lib.PasswordBasedCipher.decrypt(CryptoJS.algo.AES, formattedCiphertext, 'password', { format: CryptoJS.format.OpenSSL });
           *     var plaintext = CryptoJS.lib.PasswordBasedCipher.decrypt(CryptoJS.algo.AES, ciphertextParams, 'password', { format: CryptoJS.format.OpenSSL });
           */
          decrypt: function(cipher, ciphertext, password, cfg) {
            cfg = this.cfg.extend(cfg);
            ciphertext = this._parse(ciphertext, cfg.format);
            var derivedParams = cfg.kdf.execute(password, cipher.keySize, cipher.ivSize, ciphertext.salt, cfg.hasher);
            cfg.iv = derivedParams.iv;
            var plaintext = SerializableCipher.decrypt.call(this, cipher, ciphertext, derivedParams.key, cfg);
            return plaintext;
          }
        });
      }();
    });
  }
});

// ../../node_modules/.pnpm/crypto-js@4.2.0/node_modules/crypto-js/mode-cfb.js
var require_mode_cfb = __commonJS({
  "../../node_modules/.pnpm/crypto-js@4.2.0/node_modules/crypto-js/mode-cfb.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./cipher-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      CryptoJS.mode.CFB = function() {
        var CFB = CryptoJS.lib.BlockCipherMode.extend();
        CFB.Encryptor = CFB.extend({
          processBlock: function(words, offset) {
            var cipher = this._cipher;
            var blockSize = cipher.blockSize;
            generateKeystreamAndEncrypt.call(this, words, offset, blockSize, cipher);
            this._prevBlock = words.slice(offset, offset + blockSize);
          }
        });
        CFB.Decryptor = CFB.extend({
          processBlock: function(words, offset) {
            var cipher = this._cipher;
            var blockSize = cipher.blockSize;
            var thisBlock = words.slice(offset, offset + blockSize);
            generateKeystreamAndEncrypt.call(this, words, offset, blockSize, cipher);
            this._prevBlock = thisBlock;
          }
        });
        function generateKeystreamAndEncrypt(words, offset, blockSize, cipher) {
          var keystream;
          var iv = this._iv;
          if (iv) {
            keystream = iv.slice(0);
            this._iv = void 0;
          } else {
            keystream = this._prevBlock;
          }
          cipher.encryptBlock(keystream, 0);
          for (var i4 = 0; i4 < blockSize; i4++) {
            words[offset + i4] ^= keystream[i4];
          }
        }
        return CFB;
      }();
      return CryptoJS.mode.CFB;
    });
  }
});

// ../../node_modules/.pnpm/crypto-js@4.2.0/node_modules/crypto-js/mode-ctr.js
var require_mode_ctr = __commonJS({
  "../../node_modules/.pnpm/crypto-js@4.2.0/node_modules/crypto-js/mode-ctr.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./cipher-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      CryptoJS.mode.CTR = function() {
        var CTR = CryptoJS.lib.BlockCipherMode.extend();
        var Encryptor = CTR.Encryptor = CTR.extend({
          processBlock: function(words, offset) {
            var cipher = this._cipher;
            var blockSize = cipher.blockSize;
            var iv = this._iv;
            var counter = this._counter;
            if (iv) {
              counter = this._counter = iv.slice(0);
              this._iv = void 0;
            }
            var keystream = counter.slice(0);
            cipher.encryptBlock(keystream, 0);
            counter[blockSize - 1] = counter[blockSize - 1] + 1 | 0;
            for (var i4 = 0; i4 < blockSize; i4++) {
              words[offset + i4] ^= keystream[i4];
            }
          }
        });
        CTR.Decryptor = Encryptor;
        return CTR;
      }();
      return CryptoJS.mode.CTR;
    });
  }
});

// ../../node_modules/.pnpm/crypto-js@4.2.0/node_modules/crypto-js/mode-ctr-gladman.js
var require_mode_ctr_gladman = __commonJS({
  "../../node_modules/.pnpm/crypto-js@4.2.0/node_modules/crypto-js/mode-ctr-gladman.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./cipher-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      CryptoJS.mode.CTRGladman = function() {
        var CTRGladman = CryptoJS.lib.BlockCipherMode.extend();
        function incWord(word) {
          if ((word >> 24 & 255) === 255) {
            var b1 = word >> 16 & 255;
            var b22 = word >> 8 & 255;
            var b32 = word & 255;
            if (b1 === 255) {
              b1 = 0;
              if (b22 === 255) {
                b22 = 0;
                if (b32 === 255) {
                  b32 = 0;
                } else {
                  ++b32;
                }
              } else {
                ++b22;
              }
            } else {
              ++b1;
            }
            word = 0;
            word += b1 << 16;
            word += b22 << 8;
            word += b32;
          } else {
            word += 1 << 24;
          }
          return word;
        }
        function incCounter(counter) {
          if ((counter[0] = incWord(counter[0])) === 0) {
            counter[1] = incWord(counter[1]);
          }
          return counter;
        }
        var Encryptor = CTRGladman.Encryptor = CTRGladman.extend({
          processBlock: function(words, offset) {
            var cipher = this._cipher;
            var blockSize = cipher.blockSize;
            var iv = this._iv;
            var counter = this._counter;
            if (iv) {
              counter = this._counter = iv.slice(0);
              this._iv = void 0;
            }
            incCounter(counter);
            var keystream = counter.slice(0);
            cipher.encryptBlock(keystream, 0);
            for (var i4 = 0; i4 < blockSize; i4++) {
              words[offset + i4] ^= keystream[i4];
            }
          }
        });
        CTRGladman.Decryptor = Encryptor;
        return CTRGladman;
      }();
      return CryptoJS.mode.CTRGladman;
    });
  }
});

// ../../node_modules/.pnpm/crypto-js@4.2.0/node_modules/crypto-js/mode-ofb.js
var require_mode_ofb = __commonJS({
  "../../node_modules/.pnpm/crypto-js@4.2.0/node_modules/crypto-js/mode-ofb.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./cipher-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      CryptoJS.mode.OFB = function() {
        var OFB = CryptoJS.lib.BlockCipherMode.extend();
        var Encryptor = OFB.Encryptor = OFB.extend({
          processBlock: function(words, offset) {
            var cipher = this._cipher;
            var blockSize = cipher.blockSize;
            var iv = this._iv;
            var keystream = this._keystream;
            if (iv) {
              keystream = this._keystream = iv.slice(0);
              this._iv = void 0;
            }
            cipher.encryptBlock(keystream, 0);
            for (var i4 = 0; i4 < blockSize; i4++) {
              words[offset + i4] ^= keystream[i4];
            }
          }
        });
        OFB.Decryptor = Encryptor;
        return OFB;
      }();
      return CryptoJS.mode.OFB;
    });
  }
});

// ../../node_modules/.pnpm/crypto-js@4.2.0/node_modules/crypto-js/mode-ecb.js
var require_mode_ecb = __commonJS({
  "../../node_modules/.pnpm/crypto-js@4.2.0/node_modules/crypto-js/mode-ecb.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./cipher-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      CryptoJS.mode.ECB = function() {
        var ECB = CryptoJS.lib.BlockCipherMode.extend();
        ECB.Encryptor = ECB.extend({
          processBlock: function(words, offset) {
            this._cipher.encryptBlock(words, offset);
          }
        });
        ECB.Decryptor = ECB.extend({
          processBlock: function(words, offset) {
            this._cipher.decryptBlock(words, offset);
          }
        });
        return ECB;
      }();
      return CryptoJS.mode.ECB;
    });
  }
});

// ../../node_modules/.pnpm/crypto-js@4.2.0/node_modules/crypto-js/pad-ansix923.js
var require_pad_ansix923 = __commonJS({
  "../../node_modules/.pnpm/crypto-js@4.2.0/node_modules/crypto-js/pad-ansix923.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./cipher-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      CryptoJS.pad.AnsiX923 = {
        pad: function(data, blockSize) {
          var dataSigBytes = data.sigBytes;
          var blockSizeBytes = blockSize * 4;
          var nPaddingBytes = blockSizeBytes - dataSigBytes % blockSizeBytes;
          var lastBytePos = dataSigBytes + nPaddingBytes - 1;
          data.clamp();
          data.words[lastBytePos >>> 2] |= nPaddingBytes << 24 - lastBytePos % 4 * 8;
          data.sigBytes += nPaddingBytes;
        },
        unpad: function(data) {
          var nPaddingBytes = data.words[data.sigBytes - 1 >>> 2] & 255;
          data.sigBytes -= nPaddingBytes;
        }
      };
      return CryptoJS.pad.Ansix923;
    });
  }
});

// ../../node_modules/.pnpm/crypto-js@4.2.0/node_modules/crypto-js/pad-iso10126.js
var require_pad_iso10126 = __commonJS({
  "../../node_modules/.pnpm/crypto-js@4.2.0/node_modules/crypto-js/pad-iso10126.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./cipher-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      CryptoJS.pad.Iso10126 = {
        pad: function(data, blockSize) {
          var blockSizeBytes = blockSize * 4;
          var nPaddingBytes = blockSizeBytes - data.sigBytes % blockSizeBytes;
          data.concat(CryptoJS.lib.WordArray.random(nPaddingBytes - 1)).concat(CryptoJS.lib.WordArray.create([nPaddingBytes << 24], 1));
        },
        unpad: function(data) {
          var nPaddingBytes = data.words[data.sigBytes - 1 >>> 2] & 255;
          data.sigBytes -= nPaddingBytes;
        }
      };
      return CryptoJS.pad.Iso10126;
    });
  }
});

// ../../node_modules/.pnpm/crypto-js@4.2.0/node_modules/crypto-js/pad-iso97971.js
var require_pad_iso97971 = __commonJS({
  "../../node_modules/.pnpm/crypto-js@4.2.0/node_modules/crypto-js/pad-iso97971.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./cipher-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      CryptoJS.pad.Iso97971 = {
        pad: function(data, blockSize) {
          data.concat(CryptoJS.lib.WordArray.create([2147483648], 1));
          CryptoJS.pad.ZeroPadding.pad(data, blockSize);
        },
        unpad: function(data) {
          CryptoJS.pad.ZeroPadding.unpad(data);
          data.sigBytes--;
        }
      };
      return CryptoJS.pad.Iso97971;
    });
  }
});

// ../../node_modules/.pnpm/crypto-js@4.2.0/node_modules/crypto-js/pad-zeropadding.js
var require_pad_zeropadding = __commonJS({
  "../../node_modules/.pnpm/crypto-js@4.2.0/node_modules/crypto-js/pad-zeropadding.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./cipher-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      CryptoJS.pad.ZeroPadding = {
        pad: function(data, blockSize) {
          var blockSizeBytes = blockSize * 4;
          data.clamp();
          data.sigBytes += blockSizeBytes - (data.sigBytes % blockSizeBytes || blockSizeBytes);
        },
        unpad: function(data) {
          var dataWords = data.words;
          var i4 = data.sigBytes - 1;
          for (var i4 = data.sigBytes - 1; i4 >= 0; i4--) {
            if (dataWords[i4 >>> 2] >>> 24 - i4 % 4 * 8 & 255) {
              data.sigBytes = i4 + 1;
              break;
            }
          }
        }
      };
      return CryptoJS.pad.ZeroPadding;
    });
  }
});

// ../../node_modules/.pnpm/crypto-js@4.2.0/node_modules/crypto-js/pad-nopadding.js
var require_pad_nopadding = __commonJS({
  "../../node_modules/.pnpm/crypto-js@4.2.0/node_modules/crypto-js/pad-nopadding.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./cipher-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      CryptoJS.pad.NoPadding = {
        pad: function() {
        },
        unpad: function() {
        }
      };
      return CryptoJS.pad.NoPadding;
    });
  }
});

// ../../node_modules/.pnpm/crypto-js@4.2.0/node_modules/crypto-js/format-hex.js
var require_format_hex = __commonJS({
  "../../node_modules/.pnpm/crypto-js@4.2.0/node_modules/crypto-js/format-hex.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./cipher-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function(undefined2) {
        var C3 = CryptoJS;
        var C_lib = C3.lib;
        var CipherParams = C_lib.CipherParams;
        var C_enc = C3.enc;
        var Hex = C_enc.Hex;
        var C_format = C3.format;
        var HexFormatter = C_format.Hex = {
          /**
           * Converts the ciphertext of a cipher params object to a hexadecimally encoded string.
           *
           * @param {CipherParams} cipherParams The cipher params object.
           *
           * @return {string} The hexadecimally encoded string.
           *
           * @static
           *
           * @example
           *
           *     var hexString = CryptoJS.format.Hex.stringify(cipherParams);
           */
          stringify: function(cipherParams) {
            return cipherParams.ciphertext.toString(Hex);
          },
          /**
           * Converts a hexadecimally encoded ciphertext string to a cipher params object.
           *
           * @param {string} input The hexadecimally encoded string.
           *
           * @return {CipherParams} The cipher params object.
           *
           * @static
           *
           * @example
           *
           *     var cipherParams = CryptoJS.format.Hex.parse(hexString);
           */
          parse: function(input) {
            var ciphertext = Hex.parse(input);
            return CipherParams.create({ ciphertext });
          }
        };
      })();
      return CryptoJS.format.Hex;
    });
  }
});

// ../../node_modules/.pnpm/crypto-js@4.2.0/node_modules/crypto-js/aes.js
var require_aes = __commonJS({
  "../../node_modules/.pnpm/crypto-js@4.2.0/node_modules/crypto-js/aes.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_enc_base64(), require_md53(), require_evpkdf(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./enc-base64", "./md5", "./evpkdf", "./cipher-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function() {
        var C3 = CryptoJS;
        var C_lib = C3.lib;
        var BlockCipher = C_lib.BlockCipher;
        var C_algo = C3.algo;
        var SBOX = [];
        var INV_SBOX = [];
        var SUB_MIX_0 = [];
        var SUB_MIX_1 = [];
        var SUB_MIX_2 = [];
        var SUB_MIX_3 = [];
        var INV_SUB_MIX_0 = [];
        var INV_SUB_MIX_1 = [];
        var INV_SUB_MIX_2 = [];
        var INV_SUB_MIX_3 = [];
        (function() {
          var d4 = [];
          for (var i4 = 0; i4 < 256; i4++) {
            if (i4 < 128) {
              d4[i4] = i4 << 1;
            } else {
              d4[i4] = i4 << 1 ^ 283;
            }
          }
          var x4 = 0;
          var xi2 = 0;
          for (var i4 = 0; i4 < 256; i4++) {
            var sx = xi2 ^ xi2 << 1 ^ xi2 << 2 ^ xi2 << 3 ^ xi2 << 4;
            sx = sx >>> 8 ^ sx & 255 ^ 99;
            SBOX[x4] = sx;
            INV_SBOX[sx] = x4;
            var x22 = d4[x4];
            var x42 = d4[x22];
            var x8 = d4[x42];
            var t = d4[sx] * 257 ^ sx * 16843008;
            SUB_MIX_0[x4] = t << 24 | t >>> 8;
            SUB_MIX_1[x4] = t << 16 | t >>> 16;
            SUB_MIX_2[x4] = t << 8 | t >>> 24;
            SUB_MIX_3[x4] = t;
            var t = x8 * 16843009 ^ x42 * 65537 ^ x22 * 257 ^ x4 * 16843008;
            INV_SUB_MIX_0[sx] = t << 24 | t >>> 8;
            INV_SUB_MIX_1[sx] = t << 16 | t >>> 16;
            INV_SUB_MIX_2[sx] = t << 8 | t >>> 24;
            INV_SUB_MIX_3[sx] = t;
            if (!x4) {
              x4 = xi2 = 1;
            } else {
              x4 = x22 ^ d4[d4[d4[x8 ^ x22]]];
              xi2 ^= d4[d4[xi2]];
            }
          }
        })();
        var RCON = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54];
        var AES = C_algo.AES = BlockCipher.extend({
          _doReset: function() {
            var t;
            if (this._nRounds && this._keyPriorReset === this._key) {
              return;
            }
            var key = this._keyPriorReset = this._key;
            var keyWords = key.words;
            var keySize = key.sigBytes / 4;
            var nRounds = this._nRounds = keySize + 6;
            var ksRows = (nRounds + 1) * 4;
            var keySchedule = this._keySchedule = [];
            for (var ksRow = 0; ksRow < ksRows; ksRow++) {
              if (ksRow < keySize) {
                keySchedule[ksRow] = keyWords[ksRow];
              } else {
                t = keySchedule[ksRow - 1];
                if (!(ksRow % keySize)) {
                  t = t << 8 | t >>> 24;
                  t = SBOX[t >>> 24] << 24 | SBOX[t >>> 16 & 255] << 16 | SBOX[t >>> 8 & 255] << 8 | SBOX[t & 255];
                  t ^= RCON[ksRow / keySize | 0] << 24;
                } else if (keySize > 6 && ksRow % keySize == 4) {
                  t = SBOX[t >>> 24] << 24 | SBOX[t >>> 16 & 255] << 16 | SBOX[t >>> 8 & 255] << 8 | SBOX[t & 255];
                }
                keySchedule[ksRow] = keySchedule[ksRow - keySize] ^ t;
              }
            }
            var invKeySchedule = this._invKeySchedule = [];
            for (var invKsRow = 0; invKsRow < ksRows; invKsRow++) {
              var ksRow = ksRows - invKsRow;
              if (invKsRow % 4) {
                var t = keySchedule[ksRow];
              } else {
                var t = keySchedule[ksRow - 4];
              }
              if (invKsRow < 4 || ksRow <= 4) {
                invKeySchedule[invKsRow] = t;
              } else {
                invKeySchedule[invKsRow] = INV_SUB_MIX_0[SBOX[t >>> 24]] ^ INV_SUB_MIX_1[SBOX[t >>> 16 & 255]] ^ INV_SUB_MIX_2[SBOX[t >>> 8 & 255]] ^ INV_SUB_MIX_3[SBOX[t & 255]];
              }
            }
          },
          encryptBlock: function(M3, offset) {
            this._doCryptBlock(M3, offset, this._keySchedule, SUB_MIX_0, SUB_MIX_1, SUB_MIX_2, SUB_MIX_3, SBOX);
          },
          decryptBlock: function(M3, offset) {
            var t = M3[offset + 1];
            M3[offset + 1] = M3[offset + 3];
            M3[offset + 3] = t;
            this._doCryptBlock(M3, offset, this._invKeySchedule, INV_SUB_MIX_0, INV_SUB_MIX_1, INV_SUB_MIX_2, INV_SUB_MIX_3, INV_SBOX);
            var t = M3[offset + 1];
            M3[offset + 1] = M3[offset + 3];
            M3[offset + 3] = t;
          },
          _doCryptBlock: function(M3, offset, keySchedule, SUB_MIX_02, SUB_MIX_12, SUB_MIX_22, SUB_MIX_32, SBOX2) {
            var nRounds = this._nRounds;
            var s0 = M3[offset] ^ keySchedule[0];
            var s1 = M3[offset + 1] ^ keySchedule[1];
            var s22 = M3[offset + 2] ^ keySchedule[2];
            var s3 = M3[offset + 3] ^ keySchedule[3];
            var ksRow = 4;
            for (var round = 1; round < nRounds; round++) {
              var t0 = SUB_MIX_02[s0 >>> 24] ^ SUB_MIX_12[s1 >>> 16 & 255] ^ SUB_MIX_22[s22 >>> 8 & 255] ^ SUB_MIX_32[s3 & 255] ^ keySchedule[ksRow++];
              var t1 = SUB_MIX_02[s1 >>> 24] ^ SUB_MIX_12[s22 >>> 16 & 255] ^ SUB_MIX_22[s3 >>> 8 & 255] ^ SUB_MIX_32[s0 & 255] ^ keySchedule[ksRow++];
              var t2 = SUB_MIX_02[s22 >>> 24] ^ SUB_MIX_12[s3 >>> 16 & 255] ^ SUB_MIX_22[s0 >>> 8 & 255] ^ SUB_MIX_32[s1 & 255] ^ keySchedule[ksRow++];
              var t3 = SUB_MIX_02[s3 >>> 24] ^ SUB_MIX_12[s0 >>> 16 & 255] ^ SUB_MIX_22[s1 >>> 8 & 255] ^ SUB_MIX_32[s22 & 255] ^ keySchedule[ksRow++];
              s0 = t0;
              s1 = t1;
              s22 = t2;
              s3 = t3;
            }
            var t0 = (SBOX2[s0 >>> 24] << 24 | SBOX2[s1 >>> 16 & 255] << 16 | SBOX2[s22 >>> 8 & 255] << 8 | SBOX2[s3 & 255]) ^ keySchedule[ksRow++];
            var t1 = (SBOX2[s1 >>> 24] << 24 | SBOX2[s22 >>> 16 & 255] << 16 | SBOX2[s3 >>> 8 & 255] << 8 | SBOX2[s0 & 255]) ^ keySchedule[ksRow++];
            var t2 = (SBOX2[s22 >>> 24] << 24 | SBOX2[s3 >>> 16 & 255] << 16 | SBOX2[s0 >>> 8 & 255] << 8 | SBOX2[s1 & 255]) ^ keySchedule[ksRow++];
            var t3 = (SBOX2[s3 >>> 24] << 24 | SBOX2[s0 >>> 16 & 255] << 16 | SBOX2[s1 >>> 8 & 255] << 8 | SBOX2[s22 & 255]) ^ keySchedule[ksRow++];
            M3[offset] = t0;
            M3[offset + 1] = t1;
            M3[offset + 2] = t2;
            M3[offset + 3] = t3;
          },
          keySize: 256 / 32
        });
        C3.AES = BlockCipher._createHelper(AES);
      })();
      return CryptoJS.AES;
    });
  }
});

// ../../node_modules/.pnpm/crypto-js@4.2.0/node_modules/crypto-js/tripledes.js
var require_tripledes = __commonJS({
  "../../node_modules/.pnpm/crypto-js@4.2.0/node_modules/crypto-js/tripledes.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_enc_base64(), require_md53(), require_evpkdf(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./enc-base64", "./md5", "./evpkdf", "./cipher-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function() {
        var C3 = CryptoJS;
        var C_lib = C3.lib;
        var WordArray = C_lib.WordArray;
        var BlockCipher = C_lib.BlockCipher;
        var C_algo = C3.algo;
        var PC1 = [
          57,
          49,
          41,
          33,
          25,
          17,
          9,
          1,
          58,
          50,
          42,
          34,
          26,
          18,
          10,
          2,
          59,
          51,
          43,
          35,
          27,
          19,
          11,
          3,
          60,
          52,
          44,
          36,
          63,
          55,
          47,
          39,
          31,
          23,
          15,
          7,
          62,
          54,
          46,
          38,
          30,
          22,
          14,
          6,
          61,
          53,
          45,
          37,
          29,
          21,
          13,
          5,
          28,
          20,
          12,
          4
        ];
        var PC2 = [
          14,
          17,
          11,
          24,
          1,
          5,
          3,
          28,
          15,
          6,
          21,
          10,
          23,
          19,
          12,
          4,
          26,
          8,
          16,
          7,
          27,
          20,
          13,
          2,
          41,
          52,
          31,
          37,
          47,
          55,
          30,
          40,
          51,
          45,
          33,
          48,
          44,
          49,
          39,
          56,
          34,
          53,
          46,
          42,
          50,
          36,
          29,
          32
        ];
        var BIT_SHIFTS = [1, 2, 4, 6, 8, 10, 12, 14, 15, 17, 19, 21, 23, 25, 27, 28];
        var SBOX_P = [
          {
            0: 8421888,
            268435456: 32768,
            536870912: 8421378,
            805306368: 2,
            1073741824: 512,
            1342177280: 8421890,
            1610612736: 8389122,
            1879048192: 8388608,
            2147483648: 514,
            2415919104: 8389120,
            2684354560: 33280,
            2952790016: 8421376,
            3221225472: 32770,
            3489660928: 8388610,
            3758096384: 0,
            4026531840: 33282,
            134217728: 0,
            402653184: 8421890,
            671088640: 33282,
            939524096: 32768,
            1207959552: 8421888,
            1476395008: 512,
            1744830464: 8421378,
            2013265920: 2,
            2281701376: 8389120,
            2550136832: 33280,
            2818572288: 8421376,
            3087007744: 8389122,
            3355443200: 8388610,
            3623878656: 32770,
            3892314112: 514,
            4160749568: 8388608,
            1: 32768,
            268435457: 2,
            536870913: 8421888,
            805306369: 8388608,
            1073741825: 8421378,
            1342177281: 33280,
            1610612737: 512,
            1879048193: 8389122,
            2147483649: 8421890,
            2415919105: 8421376,
            2684354561: 8388610,
            2952790017: 33282,
            3221225473: 514,
            3489660929: 8389120,
            3758096385: 32770,
            4026531841: 0,
            134217729: 8421890,
            402653185: 8421376,
            671088641: 8388608,
            939524097: 512,
            1207959553: 32768,
            1476395009: 8388610,
            1744830465: 2,
            2013265921: 33282,
            2281701377: 32770,
            2550136833: 8389122,
            2818572289: 514,
            3087007745: 8421888,
            3355443201: 8389120,
            3623878657: 0,
            3892314113: 33280,
            4160749569: 8421378
          },
          {
            0: 1074282512,
            16777216: 16384,
            33554432: 524288,
            50331648: 1074266128,
            67108864: 1073741840,
            83886080: 1074282496,
            100663296: 1073758208,
            117440512: 16,
            134217728: 540672,
            150994944: 1073758224,
            167772160: 1073741824,
            184549376: 540688,
            201326592: 524304,
            218103808: 0,
            234881024: 16400,
            251658240: 1074266112,
            8388608: 1073758208,
            25165824: 540688,
            41943040: 16,
            58720256: 1073758224,
            75497472: 1074282512,
            92274688: 1073741824,
            109051904: 524288,
            125829120: 1074266128,
            142606336: 524304,
            159383552: 0,
            176160768: 16384,
            192937984: 1074266112,
            209715200: 1073741840,
            226492416: 540672,
            243269632: 1074282496,
            260046848: 16400,
            268435456: 0,
            285212672: 1074266128,
            301989888: 1073758224,
            318767104: 1074282496,
            335544320: 1074266112,
            352321536: 16,
            369098752: 540688,
            385875968: 16384,
            402653184: 16400,
            419430400: 524288,
            436207616: 524304,
            452984832: 1073741840,
            469762048: 540672,
            486539264: 1073758208,
            503316480: 1073741824,
            520093696: 1074282512,
            276824064: 540688,
            293601280: 524288,
            310378496: 1074266112,
            327155712: 16384,
            343932928: 1073758208,
            360710144: 1074282512,
            377487360: 16,
            394264576: 1073741824,
            411041792: 1074282496,
            427819008: 1073741840,
            444596224: 1073758224,
            461373440: 524304,
            478150656: 0,
            494927872: 16400,
            511705088: 1074266128,
            528482304: 540672
          },
          {
            0: 260,
            1048576: 0,
            2097152: 67109120,
            3145728: 65796,
            4194304: 65540,
            5242880: 67108868,
            6291456: 67174660,
            7340032: 67174400,
            8388608: 67108864,
            9437184: 67174656,
            10485760: 65792,
            11534336: 67174404,
            12582912: 67109124,
            13631488: 65536,
            14680064: 4,
            15728640: 256,
            524288: 67174656,
            1572864: 67174404,
            2621440: 0,
            3670016: 67109120,
            4718592: 67108868,
            5767168: 65536,
            6815744: 65540,
            7864320: 260,
            8912896: 4,
            9961472: 256,
            11010048: 67174400,
            12058624: 65796,
            13107200: 65792,
            14155776: 67109124,
            15204352: 67174660,
            16252928: 67108864,
            16777216: 67174656,
            17825792: 65540,
            18874368: 65536,
            19922944: 67109120,
            20971520: 256,
            22020096: 67174660,
            23068672: 67108868,
            24117248: 0,
            25165824: 67109124,
            26214400: 67108864,
            27262976: 4,
            28311552: 65792,
            29360128: 67174400,
            30408704: 260,
            31457280: 65796,
            32505856: 67174404,
            17301504: 67108864,
            18350080: 260,
            19398656: 67174656,
            20447232: 0,
            21495808: 65540,
            22544384: 67109120,
            23592960: 256,
            24641536: 67174404,
            25690112: 65536,
            26738688: 67174660,
            27787264: 65796,
            28835840: 67108868,
            29884416: 67109124,
            30932992: 67174400,
            31981568: 4,
            33030144: 65792
          },
          {
            0: 2151682048,
            65536: 2147487808,
            131072: 4198464,
            196608: 2151677952,
            262144: 0,
            327680: 4198400,
            393216: 2147483712,
            458752: 4194368,
            524288: 2147483648,
            589824: 4194304,
            655360: 64,
            720896: 2147487744,
            786432: 2151678016,
            851968: 4160,
            917504: 4096,
            983040: 2151682112,
            32768: 2147487808,
            98304: 64,
            163840: 2151678016,
            229376: 2147487744,
            294912: 4198400,
            360448: 2151682112,
            425984: 0,
            491520: 2151677952,
            557056: 4096,
            622592: 2151682048,
            688128: 4194304,
            753664: 4160,
            819200: 2147483648,
            884736: 4194368,
            950272: 4198464,
            1015808: 2147483712,
            1048576: 4194368,
            1114112: 4198400,
            1179648: 2147483712,
            1245184: 0,
            1310720: 4160,
            1376256: 2151678016,
            1441792: 2151682048,
            1507328: 2147487808,
            1572864: 2151682112,
            1638400: 2147483648,
            1703936: 2151677952,
            1769472: 4198464,
            1835008: 2147487744,
            1900544: 4194304,
            1966080: 64,
            2031616: 4096,
            1081344: 2151677952,
            1146880: 2151682112,
            1212416: 0,
            1277952: 4198400,
            1343488: 4194368,
            1409024: 2147483648,
            1474560: 2147487808,
            1540096: 64,
            1605632: 2147483712,
            1671168: 4096,
            1736704: 2147487744,
            1802240: 2151678016,
            1867776: 4160,
            1933312: 2151682048,
            1998848: 4194304,
            2064384: 4198464
          },
          {
            0: 128,
            4096: 17039360,
            8192: 262144,
            12288: 536870912,
            16384: 537133184,
            20480: 16777344,
            24576: 553648256,
            28672: 262272,
            32768: 16777216,
            36864: 537133056,
            40960: 536871040,
            45056: 553910400,
            49152: 553910272,
            53248: 0,
            57344: 17039488,
            61440: 553648128,
            2048: 17039488,
            6144: 553648256,
            10240: 128,
            14336: 17039360,
            18432: 262144,
            22528: 537133184,
            26624: 553910272,
            30720: 536870912,
            34816: 537133056,
            38912: 0,
            43008: 553910400,
            47104: 16777344,
            51200: 536871040,
            55296: 553648128,
            59392: 16777216,
            63488: 262272,
            65536: 262144,
            69632: 128,
            73728: 536870912,
            77824: 553648256,
            81920: 16777344,
            86016: 553910272,
            90112: 537133184,
            94208: 16777216,
            98304: 553910400,
            102400: 553648128,
            106496: 17039360,
            110592: 537133056,
            114688: 262272,
            118784: 536871040,
            122880: 0,
            126976: 17039488,
            67584: 553648256,
            71680: 16777216,
            75776: 17039360,
            79872: 537133184,
            83968: 536870912,
            88064: 17039488,
            92160: 128,
            96256: 553910272,
            100352: 262272,
            104448: 553910400,
            108544: 0,
            112640: 553648128,
            116736: 16777344,
            120832: 262144,
            124928: 537133056,
            129024: 536871040
          },
          {
            0: 268435464,
            256: 8192,
            512: 270532608,
            768: 270540808,
            1024: 268443648,
            1280: 2097152,
            1536: 2097160,
            1792: 268435456,
            2048: 0,
            2304: 268443656,
            2560: 2105344,
            2816: 8,
            3072: 270532616,
            3328: 2105352,
            3584: 8200,
            3840: 270540800,
            128: 270532608,
            384: 270540808,
            640: 8,
            896: 2097152,
            1152: 2105352,
            1408: 268435464,
            1664: 268443648,
            1920: 8200,
            2176: 2097160,
            2432: 8192,
            2688: 268443656,
            2944: 270532616,
            3200: 0,
            3456: 270540800,
            3712: 2105344,
            3968: 268435456,
            4096: 268443648,
            4352: 270532616,
            4608: 270540808,
            4864: 8200,
            5120: 2097152,
            5376: 268435456,
            5632: 268435464,
            5888: 2105344,
            6144: 2105352,
            6400: 0,
            6656: 8,
            6912: 270532608,
            7168: 8192,
            7424: 268443656,
            7680: 270540800,
            7936: 2097160,
            4224: 8,
            4480: 2105344,
            4736: 2097152,
            4992: 268435464,
            5248: 268443648,
            5504: 8200,
            5760: 270540808,
            6016: 270532608,
            6272: 270540800,
            6528: 270532616,
            6784: 8192,
            7040: 2105352,
            7296: 2097160,
            7552: 0,
            7808: 268435456,
            8064: 268443656
          },
          {
            0: 1048576,
            16: 33555457,
            32: 1024,
            48: 1049601,
            64: 34604033,
            80: 0,
            96: 1,
            112: 34603009,
            128: 33555456,
            144: 1048577,
            160: 33554433,
            176: 34604032,
            192: 34603008,
            208: 1025,
            224: 1049600,
            240: 33554432,
            8: 34603009,
            24: 0,
            40: 33555457,
            56: 34604032,
            72: 1048576,
            88: 33554433,
            104: 33554432,
            120: 1025,
            136: 1049601,
            152: 33555456,
            168: 34603008,
            184: 1048577,
            200: 1024,
            216: 34604033,
            232: 1,
            248: 1049600,
            256: 33554432,
            272: 1048576,
            288: 33555457,
            304: 34603009,
            320: 1048577,
            336: 33555456,
            352: 34604032,
            368: 1049601,
            384: 1025,
            400: 34604033,
            416: 1049600,
            432: 1,
            448: 0,
            464: 34603008,
            480: 33554433,
            496: 1024,
            264: 1049600,
            280: 33555457,
            296: 34603009,
            312: 1,
            328: 33554432,
            344: 1048576,
            360: 1025,
            376: 34604032,
            392: 33554433,
            408: 34603008,
            424: 0,
            440: 34604033,
            456: 1049601,
            472: 1024,
            488: 33555456,
            504: 1048577
          },
          {
            0: 134219808,
            1: 131072,
            2: 134217728,
            3: 32,
            4: 131104,
            5: 134350880,
            6: 134350848,
            7: 2048,
            8: 134348800,
            9: 134219776,
            10: 133120,
            11: 134348832,
            12: 2080,
            13: 0,
            14: 134217760,
            15: 133152,
            2147483648: 2048,
            2147483649: 134350880,
            2147483650: 134219808,
            2147483651: 134217728,
            2147483652: 134348800,
            2147483653: 133120,
            2147483654: 133152,
            2147483655: 32,
            2147483656: 134217760,
            2147483657: 2080,
            2147483658: 131104,
            2147483659: 134350848,
            2147483660: 0,
            2147483661: 134348832,
            2147483662: 134219776,
            2147483663: 131072,
            16: 133152,
            17: 134350848,
            18: 32,
            19: 2048,
            20: 134219776,
            21: 134217760,
            22: 134348832,
            23: 131072,
            24: 0,
            25: 131104,
            26: 134348800,
            27: 134219808,
            28: 134350880,
            29: 133120,
            30: 2080,
            31: 134217728,
            2147483664: 131072,
            2147483665: 2048,
            2147483666: 134348832,
            2147483667: 133152,
            2147483668: 32,
            2147483669: 134348800,
            2147483670: 134217728,
            2147483671: 134219808,
            2147483672: 134350880,
            2147483673: 134217760,
            2147483674: 134219776,
            2147483675: 0,
            2147483676: 133120,
            2147483677: 2080,
            2147483678: 131104,
            2147483679: 134350848
          }
        ];
        var SBOX_MASK = [
          4160749569,
          528482304,
          33030144,
          2064384,
          129024,
          8064,
          504,
          2147483679
        ];
        var DES = C_algo.DES = BlockCipher.extend({
          _doReset: function() {
            var key = this._key;
            var keyWords = key.words;
            var keyBits = [];
            for (var i4 = 0; i4 < 56; i4++) {
              var keyBitPos = PC1[i4] - 1;
              keyBits[i4] = keyWords[keyBitPos >>> 5] >>> 31 - keyBitPos % 32 & 1;
            }
            var subKeys = this._subKeys = [];
            for (var nSubKey = 0; nSubKey < 16; nSubKey++) {
              var subKey = subKeys[nSubKey] = [];
              var bitShift = BIT_SHIFTS[nSubKey];
              for (var i4 = 0; i4 < 24; i4++) {
                subKey[i4 / 6 | 0] |= keyBits[(PC2[i4] - 1 + bitShift) % 28] << 31 - i4 % 6;
                subKey[4 + (i4 / 6 | 0)] |= keyBits[28 + (PC2[i4 + 24] - 1 + bitShift) % 28] << 31 - i4 % 6;
              }
              subKey[0] = subKey[0] << 1 | subKey[0] >>> 31;
              for (var i4 = 1; i4 < 7; i4++) {
                subKey[i4] = subKey[i4] >>> (i4 - 1) * 4 + 3;
              }
              subKey[7] = subKey[7] << 5 | subKey[7] >>> 27;
            }
            var invSubKeys = this._invSubKeys = [];
            for (var i4 = 0; i4 < 16; i4++) {
              invSubKeys[i4] = subKeys[15 - i4];
            }
          },
          encryptBlock: function(M3, offset) {
            this._doCryptBlock(M3, offset, this._subKeys);
          },
          decryptBlock: function(M3, offset) {
            this._doCryptBlock(M3, offset, this._invSubKeys);
          },
          _doCryptBlock: function(M3, offset, subKeys) {
            this._lBlock = M3[offset];
            this._rBlock = M3[offset + 1];
            exchangeLR.call(this, 4, 252645135);
            exchangeLR.call(this, 16, 65535);
            exchangeRL.call(this, 2, 858993459);
            exchangeRL.call(this, 8, 16711935);
            exchangeLR.call(this, 1, 1431655765);
            for (var round = 0; round < 16; round++) {
              var subKey = subKeys[round];
              var lBlock = this._lBlock;
              var rBlock = this._rBlock;
              var f6 = 0;
              for (var i4 = 0; i4 < 8; i4++) {
                f6 |= SBOX_P[i4][((rBlock ^ subKey[i4]) & SBOX_MASK[i4]) >>> 0];
              }
              this._lBlock = rBlock;
              this._rBlock = lBlock ^ f6;
            }
            var t = this._lBlock;
            this._lBlock = this._rBlock;
            this._rBlock = t;
            exchangeLR.call(this, 1, 1431655765);
            exchangeRL.call(this, 8, 16711935);
            exchangeRL.call(this, 2, 858993459);
            exchangeLR.call(this, 16, 65535);
            exchangeLR.call(this, 4, 252645135);
            M3[offset] = this._lBlock;
            M3[offset + 1] = this._rBlock;
          },
          keySize: 64 / 32,
          ivSize: 64 / 32,
          blockSize: 64 / 32
        });
        function exchangeLR(offset, mask) {
          var t = (this._lBlock >>> offset ^ this._rBlock) & mask;
          this._rBlock ^= t;
          this._lBlock ^= t << offset;
        }
        function exchangeRL(offset, mask) {
          var t = (this._rBlock >>> offset ^ this._lBlock) & mask;
          this._lBlock ^= t;
          this._rBlock ^= t << offset;
        }
        C3.DES = BlockCipher._createHelper(DES);
        var TripleDES = C_algo.TripleDES = BlockCipher.extend({
          _doReset: function() {
            var key = this._key;
            var keyWords = key.words;
            if (keyWords.length !== 2 && keyWords.length !== 4 && keyWords.length < 6) {
              throw new Error("Invalid key length - 3DES requires the key length to be 64, 128, 192 or >192.");
            }
            var key1 = keyWords.slice(0, 2);
            var key2 = keyWords.length < 4 ? keyWords.slice(0, 2) : keyWords.slice(2, 4);
            var key3 = keyWords.length < 6 ? keyWords.slice(0, 2) : keyWords.slice(4, 6);
            this._des1 = DES.createEncryptor(WordArray.create(key1));
            this._des2 = DES.createEncryptor(WordArray.create(key2));
            this._des3 = DES.createEncryptor(WordArray.create(key3));
          },
          encryptBlock: function(M3, offset) {
            this._des1.encryptBlock(M3, offset);
            this._des2.decryptBlock(M3, offset);
            this._des3.encryptBlock(M3, offset);
          },
          decryptBlock: function(M3, offset) {
            this._des3.decryptBlock(M3, offset);
            this._des2.encryptBlock(M3, offset);
            this._des1.decryptBlock(M3, offset);
          },
          keySize: 192 / 32,
          ivSize: 64 / 32,
          blockSize: 64 / 32
        });
        C3.TripleDES = BlockCipher._createHelper(TripleDES);
      })();
      return CryptoJS.TripleDES;
    });
  }
});

// ../../node_modules/.pnpm/crypto-js@4.2.0/node_modules/crypto-js/rc4.js
var require_rc4 = __commonJS({
  "../../node_modules/.pnpm/crypto-js@4.2.0/node_modules/crypto-js/rc4.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_enc_base64(), require_md53(), require_evpkdf(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./enc-base64", "./md5", "./evpkdf", "./cipher-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function() {
        var C3 = CryptoJS;
        var C_lib = C3.lib;
        var StreamCipher = C_lib.StreamCipher;
        var C_algo = C3.algo;
        var RC4 = C_algo.RC4 = StreamCipher.extend({
          _doReset: function() {
            var key = this._key;
            var keyWords = key.words;
            var keySigBytes = key.sigBytes;
            var S4 = this._S = [];
            for (var i4 = 0; i4 < 256; i4++) {
              S4[i4] = i4;
            }
            for (var i4 = 0, j2 = 0; i4 < 256; i4++) {
              var keyByteIndex = i4 % keySigBytes;
              var keyByte = keyWords[keyByteIndex >>> 2] >>> 24 - keyByteIndex % 4 * 8 & 255;
              j2 = (j2 + S4[i4] + keyByte) % 256;
              var t = S4[i4];
              S4[i4] = S4[j2];
              S4[j2] = t;
            }
            this._i = this._j = 0;
          },
          _doProcessBlock: function(M3, offset) {
            M3[offset] ^= generateKeystreamWord.call(this);
          },
          keySize: 256 / 32,
          ivSize: 0
        });
        function generateKeystreamWord() {
          var S4 = this._S;
          var i4 = this._i;
          var j2 = this._j;
          var keystreamWord = 0;
          for (var n5 = 0; n5 < 4; n5++) {
            i4 = (i4 + 1) % 256;
            j2 = (j2 + S4[i4]) % 256;
            var t = S4[i4];
            S4[i4] = S4[j2];
            S4[j2] = t;
            keystreamWord |= S4[(S4[i4] + S4[j2]) % 256] << 24 - n5 * 8;
          }
          this._i = i4;
          this._j = j2;
          return keystreamWord;
        }
        C3.RC4 = StreamCipher._createHelper(RC4);
        var RC4Drop = C_algo.RC4Drop = RC4.extend({
          /**
           * Configuration options.
           *
           * @property {number} drop The number of keystream words to drop. Default 192
           */
          cfg: RC4.cfg.extend({
            drop: 192
          }),
          _doReset: function() {
            RC4._doReset.call(this);
            for (var i4 = this.cfg.drop; i4 > 0; i4--) {
              generateKeystreamWord.call(this);
            }
          }
        });
        C3.RC4Drop = StreamCipher._createHelper(RC4Drop);
      })();
      return CryptoJS.RC4;
    });
  }
});

// ../../node_modules/.pnpm/crypto-js@4.2.0/node_modules/crypto-js/rabbit.js
var require_rabbit = __commonJS({
  "../../node_modules/.pnpm/crypto-js@4.2.0/node_modules/crypto-js/rabbit.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_enc_base64(), require_md53(), require_evpkdf(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./enc-base64", "./md5", "./evpkdf", "./cipher-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function() {
        var C3 = CryptoJS;
        var C_lib = C3.lib;
        var StreamCipher = C_lib.StreamCipher;
        var C_algo = C3.algo;
        var S4 = [];
        var C_ = [];
        var G2 = [];
        var Rabbit = C_algo.Rabbit = StreamCipher.extend({
          _doReset: function() {
            var K2 = this._key.words;
            var iv = this.cfg.iv;
            for (var i4 = 0; i4 < 4; i4++) {
              K2[i4] = (K2[i4] << 8 | K2[i4] >>> 24) & 16711935 | (K2[i4] << 24 | K2[i4] >>> 8) & 4278255360;
            }
            var X2 = this._X = [
              K2[0],
              K2[3] << 16 | K2[2] >>> 16,
              K2[1],
              K2[0] << 16 | K2[3] >>> 16,
              K2[2],
              K2[1] << 16 | K2[0] >>> 16,
              K2[3],
              K2[2] << 16 | K2[1] >>> 16
            ];
            var C4 = this._C = [
              K2[2] << 16 | K2[2] >>> 16,
              K2[0] & 4294901760 | K2[1] & 65535,
              K2[3] << 16 | K2[3] >>> 16,
              K2[1] & 4294901760 | K2[2] & 65535,
              K2[0] << 16 | K2[0] >>> 16,
              K2[2] & 4294901760 | K2[3] & 65535,
              K2[1] << 16 | K2[1] >>> 16,
              K2[3] & 4294901760 | K2[0] & 65535
            ];
            this._b = 0;
            for (var i4 = 0; i4 < 4; i4++) {
              nextState.call(this);
            }
            for (var i4 = 0; i4 < 8; i4++) {
              C4[i4] ^= X2[i4 + 4 & 7];
            }
            if (iv) {
              var IV = iv.words;
              var IV_0 = IV[0];
              var IV_1 = IV[1];
              var i0 = (IV_0 << 8 | IV_0 >>> 24) & 16711935 | (IV_0 << 24 | IV_0 >>> 8) & 4278255360;
              var i22 = (IV_1 << 8 | IV_1 >>> 24) & 16711935 | (IV_1 << 24 | IV_1 >>> 8) & 4278255360;
              var i1 = i0 >>> 16 | i22 & 4294901760;
              var i32 = i22 << 16 | i0 & 65535;
              C4[0] ^= i0;
              C4[1] ^= i1;
              C4[2] ^= i22;
              C4[3] ^= i32;
              C4[4] ^= i0;
              C4[5] ^= i1;
              C4[6] ^= i22;
              C4[7] ^= i32;
              for (var i4 = 0; i4 < 4; i4++) {
                nextState.call(this);
              }
            }
          },
          _doProcessBlock: function(M3, offset) {
            var X2 = this._X;
            nextState.call(this);
            S4[0] = X2[0] ^ X2[5] >>> 16 ^ X2[3] << 16;
            S4[1] = X2[2] ^ X2[7] >>> 16 ^ X2[5] << 16;
            S4[2] = X2[4] ^ X2[1] >>> 16 ^ X2[7] << 16;
            S4[3] = X2[6] ^ X2[3] >>> 16 ^ X2[1] << 16;
            for (var i4 = 0; i4 < 4; i4++) {
              S4[i4] = (S4[i4] << 8 | S4[i4] >>> 24) & 16711935 | (S4[i4] << 24 | S4[i4] >>> 8) & 4278255360;
              M3[offset + i4] ^= S4[i4];
            }
          },
          blockSize: 128 / 32,
          ivSize: 64 / 32
        });
        function nextState() {
          var X2 = this._X;
          var C4 = this._C;
          for (var i4 = 0; i4 < 8; i4++) {
            C_[i4] = C4[i4];
          }
          C4[0] = C4[0] + 1295307597 + this._b | 0;
          C4[1] = C4[1] + 3545052371 + (C4[0] >>> 0 < C_[0] >>> 0 ? 1 : 0) | 0;
          C4[2] = C4[2] + 886263092 + (C4[1] >>> 0 < C_[1] >>> 0 ? 1 : 0) | 0;
          C4[3] = C4[3] + 1295307597 + (C4[2] >>> 0 < C_[2] >>> 0 ? 1 : 0) | 0;
          C4[4] = C4[4] + 3545052371 + (C4[3] >>> 0 < C_[3] >>> 0 ? 1 : 0) | 0;
          C4[5] = C4[5] + 886263092 + (C4[4] >>> 0 < C_[4] >>> 0 ? 1 : 0) | 0;
          C4[6] = C4[6] + 1295307597 + (C4[5] >>> 0 < C_[5] >>> 0 ? 1 : 0) | 0;
          C4[7] = C4[7] + 3545052371 + (C4[6] >>> 0 < C_[6] >>> 0 ? 1 : 0) | 0;
          this._b = C4[7] >>> 0 < C_[7] >>> 0 ? 1 : 0;
          for (var i4 = 0; i4 < 8; i4++) {
            var gx = X2[i4] + C4[i4];
            var ga2 = gx & 65535;
            var gb = gx >>> 16;
            var gh = ((ga2 * ga2 >>> 17) + ga2 * gb >>> 15) + gb * gb;
            var gl = ((gx & 4294901760) * gx | 0) + ((gx & 65535) * gx | 0);
            G2[i4] = gh ^ gl;
          }
          X2[0] = G2[0] + (G2[7] << 16 | G2[7] >>> 16) + (G2[6] << 16 | G2[6] >>> 16) | 0;
          X2[1] = G2[1] + (G2[0] << 8 | G2[0] >>> 24) + G2[7] | 0;
          X2[2] = G2[2] + (G2[1] << 16 | G2[1] >>> 16) + (G2[0] << 16 | G2[0] >>> 16) | 0;
          X2[3] = G2[3] + (G2[2] << 8 | G2[2] >>> 24) + G2[1] | 0;
          X2[4] = G2[4] + (G2[3] << 16 | G2[3] >>> 16) + (G2[2] << 16 | G2[2] >>> 16) | 0;
          X2[5] = G2[5] + (G2[4] << 8 | G2[4] >>> 24) + G2[3] | 0;
          X2[6] = G2[6] + (G2[5] << 16 | G2[5] >>> 16) + (G2[4] << 16 | G2[4] >>> 16) | 0;
          X2[7] = G2[7] + (G2[6] << 8 | G2[6] >>> 24) + G2[5] | 0;
        }
        C3.Rabbit = StreamCipher._createHelper(Rabbit);
      })();
      return CryptoJS.Rabbit;
    });
  }
});

// ../../node_modules/.pnpm/crypto-js@4.2.0/node_modules/crypto-js/rabbit-legacy.js
var require_rabbit_legacy = __commonJS({
  "../../node_modules/.pnpm/crypto-js@4.2.0/node_modules/crypto-js/rabbit-legacy.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_enc_base64(), require_md53(), require_evpkdf(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./enc-base64", "./md5", "./evpkdf", "./cipher-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function() {
        var C3 = CryptoJS;
        var C_lib = C3.lib;
        var StreamCipher = C_lib.StreamCipher;
        var C_algo = C3.algo;
        var S4 = [];
        var C_ = [];
        var G2 = [];
        var RabbitLegacy = C_algo.RabbitLegacy = StreamCipher.extend({
          _doReset: function() {
            var K2 = this._key.words;
            var iv = this.cfg.iv;
            var X2 = this._X = [
              K2[0],
              K2[3] << 16 | K2[2] >>> 16,
              K2[1],
              K2[0] << 16 | K2[3] >>> 16,
              K2[2],
              K2[1] << 16 | K2[0] >>> 16,
              K2[3],
              K2[2] << 16 | K2[1] >>> 16
            ];
            var C4 = this._C = [
              K2[2] << 16 | K2[2] >>> 16,
              K2[0] & 4294901760 | K2[1] & 65535,
              K2[3] << 16 | K2[3] >>> 16,
              K2[1] & 4294901760 | K2[2] & 65535,
              K2[0] << 16 | K2[0] >>> 16,
              K2[2] & 4294901760 | K2[3] & 65535,
              K2[1] << 16 | K2[1] >>> 16,
              K2[3] & 4294901760 | K2[0] & 65535
            ];
            this._b = 0;
            for (var i4 = 0; i4 < 4; i4++) {
              nextState.call(this);
            }
            for (var i4 = 0; i4 < 8; i4++) {
              C4[i4] ^= X2[i4 + 4 & 7];
            }
            if (iv) {
              var IV = iv.words;
              var IV_0 = IV[0];
              var IV_1 = IV[1];
              var i0 = (IV_0 << 8 | IV_0 >>> 24) & 16711935 | (IV_0 << 24 | IV_0 >>> 8) & 4278255360;
              var i22 = (IV_1 << 8 | IV_1 >>> 24) & 16711935 | (IV_1 << 24 | IV_1 >>> 8) & 4278255360;
              var i1 = i0 >>> 16 | i22 & 4294901760;
              var i32 = i22 << 16 | i0 & 65535;
              C4[0] ^= i0;
              C4[1] ^= i1;
              C4[2] ^= i22;
              C4[3] ^= i32;
              C4[4] ^= i0;
              C4[5] ^= i1;
              C4[6] ^= i22;
              C4[7] ^= i32;
              for (var i4 = 0; i4 < 4; i4++) {
                nextState.call(this);
              }
            }
          },
          _doProcessBlock: function(M3, offset) {
            var X2 = this._X;
            nextState.call(this);
            S4[0] = X2[0] ^ X2[5] >>> 16 ^ X2[3] << 16;
            S4[1] = X2[2] ^ X2[7] >>> 16 ^ X2[5] << 16;
            S4[2] = X2[4] ^ X2[1] >>> 16 ^ X2[7] << 16;
            S4[3] = X2[6] ^ X2[3] >>> 16 ^ X2[1] << 16;
            for (var i4 = 0; i4 < 4; i4++) {
              S4[i4] = (S4[i4] << 8 | S4[i4] >>> 24) & 16711935 | (S4[i4] << 24 | S4[i4] >>> 8) & 4278255360;
              M3[offset + i4] ^= S4[i4];
            }
          },
          blockSize: 128 / 32,
          ivSize: 64 / 32
        });
        function nextState() {
          var X2 = this._X;
          var C4 = this._C;
          for (var i4 = 0; i4 < 8; i4++) {
            C_[i4] = C4[i4];
          }
          C4[0] = C4[0] + 1295307597 + this._b | 0;
          C4[1] = C4[1] + 3545052371 + (C4[0] >>> 0 < C_[0] >>> 0 ? 1 : 0) | 0;
          C4[2] = C4[2] + 886263092 + (C4[1] >>> 0 < C_[1] >>> 0 ? 1 : 0) | 0;
          C4[3] = C4[3] + 1295307597 + (C4[2] >>> 0 < C_[2] >>> 0 ? 1 : 0) | 0;
          C4[4] = C4[4] + 3545052371 + (C4[3] >>> 0 < C_[3] >>> 0 ? 1 : 0) | 0;
          C4[5] = C4[5] + 886263092 + (C4[4] >>> 0 < C_[4] >>> 0 ? 1 : 0) | 0;
          C4[6] = C4[6] + 1295307597 + (C4[5] >>> 0 < C_[5] >>> 0 ? 1 : 0) | 0;
          C4[7] = C4[7] + 3545052371 + (C4[6] >>> 0 < C_[6] >>> 0 ? 1 : 0) | 0;
          this._b = C4[7] >>> 0 < C_[7] >>> 0 ? 1 : 0;
          for (var i4 = 0; i4 < 8; i4++) {
            var gx = X2[i4] + C4[i4];
            var ga2 = gx & 65535;
            var gb = gx >>> 16;
            var gh = ((ga2 * ga2 >>> 17) + ga2 * gb >>> 15) + gb * gb;
            var gl = ((gx & 4294901760) * gx | 0) + ((gx & 65535) * gx | 0);
            G2[i4] = gh ^ gl;
          }
          X2[0] = G2[0] + (G2[7] << 16 | G2[7] >>> 16) + (G2[6] << 16 | G2[6] >>> 16) | 0;
          X2[1] = G2[1] + (G2[0] << 8 | G2[0] >>> 24) + G2[7] | 0;
          X2[2] = G2[2] + (G2[1] << 16 | G2[1] >>> 16) + (G2[0] << 16 | G2[0] >>> 16) | 0;
          X2[3] = G2[3] + (G2[2] << 8 | G2[2] >>> 24) + G2[1] | 0;
          X2[4] = G2[4] + (G2[3] << 16 | G2[3] >>> 16) + (G2[2] << 16 | G2[2] >>> 16) | 0;
          X2[5] = G2[5] + (G2[4] << 8 | G2[4] >>> 24) + G2[3] | 0;
          X2[6] = G2[6] + (G2[5] << 16 | G2[5] >>> 16) + (G2[4] << 16 | G2[4] >>> 16) | 0;
          X2[7] = G2[7] + (G2[6] << 8 | G2[6] >>> 24) + G2[5] | 0;
        }
        C3.RabbitLegacy = StreamCipher._createHelper(RabbitLegacy);
      })();
      return CryptoJS.RabbitLegacy;
    });
  }
});

// ../../node_modules/.pnpm/crypto-js@4.2.0/node_modules/crypto-js/blowfish.js
var require_blowfish = __commonJS({
  "../../node_modules/.pnpm/crypto-js@4.2.0/node_modules/crypto-js/blowfish.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_enc_base64(), require_md53(), require_evpkdf(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./enc-base64", "./md5", "./evpkdf", "./cipher-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function() {
        var C3 = CryptoJS;
        var C_lib = C3.lib;
        var BlockCipher = C_lib.BlockCipher;
        var C_algo = C3.algo;
        const N3 = 16;
        const ORIG_P = [
          608135816,
          2242054355,
          320440878,
          57701188,
          2752067618,
          698298832,
          137296536,
          3964562569,
          1160258022,
          953160567,
          3193202383,
          887688300,
          3232508343,
          3380367581,
          1065670069,
          3041331479,
          2450970073,
          2306472731
        ];
        const ORIG_S = [
          [
            3509652390,
            2564797868,
            805139163,
            3491422135,
            3101798381,
            1780907670,
            3128725573,
            4046225305,
            614570311,
            3012652279,
            134345442,
            2240740374,
            1667834072,
            1901547113,
            2757295779,
            4103290238,
            227898511,
            1921955416,
            1904987480,
            2182433518,
            2069144605,
            3260701109,
            2620446009,
            720527379,
            3318853667,
            677414384,
            3393288472,
            3101374703,
            2390351024,
            1614419982,
            1822297739,
            2954791486,
            3608508353,
            3174124327,
            2024746970,
            1432378464,
            3864339955,
            2857741204,
            1464375394,
            1676153920,
            1439316330,
            715854006,
            3033291828,
            289532110,
            2706671279,
            2087905683,
            3018724369,
            1668267050,
            732546397,
            1947742710,
            3462151702,
            2609353502,
            2950085171,
            1814351708,
            2050118529,
            680887927,
            999245976,
            1800124847,
            3300911131,
            1713906067,
            1641548236,
            4213287313,
            1216130144,
            1575780402,
            4018429277,
            3917837745,
            3693486850,
            3949271944,
            596196993,
            3549867205,
            258830323,
            2213823033,
            772490370,
            2760122372,
            1774776394,
            2652871518,
            566650946,
            4142492826,
            1728879713,
            2882767088,
            1783734482,
            3629395816,
            2517608232,
            2874225571,
            1861159788,
            326777828,
            3124490320,
            2130389656,
            2716951837,
            967770486,
            1724537150,
            2185432712,
            2364442137,
            1164943284,
            2105845187,
            998989502,
            3765401048,
            2244026483,
            1075463327,
            1455516326,
            1322494562,
            910128902,
            469688178,
            1117454909,
            936433444,
            3490320968,
            3675253459,
            1240580251,
            122909385,
            2157517691,
            634681816,
            4142456567,
            3825094682,
            3061402683,
            2540495037,
            79693498,
            3249098678,
            1084186820,
            1583128258,
            426386531,
            1761308591,
            1047286709,
            322548459,
            995290223,
            1845252383,
            2603652396,
            3431023940,
            2942221577,
            3202600964,
            3727903485,
            1712269319,
            422464435,
            3234572375,
            1170764815,
            3523960633,
            3117677531,
            1434042557,
            442511882,
            3600875718,
            1076654713,
            1738483198,
            4213154764,
            2393238008,
            3677496056,
            1014306527,
            4251020053,
            793779912,
            2902807211,
            842905082,
            4246964064,
            1395751752,
            1040244610,
            2656851899,
            3396308128,
            445077038,
            3742853595,
            3577915638,
            679411651,
            2892444358,
            2354009459,
            1767581616,
            3150600392,
            3791627101,
            3102740896,
            284835224,
            4246832056,
            1258075500,
            768725851,
            2589189241,
            3069724005,
            3532540348,
            1274779536,
            3789419226,
            2764799539,
            1660621633,
            3471099624,
            4011903706,
            913787905,
            3497959166,
            737222580,
            2514213453,
            2928710040,
            3937242737,
            1804850592,
            3499020752,
            2949064160,
            2386320175,
            2390070455,
            2415321851,
            4061277028,
            2290661394,
            2416832540,
            1336762016,
            1754252060,
            3520065937,
            3014181293,
            791618072,
            3188594551,
            3933548030,
            2332172193,
            3852520463,
            3043980520,
            413987798,
            3465142937,
            3030929376,
            4245938359,
            2093235073,
            3534596313,
            375366246,
            2157278981,
            2479649556,
            555357303,
            3870105701,
            2008414854,
            3344188149,
            4221384143,
            3956125452,
            2067696032,
            3594591187,
            2921233993,
            2428461,
            544322398,
            577241275,
            1471733935,
            610547355,
            4027169054,
            1432588573,
            1507829418,
            2025931657,
            3646575487,
            545086370,
            48609733,
            2200306550,
            1653985193,
            298326376,
            1316178497,
            3007786442,
            2064951626,
            458293330,
            2589141269,
            3591329599,
            3164325604,
            727753846,
            2179363840,
            146436021,
            1461446943,
            4069977195,
            705550613,
            3059967265,
            3887724982,
            4281599278,
            3313849956,
            1404054877,
            2845806497,
            146425753,
            1854211946
          ],
          [
            1266315497,
            3048417604,
            3681880366,
            3289982499,
            290971e4,
            1235738493,
            2632868024,
            2414719590,
            3970600049,
            1771706367,
            1449415276,
            3266420449,
            422970021,
            1963543593,
            2690192192,
            3826793022,
            1062508698,
            1531092325,
            1804592342,
            2583117782,
            2714934279,
            4024971509,
            1294809318,
            4028980673,
            1289560198,
            2221992742,
            1669523910,
            35572830,
            157838143,
            1052438473,
            1016535060,
            1802137761,
            1753167236,
            1386275462,
            3080475397,
            2857371447,
            1040679964,
            2145300060,
            2390574316,
            1461121720,
            2956646967,
            4031777805,
            4028374788,
            33600511,
            2920084762,
            1018524850,
            629373528,
            3691585981,
            3515945977,
            2091462646,
            2486323059,
            586499841,
            988145025,
            935516892,
            3367335476,
            2599673255,
            2839830854,
            265290510,
            3972581182,
            2759138881,
            3795373465,
            1005194799,
            847297441,
            406762289,
            1314163512,
            1332590856,
            1866599683,
            4127851711,
            750260880,
            613907577,
            1450815602,
            3165620655,
            3734664991,
            3650291728,
            3012275730,
            3704569646,
            1427272223,
            778793252,
            1343938022,
            2676280711,
            2052605720,
            1946737175,
            3164576444,
            3914038668,
            3967478842,
            3682934266,
            1661551462,
            3294938066,
            4011595847,
            840292616,
            3712170807,
            616741398,
            312560963,
            711312465,
            1351876610,
            322626781,
            1910503582,
            271666773,
            2175563734,
            1594956187,
            70604529,
            3617834859,
            1007753275,
            1495573769,
            4069517037,
            2549218298,
            2663038764,
            504708206,
            2263041392,
            3941167025,
            2249088522,
            1514023603,
            1998579484,
            1312622330,
            694541497,
            2582060303,
            2151582166,
            1382467621,
            776784248,
            2618340202,
            3323268794,
            2497899128,
            2784771155,
            503983604,
            4076293799,
            907881277,
            423175695,
            432175456,
            1378068232,
            4145222326,
            3954048622,
            3938656102,
            3820766613,
            2793130115,
            2977904593,
            26017576,
            3274890735,
            3194772133,
            1700274565,
            1756076034,
            4006520079,
            3677328699,
            720338349,
            1533947780,
            354530856,
            688349552,
            3973924725,
            1637815568,
            332179504,
            3949051286,
            53804574,
            2852348879,
            3044236432,
            1282449977,
            3583942155,
            3416972820,
            4006381244,
            1617046695,
            2628476075,
            3002303598,
            1686838959,
            431878346,
            2686675385,
            1700445008,
            1080580658,
            1009431731,
            832498133,
            3223435511,
            2605976345,
            2271191193,
            2516031870,
            1648197032,
            4164389018,
            2548247927,
            300782431,
            375919233,
            238389289,
            3353747414,
            2531188641,
            2019080857,
            1475708069,
            455242339,
            2609103871,
            448939670,
            3451063019,
            1395535956,
            2413381860,
            1841049896,
            1491858159,
            885456874,
            4264095073,
            4001119347,
            1565136089,
            3898914787,
            1108368660,
            540939232,
            1173283510,
            2745871338,
            3681308437,
            4207628240,
            3343053890,
            4016749493,
            1699691293,
            1103962373,
            3625875870,
            2256883143,
            3830138730,
            1031889488,
            3479347698,
            1535977030,
            4236805024,
            3251091107,
            2132092099,
            1774941330,
            1199868427,
            1452454533,
            157007616,
            2904115357,
            342012276,
            595725824,
            1480756522,
            206960106,
            497939518,
            591360097,
            863170706,
            2375253569,
            3596610801,
            1814182875,
            2094937945,
            3421402208,
            1082520231,
            3463918190,
            2785509508,
            435703966,
            3908032597,
            1641649973,
            2842273706,
            3305899714,
            1510255612,
            2148256476,
            2655287854,
            3276092548,
            4258621189,
            236887753,
            3681803219,
            274041037,
            1734335097,
            3815195456,
            3317970021,
            1899903192,
            1026095262,
            4050517792,
            356393447,
            2410691914,
            3873677099,
            3682840055
          ],
          [
            3913112168,
            2491498743,
            4132185628,
            2489919796,
            1091903735,
            1979897079,
            3170134830,
            3567386728,
            3557303409,
            857797738,
            1136121015,
            1342202287,
            507115054,
            2535736646,
            337727348,
            3213592640,
            1301675037,
            2528481711,
            1895095763,
            1721773893,
            3216771564,
            62756741,
            2142006736,
            835421444,
            2531993523,
            1442658625,
            3659876326,
            2882144922,
            676362277,
            1392781812,
            170690266,
            3921047035,
            1759253602,
            3611846912,
            1745797284,
            664899054,
            1329594018,
            3901205900,
            3045908486,
            2062866102,
            2865634940,
            3543621612,
            3464012697,
            1080764994,
            553557557,
            3656615353,
            3996768171,
            991055499,
            499776247,
            1265440854,
            648242737,
            3940784050,
            980351604,
            3713745714,
            1749149687,
            3396870395,
            4211799374,
            3640570775,
            1161844396,
            3125318951,
            1431517754,
            545492359,
            4268468663,
            3499529547,
            1437099964,
            2702547544,
            3433638243,
            2581715763,
            2787789398,
            1060185593,
            1593081372,
            2418618748,
            4260947970,
            69676912,
            2159744348,
            86519011,
            2512459080,
            3838209314,
            1220612927,
            3339683548,
            133810670,
            1090789135,
            1078426020,
            1569222167,
            845107691,
            3583754449,
            4072456591,
            1091646820,
            628848692,
            1613405280,
            3757631651,
            526609435,
            236106946,
            48312990,
            2942717905,
            3402727701,
            1797494240,
            859738849,
            992217954,
            4005476642,
            2243076622,
            3870952857,
            3732016268,
            765654824,
            3490871365,
            2511836413,
            1685915746,
            3888969200,
            1414112111,
            2273134842,
            3281911079,
            4080962846,
            172450625,
            2569994100,
            980381355,
            4109958455,
            2819808352,
            2716589560,
            2568741196,
            3681446669,
            3329971472,
            1835478071,
            660984891,
            3704678404,
            4045999559,
            3422617507,
            3040415634,
            1762651403,
            1719377915,
            3470491036,
            2693910283,
            3642056355,
            3138596744,
            1364962596,
            2073328063,
            1983633131,
            926494387,
            3423689081,
            2150032023,
            4096667949,
            1749200295,
            3328846651,
            309677260,
            2016342300,
            1779581495,
            3079819751,
            111262694,
            1274766160,
            443224088,
            298511866,
            1025883608,
            3806446537,
            1145181785,
            168956806,
            3641502830,
            3584813610,
            1689216846,
            3666258015,
            3200248200,
            1692713982,
            2646376535,
            4042768518,
            1618508792,
            1610833997,
            3523052358,
            4130873264,
            2001055236,
            3610705100,
            2202168115,
            4028541809,
            2961195399,
            1006657119,
            2006996926,
            3186142756,
            1430667929,
            3210227297,
            1314452623,
            4074634658,
            4101304120,
            2273951170,
            1399257539,
            3367210612,
            3027628629,
            1190975929,
            2062231137,
            2333990788,
            2221543033,
            2438960610,
            1181637006,
            548689776,
            2362791313,
            3372408396,
            3104550113,
            3145860560,
            296247880,
            1970579870,
            3078560182,
            3769228297,
            1714227617,
            3291629107,
            3898220290,
            166772364,
            1251581989,
            493813264,
            448347421,
            195405023,
            2709975567,
            677966185,
            3703036547,
            1463355134,
            2715995803,
            1338867538,
            1343315457,
            2802222074,
            2684532164,
            233230375,
            2599980071,
            2000651841,
            3277868038,
            1638401717,
            4028070440,
            3237316320,
            6314154,
            819756386,
            300326615,
            590932579,
            1405279636,
            3267499572,
            3150704214,
            2428286686,
            3959192993,
            3461946742,
            1862657033,
            1266418056,
            963775037,
            2089974820,
            2263052895,
            1917689273,
            448879540,
            3550394620,
            3981727096,
            150775221,
            3627908307,
            1303187396,
            508620638,
            2975983352,
            2726630617,
            1817252668,
            1876281319,
            1457606340,
            908771278,
            3720792119,
            3617206836,
            2455994898,
            1729034894,
            1080033504
          ],
          [
            976866871,
            3556439503,
            2881648439,
            1522871579,
            1555064734,
            1336096578,
            3548522304,
            2579274686,
            3574697629,
            3205460757,
            3593280638,
            3338716283,
            3079412587,
            564236357,
            2993598910,
            1781952180,
            1464380207,
            3163844217,
            3332601554,
            1699332808,
            1393555694,
            1183702653,
            3581086237,
            1288719814,
            691649499,
            2847557200,
            2895455976,
            3193889540,
            2717570544,
            1781354906,
            1676643554,
            2592534050,
            3230253752,
            1126444790,
            2770207658,
            2633158820,
            2210423226,
            2615765581,
            2414155088,
            3127139286,
            673620729,
            2805611233,
            1269405062,
            4015350505,
            3341807571,
            4149409754,
            1057255273,
            2012875353,
            2162469141,
            2276492801,
            2601117357,
            993977747,
            3918593370,
            2654263191,
            753973209,
            36408145,
            2530585658,
            25011837,
            3520020182,
            2088578344,
            530523599,
            2918365339,
            1524020338,
            1518925132,
            3760827505,
            3759777254,
            1202760957,
            3985898139,
            3906192525,
            674977740,
            4174734889,
            2031300136,
            2019492241,
            3983892565,
            4153806404,
            3822280332,
            352677332,
            2297720250,
            60907813,
            90501309,
            3286998549,
            1016092578,
            2535922412,
            2839152426,
            457141659,
            509813237,
            4120667899,
            652014361,
            1966332200,
            2975202805,
            55981186,
            2327461051,
            676427537,
            3255491064,
            2882294119,
            3433927263,
            1307055953,
            942726286,
            933058658,
            2468411793,
            3933900994,
            4215176142,
            1361170020,
            2001714738,
            2830558078,
            3274259782,
            1222529897,
            1679025792,
            2729314320,
            3714953764,
            1770335741,
            151462246,
            3013232138,
            1682292957,
            1483529935,
            471910574,
            1539241949,
            458788160,
            3436315007,
            1807016891,
            3718408830,
            978976581,
            1043663428,
            3165965781,
            1927990952,
            4200891579,
            2372276910,
            3208408903,
            3533431907,
            1412390302,
            2931980059,
            4132332400,
            1947078029,
            3881505623,
            4168226417,
            2941484381,
            1077988104,
            1320477388,
            886195818,
            18198404,
            3786409e3,
            2509781533,
            112762804,
            3463356488,
            1866414978,
            891333506,
            18488651,
            661792760,
            1628790961,
            3885187036,
            3141171499,
            876946877,
            2693282273,
            1372485963,
            791857591,
            2686433993,
            3759982718,
            3167212022,
            3472953795,
            2716379847,
            445679433,
            3561995674,
            3504004811,
            3574258232,
            54117162,
            3331405415,
            2381918588,
            3769707343,
            4154350007,
            1140177722,
            4074052095,
            668550556,
            3214352940,
            367459370,
            261225585,
            2610173221,
            4209349473,
            3468074219,
            3265815641,
            314222801,
            3066103646,
            3808782860,
            282218597,
            3406013506,
            3773591054,
            379116347,
            1285071038,
            846784868,
            2669647154,
            3771962079,
            3550491691,
            2305946142,
            453669953,
            1268987020,
            3317592352,
            3279303384,
            3744833421,
            2610507566,
            3859509063,
            266596637,
            3847019092,
            517658769,
            3462560207,
            3443424879,
            370717030,
            4247526661,
            2224018117,
            4143653529,
            4112773975,
            2788324899,
            2477274417,
            1456262402,
            2901442914,
            1517677493,
            1846949527,
            2295493580,
            3734397586,
            2176403920,
            1280348187,
            1908823572,
            3871786941,
            846861322,
            1172426758,
            3287448474,
            3383383037,
            1655181056,
            3139813346,
            901632758,
            1897031941,
            2986607138,
            3066810236,
            3447102507,
            1393639104,
            373351379,
            950779232,
            625454576,
            3124240540,
            4148612726,
            2007998917,
            544563296,
            2244738638,
            2330496472,
            2058025392,
            1291430526,
            424198748,
            50039436,
            29584100,
            3605783033,
            2429876329,
            2791104160,
            1057563949,
            3255363231,
            3075367218,
            3463963227,
            1469046755,
            985887462
          ]
        ];
        var BLOWFISH_CTX = {
          pbox: [],
          sbox: []
        };
        function F2(ctx, x4) {
          let a3 = x4 >> 24 & 255;
          let b4 = x4 >> 16 & 255;
          let c6 = x4 >> 8 & 255;
          let d4 = x4 & 255;
          let y5 = ctx.sbox[0][a3] + ctx.sbox[1][b4];
          y5 = y5 ^ ctx.sbox[2][c6];
          y5 = y5 + ctx.sbox[3][d4];
          return y5;
        }
        function BlowFish_Encrypt(ctx, left, right) {
          let Xl = left;
          let Xr2 = right;
          let temp;
          for (let i4 = 0; i4 < N3; ++i4) {
            Xl = Xl ^ ctx.pbox[i4];
            Xr2 = F2(ctx, Xl) ^ Xr2;
            temp = Xl;
            Xl = Xr2;
            Xr2 = temp;
          }
          temp = Xl;
          Xl = Xr2;
          Xr2 = temp;
          Xr2 = Xr2 ^ ctx.pbox[N3];
          Xl = Xl ^ ctx.pbox[N3 + 1];
          return { left: Xl, right: Xr2 };
        }
        function BlowFish_Decrypt(ctx, left, right) {
          let Xl = left;
          let Xr2 = right;
          let temp;
          for (let i4 = N3 + 1; i4 > 1; --i4) {
            Xl = Xl ^ ctx.pbox[i4];
            Xr2 = F2(ctx, Xl) ^ Xr2;
            temp = Xl;
            Xl = Xr2;
            Xr2 = temp;
          }
          temp = Xl;
          Xl = Xr2;
          Xr2 = temp;
          Xr2 = Xr2 ^ ctx.pbox[1];
          Xl = Xl ^ ctx.pbox[0];
          return { left: Xl, right: Xr2 };
        }
        function BlowFishInit(ctx, key, keysize) {
          for (let Row = 0; Row < 4; Row++) {
            ctx.sbox[Row] = [];
            for (let Col = 0; Col < 256; Col++) {
              ctx.sbox[Row][Col] = ORIG_S[Row][Col];
            }
          }
          let keyIndex = 0;
          for (let index = 0; index < N3 + 2; index++) {
            ctx.pbox[index] = ORIG_P[index] ^ key[keyIndex];
            keyIndex++;
            if (keyIndex >= keysize) {
              keyIndex = 0;
            }
          }
          let Data1 = 0;
          let Data2 = 0;
          let res = 0;
          for (let i4 = 0; i4 < N3 + 2; i4 += 2) {
            res = BlowFish_Encrypt(ctx, Data1, Data2);
            Data1 = res.left;
            Data2 = res.right;
            ctx.pbox[i4] = Data1;
            ctx.pbox[i4 + 1] = Data2;
          }
          for (let i4 = 0; i4 < 4; i4++) {
            for (let j2 = 0; j2 < 256; j2 += 2) {
              res = BlowFish_Encrypt(ctx, Data1, Data2);
              Data1 = res.left;
              Data2 = res.right;
              ctx.sbox[i4][j2] = Data1;
              ctx.sbox[i4][j2 + 1] = Data2;
            }
          }
          return true;
        }
        var Blowfish = C_algo.Blowfish = BlockCipher.extend({
          _doReset: function() {
            if (this._keyPriorReset === this._key) {
              return;
            }
            var key = this._keyPriorReset = this._key;
            var keyWords = key.words;
            var keySize = key.sigBytes / 4;
            BlowFishInit(BLOWFISH_CTX, keyWords, keySize);
          },
          encryptBlock: function(M3, offset) {
            var res = BlowFish_Encrypt(BLOWFISH_CTX, M3[offset], M3[offset + 1]);
            M3[offset] = res.left;
            M3[offset + 1] = res.right;
          },
          decryptBlock: function(M3, offset) {
            var res = BlowFish_Decrypt(BLOWFISH_CTX, M3[offset], M3[offset + 1]);
            M3[offset] = res.left;
            M3[offset + 1] = res.right;
          },
          blockSize: 64 / 32,
          keySize: 128 / 32,
          ivSize: 64 / 32
        });
        C3.Blowfish = BlockCipher._createHelper(Blowfish);
      })();
      return CryptoJS.Blowfish;
    });
  }
});

// ../../node_modules/.pnpm/crypto-js@4.2.0/node_modules/crypto-js/index.js
var require_crypto_js = __commonJS({
  "../../node_modules/.pnpm/crypto-js@4.2.0/node_modules/crypto-js/index.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_x64_core(), require_lib_typedarrays(), require_enc_utf16(), require_enc_base64(), require_enc_base64url(), require_md53(), require_sha1(), require_sha2562(), require_sha224(), require_sha5122(), require_sha384(), require_sha32(), require_ripemd1602(), require_hmac(), require_pbkdf22(), require_evpkdf(), require_cipher_core(), require_mode_cfb(), require_mode_ctr(), require_mode_ctr_gladman(), require_mode_ofb(), require_mode_ecb(), require_pad_ansix923(), require_pad_iso10126(), require_pad_iso97971(), require_pad_zeropadding(), require_pad_nopadding(), require_format_hex(), require_aes(), require_tripledes(), require_rc4(), require_rabbit(), require_rabbit_legacy(), require_blowfish());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./x64-core", "./lib-typedarrays", "./enc-utf16", "./enc-base64", "./enc-base64url", "./md5", "./sha1", "./sha256", "./sha224", "./sha512", "./sha384", "./sha3", "./ripemd160", "./hmac", "./pbkdf2", "./evpkdf", "./cipher-core", "./mode-cfb", "./mode-ctr", "./mode-ctr-gladman", "./mode-ofb", "./mode-ecb", "./pad-ansix923", "./pad-iso10126", "./pad-iso97971", "./pad-zeropadding", "./pad-nopadding", "./format-hex", "./aes", "./tripledes", "./rc4", "./rabbit", "./rabbit-legacy", "./blowfish"], factory);
      } else {
        root.CryptoJS = factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      return CryptoJS;
    });
  }
});

// ../../node_modules/.pnpm/@keplr-wallet+crypto@0.12.28/node_modules/@keplr-wallet/crypto/build/hash.js
var require_hash = __commonJS({
  "../../node_modules/.pnpm/@keplr-wallet+crypto@0.12.28/node_modules/@keplr-wallet/crypto/build/hash.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Hash = void 0;
    var sha_js_1 = require_sha();
    var keccak256_1 = (init_lib4(), __toCommonJS(lib_exports));
    var buffer_1 = require_buffer();
    var Hash = class {
      static sha256(data) {
        return new Uint8Array(new sha_js_1.sha256().update(data).digest());
      }
      static keccak256(data) {
        return buffer_1.Buffer.from((0, keccak256_1.keccak256)(data).replace("0x", ""), "hex");
      }
      static truncHashPortion(str, firstCharCount = str.length, endCharCount = 0) {
        return str.substring(0, firstCharCount) + "" + str.substring(str.length - endCharCount, str.length);
      }
    };
    exports.Hash = Hash;
  }
});

// ../../node_modules/.pnpm/@keplr-wallet+crypto@0.12.28/node_modules/@keplr-wallet/crypto/build/key.js
var require_key = __commonJS({
  "../../node_modules/.pnpm/@keplr-wallet+crypto@0.12.28/node_modules/@keplr-wallet/crypto/build/key.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PubKeySecp256k1 = exports.PrivKeySecp256k1 = void 0;
    var elliptic_1 = require_elliptic();
    var crypto_js_1 = __importDefault(require_crypto_js());
    var buffer_1 = require_buffer();
    var hash_1 = require_hash();
    var PrivKeySecp256k1 = class _PrivKeySecp256k1 {
      static generateRandomKey() {
        const secp256k1 = new elliptic_1.ec("secp256k1");
        return new _PrivKeySecp256k1(buffer_1.Buffer.from(secp256k1.genKeyPair().getPrivate().toArray()));
      }
      constructor(privKey) {
        this.privKey = privKey;
      }
      toBytes() {
        return new Uint8Array(this.privKey);
      }
      getPubKey() {
        const secp256k1 = new elliptic_1.ec("secp256k1");
        const key = secp256k1.keyFromPrivate(this.privKey);
        return new PubKeySecp256k1(new Uint8Array(key.getPublic().encodeCompressed("array")));
      }
      signDigest32(digest) {
        if (digest.length !== 32) {
          throw new Error(`Invalid length of digest to sign: ${digest.length}`);
        }
        const secp256k1 = new elliptic_1.ec("secp256k1");
        const key = secp256k1.keyFromPrivate(this.privKey);
        const signature = key.sign(digest, {
          canonical: true
        });
        return {
          r: new Uint8Array(signature.r.toArray("be", 32)),
          s: new Uint8Array(signature.s.toArray("be", 32)),
          v: signature.recoveryParam
        };
      }
    };
    exports.PrivKeySecp256k1 = PrivKeySecp256k1;
    var PubKeySecp256k1 = class {
      constructor(pubKey) {
        this.pubKey = pubKey;
        if (pubKey.length !== 33 && pubKey.length !== 65) {
          throw new Error(`Invalid length of public key: ${pubKey.length}`);
        }
      }
      toBytes(uncompressed) {
        if (uncompressed && this.pubKey.length === 65) {
          return this.pubKey;
        }
        if (!uncompressed && this.pubKey.length === 33) {
          return this.pubKey;
        }
        const keyPair = this.toKeyPair();
        if (uncompressed) {
          return new Uint8Array(buffer_1.Buffer.from(keyPair.getPublic().encode("hex", false), "hex"));
        } else {
          return new Uint8Array(buffer_1.Buffer.from(keyPair.getPublic().encodeCompressed("hex"), "hex"));
        }
      }
      /**
       * @deprecated Use `getCosmosAddress()` instead.
       */
      getAddress() {
        return this.getCosmosAddress();
      }
      getCosmosAddress() {
        let hash = crypto_js_1.default.SHA256(crypto_js_1.default.lib.WordArray.create(this.toBytes(false))).toString();
        hash = crypto_js_1.default.RIPEMD160(crypto_js_1.default.enc.Hex.parse(hash)).toString();
        return new Uint8Array(buffer_1.Buffer.from(hash, "hex"));
      }
      getEthAddress() {
        return hash_1.Hash.keccak256(this.toBytes(true).slice(1)).slice(-20);
      }
      toKeyPair() {
        const secp256k1 = new elliptic_1.ec("secp256k1");
        return secp256k1.keyFromPublic(buffer_1.Buffer.from(this.pubKey).toString("hex"), "hex");
      }
      verifyDigest32(digest, signature) {
        if (digest.length !== 32) {
          throw new Error(`Invalid length of digest to verify: ${digest.length}`);
        }
        if (signature.length !== 64) {
          throw new Error(`Invalid length of signature: ${signature.length}`);
        }
        const secp256k1 = new elliptic_1.ec("secp256k1");
        const r3 = signature.slice(0, 32);
        const s3 = signature.slice(32);
        return secp256k1.verify(digest, {
          r: buffer_1.Buffer.from(r3).toString("hex"),
          s: buffer_1.Buffer.from(s3).toString("hex")
        }, this.toKeyPair());
      }
    };
    exports.PubKeySecp256k1 = PubKeySecp256k1;
  }
});

// ../../node_modules/.pnpm/@keplr-wallet+crypto@0.12.28/node_modules/@keplr-wallet/crypto/build/index.js
var require_build5 = __commonJS({
  "../../node_modules/.pnpm/@keplr-wallet+crypto@0.12.28/node_modules/@keplr-wallet/crypto/build/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o4, m3, k5, k22) {
      if (k22 === void 0)
        k22 = k5;
      var desc = Object.getOwnPropertyDescriptor(m3, k5);
      if (!desc || ("get" in desc ? !m3.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m3[k5];
        } };
      }
      Object.defineProperty(o4, k22, desc);
    } : function(o4, m3, k5, k22) {
      if (k22 === void 0)
        k22 = k5;
      o4[k22] = m3[k5];
    });
    var __exportStar = exports && exports.__exportStar || function(m3, exports2) {
      for (var p4 in m3)
        if (p4 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p4))
          __createBinding(exports2, m3, p4);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_mnemonic(), exports);
    __exportStar(require_key(), exports);
    __exportStar(require_hash(), exports);
  }
});

// ../../node_modules/.pnpm/@keplr-wallet+common@0.12.28/node_modules/@keplr-wallet/common/build/denom/index.js
var require_denom = __commonJS({
  "../../node_modules/.pnpm/@keplr-wallet+common@0.12.28/node_modules/@keplr-wallet/common/build/denom/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DenomHelper = void 0;
    var buffer_1 = require_buffer();
    var crypto_1 = require_build5();
    var DenomHelper = class {
      static ibcDenom(paths, coinMinimalDenom) {
        const prefixes = [];
        for (const path of paths) {
          prefixes.push(`${path.portId}/${path.channelId}`);
        }
        const prefix = prefixes.join("/");
        const denom = `${prefix}/${coinMinimalDenom}`;
        return "ibc/" + buffer_1.Buffer.from(crypto_1.Hash.sha256(buffer_1.Buffer.from(denom))).toString("hex").toUpperCase();
      }
      constructor(_denom) {
        this._denom = _denom;
        const split = this.denom.split(/(\w+):(\w+):(.+)/).filter(Boolean);
        if (split.length !== 1 && split.length !== 3) {
          throw new Error(`Invalid denom: ${this.denom}`);
        }
        this._type = split.length === 3 ? split[0] : "";
        this._contractAddress = split.length === 3 ? split[1] : "";
      }
      get denom() {
        return this._denom;
      }
      get type() {
        return this._type || "native";
      }
      get contractAddress() {
        return this._contractAddress;
      }
    };
    exports.DenomHelper = DenomHelper;
  }
});

// ../../node_modules/.pnpm/@keplr-wallet+common@0.12.28/node_modules/@keplr-wallet/common/build/mobx/etc.js
var require_etc2 = __commonJS({
  "../../node_modules/.pnpm/@keplr-wallet+common@0.12.28/node_modules/@keplr-wallet/common/build/mobx/etc.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.toGenerator = void 0;
    function* toGenerator(p4) {
      return yield p4;
    }
    exports.toGenerator = toGenerator;
  }
});

// ../../node_modules/.pnpm/mobx@6.13.7/node_modules/mobx/dist/mobx.esm.js
var mobx_esm_exports = {};
__export(mobx_esm_exports, {
  $mobx: () => $mobx,
  FlowCancellationError: () => FlowCancellationError,
  ObservableMap: () => ObservableMap,
  ObservableSet: () => ObservableSet,
  Reaction: () => Reaction,
  _allowStateChanges: () => allowStateChanges,
  _allowStateChangesInsideComputed: () => runInAction,
  _allowStateReadsEnd: () => allowStateReadsEnd,
  _allowStateReadsStart: () => allowStateReadsStart,
  _autoAction: () => autoAction,
  _endAction: () => _endAction,
  _getAdministration: () => getAdministration,
  _getGlobalState: () => getGlobalState,
  _interceptReads: () => interceptReads,
  _isComputingDerivation: () => isComputingDerivation,
  _resetGlobalState: () => resetGlobalState,
  _startAction: () => _startAction,
  action: () => action,
  autorun: () => autorun,
  comparer: () => comparer,
  computed: () => computed,
  configure: () => configure,
  createAtom: () => createAtom,
  defineProperty: () => apiDefineProperty,
  entries: () => entries,
  extendObservable: () => extendObservable,
  flow: () => flow,
  flowResult: () => flowResult,
  get: () => get,
  getAtom: () => getAtom,
  getDebugName: () => getDebugName,
  getDependencyTree: () => getDependencyTree,
  getObserverTree: () => getObserverTree,
  has: () => has,
  intercept: () => intercept,
  isAction: () => isAction,
  isBoxedObservable: () => isObservableValue,
  isComputed: () => isComputed,
  isComputedProp: () => isComputedProp,
  isFlow: () => isFlow,
  isFlowCancellationError: () => isFlowCancellationError,
  isObservable: () => isObservable,
  isObservableArray: () => isObservableArray,
  isObservableMap: () => isObservableMap,
  isObservableObject: () => isObservableObject,
  isObservableProp: () => isObservableProp,
  isObservableSet: () => isObservableSet,
  keys: () => keys,
  makeAutoObservable: () => makeAutoObservable,
  makeObservable: () => makeObservable,
  observable: () => observable,
  observe: () => observe,
  onBecomeObserved: () => onBecomeObserved,
  onBecomeUnobserved: () => onBecomeUnobserved,
  onReactionError: () => onReactionError,
  override: () => override,
  ownKeys: () => apiOwnKeys,
  reaction: () => reaction,
  remove: () => remove,
  runInAction: () => runInAction,
  set: () => set2,
  spy: () => spy,
  toJS: () => toJS,
  trace: () => trace,
  transaction: () => transaction,
  untracked: () => untracked,
  values: () => values,
  when: () => when
});
function die(error) {
  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }
  if (true) {
    var e2 = typeof error === "string" ? error : errors[error];
    if (typeof e2 === "function")
      e2 = e2.apply(null, args);
    throw new Error("[MobX] " + e2);
  }
  throw new Error(typeof error === "number" ? "[MobX] minified error nr: " + error + (args.length ? " " + args.map(String).join(",") : "") + ". Find the full error at: https://github.com/mobxjs/mobx/blob/main/packages/mobx/src/errors.ts" : "[MobX] " + error);
}
function getGlobal() {
  if (typeof globalThis !== "undefined") {
    return globalThis;
  }
  if (typeof window !== "undefined") {
    return window;
  }
  if (typeof global !== "undefined") {
    return global;
  }
  if (typeof self !== "undefined") {
    return self;
  }
  return mockGlobal;
}
function assertProxies() {
  if (!hasProxy) {
    die(true ? "`Proxy` objects are not available in the current environment. Please configure MobX to enable a fallback implementation.`" : "Proxy not available");
  }
}
function warnAboutProxyRequirement(msg) {
  if (globalState.verifyProxies) {
    die("MobX is currently configured to be able to run in ES5 mode, but in ES5 MobX won't be able to " + msg);
  }
}
function getNextId() {
  return ++globalState.mobxGuid;
}
function once(func) {
  var invoked = false;
  return function() {
    if (invoked) {
      return;
    }
    invoked = true;
    return func.apply(this, arguments);
  };
}
function isFunction(fn2) {
  return typeof fn2 === "function";
}
function isStringish(value) {
  var t = typeof value;
  switch (t) {
    case "string":
    case "symbol":
    case "number":
      return true;
  }
  return false;
}
function isObject(value) {
  return value !== null && typeof value === "object";
}
function isPlainObject(value) {
  if (!isObject(value)) {
    return false;
  }
  var proto = Object.getPrototypeOf(value);
  if (proto == null) {
    return true;
  }
  var protoConstructor = Object.hasOwnProperty.call(proto, "constructor") && proto.constructor;
  return typeof protoConstructor === "function" && protoConstructor.toString() === plainObjectString;
}
function isGenerator(obj) {
  var constructor = obj == null ? void 0 : obj.constructor;
  if (!constructor) {
    return false;
  }
  if ("GeneratorFunction" === constructor.name || "GeneratorFunction" === constructor.displayName) {
    return true;
  }
  return false;
}
function addHiddenProp(object2, propName, value) {
  defineProperty(object2, propName, {
    enumerable: false,
    writable: true,
    configurable: true,
    value
  });
}
function addHiddenFinalProp(object2, propName, value) {
  defineProperty(object2, propName, {
    enumerable: false,
    writable: false,
    configurable: true,
    value
  });
}
function createInstanceofPredicate(name, theClass) {
  var propName = "isMobX" + name;
  theClass.prototype[propName] = true;
  return function(x4) {
    return isObject(x4) && x4[propName] === true;
  };
}
function isES6Map(thing) {
  return thing != null && Object.prototype.toString.call(thing) === "[object Map]";
}
function isPlainES6Map(thing) {
  var mapProto = Object.getPrototypeOf(thing);
  var objectProto = Object.getPrototypeOf(mapProto);
  var nullProto = Object.getPrototypeOf(objectProto);
  return nullProto === null;
}
function isES6Set(thing) {
  return thing != null && Object.prototype.toString.call(thing) === "[object Set]";
}
function getPlainObjectKeys(object2) {
  var keys3 = Object.keys(object2);
  if (!hasGetOwnPropertySymbols) {
    return keys3;
  }
  var symbols = Object.getOwnPropertySymbols(object2);
  if (!symbols.length) {
    return keys3;
  }
  return [].concat(keys3, symbols.filter(function(s3) {
    return objectPrototype.propertyIsEnumerable.call(object2, s3);
  }));
}
function stringifyKey(key) {
  if (typeof key === "string") {
    return key;
  }
  if (typeof key === "symbol") {
    return key.toString();
  }
  return new String(key).toString();
}
function toPrimitive(value) {
  return value === null ? null : typeof value === "object" ? "" + value : value;
}
function hasProp(target, prop) {
  return objectPrototype.hasOwnProperty.call(target, prop);
}
function getFlag(flags, mask) {
  return !!(flags & mask);
}
function setFlag(flags, mask, newValue) {
  if (newValue) {
    flags |= mask;
  } else {
    flags &= ~mask;
  }
  return flags;
}
function _arrayLikeToArray(r3, a3) {
  (null == a3 || a3 > r3.length) && (a3 = r3.length);
  for (var e2 = 0, n5 = Array(a3); e2 < a3; e2++)
    n5[e2] = r3[e2];
  return n5;
}
function _defineProperties(e2, r3) {
  for (var t = 0; t < r3.length; t++) {
    var o4 = r3[t];
    o4.enumerable = o4.enumerable || false, o4.configurable = true, "value" in o4 && (o4.writable = true), Object.defineProperty(e2, _toPropertyKey(o4.key), o4);
  }
}
function _createClass(e2, r3, t) {
  return r3 && _defineProperties(e2.prototype, r3), t && _defineProperties(e2, t), Object.defineProperty(e2, "prototype", {
    writable: false
  }), e2;
}
function _createForOfIteratorHelperLoose(r3, e2) {
  var t = "undefined" != typeof Symbol && r3[Symbol.iterator] || r3["@@iterator"];
  if (t)
    return (t = t.call(r3)).next.bind(t);
  if (Array.isArray(r3) || (t = _unsupportedIterableToArray(r3)) || e2 && r3 && "number" == typeof r3.length) {
    t && (r3 = t);
    var o4 = 0;
    return function() {
      return o4 >= r3.length ? {
        done: true
      } : {
        done: false,
        value: r3[o4++]
      };
    };
  }
  throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _extends() {
  return _extends = Object.assign ? Object.assign.bind() : function(n5) {
    for (var e2 = 1; e2 < arguments.length; e2++) {
      var t = arguments[e2];
      for (var r3 in t)
        ({}).hasOwnProperty.call(t, r3) && (n5[r3] = t[r3]);
    }
    return n5;
  }, _extends.apply(null, arguments);
}
function _inheritsLoose(t, o4) {
  t.prototype = Object.create(o4.prototype), t.prototype.constructor = t, _setPrototypeOf(t, o4);
}
function _setPrototypeOf(t, e2) {
  return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t2, e3) {
    return t2.__proto__ = e3, t2;
  }, _setPrototypeOf(t, e2);
}
function _toPrimitive(t, r3) {
  if ("object" != typeof t || !t)
    return t;
  var e2 = t[Symbol.toPrimitive];
  if (void 0 !== e2) {
    var i4 = e2.call(t, r3 || "default");
    if ("object" != typeof i4)
      return i4;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r3 ? String : Number)(t);
}
function _toPropertyKey(t) {
  var i4 = _toPrimitive(t, "string");
  return "symbol" == typeof i4 ? i4 : i4 + "";
}
function _unsupportedIterableToArray(r3, a3) {
  if (r3) {
    if ("string" == typeof r3)
      return _arrayLikeToArray(r3, a3);
    var t = {}.toString.call(r3).slice(8, -1);
    return "Object" === t && r3.constructor && (t = r3.constructor.name), "Map" === t || "Set" === t ? Array.from(r3) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r3, a3) : void 0;
  }
}
function createDecoratorAnnotation(annotation) {
  function decorator(target, property) {
    if (is20223Decorator(property)) {
      return annotation.decorate_20223_(target, property);
    } else {
      storeAnnotation(target, property, annotation);
    }
  }
  return Object.assign(decorator, annotation);
}
function storeAnnotation(prototype, key, annotation) {
  if (!hasProp(prototype, storedAnnotationsSymbol)) {
    addHiddenProp(prototype, storedAnnotationsSymbol, _extends({}, prototype[storedAnnotationsSymbol]));
  }
  if (isOverride(annotation) && !hasProp(prototype[storedAnnotationsSymbol], key)) {
    var fieldName = prototype.constructor.name + ".prototype." + key.toString();
    die("'" + fieldName + "' is decorated with 'override', but no such decorated member was found on prototype.");
  }
  assertNotDecorated(prototype, annotation, key);
  if (!isOverride(annotation)) {
    prototype[storedAnnotationsSymbol][key] = annotation;
  }
}
function assertNotDecorated(prototype, annotation, key) {
  if (!isOverride(annotation) && hasProp(prototype[storedAnnotationsSymbol], key)) {
    var fieldName = prototype.constructor.name + ".prototype." + key.toString();
    var currentAnnotationType = prototype[storedAnnotationsSymbol][key].annotationType_;
    var requestedAnnotationType = annotation.annotationType_;
    die("Cannot apply '@" + requestedAnnotationType + "' to '" + fieldName + "':" + ("\nThe field is already decorated with '@" + currentAnnotationType + "'.") + "\nRe-decorating fields is not allowed.\nUse '@override' decorator for methods overridden by subclass.");
  }
}
function collectStoredAnnotations(target) {
  if (!hasProp(target, storedAnnotationsSymbol)) {
    addHiddenProp(target, storedAnnotationsSymbol, _extends({}, target[storedAnnotationsSymbol]));
  }
  return target[storedAnnotationsSymbol];
}
function is20223Decorator(context) {
  return typeof context == "object" && typeof context["kind"] == "string";
}
function assert20223DecoratorType(context, types) {
  if (!types.includes(context.kind)) {
    die("The decorator applied to '" + String(context.name) + "' cannot be used on a " + context.kind + " element");
  }
}
function createAtom(name, onBecomeObservedHandler, onBecomeUnobservedHandler) {
  if (onBecomeObservedHandler === void 0) {
    onBecomeObservedHandler = noop;
  }
  if (onBecomeUnobservedHandler === void 0) {
    onBecomeUnobservedHandler = noop;
  }
  var atom = new Atom(name);
  if (onBecomeObservedHandler !== noop) {
    onBecomeObserved(atom, onBecomeObservedHandler);
  }
  if (onBecomeUnobservedHandler !== noop) {
    onBecomeUnobserved(atom, onBecomeUnobservedHandler);
  }
  return atom;
}
function identityComparer(a3, b4) {
  return a3 === b4;
}
function structuralComparer(a3, b4) {
  return deepEqual(a3, b4);
}
function shallowComparer(a3, b4) {
  return deepEqual(a3, b4, 1);
}
function defaultComparer(a3, b4) {
  if (Object.is) {
    return Object.is(a3, b4);
  }
  return a3 === b4 ? a3 !== 0 || 1 / a3 === 1 / b4 : a3 !== a3 && b4 !== b4;
}
function deepEnhancer(v5, _16, name) {
  if (isObservable(v5)) {
    return v5;
  }
  if (Array.isArray(v5)) {
    return observable.array(v5, {
      name
    });
  }
  if (isPlainObject(v5)) {
    return observable.object(v5, void 0, {
      name
    });
  }
  if (isES6Map(v5)) {
    return observable.map(v5, {
      name
    });
  }
  if (isES6Set(v5)) {
    return observable.set(v5, {
      name
    });
  }
  if (typeof v5 === "function" && !isAction(v5) && !isFlow(v5)) {
    if (isGenerator(v5)) {
      return flow(v5);
    } else {
      return autoAction(name, v5);
    }
  }
  return v5;
}
function shallowEnhancer(v5, _16, name) {
  if (v5 === void 0 || v5 === null) {
    return v5;
  }
  if (isObservableObject(v5) || isObservableArray(v5) || isObservableMap(v5) || isObservableSet(v5)) {
    return v5;
  }
  if (Array.isArray(v5)) {
    return observable.array(v5, {
      name,
      deep: false
    });
  }
  if (isPlainObject(v5)) {
    return observable.object(v5, void 0, {
      name,
      deep: false
    });
  }
  if (isES6Map(v5)) {
    return observable.map(v5, {
      name,
      deep: false
    });
  }
  if (isES6Set(v5)) {
    return observable.set(v5, {
      name,
      deep: false
    });
  }
  if (true) {
    die("The shallow modifier / decorator can only used in combination with arrays, objects, maps and sets");
  }
}
function referenceEnhancer(newValue) {
  return newValue;
}
function refStructEnhancer(v5, oldValue) {
  if (isObservable(v5)) {
    die("observable.struct should not be used with observable values");
  }
  if (deepEqual(v5, oldValue)) {
    return oldValue;
  }
  return v5;
}
function isOverride(annotation) {
  return annotation.annotationType_ === OVERRIDE;
}
function make_(adm, key) {
  if (adm.isPlainObject_) {
    die("Cannot apply '" + this.annotationType_ + "' to '" + adm.name_ + "." + key.toString() + "':" + ("\n'" + this.annotationType_ + "' cannot be used on plain objects."));
  }
  if (!hasProp(adm.appliedAnnotations_, key)) {
    die("'" + adm.name_ + "." + key.toString() + "' is annotated with '" + this.annotationType_ + "', but no such annotated member was found on prototype.");
  }
  return 0;
}
function extend_(adm, key, descriptor, proxyTrap) {
  die("'" + this.annotationType_ + "' can only be used with 'makeObservable'");
}
function decorate_20223_(desc, context) {
  console.warn("'" + this.annotationType_ + "' cannot be used with decorators - this is a no-op");
}
function createActionAnnotation(name, options) {
  return {
    annotationType_: name,
    options_: options,
    make_: make_$1,
    extend_: extend_$1,
    decorate_20223_: decorate_20223_$1
  };
}
function make_$1(adm, key, descriptor, source) {
  var _this$options_;
  if ((_this$options_ = this.options_) != null && _this$options_.bound) {
    return this.extend_(adm, key, descriptor, false) === null ? 0 : 1;
  }
  if (source === adm.target_) {
    return this.extend_(adm, key, descriptor, false) === null ? 0 : 2;
  }
  if (isAction(descriptor.value)) {
    return 1;
  }
  var actionDescriptor = createActionDescriptor(adm, this, key, descriptor, false);
  defineProperty(source, key, actionDescriptor);
  return 2;
}
function extend_$1(adm, key, descriptor, proxyTrap) {
  var actionDescriptor = createActionDescriptor(adm, this, key, descriptor);
  return adm.defineProperty_(key, actionDescriptor, proxyTrap);
}
function decorate_20223_$1(mthd, context) {
  if (true) {
    assert20223DecoratorType(context, ["method", "field"]);
  }
  var kind = context.kind, name = context.name, addInitializer = context.addInitializer;
  var ann = this;
  var _createAction = function _createAction2(m3) {
    var _ann$options_$name, _ann$options_, _ann$options_$autoAct, _ann$options_2;
    return createAction((_ann$options_$name = (_ann$options_ = ann.options_) == null ? void 0 : _ann$options_.name) != null ? _ann$options_$name : name.toString(), m3, (_ann$options_$autoAct = (_ann$options_2 = ann.options_) == null ? void 0 : _ann$options_2.autoAction) != null ? _ann$options_$autoAct : false);
  };
  if (kind == "field") {
    return function(initMthd) {
      var _ann$options_3;
      var mthd2 = initMthd;
      if (!isAction(mthd2)) {
        mthd2 = _createAction(mthd2);
      }
      if ((_ann$options_3 = ann.options_) != null && _ann$options_3.bound) {
        mthd2 = mthd2.bind(this);
        mthd2.isMobxAction = true;
      }
      return mthd2;
    };
  }
  if (kind == "method") {
    var _this$options_2;
    if (!isAction(mthd)) {
      mthd = _createAction(mthd);
    }
    if ((_this$options_2 = this.options_) != null && _this$options_2.bound) {
      addInitializer(function() {
        var self2 = this;
        var bound = self2[name].bind(self2);
        bound.isMobxAction = true;
        self2[name] = bound;
      });
    }
    return mthd;
  }
  die("Cannot apply '" + ann.annotationType_ + "' to '" + String(name) + "' (kind: " + kind + "):" + ("\n'" + ann.annotationType_ + "' can only be used on properties with a function value."));
}
function assertActionDescriptor(adm, _ref, key, _ref2) {
  var annotationType_ = _ref.annotationType_;
  var value = _ref2.value;
  if (!isFunction(value)) {
    die("Cannot apply '" + annotationType_ + "' to '" + adm.name_ + "." + key.toString() + "':" + ("\n'" + annotationType_ + "' can only be used on properties with a function value."));
  }
}
function createActionDescriptor(adm, annotation, key, descriptor, safeDescriptors) {
  var _annotation$options_, _annotation$options_$, _annotation$options_2, _annotation$options_$2, _annotation$options_3, _annotation$options_4, _adm$proxy_2;
  if (safeDescriptors === void 0) {
    safeDescriptors = globalState.safeDescriptors;
  }
  assertActionDescriptor(adm, annotation, key, descriptor);
  var value = descriptor.value;
  if ((_annotation$options_ = annotation.options_) != null && _annotation$options_.bound) {
    var _adm$proxy_;
    value = value.bind((_adm$proxy_ = adm.proxy_) != null ? _adm$proxy_ : adm.target_);
  }
  return {
    value: createAction(
      (_annotation$options_$ = (_annotation$options_2 = annotation.options_) == null ? void 0 : _annotation$options_2.name) != null ? _annotation$options_$ : key.toString(),
      value,
      (_annotation$options_$2 = (_annotation$options_3 = annotation.options_) == null ? void 0 : _annotation$options_3.autoAction) != null ? _annotation$options_$2 : false,
      // https://github.com/mobxjs/mobx/discussions/3140
      (_annotation$options_4 = annotation.options_) != null && _annotation$options_4.bound ? (_adm$proxy_2 = adm.proxy_) != null ? _adm$proxy_2 : adm.target_ : void 0
    ),
    // Non-configurable for classes
    // prevents accidental field redefinition in subclass
    configurable: safeDescriptors ? adm.isPlainObject_ : true,
    // https://github.com/mobxjs/mobx/pull/2641#issuecomment-737292058
    enumerable: false,
    // Non-obsevable, therefore non-writable
    // Also prevents rewriting in subclass constructor
    writable: safeDescriptors ? false : true
  };
}
function createFlowAnnotation(name, options) {
  return {
    annotationType_: name,
    options_: options,
    make_: make_$2,
    extend_: extend_$2,
    decorate_20223_: decorate_20223_$2
  };
}
function make_$2(adm, key, descriptor, source) {
  var _this$options_;
  if (source === adm.target_) {
    return this.extend_(adm, key, descriptor, false) === null ? 0 : 2;
  }
  if ((_this$options_ = this.options_) != null && _this$options_.bound && (!hasProp(adm.target_, key) || !isFlow(adm.target_[key]))) {
    if (this.extend_(adm, key, descriptor, false) === null) {
      return 0;
    }
  }
  if (isFlow(descriptor.value)) {
    return 1;
  }
  var flowDescriptor = createFlowDescriptor(adm, this, key, descriptor, false, false);
  defineProperty(source, key, flowDescriptor);
  return 2;
}
function extend_$2(adm, key, descriptor, proxyTrap) {
  var _this$options_2;
  var flowDescriptor = createFlowDescriptor(adm, this, key, descriptor, (_this$options_2 = this.options_) == null ? void 0 : _this$options_2.bound);
  return adm.defineProperty_(key, flowDescriptor, proxyTrap);
}
function decorate_20223_$2(mthd, context) {
  var _this$options_3;
  if (true) {
    assert20223DecoratorType(context, ["method"]);
  }
  var name = context.name, addInitializer = context.addInitializer;
  if (!isFlow(mthd)) {
    mthd = flow(mthd);
  }
  if ((_this$options_3 = this.options_) != null && _this$options_3.bound) {
    addInitializer(function() {
      var self2 = this;
      var bound = self2[name].bind(self2);
      bound.isMobXFlow = true;
      self2[name] = bound;
    });
  }
  return mthd;
}
function assertFlowDescriptor(adm, _ref, key, _ref2) {
  var annotationType_ = _ref.annotationType_;
  var value = _ref2.value;
  if (!isFunction(value)) {
    die("Cannot apply '" + annotationType_ + "' to '" + adm.name_ + "." + key.toString() + "':" + ("\n'" + annotationType_ + "' can only be used on properties with a generator function value."));
  }
}
function createFlowDescriptor(adm, annotation, key, descriptor, bound, safeDescriptors) {
  if (safeDescriptors === void 0) {
    safeDescriptors = globalState.safeDescriptors;
  }
  assertFlowDescriptor(adm, annotation, key, descriptor);
  var value = descriptor.value;
  if (!isFlow(value)) {
    value = flow(value);
  }
  if (bound) {
    var _adm$proxy_;
    value = value.bind((_adm$proxy_ = adm.proxy_) != null ? _adm$proxy_ : adm.target_);
    value.isMobXFlow = true;
  }
  return {
    value,
    // Non-configurable for classes
    // prevents accidental field redefinition in subclass
    configurable: safeDescriptors ? adm.isPlainObject_ : true,
    // https://github.com/mobxjs/mobx/pull/2641#issuecomment-737292058
    enumerable: false,
    // Non-obsevable, therefore non-writable
    // Also prevents rewriting in subclass constructor
    writable: safeDescriptors ? false : true
  };
}
function createComputedAnnotation(name, options) {
  return {
    annotationType_: name,
    options_: options,
    make_: make_$3,
    extend_: extend_$3,
    decorate_20223_: decorate_20223_$3
  };
}
function make_$3(adm, key, descriptor) {
  return this.extend_(adm, key, descriptor, false) === null ? 0 : 1;
}
function extend_$3(adm, key, descriptor, proxyTrap) {
  assertComputedDescriptor(adm, this, key, descriptor);
  return adm.defineComputedProperty_(key, _extends({}, this.options_, {
    get: descriptor.get,
    set: descriptor.set
  }), proxyTrap);
}
function decorate_20223_$3(get5, context) {
  if (true) {
    assert20223DecoratorType(context, ["getter"]);
  }
  var ann = this;
  var key = context.name, addInitializer = context.addInitializer;
  addInitializer(function() {
    var adm = asObservableObject(this)[$mobx];
    var options = _extends({}, ann.options_, {
      get: get5,
      context: this
    });
    options.name || (options.name = true ? adm.name_ + "." + key.toString() : "ObservableObject." + key.toString());
    adm.values_.set(key, new ComputedValue(options));
  });
  return function() {
    return this[$mobx].getObservablePropValue_(key);
  };
}
function assertComputedDescriptor(adm, _ref, key, _ref2) {
  var annotationType_ = _ref.annotationType_;
  var get5 = _ref2.get;
  if (!get5) {
    die("Cannot apply '" + annotationType_ + "' to '" + adm.name_ + "." + key.toString() + "':" + ("\n'" + annotationType_ + "' can only be used on getter(+setter) properties."));
  }
}
function createObservableAnnotation(name, options) {
  return {
    annotationType_: name,
    options_: options,
    make_: make_$4,
    extend_: extend_$4,
    decorate_20223_: decorate_20223_$4
  };
}
function make_$4(adm, key, descriptor) {
  return this.extend_(adm, key, descriptor, false) === null ? 0 : 1;
}
function extend_$4(adm, key, descriptor, proxyTrap) {
  var _this$options_$enhanc, _this$options_;
  assertObservableDescriptor(adm, this, key, descriptor);
  return adm.defineObservableProperty_(key, descriptor.value, (_this$options_$enhanc = (_this$options_ = this.options_) == null ? void 0 : _this$options_.enhancer) != null ? _this$options_$enhanc : deepEnhancer, proxyTrap);
}
function decorate_20223_$4(desc, context) {
  if (true) {
    if (context.kind === "field") {
      throw die("Please use `@observable accessor " + String(context.name) + "` instead of `@observable " + String(context.name) + "`");
    }
    assert20223DecoratorType(context, ["accessor"]);
  }
  var ann = this;
  var kind = context.kind, name = context.name;
  var initializedObjects = /* @__PURE__ */ new WeakSet();
  function initializeObservable(target, value) {
    var _ann$options_$enhance, _ann$options_;
    var adm = asObservableObject(target)[$mobx];
    var observable2 = new ObservableValue(value, (_ann$options_$enhance = (_ann$options_ = ann.options_) == null ? void 0 : _ann$options_.enhancer) != null ? _ann$options_$enhance : deepEnhancer, true ? adm.name_ + "." + name.toString() : "ObservableObject." + name.toString(), false);
    adm.values_.set(name, observable2);
    initializedObjects.add(target);
  }
  if (kind == "accessor") {
    return {
      get: function get5() {
        if (!initializedObjects.has(this)) {
          initializeObservable(this, desc.get.call(this));
        }
        return this[$mobx].getObservablePropValue_(name);
      },
      set: function set6(value) {
        if (!initializedObjects.has(this)) {
          initializeObservable(this, value);
        }
        return this[$mobx].setObservablePropValue_(name, value);
      },
      init: function init(value) {
        if (!initializedObjects.has(this)) {
          initializeObservable(this, value);
        }
        return value;
      }
    };
  }
  return;
}
function assertObservableDescriptor(adm, _ref, key, descriptor) {
  var annotationType_ = _ref.annotationType_;
  if (!("value" in descriptor)) {
    die("Cannot apply '" + annotationType_ + "' to '" + adm.name_ + "." + key.toString() + "':" + ("\n'" + annotationType_ + "' cannot be used on getter/setter properties"));
  }
}
function createAutoAnnotation(options) {
  return {
    annotationType_: AUTO,
    options_: options,
    make_: make_$5,
    extend_: extend_$5,
    decorate_20223_: decorate_20223_$5
  };
}
function make_$5(adm, key, descriptor, source) {
  var _this$options_3, _this$options_4;
  if (descriptor.get) {
    return computed.make_(adm, key, descriptor, source);
  }
  if (descriptor.set) {
    var set6 = createAction(key.toString(), descriptor.set);
    if (source === adm.target_) {
      return adm.defineProperty_(key, {
        configurable: globalState.safeDescriptors ? adm.isPlainObject_ : true,
        set: set6
      }) === null ? 0 : 2;
    }
    defineProperty(source, key, {
      configurable: true,
      set: set6
    });
    return 2;
  }
  if (source !== adm.target_ && typeof descriptor.value === "function") {
    var _this$options_2;
    if (isGenerator(descriptor.value)) {
      var _this$options_;
      var flowAnnotation2 = (_this$options_ = this.options_) != null && _this$options_.autoBind ? flow.bound : flow;
      return flowAnnotation2.make_(adm, key, descriptor, source);
    }
    var actionAnnotation2 = (_this$options_2 = this.options_) != null && _this$options_2.autoBind ? autoAction.bound : autoAction;
    return actionAnnotation2.make_(adm, key, descriptor, source);
  }
  var observableAnnotation2 = ((_this$options_3 = this.options_) == null ? void 0 : _this$options_3.deep) === false ? observable.ref : observable;
  if (typeof descriptor.value === "function" && (_this$options_4 = this.options_) != null && _this$options_4.autoBind) {
    var _adm$proxy_;
    descriptor.value = descriptor.value.bind((_adm$proxy_ = adm.proxy_) != null ? _adm$proxy_ : adm.target_);
  }
  return observableAnnotation2.make_(adm, key, descriptor, source);
}
function extend_$5(adm, key, descriptor, proxyTrap) {
  var _this$options_5, _this$options_6;
  if (descriptor.get) {
    return computed.extend_(adm, key, descriptor, proxyTrap);
  }
  if (descriptor.set) {
    return adm.defineProperty_(key, {
      configurable: globalState.safeDescriptors ? adm.isPlainObject_ : true,
      set: createAction(key.toString(), descriptor.set)
    }, proxyTrap);
  }
  if (typeof descriptor.value === "function" && (_this$options_5 = this.options_) != null && _this$options_5.autoBind) {
    var _adm$proxy_2;
    descriptor.value = descriptor.value.bind((_adm$proxy_2 = adm.proxy_) != null ? _adm$proxy_2 : adm.target_);
  }
  var observableAnnotation2 = ((_this$options_6 = this.options_) == null ? void 0 : _this$options_6.deep) === false ? observable.ref : observable;
  return observableAnnotation2.extend_(adm, key, descriptor, proxyTrap);
}
function decorate_20223_$5(desc, context) {
  die("'" + this.annotationType_ + "' cannot be used as a decorator");
}
function asCreateObservableOptions(thing) {
  return thing || defaultCreateObservableOptions;
}
function getEnhancerFromOptions(options) {
  return options.deep === true ? deepEnhancer : options.deep === false ? referenceEnhancer : getEnhancerFromAnnotation(options.defaultDecorator);
}
function getAnnotationFromOptions(options) {
  var _options$defaultDecor;
  return options ? (_options$defaultDecor = options.defaultDecorator) != null ? _options$defaultDecor : createAutoAnnotation(options) : void 0;
}
function getEnhancerFromAnnotation(annotation) {
  var _annotation$options_$, _annotation$options_;
  return !annotation ? deepEnhancer : (_annotation$options_$ = (_annotation$options_ = annotation.options_) == null ? void 0 : _annotation$options_.enhancer) != null ? _annotation$options_$ : deepEnhancer;
}
function createObservable(v5, arg2, arg3) {
  if (is20223Decorator(arg2)) {
    return observableAnnotation.decorate_20223_(v5, arg2);
  }
  if (isStringish(arg2)) {
    storeAnnotation(v5, arg2, observableAnnotation);
    return;
  }
  if (isObservable(v5)) {
    return v5;
  }
  if (isPlainObject(v5)) {
    return observable.object(v5, arg2, arg3);
  }
  if (Array.isArray(v5)) {
    return observable.array(v5, arg2);
  }
  if (isES6Map(v5)) {
    return observable.map(v5, arg2);
  }
  if (isES6Set(v5)) {
    return observable.set(v5, arg2);
  }
  if (typeof v5 === "object" && v5 !== null) {
    return v5;
  }
  return observable.box(v5, arg2);
}
function createAction(actionName, fn2, autoAction2, ref) {
  if (autoAction2 === void 0) {
    autoAction2 = false;
  }
  if (true) {
    if (!isFunction(fn2)) {
      die("`action` can only be invoked on functions");
    }
    if (typeof actionName !== "string" || !actionName) {
      die("actions should have valid names, got: '" + actionName + "'");
    }
  }
  function res() {
    return executeAction(actionName, autoAction2, fn2, ref || this, arguments);
  }
  res.isMobxAction = true;
  res.toString = function() {
    return fn2.toString();
  };
  if (isFunctionNameConfigurable) {
    tmpNameDescriptor.value = actionName;
    defineProperty(res, "name", tmpNameDescriptor);
  }
  return res;
}
function executeAction(actionName, canRunAsDerivation, fn2, scope, args) {
  var runInfo = _startAction(actionName, canRunAsDerivation, scope, args);
  try {
    return fn2.apply(scope, args);
  } catch (err) {
    runInfo.error_ = err;
    throw err;
  } finally {
    _endAction(runInfo);
  }
}
function _startAction(actionName, canRunAsDerivation, scope, args) {
  var notifySpy_ = isSpyEnabled() && !!actionName;
  var startTime_ = 0;
  if (notifySpy_) {
    startTime_ = Date.now();
    var flattenedArgs = args ? Array.from(args) : EMPTY_ARRAY;
    spyReportStart({
      type: ACTION,
      name: actionName,
      object: scope,
      arguments: flattenedArgs
    });
  }
  var prevDerivation_ = globalState.trackingDerivation;
  var runAsAction = !canRunAsDerivation || !prevDerivation_;
  startBatch();
  var prevAllowStateChanges_ = globalState.allowStateChanges;
  if (runAsAction) {
    untrackedStart();
    prevAllowStateChanges_ = allowStateChangesStart(true);
  }
  var prevAllowStateReads_ = allowStateReadsStart(true);
  var runInfo = {
    runAsAction_: runAsAction,
    prevDerivation_,
    prevAllowStateChanges_,
    prevAllowStateReads_,
    notifySpy_,
    startTime_,
    actionId_: nextActionId++,
    parentActionId_: currentActionId
  };
  currentActionId = runInfo.actionId_;
  return runInfo;
}
function _endAction(runInfo) {
  if (currentActionId !== runInfo.actionId_) {
    die(30);
  }
  currentActionId = runInfo.parentActionId_;
  if (runInfo.error_ !== void 0) {
    globalState.suppressReactionErrors = true;
  }
  allowStateChangesEnd(runInfo.prevAllowStateChanges_);
  allowStateReadsEnd(runInfo.prevAllowStateReads_);
  endBatch();
  if (runInfo.runAsAction_) {
    untrackedEnd(runInfo.prevDerivation_);
  }
  if (runInfo.notifySpy_) {
    spyReportEnd({
      time: Date.now() - runInfo.startTime_
    });
  }
  globalState.suppressReactionErrors = false;
}
function allowStateChanges(allowStateChanges2, func) {
  var prev = allowStateChangesStart(allowStateChanges2);
  try {
    return func();
  } finally {
    allowStateChangesEnd(prev);
  }
}
function allowStateChangesStart(allowStateChanges2) {
  var prev = globalState.allowStateChanges;
  globalState.allowStateChanges = allowStateChanges2;
  return prev;
}
function allowStateChangesEnd(prev) {
  globalState.allowStateChanges = prev;
}
function isCaughtException(e2) {
  return e2 instanceof CaughtException;
}
function shouldCompute(derivation) {
  switch (derivation.dependenciesState_) {
    case IDerivationState_.UP_TO_DATE_:
      return false;
    case IDerivationState_.NOT_TRACKING_:
    case IDerivationState_.STALE_:
      return true;
    case IDerivationState_.POSSIBLY_STALE_: {
      var prevAllowStateReads = allowStateReadsStart(true);
      var prevUntracked = untrackedStart();
      var obs = derivation.observing_, l6 = obs.length;
      for (var i4 = 0; i4 < l6; i4++) {
        var obj = obs[i4];
        if (isComputedValue(obj)) {
          if (globalState.disableErrorBoundaries) {
            obj.get();
          } else {
            try {
              obj.get();
            } catch (e2) {
              untrackedEnd(prevUntracked);
              allowStateReadsEnd(prevAllowStateReads);
              return true;
            }
          }
          if (derivation.dependenciesState_ === IDerivationState_.STALE_) {
            untrackedEnd(prevUntracked);
            allowStateReadsEnd(prevAllowStateReads);
            return true;
          }
        }
      }
      changeDependenciesStateTo0(derivation);
      untrackedEnd(prevUntracked);
      allowStateReadsEnd(prevAllowStateReads);
      return false;
    }
  }
}
function isComputingDerivation() {
  return globalState.trackingDerivation !== null;
}
function checkIfStateModificationsAreAllowed(atom) {
  if (false) {
    return;
  }
  var hasObservers2 = atom.observers_.size > 0;
  if (!globalState.allowStateChanges && (hasObservers2 || globalState.enforceActions === "always")) {
    console.warn("[MobX] " + (globalState.enforceActions ? "Since strict-mode is enabled, changing (observed) observable values without using an action is not allowed. Tried to modify: " : "Side effects like changing state are not allowed at this point. Are you trying to modify state from, for example, a computed value or the render function of a React component? You can wrap side effects in 'runInAction' (or decorate functions with 'action') if needed. Tried to modify: ") + atom.name_);
  }
}
function checkIfStateReadsAreAllowed(observable2) {
  if (!globalState.allowStateReads && globalState.observableRequiresReaction) {
    console.warn("[mobx] Observable '" + observable2.name_ + "' being read outside a reactive context.");
  }
}
function trackDerivedFunction(derivation, f6, context) {
  var prevAllowStateReads = allowStateReadsStart(true);
  changeDependenciesStateTo0(derivation);
  derivation.newObserving_ = new Array(
    // Reserve constant space for initial dependencies, dynamic space otherwise.
    // See https://github.com/mobxjs/mobx/pull/3833
    derivation.runId_ === 0 ? 100 : derivation.observing_.length
  );
  derivation.unboundDepsCount_ = 0;
  derivation.runId_ = ++globalState.runId;
  var prevTracking = globalState.trackingDerivation;
  globalState.trackingDerivation = derivation;
  globalState.inBatch++;
  var result;
  if (globalState.disableErrorBoundaries === true) {
    result = f6.call(context);
  } else {
    try {
      result = f6.call(context);
    } catch (e2) {
      result = new CaughtException(e2);
    }
  }
  globalState.inBatch--;
  globalState.trackingDerivation = prevTracking;
  bindDependencies(derivation);
  warnAboutDerivationWithoutDependencies(derivation);
  allowStateReadsEnd(prevAllowStateReads);
  return result;
}
function warnAboutDerivationWithoutDependencies(derivation) {
  if (false) {
    return;
  }
  if (derivation.observing_.length !== 0) {
    return;
  }
  if (typeof derivation.requiresObservable_ === "boolean" ? derivation.requiresObservable_ : globalState.reactionRequiresObservable) {
    console.warn("[mobx] Derivation '" + derivation.name_ + "' is created/updated without reading any observable value.");
  }
}
function bindDependencies(derivation) {
  var prevObserving = derivation.observing_;
  var observing = derivation.observing_ = derivation.newObserving_;
  var lowestNewObservingDerivationState = IDerivationState_.UP_TO_DATE_;
  var i0 = 0, l6 = derivation.unboundDepsCount_;
  for (var i4 = 0; i4 < l6; i4++) {
    var dep = observing[i4];
    if (dep.diffValue === 0) {
      dep.diffValue = 1;
      if (i0 !== i4) {
        observing[i0] = dep;
      }
      i0++;
    }
    if (dep.dependenciesState_ > lowestNewObservingDerivationState) {
      lowestNewObservingDerivationState = dep.dependenciesState_;
    }
  }
  observing.length = i0;
  derivation.newObserving_ = null;
  l6 = prevObserving.length;
  while (l6--) {
    var _dep = prevObserving[l6];
    if (_dep.diffValue === 0) {
      removeObserver(_dep, derivation);
    }
    _dep.diffValue = 0;
  }
  while (i0--) {
    var _dep2 = observing[i0];
    if (_dep2.diffValue === 1) {
      _dep2.diffValue = 0;
      addObserver(_dep2, derivation);
    }
  }
  if (lowestNewObservingDerivationState !== IDerivationState_.UP_TO_DATE_) {
    derivation.dependenciesState_ = lowestNewObservingDerivationState;
    derivation.onBecomeStale_();
  }
}
function clearObserving(derivation) {
  var obs = derivation.observing_;
  derivation.observing_ = [];
  var i4 = obs.length;
  while (i4--) {
    removeObserver(obs[i4], derivation);
  }
  derivation.dependenciesState_ = IDerivationState_.NOT_TRACKING_;
}
function untracked(action2) {
  var prev = untrackedStart();
  try {
    return action2();
  } finally {
    untrackedEnd(prev);
  }
}
function untrackedStart() {
  var prev = globalState.trackingDerivation;
  globalState.trackingDerivation = null;
  return prev;
}
function untrackedEnd(prev) {
  globalState.trackingDerivation = prev;
}
function allowStateReadsStart(allowStateReads) {
  var prev = globalState.allowStateReads;
  globalState.allowStateReads = allowStateReads;
  return prev;
}
function allowStateReadsEnd(prev) {
  globalState.allowStateReads = prev;
}
function changeDependenciesStateTo0(derivation) {
  if (derivation.dependenciesState_ === IDerivationState_.UP_TO_DATE_) {
    return;
  }
  derivation.dependenciesState_ = IDerivationState_.UP_TO_DATE_;
  var obs = derivation.observing_;
  var i4 = obs.length;
  while (i4--) {
    obs[i4].lowestObserverState_ = IDerivationState_.UP_TO_DATE_;
  }
}
function isolateGlobalState() {
  if (globalState.pendingReactions.length || globalState.inBatch || globalState.isRunningReactions) {
    die(36);
  }
  isolateCalled = true;
  if (canMergeGlobalState) {
    var global2 = getGlobal();
    if (--global2.__mobxInstanceCount === 0) {
      global2.__mobxGlobals = void 0;
    }
    globalState = new MobXGlobals();
  }
}
function getGlobalState() {
  return globalState;
}
function resetGlobalState() {
  var defaultGlobals = new MobXGlobals();
  for (var key in defaultGlobals) {
    if (persistentKeys.indexOf(key) === -1) {
      globalState[key] = defaultGlobals[key];
    }
  }
  globalState.allowStateChanges = !globalState.enforceActions;
}
function hasObservers(observable2) {
  return observable2.observers_ && observable2.observers_.size > 0;
}
function getObservers(observable2) {
  return observable2.observers_;
}
function addObserver(observable2, node) {
  observable2.observers_.add(node);
  if (observable2.lowestObserverState_ > node.dependenciesState_) {
    observable2.lowestObserverState_ = node.dependenciesState_;
  }
}
function removeObserver(observable2, node) {
  observable2.observers_["delete"](node);
  if (observable2.observers_.size === 0) {
    queueForUnobservation(observable2);
  }
}
function queueForUnobservation(observable2) {
  if (observable2.isPendingUnobservation === false) {
    observable2.isPendingUnobservation = true;
    globalState.pendingUnobservations.push(observable2);
  }
}
function startBatch() {
  globalState.inBatch++;
}
function endBatch() {
  if (--globalState.inBatch === 0) {
    runReactions();
    var list = globalState.pendingUnobservations;
    for (var i4 = 0; i4 < list.length; i4++) {
      var observable2 = list[i4];
      observable2.isPendingUnobservation = false;
      if (observable2.observers_.size === 0) {
        if (observable2.isBeingObserved) {
          observable2.isBeingObserved = false;
          observable2.onBUO();
        }
        if (observable2 instanceof ComputedValue) {
          observable2.suspend_();
        }
      }
    }
    globalState.pendingUnobservations = [];
  }
}
function reportObserved(observable2) {
  checkIfStateReadsAreAllowed(observable2);
  var derivation = globalState.trackingDerivation;
  if (derivation !== null) {
    if (derivation.runId_ !== observable2.lastAccessedBy_) {
      observable2.lastAccessedBy_ = derivation.runId_;
      derivation.newObserving_[derivation.unboundDepsCount_++] = observable2;
      if (!observable2.isBeingObserved && globalState.trackingContext) {
        observable2.isBeingObserved = true;
        observable2.onBO();
      }
    }
    return observable2.isBeingObserved;
  } else if (observable2.observers_.size === 0 && globalState.inBatch > 0) {
    queueForUnobservation(observable2);
  }
  return false;
}
function propagateChanged(observable2) {
  if (observable2.lowestObserverState_ === IDerivationState_.STALE_) {
    return;
  }
  observable2.lowestObserverState_ = IDerivationState_.STALE_;
  observable2.observers_.forEach(function(d4) {
    if (d4.dependenciesState_ === IDerivationState_.UP_TO_DATE_) {
      if (d4.isTracing_ !== TraceMode.NONE) {
        logTraceInfo(d4, observable2);
      }
      d4.onBecomeStale_();
    }
    d4.dependenciesState_ = IDerivationState_.STALE_;
  });
}
function propagateChangeConfirmed(observable2) {
  if (observable2.lowestObserverState_ === IDerivationState_.STALE_) {
    return;
  }
  observable2.lowestObserverState_ = IDerivationState_.STALE_;
  observable2.observers_.forEach(function(d4) {
    if (d4.dependenciesState_ === IDerivationState_.POSSIBLY_STALE_) {
      d4.dependenciesState_ = IDerivationState_.STALE_;
      if (d4.isTracing_ !== TraceMode.NONE) {
        logTraceInfo(d4, observable2);
      }
    } else if (d4.dependenciesState_ === IDerivationState_.UP_TO_DATE_) {
      observable2.lowestObserverState_ = IDerivationState_.UP_TO_DATE_;
    }
  });
}
function propagateMaybeChanged(observable2) {
  if (observable2.lowestObserverState_ !== IDerivationState_.UP_TO_DATE_) {
    return;
  }
  observable2.lowestObserverState_ = IDerivationState_.POSSIBLY_STALE_;
  observable2.observers_.forEach(function(d4) {
    if (d4.dependenciesState_ === IDerivationState_.UP_TO_DATE_) {
      d4.dependenciesState_ = IDerivationState_.POSSIBLY_STALE_;
      d4.onBecomeStale_();
    }
  });
}
function logTraceInfo(derivation, observable2) {
  console.log("[mobx.trace] '" + derivation.name_ + "' is invalidated due to a change in: '" + observable2.name_ + "'");
  if (derivation.isTracing_ === TraceMode.BREAK) {
    var lines = [];
    printDepTree(getDependencyTree(derivation), lines, 1);
    new Function("debugger;\n/*\nTracing '" + derivation.name_ + "'\n\nYou are entering this break point because derivation '" + derivation.name_ + "' is being traced and '" + observable2.name_ + "' is now forcing it to update.\nJust follow the stacktrace you should now see in the devtools to see precisely what piece of your code is causing this update\nThe stackframe you are looking for is at least ~6-8 stack-frames up.\n\n" + (derivation instanceof ComputedValue ? derivation.derivation.toString().replace(/[*]\//g, "/") : "") + "\n\nThe dependencies for this derivation are:\n\n" + lines.join("\n") + "\n*/\n    ")();
  }
}
function printDepTree(tree, lines, depth) {
  if (lines.length >= 1e3) {
    lines.push("(and many more)");
    return;
  }
  lines.push("" + "	".repeat(depth - 1) + tree.name);
  if (tree.dependencies) {
    tree.dependencies.forEach(function(child) {
      return printDepTree(child, lines, depth + 1);
    });
  }
}
function onReactionError(handler) {
  globalState.globalReactionErrorHandlers.push(handler);
  return function() {
    var idx = globalState.globalReactionErrorHandlers.indexOf(handler);
    if (idx >= 0) {
      globalState.globalReactionErrorHandlers.splice(idx, 1);
    }
  };
}
function runReactions() {
  if (globalState.inBatch > 0 || globalState.isRunningReactions) {
    return;
  }
  reactionScheduler(runReactionsHelper);
}
function runReactionsHelper() {
  globalState.isRunningReactions = true;
  var allReactions = globalState.pendingReactions;
  var iterations = 0;
  while (allReactions.length > 0) {
    if (++iterations === MAX_REACTION_ITERATIONS) {
      console.error(true ? "Reaction doesn't converge to a stable state after " + MAX_REACTION_ITERATIONS + " iterations." + (" Probably there is a cycle in the reactive function: " + allReactions[0]) : "[mobx] cycle in reaction: " + allReactions[0]);
      allReactions.splice(0);
    }
    var remainingReactions = allReactions.splice(0);
    for (var i4 = 0, l6 = remainingReactions.length; i4 < l6; i4++) {
      remainingReactions[i4].runReaction_();
    }
  }
  globalState.isRunningReactions = false;
}
function setReactionScheduler(fn2) {
  var baseScheduler = reactionScheduler;
  reactionScheduler = function reactionScheduler3(f6) {
    return fn2(function() {
      return baseScheduler(f6);
    });
  };
}
function isSpyEnabled() {
  return !!globalState.spyListeners.length;
}
function spyReport(event) {
  if (false) {
    return;
  }
  if (!globalState.spyListeners.length) {
    return;
  }
  var listeners = globalState.spyListeners;
  for (var i4 = 0, l6 = listeners.length; i4 < l6; i4++) {
    listeners[i4](event);
  }
}
function spyReportStart(event) {
  if (false) {
    return;
  }
  var change = _extends({}, event, {
    spyReportStart: true
  });
  spyReport(change);
}
function spyReportEnd(change) {
  if (false) {
    return;
  }
  if (change) {
    spyReport(_extends({}, change, {
      type: "report-end",
      spyReportEnd: true
    }));
  } else {
    spyReport(END_EVENT);
  }
}
function spy(listener) {
  if (false) {
    console.warn("[mobx.spy] Is a no-op in production builds");
    return function() {
    };
  } else {
    globalState.spyListeners.push(listener);
    return once(function() {
      globalState.spyListeners = globalState.spyListeners.filter(function(l6) {
        return l6 !== listener;
      });
    });
  }
}
function createActionFactory(autoAction2) {
  var res = function action2(arg1, arg2) {
    if (isFunction(arg1)) {
      return createAction(arg1.name || DEFAULT_ACTION_NAME, arg1, autoAction2);
    }
    if (isFunction(arg2)) {
      return createAction(arg1, arg2, autoAction2);
    }
    if (is20223Decorator(arg2)) {
      return (autoAction2 ? autoActionAnnotation : actionAnnotation).decorate_20223_(arg1, arg2);
    }
    if (isStringish(arg2)) {
      return storeAnnotation(arg1, arg2, autoAction2 ? autoActionAnnotation : actionAnnotation);
    }
    if (isStringish(arg1)) {
      return createDecoratorAnnotation(createActionAnnotation(autoAction2 ? AUTOACTION : ACTION, {
        name: arg1,
        autoAction: autoAction2
      }));
    }
    if (true) {
      die("Invalid arguments for `action`");
    }
  };
  return res;
}
function runInAction(fn2) {
  return executeAction(fn2.name || DEFAULT_ACTION_NAME, false, fn2, this, void 0);
}
function isAction(thing) {
  return isFunction(thing) && thing.isMobxAction === true;
}
function autorun(view, opts) {
  var _opts$name, _opts, _opts2, _opts3;
  if (opts === void 0) {
    opts = EMPTY_OBJECT;
  }
  if (true) {
    if (!isFunction(view)) {
      die("Autorun expects a function as first argument");
    }
    if (isAction(view)) {
      die("Autorun does not accept actions since actions are untrackable");
    }
  }
  var name = (_opts$name = (_opts = opts) == null ? void 0 : _opts.name) != null ? _opts$name : true ? view.name || "Autorun@" + getNextId() : "Autorun";
  var runSync = !opts.scheduler && !opts.delay;
  var reaction2;
  if (runSync) {
    reaction2 = new Reaction(name, function() {
      this.track(reactionRunner);
    }, opts.onError, opts.requiresObservable);
  } else {
    var scheduler = createSchedulerFromOptions(opts);
    var isScheduled = false;
    reaction2 = new Reaction(name, function() {
      if (!isScheduled) {
        isScheduled = true;
        scheduler(function() {
          isScheduled = false;
          if (!reaction2.isDisposed) {
            reaction2.track(reactionRunner);
          }
        });
      }
    }, opts.onError, opts.requiresObservable);
  }
  function reactionRunner() {
    view(reaction2);
  }
  if (!((_opts2 = opts) != null && (_opts2 = _opts2.signal) != null && _opts2.aborted)) {
    reaction2.schedule_();
  }
  return reaction2.getDisposer_((_opts3 = opts) == null ? void 0 : _opts3.signal);
}
function createSchedulerFromOptions(opts) {
  return opts.scheduler ? opts.scheduler : opts.delay ? function(f6) {
    return setTimeout(f6, opts.delay);
  } : run;
}
function reaction(expression, effect, opts) {
  var _opts$name2, _opts4, _opts5;
  if (opts === void 0) {
    opts = EMPTY_OBJECT;
  }
  if (true) {
    if (!isFunction(expression) || !isFunction(effect)) {
      die("First and second argument to reaction should be functions");
    }
    if (!isPlainObject(opts)) {
      die("Third argument of reactions should be an object");
    }
  }
  var name = (_opts$name2 = opts.name) != null ? _opts$name2 : true ? "Reaction@" + getNextId() : "Reaction";
  var effectAction = action(name, opts.onError ? wrapErrorHandler(opts.onError, effect) : effect);
  var runSync = !opts.scheduler && !opts.delay;
  var scheduler = createSchedulerFromOptions(opts);
  var firstTime = true;
  var isScheduled = false;
  var value;
  var equals = opts.compareStructural ? comparer.structural : opts.equals || comparer["default"];
  var r3 = new Reaction(name, function() {
    if (firstTime || runSync) {
      reactionRunner();
    } else if (!isScheduled) {
      isScheduled = true;
      scheduler(reactionRunner);
    }
  }, opts.onError, opts.requiresObservable);
  function reactionRunner() {
    isScheduled = false;
    if (r3.isDisposed) {
      return;
    }
    var changed = false;
    var oldValue = value;
    r3.track(function() {
      var nextValue = allowStateChanges(false, function() {
        return expression(r3);
      });
      changed = firstTime || !equals(value, nextValue);
      value = nextValue;
    });
    if (firstTime && opts.fireImmediately) {
      effectAction(value, oldValue, r3);
    } else if (!firstTime && changed) {
      effectAction(value, oldValue, r3);
    }
    firstTime = false;
  }
  if (!((_opts4 = opts) != null && (_opts4 = _opts4.signal) != null && _opts4.aborted)) {
    r3.schedule_();
  }
  return r3.getDisposer_((_opts5 = opts) == null ? void 0 : _opts5.signal);
}
function wrapErrorHandler(errorHandler, baseFn) {
  return function() {
    try {
      return baseFn.apply(this, arguments);
    } catch (e2) {
      errorHandler.call(this, e2);
    }
  };
}
function onBecomeObserved(thing, arg2, arg3) {
  return interceptHook(ON_BECOME_OBSERVED, thing, arg2, arg3);
}
function onBecomeUnobserved(thing, arg2, arg3) {
  return interceptHook(ON_BECOME_UNOBSERVED, thing, arg2, arg3);
}
function interceptHook(hook, thing, arg2, arg3) {
  var atom = typeof arg3 === "function" ? getAtom(thing, arg2) : getAtom(thing);
  var cb = isFunction(arg3) ? arg3 : arg2;
  var listenersKey = hook + "L";
  if (atom[listenersKey]) {
    atom[listenersKey].add(cb);
  } else {
    atom[listenersKey] = /* @__PURE__ */ new Set([cb]);
  }
  return function() {
    var hookListeners = atom[listenersKey];
    if (hookListeners) {
      hookListeners["delete"](cb);
      if (hookListeners.size === 0) {
        delete atom[listenersKey];
      }
    }
  };
}
function configure(options) {
  if (options.isolateGlobalState === true) {
    isolateGlobalState();
  }
  var useProxies = options.useProxies, enforceActions = options.enforceActions;
  if (useProxies !== void 0) {
    globalState.useProxies = useProxies === ALWAYS ? true : useProxies === NEVER ? false : typeof Proxy !== "undefined";
  }
  if (useProxies === "ifavailable") {
    globalState.verifyProxies = true;
  }
  if (enforceActions !== void 0) {
    var ea2 = enforceActions === ALWAYS ? ALWAYS : enforceActions === OBSERVED;
    globalState.enforceActions = ea2;
    globalState.allowStateChanges = ea2 === true || ea2 === ALWAYS ? false : true;
  }
  ["computedRequiresReaction", "reactionRequiresObservable", "observableRequiresReaction", "disableErrorBoundaries", "safeDescriptors"].forEach(function(key) {
    if (key in options) {
      globalState[key] = !!options[key];
    }
  });
  globalState.allowStateReads = !globalState.observableRequiresReaction;
  if (globalState.disableErrorBoundaries === true) {
    console.warn("WARNING: Debug feature only. MobX will NOT recover from errors when `disableErrorBoundaries` is enabled.");
  }
  if (options.reactionScheduler) {
    setReactionScheduler(options.reactionScheduler);
  }
}
function extendObservable(target, properties, annotations, options) {
  if (true) {
    if (arguments.length > 4) {
      die("'extendObservable' expected 2-4 arguments");
    }
    if (typeof target !== "object") {
      die("'extendObservable' expects an object as first argument");
    }
    if (isObservableMap(target)) {
      die("'extendObservable' should not be used on maps, use map.merge instead");
    }
    if (!isPlainObject(properties)) {
      die("'extendObservable' only accepts plain objects as second argument");
    }
    if (isObservable(properties) || isObservable(annotations)) {
      die("Extending an object with another observable (object) is not supported");
    }
  }
  var descriptors = getOwnPropertyDescriptors(properties);
  initObservable(function() {
    var adm = asObservableObject(target, options)[$mobx];
    ownKeys(descriptors).forEach(function(key) {
      adm.extend_(
        key,
        descriptors[key],
        // must pass "undefined" for { key: undefined }
        !annotations ? true : key in annotations ? annotations[key] : true
      );
    });
  });
  return target;
}
function getDependencyTree(thing, property) {
  return nodeToDependencyTree(getAtom(thing, property));
}
function nodeToDependencyTree(node) {
  var result = {
    name: node.name_
  };
  if (node.observing_ && node.observing_.length > 0) {
    result.dependencies = unique(node.observing_).map(nodeToDependencyTree);
  }
  return result;
}
function getObserverTree(thing, property) {
  return nodeToObserverTree(getAtom(thing, property));
}
function nodeToObserverTree(node) {
  var result = {
    name: node.name_
  };
  if (hasObservers(node)) {
    result.observers = Array.from(getObservers(node)).map(nodeToObserverTree);
  }
  return result;
}
function unique(list) {
  return Array.from(new Set(list));
}
function FlowCancellationError() {
  this.message = "FLOW_CANCELLED";
}
function isFlowCancellationError(error) {
  return error instanceof FlowCancellationError;
}
function cancelPromise(promise) {
  if (isFunction(promise.cancel)) {
    promise.cancel();
  }
}
function flowResult(result) {
  return result;
}
function isFlow(fn2) {
  return (fn2 == null ? void 0 : fn2.isMobXFlow) === true;
}
function interceptReads(thing, propOrHandler, handler) {
  var target;
  if (isObservableMap(thing) || isObservableArray(thing) || isObservableValue(thing)) {
    target = getAdministration(thing);
  } else if (isObservableObject(thing)) {
    if (!isStringish(propOrHandler)) {
      return die("InterceptReads can only be used with a specific property, not with an object in general");
    }
    target = getAdministration(thing, propOrHandler);
  } else if (true) {
    return die("Expected observable map, object or array as first array");
  }
  if (target.dehancer !== void 0) {
    return die("An intercept reader was already established");
  }
  target.dehancer = typeof propOrHandler === "function" ? propOrHandler : handler;
  return function() {
    target.dehancer = void 0;
  };
}
function intercept(thing, propOrHandler, handler) {
  if (isFunction(handler)) {
    return interceptProperty(thing, propOrHandler, handler);
  } else {
    return interceptInterceptable(thing, propOrHandler);
  }
}
function interceptInterceptable(thing, handler) {
  return getAdministration(thing).intercept_(handler);
}
function interceptProperty(thing, property, handler) {
  return getAdministration(thing, property).intercept_(handler);
}
function _isComputed(value, property) {
  if (property === void 0) {
    return isComputedValue(value);
  }
  if (isObservableObject(value) === false) {
    return false;
  }
  if (!value[$mobx].values_.has(property)) {
    return false;
  }
  var atom = getAtom(value, property);
  return isComputedValue(atom);
}
function isComputed(value) {
  if (arguments.length > 1) {
    return die("isComputed expects only 1 argument. Use isComputedProp to inspect the observability of a property");
  }
  return _isComputed(value);
}
function isComputedProp(value, propName) {
  if (!isStringish(propName)) {
    return die("isComputed expected a property name as second argument");
  }
  return _isComputed(value, propName);
}
function _isObservable(value, property) {
  if (!value) {
    return false;
  }
  if (property !== void 0) {
    if (isObservableMap(value) || isObservableArray(value)) {
      return die("isObservable(object, propertyName) is not supported for arrays and maps. Use map.has or array.length instead.");
    }
    if (isObservableObject(value)) {
      return value[$mobx].values_.has(property);
    }
    return false;
  }
  return isObservableObject(value) || !!value[$mobx] || isAtom(value) || isReaction(value) || isComputedValue(value);
}
function isObservable(value) {
  if (arguments.length !== 1) {
    die("isObservable expects only 1 argument. Use isObservableProp to inspect the observability of a property");
  }
  return _isObservable(value);
}
function isObservableProp(value, propName) {
  if (!isStringish(propName)) {
    return die("expected a property name as second argument");
  }
  return _isObservable(value, propName);
}
function keys(obj) {
  if (isObservableObject(obj)) {
    return obj[$mobx].keys_();
  }
  if (isObservableMap(obj) || isObservableSet(obj)) {
    return Array.from(obj.keys());
  }
  if (isObservableArray(obj)) {
    return obj.map(function(_16, index) {
      return index;
    });
  }
  die(5);
}
function values(obj) {
  if (isObservableObject(obj)) {
    return keys(obj).map(function(key) {
      return obj[key];
    });
  }
  if (isObservableMap(obj)) {
    return keys(obj).map(function(key) {
      return obj.get(key);
    });
  }
  if (isObservableSet(obj)) {
    return Array.from(obj.values());
  }
  if (isObservableArray(obj)) {
    return obj.slice();
  }
  die(6);
}
function entries(obj) {
  if (isObservableObject(obj)) {
    return keys(obj).map(function(key) {
      return [key, obj[key]];
    });
  }
  if (isObservableMap(obj)) {
    return keys(obj).map(function(key) {
      return [key, obj.get(key)];
    });
  }
  if (isObservableSet(obj)) {
    return Array.from(obj.entries());
  }
  if (isObservableArray(obj)) {
    return obj.map(function(key, index) {
      return [index, key];
    });
  }
  die(7);
}
function set2(obj, key, value) {
  if (arguments.length === 2 && !isObservableSet(obj)) {
    startBatch();
    var _values = key;
    try {
      for (var _key in _values) {
        set2(obj, _key, _values[_key]);
      }
    } finally {
      endBatch();
    }
    return;
  }
  if (isObservableObject(obj)) {
    obj[$mobx].set_(key, value);
  } else if (isObservableMap(obj)) {
    obj.set(key, value);
  } else if (isObservableSet(obj)) {
    obj.add(key);
  } else if (isObservableArray(obj)) {
    if (typeof key !== "number") {
      key = parseInt(key, 10);
    }
    if (key < 0) {
      die("Invalid index: '" + key + "'");
    }
    startBatch();
    if (key >= obj.length) {
      obj.length = key + 1;
    }
    obj[key] = value;
    endBatch();
  } else {
    die(8);
  }
}
function remove(obj, key) {
  if (isObservableObject(obj)) {
    obj[$mobx].delete_(key);
  } else if (isObservableMap(obj)) {
    obj["delete"](key);
  } else if (isObservableSet(obj)) {
    obj["delete"](key);
  } else if (isObservableArray(obj)) {
    if (typeof key !== "number") {
      key = parseInt(key, 10);
    }
    obj.splice(key, 1);
  } else {
    die(9);
  }
}
function has(obj, key) {
  if (isObservableObject(obj)) {
    return obj[$mobx].has_(key);
  } else if (isObservableMap(obj)) {
    return obj.has(key);
  } else if (isObservableSet(obj)) {
    return obj.has(key);
  } else if (isObservableArray(obj)) {
    return key >= 0 && key < obj.length;
  }
  die(10);
}
function get(obj, key) {
  if (!has(obj, key)) {
    return void 0;
  }
  if (isObservableObject(obj)) {
    return obj[$mobx].get_(key);
  } else if (isObservableMap(obj)) {
    return obj.get(key);
  } else if (isObservableArray(obj)) {
    return obj[key];
  }
  die(11);
}
function apiDefineProperty(obj, key, descriptor) {
  if (isObservableObject(obj)) {
    return obj[$mobx].defineProperty_(key, descriptor);
  }
  die(39);
}
function apiOwnKeys(obj) {
  if (isObservableObject(obj)) {
    return obj[$mobx].ownKeys_();
  }
  die(38);
}
function observe(thing, propOrCb, cbOrFire, fireImmediately) {
  if (isFunction(cbOrFire)) {
    return observeObservableProperty(thing, propOrCb, cbOrFire, fireImmediately);
  } else {
    return observeObservable(thing, propOrCb, cbOrFire);
  }
}
function observeObservable(thing, listener, fireImmediately) {
  return getAdministration(thing).observe_(listener, fireImmediately);
}
function observeObservableProperty(thing, property, listener, fireImmediately) {
  return getAdministration(thing, property).observe_(listener, fireImmediately);
}
function cache(map2, key, value) {
  map2.set(key, value);
  return value;
}
function toJSHelper(source, __alreadySeen) {
  if (source == null || typeof source !== "object" || source instanceof Date || !isObservable(source)) {
    return source;
  }
  if (isObservableValue(source) || isComputedValue(source)) {
    return toJSHelper(source.get(), __alreadySeen);
  }
  if (__alreadySeen.has(source)) {
    return __alreadySeen.get(source);
  }
  if (isObservableArray(source)) {
    var res = cache(__alreadySeen, source, new Array(source.length));
    source.forEach(function(value, idx) {
      res[idx] = toJSHelper(value, __alreadySeen);
    });
    return res;
  }
  if (isObservableSet(source)) {
    var _res = cache(__alreadySeen, source, /* @__PURE__ */ new Set());
    source.forEach(function(value) {
      _res.add(toJSHelper(value, __alreadySeen));
    });
    return _res;
  }
  if (isObservableMap(source)) {
    var _res2 = cache(__alreadySeen, source, /* @__PURE__ */ new Map());
    source.forEach(function(value, key) {
      _res2.set(key, toJSHelper(value, __alreadySeen));
    });
    return _res2;
  } else {
    var _res3 = cache(__alreadySeen, source, {});
    apiOwnKeys(source).forEach(function(key) {
      if (objectPrototype.propertyIsEnumerable.call(source, key)) {
        _res3[key] = toJSHelper(source[key], __alreadySeen);
      }
    });
    return _res3;
  }
}
function toJS(source, options) {
  if (options) {
    die("toJS no longer supports options");
  }
  return toJSHelper(source, /* @__PURE__ */ new Map());
}
function trace() {
  if (false) {
    return;
  }
  var enterBreakPoint = false;
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  if (typeof args[args.length - 1] === "boolean") {
    enterBreakPoint = args.pop();
  }
  var derivation = getAtomFromArgs(args);
  if (!derivation) {
    return die("'trace(break?)' can only be used inside a tracked computed value or a Reaction. Consider passing in the computed value or reaction explicitly");
  }
  if (derivation.isTracing_ === TraceMode.NONE) {
    console.log("[mobx.trace] '" + derivation.name_ + "' tracing enabled");
  }
  derivation.isTracing_ = enterBreakPoint ? TraceMode.BREAK : TraceMode.LOG;
}
function getAtomFromArgs(args) {
  switch (args.length) {
    case 0:
      return globalState.trackingDerivation;
    case 1:
      return getAtom(args[0]);
    case 2:
      return getAtom(args[0], args[1]);
  }
}
function transaction(action2, thisArg) {
  if (thisArg === void 0) {
    thisArg = void 0;
  }
  startBatch();
  try {
    return action2.apply(thisArg);
  } finally {
    endBatch();
  }
}
function when(predicate, arg1, arg2) {
  if (arguments.length === 1 || arg1 && typeof arg1 === "object") {
    return whenPromise(predicate, arg1);
  }
  return _when(predicate, arg1, arg2 || {});
}
function _when(predicate, effect, opts) {
  var timeoutHandle;
  if (typeof opts.timeout === "number") {
    var error = new Error("WHEN_TIMEOUT");
    timeoutHandle = setTimeout(function() {
      if (!disposer[$mobx].isDisposed) {
        disposer();
        if (opts.onError) {
          opts.onError(error);
        } else {
          throw error;
        }
      }
    }, opts.timeout);
  }
  opts.name = true ? opts.name || "When@" + getNextId() : "When";
  var effectAction = createAction(true ? opts.name + "-effect" : "When-effect", effect);
  var disposer = autorun(function(r3) {
    var cond = allowStateChanges(false, predicate);
    if (cond) {
      r3.dispose();
      if (timeoutHandle) {
        clearTimeout(timeoutHandle);
      }
      effectAction();
    }
  }, opts);
  return disposer;
}
function whenPromise(predicate, opts) {
  var _opts$signal;
  if (opts && opts.onError) {
    return die("the options 'onError' and 'promise' cannot be combined");
  }
  if (opts != null && (_opts$signal = opts.signal) != null && _opts$signal.aborted) {
    return Object.assign(Promise.reject(new Error("WHEN_ABORTED")), {
      cancel: function cancel2() {
        return null;
      }
    });
  }
  var cancel;
  var abort;
  var res = new Promise(function(resolve, reject) {
    var _opts$signal2;
    var disposer = _when(predicate, resolve, _extends({}, opts, {
      onError: reject
    }));
    cancel = function cancel2() {
      disposer();
      reject(new Error("WHEN_CANCELLED"));
    };
    abort = function abort2() {
      disposer();
      reject(new Error("WHEN_ABORTED"));
    };
    opts == null || (_opts$signal2 = opts.signal) == null || _opts$signal2.addEventListener == null || _opts$signal2.addEventListener("abort", abort);
  })["finally"](function() {
    var _opts$signal3;
    return opts == null || (_opts$signal3 = opts.signal) == null || _opts$signal3.removeEventListener == null ? void 0 : _opts$signal3.removeEventListener("abort", abort);
  });
  res.cancel = cancel;
  return res;
}
function getAdm(target) {
  return target[$mobx];
}
function asDynamicObservableObject(target, options) {
  var _target$$mobx, _target$$mobx$proxy_;
  assertProxies();
  target = asObservableObject(target, options);
  return (_target$$mobx$proxy_ = (_target$$mobx = target[$mobx]).proxy_) != null ? _target$$mobx$proxy_ : _target$$mobx.proxy_ = new Proxy(target, objectProxyTraps);
}
function hasInterceptors(interceptable) {
  return interceptable.interceptors_ !== void 0 && interceptable.interceptors_.length > 0;
}
function registerInterceptor(interceptable, handler) {
  var interceptors = interceptable.interceptors_ || (interceptable.interceptors_ = []);
  interceptors.push(handler);
  return once(function() {
    var idx = interceptors.indexOf(handler);
    if (idx !== -1) {
      interceptors.splice(idx, 1);
    }
  });
}
function interceptChange(interceptable, change) {
  var prevU = untrackedStart();
  try {
    var interceptors = [].concat(interceptable.interceptors_ || []);
    for (var i4 = 0, l6 = interceptors.length; i4 < l6; i4++) {
      change = interceptors[i4](change);
      if (change && !change.type) {
        die(14);
      }
      if (!change) {
        break;
      }
    }
    return change;
  } finally {
    untrackedEnd(prevU);
  }
}
function hasListeners(listenable) {
  return listenable.changeListeners_ !== void 0 && listenable.changeListeners_.length > 0;
}
function registerListener(listenable, handler) {
  var listeners = listenable.changeListeners_ || (listenable.changeListeners_ = []);
  listeners.push(handler);
  return once(function() {
    var idx = listeners.indexOf(handler);
    if (idx !== -1) {
      listeners.splice(idx, 1);
    }
  });
}
function notifyListeners(listenable, change) {
  var prevU = untrackedStart();
  var listeners = listenable.changeListeners_;
  if (!listeners) {
    return;
  }
  listeners = listeners.slice();
  for (var i4 = 0, l6 = listeners.length; i4 < l6; i4++) {
    listeners[i4](change);
  }
  untrackedEnd(prevU);
}
function makeObservable(target, annotations, options) {
  initObservable(function() {
    var _annotations;
    var adm = asObservableObject(target, options)[$mobx];
    if (annotations && target[storedAnnotationsSymbol]) {
      die("makeObservable second arg must be nullish when using decorators. Mixing @decorator syntax with annotations is not supported.");
    }
    (_annotations = annotations) != null ? _annotations : annotations = collectStoredAnnotations(target);
    ownKeys(annotations).forEach(function(key) {
      return adm.make_(key, annotations[key]);
    });
  });
  return target;
}
function makeAutoObservable(target, overrides, options) {
  if (true) {
    if (!isPlainObject(target) && !isPlainObject(Object.getPrototypeOf(target))) {
      die("'makeAutoObservable' can only be used for classes that don't have a superclass");
    }
    if (isObservableObject(target)) {
      die("makeAutoObservable can only be used on objects not already made observable");
    }
  }
  if (isPlainObject(target)) {
    return extendObservable(target, target, overrides, options);
  }
  initObservable(function() {
    var adm = asObservableObject(target, options)[$mobx];
    if (!target[keysSymbol]) {
      var proto = Object.getPrototypeOf(target);
      var keys3 = new Set([].concat(ownKeys(target), ownKeys(proto)));
      keys3["delete"]("constructor");
      keys3["delete"]($mobx);
      addHiddenProp(proto, keysSymbol, keys3);
    }
    target[keysSymbol].forEach(function(key) {
      return adm.make_(
        key,
        // must pass "undefined" for { key: undefined }
        !overrides ? true : key in overrides ? overrides[key] : true
      );
    });
  });
  return target;
}
function createObservableArray(initialValues, enhancer, name, owned) {
  if (name === void 0) {
    name = true ? "ObservableArray@" + getNextId() : "ObservableArray";
  }
  if (owned === void 0) {
    owned = false;
  }
  assertProxies();
  return initObservable(function() {
    var adm = new ObservableArrayAdministration(name, enhancer, owned, false);
    addHiddenFinalProp(adm.values_, $mobx, adm);
    var proxy = new Proxy(adm.values_, arrayTraps);
    adm.proxy_ = proxy;
    if (initialValues && initialValues.length) {
      adm.spliceWithArray_(0, 0, initialValues);
    }
    return proxy;
  });
}
function addArrayExtension(funcName, funcFactory) {
  if (typeof Array.prototype[funcName] === "function") {
    arrayExtensions[funcName] = funcFactory(funcName);
  }
}
function simpleFunc(funcName) {
  return function() {
    var adm = this[$mobx];
    adm.atom_.reportObserved();
    var dehancedValues = adm.dehanceValues_(adm.values_);
    return dehancedValues[funcName].apply(dehancedValues, arguments);
  };
}
function mapLikeFunc(funcName) {
  return function(callback, thisArg) {
    var _this2 = this;
    var adm = this[$mobx];
    adm.atom_.reportObserved();
    var dehancedValues = adm.dehanceValues_(adm.values_);
    return dehancedValues[funcName](function(element, index) {
      return callback.call(thisArg, element, index, _this2);
    });
  };
}
function reduceLikeFunc(funcName) {
  return function() {
    var _this3 = this;
    var adm = this[$mobx];
    adm.atom_.reportObserved();
    var dehancedValues = adm.dehanceValues_(adm.values_);
    var callback = arguments[0];
    arguments[0] = function(accumulator, currentValue, index) {
      return callback(accumulator, currentValue, index, _this3);
    };
    return dehancedValues[funcName].apply(dehancedValues, arguments);
  };
}
function isObservableArray(thing) {
  return isObject(thing) && isObservableArrayAdministration(thing[$mobx]);
}
function makeIterableForMap(iterator) {
  iterator[Symbol.toStringTag] = "MapIterator";
  return makeIterable(iterator);
}
function convertToMap(dataStructure) {
  if (isES6Map(dataStructure) || isObservableMap(dataStructure)) {
    return dataStructure;
  } else if (Array.isArray(dataStructure)) {
    return new Map(dataStructure);
  } else if (isPlainObject(dataStructure)) {
    var map2 = /* @__PURE__ */ new Map();
    for (var key in dataStructure) {
      map2.set(key, dataStructure[key]);
    }
    return map2;
  } else {
    return die(21, dataStructure);
  }
}
function makeIterableForSet(iterator) {
  iterator[Symbol.toStringTag] = "SetIterator";
  return makeIterable(iterator);
}
function asObservableObject(target, options) {
  var _options$name;
  if (options && isObservableObject(target)) {
    die("Options can't be provided for already observable objects.");
  }
  if (hasProp(target, $mobx)) {
    if (!(getAdministration(target) instanceof ObservableObjectAdministration)) {
      die("Cannot convert '" + getDebugName(target) + "' into observable object:\nThe target is already observable of different type.\nExtending builtins is not supported.");
    }
    return target;
  }
  if (!Object.isExtensible(target)) {
    die("Cannot make the designated object observable; it is not extensible");
  }
  var name = (_options$name = options == null ? void 0 : options.name) != null ? _options$name : true ? (isPlainObject(target) ? "ObservableObject" : target.constructor.name) + "@" + getNextId() : "ObservableObject";
  var adm = new ObservableObjectAdministration(target, /* @__PURE__ */ new Map(), String(name), getAnnotationFromOptions(options));
  addHiddenProp(target, $mobx, adm);
  return target;
}
function getCachedObservablePropDescriptor(key) {
  return descriptorCache[key] || (descriptorCache[key] = {
    get: function get5() {
      return this[$mobx].getObservablePropValue_(key);
    },
    set: function set6(value) {
      return this[$mobx].setObservablePropValue_(key, value);
    }
  });
}
function isObservableObject(thing) {
  if (isObject(thing)) {
    return isObservableObjectAdministration(thing[$mobx]);
  }
  return false;
}
function recordAnnotationApplied(adm, annotation, key) {
  var _adm$target_$storedAn;
  if (true) {
    adm.appliedAnnotations_[key] = annotation;
  }
  (_adm$target_$storedAn = adm.target_[storedAnnotationsSymbol]) == null || delete _adm$target_$storedAn[key];
}
function assertAnnotable(adm, annotation, key) {
  if (!isAnnotation(annotation)) {
    die("Cannot annotate '" + adm.name_ + "." + key.toString() + "': Invalid annotation.");
  }
  if (!isOverride(annotation) && hasProp(adm.appliedAnnotations_, key)) {
    var fieldName = adm.name_ + "." + key.toString();
    var currentAnnotationType = adm.appliedAnnotations_[key].annotationType_;
    var requestedAnnotationType = annotation.annotationType_;
    die("Cannot apply '" + requestedAnnotationType + "' to '" + fieldName + "':" + ("\nThe field is already annotated with '" + currentAnnotationType + "'.") + "\nRe-annotating fields is not allowed.\nUse 'override' annotation for methods overridden by subclass.");
  }
}
function inherit(ctor, proto) {
  if (Object.setPrototypeOf) {
    Object.setPrototypeOf(ctor.prototype, proto);
  } else if (ctor.prototype.__proto__ !== void 0) {
    ctor.prototype.__proto__ = proto;
  } else {
    ctor.prototype = proto;
  }
}
function createArrayEntryDescriptor(index) {
  return {
    enumerable: false,
    configurable: true,
    get: function get5() {
      return this[$mobx].get_(index);
    },
    set: function set6(value) {
      this[$mobx].set_(index, value);
    }
  };
}
function createArrayBufferItem(index) {
  defineProperty(LegacyObservableArray.prototype, "" + index, createArrayEntryDescriptor(index));
}
function reserveArrayBuffer(max) {
  if (max > OBSERVABLE_ARRAY_BUFFER_SIZE) {
    for (var index = OBSERVABLE_ARRAY_BUFFER_SIZE; index < max + 100; index++) {
      createArrayBufferItem(index);
    }
    OBSERVABLE_ARRAY_BUFFER_SIZE = max;
  }
}
function createLegacyArray(initialValues, enhancer, name) {
  return new LegacyObservableArray(initialValues, enhancer, name);
}
function getAtom(thing, property) {
  if (typeof thing === "object" && thing !== null) {
    if (isObservableArray(thing)) {
      if (property !== void 0) {
        die(23);
      }
      return thing[$mobx].atom_;
    }
    if (isObservableSet(thing)) {
      return thing.atom_;
    }
    if (isObservableMap(thing)) {
      if (property === void 0) {
        return thing.keysAtom_;
      }
      var observable2 = thing.data_.get(property) || thing.hasMap_.get(property);
      if (!observable2) {
        die(25, property, getDebugName(thing));
      }
      return observable2;
    }
    if (isObservableObject(thing)) {
      if (!property) {
        return die(26);
      }
      var _observable = thing[$mobx].values_.get(property);
      if (!_observable) {
        die(27, property, getDebugName(thing));
      }
      return _observable;
    }
    if (isAtom(thing) || isComputedValue(thing) || isReaction(thing)) {
      return thing;
    }
  } else if (isFunction(thing)) {
    if (isReaction(thing[$mobx])) {
      return thing[$mobx];
    }
  }
  die(28);
}
function getAdministration(thing, property) {
  if (!thing) {
    die(29);
  }
  if (property !== void 0) {
    return getAdministration(getAtom(thing, property));
  }
  if (isAtom(thing) || isComputedValue(thing) || isReaction(thing)) {
    return thing;
  }
  if (isObservableMap(thing) || isObservableSet(thing)) {
    return thing;
  }
  if (thing[$mobx]) {
    return thing[$mobx];
  }
  die(24, thing);
}
function getDebugName(thing, property) {
  var named;
  if (property !== void 0) {
    named = getAtom(thing, property);
  } else if (isAction(thing)) {
    return thing.name;
  } else if (isObservableObject(thing) || isObservableMap(thing) || isObservableSet(thing)) {
    named = getAdministration(thing);
  } else {
    named = getAtom(thing);
  }
  return named.name_;
}
function initObservable(cb) {
  var derivation = untrackedStart();
  var allowStateChanges2 = allowStateChangesStart(true);
  startBatch();
  try {
    return cb();
  } finally {
    endBatch();
    allowStateChangesEnd(allowStateChanges2);
    untrackedEnd(derivation);
  }
}
function deepEqual(a3, b4, depth) {
  if (depth === void 0) {
    depth = -1;
  }
  return eq(a3, b4, depth);
}
function eq(a3, b4, depth, aStack, bStack) {
  if (a3 === b4) {
    return a3 !== 0 || 1 / a3 === 1 / b4;
  }
  if (a3 == null || b4 == null) {
    return false;
  }
  if (a3 !== a3) {
    return b4 !== b4;
  }
  var type = typeof a3;
  if (type !== "function" && type !== "object" && typeof b4 != "object") {
    return false;
  }
  var className = toString2.call(a3);
  if (className !== toString2.call(b4)) {
    return false;
  }
  switch (className) {
    case "[object RegExp]":
    case "[object String]":
      return "" + a3 === "" + b4;
    case "[object Number]":
      if (+a3 !== +a3) {
        return +b4 !== +b4;
      }
      return +a3 === 0 ? 1 / +a3 === 1 / b4 : +a3 === +b4;
    case "[object Date]":
    case "[object Boolean]":
      return +a3 === +b4;
    case "[object Symbol]":
      return typeof Symbol !== "undefined" && Symbol.valueOf.call(a3) === Symbol.valueOf.call(b4);
    case "[object Map]":
    case "[object Set]":
      if (depth >= 0) {
        depth++;
      }
      break;
  }
  a3 = unwrap(a3);
  b4 = unwrap(b4);
  var areArrays = className === "[object Array]";
  if (!areArrays) {
    if (typeof a3 != "object" || typeof b4 != "object") {
      return false;
    }
    var aCtor = a3.constructor, bCtor = b4.constructor;
    if (aCtor !== bCtor && !(isFunction(aCtor) && aCtor instanceof aCtor && isFunction(bCtor) && bCtor instanceof bCtor) && "constructor" in a3 && "constructor" in b4) {
      return false;
    }
  }
  if (depth === 0) {
    return false;
  } else if (depth < 0) {
    depth = -1;
  }
  aStack = aStack || [];
  bStack = bStack || [];
  var length = aStack.length;
  while (length--) {
    if (aStack[length] === a3) {
      return bStack[length] === b4;
    }
  }
  aStack.push(a3);
  bStack.push(b4);
  if (areArrays) {
    length = a3.length;
    if (length !== b4.length) {
      return false;
    }
    while (length--) {
      if (!eq(a3[length], b4[length], depth - 1, aStack, bStack)) {
        return false;
      }
    }
  } else {
    var keys3 = Object.keys(a3);
    var _length = keys3.length;
    if (Object.keys(b4).length !== _length) {
      return false;
    }
    for (var i4 = 0; i4 < _length; i4++) {
      var key = keys3[i4];
      if (!(hasProp(b4, key) && eq(a3[key], b4[key], depth - 1, aStack, bStack))) {
        return false;
      }
    }
  }
  aStack.pop();
  bStack.pop();
  return true;
}
function unwrap(a3) {
  if (isObservableArray(a3)) {
    return a3.slice();
  }
  if (isES6Map(a3) || isObservableMap(a3)) {
    return Array.from(a3.entries());
  }
  if (isES6Set(a3) || isObservableSet(a3)) {
    return Array.from(a3.entries());
  }
  return a3;
}
function makeIterable(iterator) {
  iterator[Symbol.iterator] = getSelf;
  return Object.assign(Object.create(maybeIteratorPrototype), iterator);
}
function getSelf() {
  return this;
}
function isAnnotation(thing) {
  return (
    // Can be function
    thing instanceof Object && typeof thing.annotationType_ === "string" && isFunction(thing.make_) && isFunction(thing.extend_)
  );
}
var niceErrors, errors, mockGlobal, assign, getDescriptor, defineProperty, objectPrototype, EMPTY_ARRAY, EMPTY_OBJECT, hasProxy, plainObjectString, noop, hasGetOwnPropertySymbols, ownKeys, getOwnPropertyDescriptors, storedAnnotationsSymbol, $mobx, Atom, isAtom, comparer, OVERRIDE, override, AUTO, autoAnnotation, OBSERVABLE, OBSERVABLE_REF, OBSERVABLE_SHALLOW, OBSERVABLE_STRUCT, defaultCreateObservableOptions, observableAnnotation, observableRefAnnotation, observableShallowAnnotation, observableStructAnnotation, observableDecoratorAnnotation, observableFactories, observable, COMPUTED, COMPUTED_STRUCT, computedAnnotation, computedStructAnnotation, computed, _getDescriptor$config, _getDescriptor, currentActionId, nextActionId, isFunctionNameConfigurable, tmpNameDescriptor, CREATE, ObservableValue, isObservableValue, ComputedValue, isComputedValue, IDerivationState_, TraceMode, CaughtException, persistentKeys, MobXGlobals, canMergeGlobalState, isolateCalled, globalState, Reaction, MAX_REACTION_ITERATIONS, reactionScheduler, isReaction, END_EVENT, ACTION, ACTION_BOUND, AUTOACTION, AUTOACTION_BOUND, DEFAULT_ACTION_NAME, actionAnnotation, actionBoundAnnotation, autoActionAnnotation, autoActionBoundAnnotation, action, autoAction, run, ON_BECOME_OBSERVED, ON_BECOME_UNOBSERVED, NEVER, ALWAYS, OBSERVED, generatorId, flowAnnotation, flowBoundAnnotation, flow, objectProxyTraps, keysSymbol, SPLICE, UPDATE, MAX_SPLICE_SIZE, arrayTraps, ObservableArrayAdministration, arrayExtensions, isObservableArrayAdministration, ObservableMapMarker, ADD, DELETE, ObservableMap, isObservableMap, ObservableSetMarker, ObservableSet, isObservableSet, descriptorCache, REMOVE, ObservableObjectAdministration, isObservableObjectAdministration, ENTRY_0, safariPrototypeSetterInheritanceBug, OBSERVABLE_ARRAY_BUFFER_SIZE, StubArray, LegacyObservableArray, toString2, _getGlobal$Iterator, maybeIteratorPrototype;
var init_mobx_esm = __esm({
  "../../node_modules/.pnpm/mobx@6.13.7/node_modules/mobx/dist/mobx.esm.js"() {
    niceErrors = {
      0: "Invalid value for configuration 'enforceActions', expected 'never', 'always' or 'observed'",
      1: function _(annotationType, key) {
        return "Cannot apply '" + annotationType + "' to '" + key.toString() + "': Field not found.";
      },
      /*
      2(prop) {
          return `invalid decorator for '${prop.toString()}'`
      },
      3(prop) {
          return `Cannot decorate '${prop.toString()}': action can only be used on properties with a function value.`
      },
      4(prop) {
          return `Cannot decorate '${prop.toString()}': computed can only be used on getter properties.`
      },
      */
      5: "'keys()' can only be used on observable objects, arrays, sets and maps",
      6: "'values()' can only be used on observable objects, arrays, sets and maps",
      7: "'entries()' can only be used on observable objects, arrays and maps",
      8: "'set()' can only be used on observable objects, arrays and maps",
      9: "'remove()' can only be used on observable objects, arrays and maps",
      10: "'has()' can only be used on observable objects, arrays and maps",
      11: "'get()' can only be used on observable objects, arrays and maps",
      12: "Invalid annotation",
      13: "Dynamic observable objects cannot be frozen. If you're passing observables to 3rd party component/function that calls Object.freeze, pass copy instead: toJS(observable)",
      14: "Intercept handlers should return nothing or a change object",
      15: "Observable arrays cannot be frozen. If you're passing observables to 3rd party component/function that calls Object.freeze, pass copy instead: toJS(observable)",
      16: "Modification exception: the internal structure of an observable array was changed.",
      17: function _2(index, length) {
        return "[mobx.array] Index out of bounds, " + index + " is larger than " + length;
      },
      18: "mobx.map requires Map polyfill for the current browser. Check babel-polyfill or core-js/es6/map.js",
      19: function _3(other) {
        return "Cannot initialize from classes that inherit from Map: " + other.constructor.name;
      },
      20: function _4(other) {
        return "Cannot initialize map from " + other;
      },
      21: function _5(dataStructure) {
        return "Cannot convert to map from '" + dataStructure + "'";
      },
      22: "mobx.set requires Set polyfill for the current browser. Check babel-polyfill or core-js/es6/set.js",
      23: "It is not possible to get index atoms from arrays",
      24: function _6(thing) {
        return "Cannot obtain administration from " + thing;
      },
      25: function _7(property, name) {
        return "the entry '" + property + "' does not exist in the observable map '" + name + "'";
      },
      26: "please specify a property",
      27: function _8(property, name) {
        return "no observable property '" + property.toString() + "' found on the observable object '" + name + "'";
      },
      28: function _9(thing) {
        return "Cannot obtain atom from " + thing;
      },
      29: "Expecting some object",
      30: "invalid action stack. did you forget to finish an action?",
      31: "missing option for computed: get",
      32: function _10(name, derivation) {
        return "Cycle detected in computation " + name + ": " + derivation;
      },
      33: function _11(name) {
        return "The setter of computed value '" + name + "' is trying to update itself. Did you intend to update an _observable_ value, instead of the computed property?";
      },
      34: function _12(name) {
        return "[ComputedValue '" + name + "'] It is not possible to assign a new value to a computed value.";
      },
      35: "There are multiple, different versions of MobX active. Make sure MobX is loaded only once or use `configure({ isolateGlobalState: true })`",
      36: "isolateGlobalState should be called before MobX is running any reactions",
      37: function _13(method) {
        return "[mobx] `observableArray." + method + "()` mutates the array in-place, which is not allowed inside a derivation. Use `array.slice()." + method + "()` instead";
      },
      38: "'ownKeys()' can only be used on observable objects",
      39: "'defineProperty()' can only be used on observable objects"
    };
    errors = true ? niceErrors : {};
    mockGlobal = {};
    assign = Object.assign;
    getDescriptor = Object.getOwnPropertyDescriptor;
    defineProperty = Object.defineProperty;
    objectPrototype = Object.prototype;
    EMPTY_ARRAY = [];
    Object.freeze(EMPTY_ARRAY);
    EMPTY_OBJECT = {};
    Object.freeze(EMPTY_OBJECT);
    hasProxy = typeof Proxy !== "undefined";
    plainObjectString = Object.toString();
    noop = function noop2() {
    };
    hasGetOwnPropertySymbols = typeof Object.getOwnPropertySymbols !== "undefined";
    ownKeys = typeof Reflect !== "undefined" && Reflect.ownKeys ? Reflect.ownKeys : hasGetOwnPropertySymbols ? function(obj) {
      return Object.getOwnPropertyNames(obj).concat(Object.getOwnPropertySymbols(obj));
    } : (
      /* istanbul ignore next */
      Object.getOwnPropertyNames
    );
    getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors || function getOwnPropertyDescriptors2(target) {
      var res = {};
      ownKeys(target).forEach(function(key) {
        res[key] = getDescriptor(target, key);
      });
      return res;
    };
    storedAnnotationsSymbol = Symbol("mobx-stored-annotations");
    $mobx = Symbol("mobx administration");
    Atom = function() {
      function Atom2(name_) {
        if (name_ === void 0) {
          name_ = true ? "Atom@" + getNextId() : "Atom";
        }
        this.name_ = void 0;
        this.flags_ = 0;
        this.observers_ = /* @__PURE__ */ new Set();
        this.lastAccessedBy_ = 0;
        this.lowestObserverState_ = IDerivationState_.NOT_TRACKING_;
        this.onBOL = void 0;
        this.onBUOL = void 0;
        this.name_ = name_;
      }
      var _proto = Atom2.prototype;
      _proto.onBO = function onBO() {
        if (this.onBOL) {
          this.onBOL.forEach(function(listener) {
            return listener();
          });
        }
      };
      _proto.onBUO = function onBUO() {
        if (this.onBUOL) {
          this.onBUOL.forEach(function(listener) {
            return listener();
          });
        }
      };
      _proto.reportObserved = function reportObserved$1() {
        return reportObserved(this);
      };
      _proto.reportChanged = function reportChanged() {
        startBatch();
        propagateChanged(this);
        endBatch();
      };
      _proto.toString = function toString3() {
        return this.name_;
      };
      return _createClass(Atom2, [{
        key: "isBeingObserved",
        get: function get5() {
          return getFlag(this.flags_, Atom2.isBeingObservedMask_);
        },
        set: function set6(newValue) {
          this.flags_ = setFlag(this.flags_, Atom2.isBeingObservedMask_, newValue);
        }
      }, {
        key: "isPendingUnobservation",
        get: function get5() {
          return getFlag(this.flags_, Atom2.isPendingUnobservationMask_);
        },
        set: function set6(newValue) {
          this.flags_ = setFlag(this.flags_, Atom2.isPendingUnobservationMask_, newValue);
        }
      }, {
        key: "diffValue",
        get: function get5() {
          return getFlag(this.flags_, Atom2.diffValueMask_) ? 1 : 0;
        },
        set: function set6(newValue) {
          this.flags_ = setFlag(this.flags_, Atom2.diffValueMask_, newValue === 1 ? true : false);
        }
      }]);
    }();
    Atom.isBeingObservedMask_ = 1;
    Atom.isPendingUnobservationMask_ = 2;
    Atom.diffValueMask_ = 4;
    isAtom = createInstanceofPredicate("Atom", Atom);
    comparer = {
      identity: identityComparer,
      structural: structuralComparer,
      "default": defaultComparer,
      shallow: shallowComparer
    };
    OVERRIDE = "override";
    override = createDecoratorAnnotation({
      annotationType_: OVERRIDE,
      make_,
      extend_,
      decorate_20223_
    });
    AUTO = "true";
    autoAnnotation = createAutoAnnotation();
    OBSERVABLE = "observable";
    OBSERVABLE_REF = "observable.ref";
    OBSERVABLE_SHALLOW = "observable.shallow";
    OBSERVABLE_STRUCT = "observable.struct";
    defaultCreateObservableOptions = {
      deep: true,
      name: void 0,
      defaultDecorator: void 0,
      proxy: true
    };
    Object.freeze(defaultCreateObservableOptions);
    observableAnnotation = createObservableAnnotation(OBSERVABLE);
    observableRefAnnotation = createObservableAnnotation(OBSERVABLE_REF, {
      enhancer: referenceEnhancer
    });
    observableShallowAnnotation = createObservableAnnotation(OBSERVABLE_SHALLOW, {
      enhancer: shallowEnhancer
    });
    observableStructAnnotation = createObservableAnnotation(OBSERVABLE_STRUCT, {
      enhancer: refStructEnhancer
    });
    observableDecoratorAnnotation = createDecoratorAnnotation(observableAnnotation);
    assign(createObservable, observableDecoratorAnnotation);
    observableFactories = {
      box: function box(value, options) {
        var o4 = asCreateObservableOptions(options);
        return new ObservableValue(value, getEnhancerFromOptions(o4), o4.name, true, o4.equals);
      },
      array: function array(initialValues, options) {
        var o4 = asCreateObservableOptions(options);
        return (globalState.useProxies === false || o4.proxy === false ? createLegacyArray : createObservableArray)(initialValues, getEnhancerFromOptions(o4), o4.name);
      },
      map: function map(initialValues, options) {
        var o4 = asCreateObservableOptions(options);
        return new ObservableMap(initialValues, getEnhancerFromOptions(o4), o4.name);
      },
      set: function set(initialValues, options) {
        var o4 = asCreateObservableOptions(options);
        return new ObservableSet(initialValues, getEnhancerFromOptions(o4), o4.name);
      },
      object: function object(props, decorators, options) {
        return initObservable(function() {
          return extendObservable(globalState.useProxies === false || (options == null ? void 0 : options.proxy) === false ? asObservableObject({}, options) : asDynamicObservableObject({}, options), props, decorators);
        });
      },
      ref: createDecoratorAnnotation(observableRefAnnotation),
      shallow: createDecoratorAnnotation(observableShallowAnnotation),
      deep: observableDecoratorAnnotation,
      struct: createDecoratorAnnotation(observableStructAnnotation)
    };
    observable = assign(createObservable, observableFactories);
    COMPUTED = "computed";
    COMPUTED_STRUCT = "computed.struct";
    computedAnnotation = createComputedAnnotation(COMPUTED);
    computedStructAnnotation = createComputedAnnotation(COMPUTED_STRUCT, {
      equals: comparer.structural
    });
    computed = function computed2(arg1, arg2) {
      if (is20223Decorator(arg2)) {
        return computedAnnotation.decorate_20223_(arg1, arg2);
      }
      if (isStringish(arg2)) {
        return storeAnnotation(arg1, arg2, computedAnnotation);
      }
      if (isPlainObject(arg1)) {
        return createDecoratorAnnotation(createComputedAnnotation(COMPUTED, arg1));
      }
      if (true) {
        if (!isFunction(arg1)) {
          die("First argument to `computed` should be an expression.");
        }
        if (isFunction(arg2)) {
          die("A setter as second argument is no longer supported, use `{ set: fn }` option instead");
        }
      }
      var opts = isPlainObject(arg2) ? arg2 : {};
      opts.get = arg1;
      opts.name || (opts.name = arg1.name || "");
      return new ComputedValue(opts);
    };
    Object.assign(computed, computedAnnotation);
    computed.struct = createDecoratorAnnotation(computedStructAnnotation);
    currentActionId = 0;
    nextActionId = 1;
    isFunctionNameConfigurable = (_getDescriptor$config = (_getDescriptor = getDescriptor(function() {
    }, "name")) == null ? void 0 : _getDescriptor.configurable) != null ? _getDescriptor$config : false;
    tmpNameDescriptor = {
      value: "action",
      configurable: true,
      writable: false,
      enumerable: false
    };
    CREATE = "create";
    ObservableValue = function(_Atom) {
      function ObservableValue2(value, enhancer, name_, notifySpy, equals) {
        var _this;
        if (name_ === void 0) {
          name_ = true ? "ObservableValue@" + getNextId() : "ObservableValue";
        }
        if (notifySpy === void 0) {
          notifySpy = true;
        }
        if (equals === void 0) {
          equals = comparer["default"];
        }
        _this = _Atom.call(this, name_) || this;
        _this.enhancer = void 0;
        _this.name_ = void 0;
        _this.equals = void 0;
        _this.hasUnreportedChange_ = false;
        _this.interceptors_ = void 0;
        _this.changeListeners_ = void 0;
        _this.value_ = void 0;
        _this.dehancer = void 0;
        _this.enhancer = enhancer;
        _this.name_ = name_;
        _this.equals = equals;
        _this.value_ = enhancer(value, void 0, name_);
        if (notifySpy && isSpyEnabled()) {
          spyReport({
            type: CREATE,
            object: _this,
            observableKind: "value",
            debugObjectName: _this.name_,
            newValue: "" + _this.value_
          });
        }
        return _this;
      }
      _inheritsLoose(ObservableValue2, _Atom);
      var _proto = ObservableValue2.prototype;
      _proto.dehanceValue = function dehanceValue(value) {
        if (this.dehancer !== void 0) {
          return this.dehancer(value);
        }
        return value;
      };
      _proto.set = function set6(newValue) {
        var oldValue = this.value_;
        newValue = this.prepareNewValue_(newValue);
        if (newValue !== globalState.UNCHANGED) {
          var notifySpy = isSpyEnabled();
          if (notifySpy) {
            spyReportStart({
              type: UPDATE,
              object: this,
              observableKind: "value",
              debugObjectName: this.name_,
              newValue,
              oldValue
            });
          }
          this.setNewValue_(newValue);
          if (notifySpy) {
            spyReportEnd();
          }
        }
      };
      _proto.prepareNewValue_ = function prepareNewValue_(newValue) {
        checkIfStateModificationsAreAllowed(this);
        if (hasInterceptors(this)) {
          var change = interceptChange(this, {
            object: this,
            type: UPDATE,
            newValue
          });
          if (!change) {
            return globalState.UNCHANGED;
          }
          newValue = change.newValue;
        }
        newValue = this.enhancer(newValue, this.value_, this.name_);
        return this.equals(this.value_, newValue) ? globalState.UNCHANGED : newValue;
      };
      _proto.setNewValue_ = function setNewValue_(newValue) {
        var oldValue = this.value_;
        this.value_ = newValue;
        this.reportChanged();
        if (hasListeners(this)) {
          notifyListeners(this, {
            type: UPDATE,
            object: this,
            newValue,
            oldValue
          });
        }
      };
      _proto.get = function get5() {
        this.reportObserved();
        return this.dehanceValue(this.value_);
      };
      _proto.intercept_ = function intercept_(handler) {
        return registerInterceptor(this, handler);
      };
      _proto.observe_ = function observe_(listener, fireImmediately) {
        if (fireImmediately) {
          listener({
            observableKind: "value",
            debugObjectName: this.name_,
            object: this,
            type: UPDATE,
            newValue: this.value_,
            oldValue: void 0
          });
        }
        return registerListener(this, listener);
      };
      _proto.raw = function raw() {
        return this.value_;
      };
      _proto.toJSON = function toJSON2() {
        return this.get();
      };
      _proto.toString = function toString3() {
        return this.name_ + "[" + this.value_ + "]";
      };
      _proto.valueOf = function valueOf() {
        return toPrimitive(this.get());
      };
      _proto[Symbol.toPrimitive] = function() {
        return this.valueOf();
      };
      return ObservableValue2;
    }(Atom);
    isObservableValue = createInstanceofPredicate("ObservableValue", ObservableValue);
    ComputedValue = function() {
      function ComputedValue2(options) {
        this.dependenciesState_ = IDerivationState_.NOT_TRACKING_;
        this.observing_ = [];
        this.newObserving_ = null;
        this.observers_ = /* @__PURE__ */ new Set();
        this.runId_ = 0;
        this.lastAccessedBy_ = 0;
        this.lowestObserverState_ = IDerivationState_.UP_TO_DATE_;
        this.unboundDepsCount_ = 0;
        this.value_ = new CaughtException(null);
        this.name_ = void 0;
        this.triggeredBy_ = void 0;
        this.flags_ = 0;
        this.derivation = void 0;
        this.setter_ = void 0;
        this.isTracing_ = TraceMode.NONE;
        this.scope_ = void 0;
        this.equals_ = void 0;
        this.requiresReaction_ = void 0;
        this.keepAlive_ = void 0;
        this.onBOL = void 0;
        this.onBUOL = void 0;
        if (!options.get) {
          die(31);
        }
        this.derivation = options.get;
        this.name_ = options.name || (true ? "ComputedValue@" + getNextId() : "ComputedValue");
        if (options.set) {
          this.setter_ = createAction(true ? this.name_ + "-setter" : "ComputedValue-setter", options.set);
        }
        this.equals_ = options.equals || (options.compareStructural || options.struct ? comparer.structural : comparer["default"]);
        this.scope_ = options.context;
        this.requiresReaction_ = options.requiresReaction;
        this.keepAlive_ = !!options.keepAlive;
      }
      var _proto = ComputedValue2.prototype;
      _proto.onBecomeStale_ = function onBecomeStale_() {
        propagateMaybeChanged(this);
      };
      _proto.onBO = function onBO() {
        if (this.onBOL) {
          this.onBOL.forEach(function(listener) {
            return listener();
          });
        }
      };
      _proto.onBUO = function onBUO() {
        if (this.onBUOL) {
          this.onBUOL.forEach(function(listener) {
            return listener();
          });
        }
      };
      _proto.get = function get5() {
        if (this.isComputing) {
          die(32, this.name_, this.derivation);
        }
        if (globalState.inBatch === 0 && // !globalState.trackingDerivatpion &&
        this.observers_.size === 0 && !this.keepAlive_) {
          if (shouldCompute(this)) {
            this.warnAboutUntrackedRead_();
            startBatch();
            this.value_ = this.computeValue_(false);
            endBatch();
          }
        } else {
          reportObserved(this);
          if (shouldCompute(this)) {
            var prevTrackingContext = globalState.trackingContext;
            if (this.keepAlive_ && !prevTrackingContext) {
              globalState.trackingContext = this;
            }
            if (this.trackAndCompute()) {
              propagateChangeConfirmed(this);
            }
            globalState.trackingContext = prevTrackingContext;
          }
        }
        var result = this.value_;
        if (isCaughtException(result)) {
          throw result.cause;
        }
        return result;
      };
      _proto.set = function set6(value) {
        if (this.setter_) {
          if (this.isRunningSetter) {
            die(33, this.name_);
          }
          this.isRunningSetter = true;
          try {
            this.setter_.call(this.scope_, value);
          } finally {
            this.isRunningSetter = false;
          }
        } else {
          die(34, this.name_);
        }
      };
      _proto.trackAndCompute = function trackAndCompute() {
        var oldValue = this.value_;
        var wasSuspended = (
          /* see #1208 */
          this.dependenciesState_ === IDerivationState_.NOT_TRACKING_
        );
        var newValue = this.computeValue_(true);
        var changed = wasSuspended || isCaughtException(oldValue) || isCaughtException(newValue) || !this.equals_(oldValue, newValue);
        if (changed) {
          this.value_ = newValue;
          if (isSpyEnabled()) {
            spyReport({
              observableKind: "computed",
              debugObjectName: this.name_,
              object: this.scope_,
              type: "update",
              oldValue,
              newValue
            });
          }
        }
        return changed;
      };
      _proto.computeValue_ = function computeValue_(track) {
        this.isComputing = true;
        var prev = allowStateChangesStart(false);
        var res;
        if (track) {
          res = trackDerivedFunction(this, this.derivation, this.scope_);
        } else {
          if (globalState.disableErrorBoundaries === true) {
            res = this.derivation.call(this.scope_);
          } else {
            try {
              res = this.derivation.call(this.scope_);
            } catch (e2) {
              res = new CaughtException(e2);
            }
          }
        }
        allowStateChangesEnd(prev);
        this.isComputing = false;
        return res;
      };
      _proto.suspend_ = function suspend_() {
        if (!this.keepAlive_) {
          clearObserving(this);
          this.value_ = void 0;
          if (this.isTracing_ !== TraceMode.NONE) {
            console.log("[mobx.trace] Computed value '" + this.name_ + "' was suspended and it will recompute on the next access.");
          }
        }
      };
      _proto.observe_ = function observe_(listener, fireImmediately) {
        var _this = this;
        var firstTime = true;
        var prevValue = void 0;
        return autorun(function() {
          var newValue = _this.get();
          if (!firstTime || fireImmediately) {
            var prevU = untrackedStart();
            listener({
              observableKind: "computed",
              debugObjectName: _this.name_,
              type: UPDATE,
              object: _this,
              newValue,
              oldValue: prevValue
            });
            untrackedEnd(prevU);
          }
          firstTime = false;
          prevValue = newValue;
        });
      };
      _proto.warnAboutUntrackedRead_ = function warnAboutUntrackedRead_() {
        if (false) {
          return;
        }
        if (this.isTracing_ !== TraceMode.NONE) {
          console.log("[mobx.trace] Computed value '" + this.name_ + "' is being read outside a reactive context. Doing a full recompute.");
        }
        if (typeof this.requiresReaction_ === "boolean" ? this.requiresReaction_ : globalState.computedRequiresReaction) {
          console.warn("[mobx] Computed value '" + this.name_ + "' is being read outside a reactive context. Doing a full recompute.");
        }
      };
      _proto.toString = function toString3() {
        return this.name_ + "[" + this.derivation.toString() + "]";
      };
      _proto.valueOf = function valueOf() {
        return toPrimitive(this.get());
      };
      _proto[Symbol.toPrimitive] = function() {
        return this.valueOf();
      };
      return _createClass(ComputedValue2, [{
        key: "isComputing",
        get: function get5() {
          return getFlag(this.flags_, ComputedValue2.isComputingMask_);
        },
        set: function set6(newValue) {
          this.flags_ = setFlag(this.flags_, ComputedValue2.isComputingMask_, newValue);
        }
      }, {
        key: "isRunningSetter",
        get: function get5() {
          return getFlag(this.flags_, ComputedValue2.isRunningSetterMask_);
        },
        set: function set6(newValue) {
          this.flags_ = setFlag(this.flags_, ComputedValue2.isRunningSetterMask_, newValue);
        }
      }, {
        key: "isBeingObserved",
        get: function get5() {
          return getFlag(this.flags_, ComputedValue2.isBeingObservedMask_);
        },
        set: function set6(newValue) {
          this.flags_ = setFlag(this.flags_, ComputedValue2.isBeingObservedMask_, newValue);
        }
      }, {
        key: "isPendingUnobservation",
        get: function get5() {
          return getFlag(this.flags_, ComputedValue2.isPendingUnobservationMask_);
        },
        set: function set6(newValue) {
          this.flags_ = setFlag(this.flags_, ComputedValue2.isPendingUnobservationMask_, newValue);
        }
      }, {
        key: "diffValue",
        get: function get5() {
          return getFlag(this.flags_, ComputedValue2.diffValueMask_) ? 1 : 0;
        },
        set: function set6(newValue) {
          this.flags_ = setFlag(this.flags_, ComputedValue2.diffValueMask_, newValue === 1 ? true : false);
        }
      }]);
    }();
    ComputedValue.isComputingMask_ = 1;
    ComputedValue.isRunningSetterMask_ = 2;
    ComputedValue.isBeingObservedMask_ = 4;
    ComputedValue.isPendingUnobservationMask_ = 8;
    ComputedValue.diffValueMask_ = 16;
    isComputedValue = createInstanceofPredicate("ComputedValue", ComputedValue);
    (function(IDerivationState_2) {
      IDerivationState_2[IDerivationState_2["NOT_TRACKING_"] = -1] = "NOT_TRACKING_";
      IDerivationState_2[IDerivationState_2["UP_TO_DATE_"] = 0] = "UP_TO_DATE_";
      IDerivationState_2[IDerivationState_2["POSSIBLY_STALE_"] = 1] = "POSSIBLY_STALE_";
      IDerivationState_2[IDerivationState_2["STALE_"] = 2] = "STALE_";
    })(IDerivationState_ || (IDerivationState_ = {}));
    (function(TraceMode2) {
      TraceMode2[TraceMode2["NONE"] = 0] = "NONE";
      TraceMode2[TraceMode2["LOG"] = 1] = "LOG";
      TraceMode2[TraceMode2["BREAK"] = 2] = "BREAK";
    })(TraceMode || (TraceMode = {}));
    CaughtException = function CaughtException2(cause) {
      this.cause = void 0;
      this.cause = cause;
    };
    persistentKeys = ["mobxGuid", "spyListeners", "enforceActions", "computedRequiresReaction", "reactionRequiresObservable", "observableRequiresReaction", "allowStateReads", "disableErrorBoundaries", "runId", "UNCHANGED", "useProxies"];
    MobXGlobals = function MobXGlobals2() {
      this.version = 6;
      this.UNCHANGED = {};
      this.trackingDerivation = null;
      this.trackingContext = null;
      this.runId = 0;
      this.mobxGuid = 0;
      this.inBatch = 0;
      this.pendingUnobservations = [];
      this.pendingReactions = [];
      this.isRunningReactions = false;
      this.allowStateChanges = false;
      this.allowStateReads = true;
      this.enforceActions = true;
      this.spyListeners = [];
      this.globalReactionErrorHandlers = [];
      this.computedRequiresReaction = false;
      this.reactionRequiresObservable = false;
      this.observableRequiresReaction = false;
      this.disableErrorBoundaries = false;
      this.suppressReactionErrors = false;
      this.useProxies = true;
      this.verifyProxies = false;
      this.safeDescriptors = true;
    };
    canMergeGlobalState = true;
    isolateCalled = false;
    globalState = function() {
      var global2 = getGlobal();
      if (global2.__mobxInstanceCount > 0 && !global2.__mobxGlobals) {
        canMergeGlobalState = false;
      }
      if (global2.__mobxGlobals && global2.__mobxGlobals.version !== new MobXGlobals().version) {
        canMergeGlobalState = false;
      }
      if (!canMergeGlobalState) {
        setTimeout(function() {
          if (!isolateCalled) {
            die(35);
          }
        }, 1);
        return new MobXGlobals();
      } else if (global2.__mobxGlobals) {
        global2.__mobxInstanceCount += 1;
        if (!global2.__mobxGlobals.UNCHANGED) {
          global2.__mobxGlobals.UNCHANGED = {};
        }
        return global2.__mobxGlobals;
      } else {
        global2.__mobxInstanceCount = 1;
        return global2.__mobxGlobals = new MobXGlobals();
      }
    }();
    Reaction = function() {
      function Reaction2(name_, onInvalidate_, errorHandler_, requiresObservable_) {
        if (name_ === void 0) {
          name_ = true ? "Reaction@" + getNextId() : "Reaction";
        }
        this.name_ = void 0;
        this.onInvalidate_ = void 0;
        this.errorHandler_ = void 0;
        this.requiresObservable_ = void 0;
        this.observing_ = [];
        this.newObserving_ = [];
        this.dependenciesState_ = IDerivationState_.NOT_TRACKING_;
        this.runId_ = 0;
        this.unboundDepsCount_ = 0;
        this.flags_ = 0;
        this.isTracing_ = TraceMode.NONE;
        this.name_ = name_;
        this.onInvalidate_ = onInvalidate_;
        this.errorHandler_ = errorHandler_;
        this.requiresObservable_ = requiresObservable_;
      }
      var _proto = Reaction2.prototype;
      _proto.onBecomeStale_ = function onBecomeStale_() {
        this.schedule_();
      };
      _proto.schedule_ = function schedule_() {
        if (!this.isScheduled) {
          this.isScheduled = true;
          globalState.pendingReactions.push(this);
          runReactions();
        }
      };
      _proto.runReaction_ = function runReaction_() {
        if (!this.isDisposed) {
          startBatch();
          this.isScheduled = false;
          var prev = globalState.trackingContext;
          globalState.trackingContext = this;
          if (shouldCompute(this)) {
            this.isTrackPending = true;
            try {
              this.onInvalidate_();
              if (this.isTrackPending && isSpyEnabled()) {
                spyReport({
                  name: this.name_,
                  type: "scheduled-reaction"
                });
              }
            } catch (e2) {
              this.reportExceptionInDerivation_(e2);
            }
          }
          globalState.trackingContext = prev;
          endBatch();
        }
      };
      _proto.track = function track(fn2) {
        if (this.isDisposed) {
          return;
        }
        startBatch();
        var notify = isSpyEnabled();
        var startTime;
        if (notify) {
          startTime = Date.now();
          spyReportStart({
            name: this.name_,
            type: "reaction"
          });
        }
        this.isRunning = true;
        var prevReaction = globalState.trackingContext;
        globalState.trackingContext = this;
        var result = trackDerivedFunction(this, fn2, void 0);
        globalState.trackingContext = prevReaction;
        this.isRunning = false;
        this.isTrackPending = false;
        if (this.isDisposed) {
          clearObserving(this);
        }
        if (isCaughtException(result)) {
          this.reportExceptionInDerivation_(result.cause);
        }
        if (notify) {
          spyReportEnd({
            time: Date.now() - startTime
          });
        }
        endBatch();
      };
      _proto.reportExceptionInDerivation_ = function reportExceptionInDerivation_(error) {
        var _this = this;
        if (this.errorHandler_) {
          this.errorHandler_(error, this);
          return;
        }
        if (globalState.disableErrorBoundaries) {
          throw error;
        }
        var message = true ? "[mobx] Encountered an uncaught exception that was thrown by a reaction or observer component, in: '" + this + "'" : "[mobx] uncaught error in '" + this + "'";
        if (!globalState.suppressReactionErrors) {
          console.error(message, error);
        } else if (true) {
          console.warn("[mobx] (error in reaction '" + this.name_ + "' suppressed, fix error of causing action below)");
        }
        if (isSpyEnabled()) {
          spyReport({
            type: "error",
            name: this.name_,
            message,
            error: "" + error
          });
        }
        globalState.globalReactionErrorHandlers.forEach(function(f6) {
          return f6(error, _this);
        });
      };
      _proto.dispose = function dispose2() {
        if (!this.isDisposed) {
          this.isDisposed = true;
          if (!this.isRunning) {
            startBatch();
            clearObserving(this);
            endBatch();
          }
        }
      };
      _proto.getDisposer_ = function getDisposer_(abortSignal) {
        var _this2 = this;
        var dispose2 = function dispose3() {
          _this2.dispose();
          abortSignal == null || abortSignal.removeEventListener == null || abortSignal.removeEventListener("abort", dispose3);
        };
        abortSignal == null || abortSignal.addEventListener == null || abortSignal.addEventListener("abort", dispose2);
        dispose2[$mobx] = this;
        return dispose2;
      };
      _proto.toString = function toString3() {
        return "Reaction[" + this.name_ + "]";
      };
      _proto.trace = function trace$1(enterBreakPoint) {
        if (enterBreakPoint === void 0) {
          enterBreakPoint = false;
        }
        trace(this, enterBreakPoint);
      };
      return _createClass(Reaction2, [{
        key: "isDisposed",
        get: function get5() {
          return getFlag(this.flags_, Reaction2.isDisposedMask_);
        },
        set: function set6(newValue) {
          this.flags_ = setFlag(this.flags_, Reaction2.isDisposedMask_, newValue);
        }
      }, {
        key: "isScheduled",
        get: function get5() {
          return getFlag(this.flags_, Reaction2.isScheduledMask_);
        },
        set: function set6(newValue) {
          this.flags_ = setFlag(this.flags_, Reaction2.isScheduledMask_, newValue);
        }
      }, {
        key: "isTrackPending",
        get: function get5() {
          return getFlag(this.flags_, Reaction2.isTrackPendingMask_);
        },
        set: function set6(newValue) {
          this.flags_ = setFlag(this.flags_, Reaction2.isTrackPendingMask_, newValue);
        }
      }, {
        key: "isRunning",
        get: function get5() {
          return getFlag(this.flags_, Reaction2.isRunningMask_);
        },
        set: function set6(newValue) {
          this.flags_ = setFlag(this.flags_, Reaction2.isRunningMask_, newValue);
        }
      }, {
        key: "diffValue",
        get: function get5() {
          return getFlag(this.flags_, Reaction2.diffValueMask_) ? 1 : 0;
        },
        set: function set6(newValue) {
          this.flags_ = setFlag(this.flags_, Reaction2.diffValueMask_, newValue === 1 ? true : false);
        }
      }]);
    }();
    Reaction.isDisposedMask_ = 1;
    Reaction.isScheduledMask_ = 2;
    Reaction.isTrackPendingMask_ = 4;
    Reaction.isRunningMask_ = 8;
    Reaction.diffValueMask_ = 16;
    MAX_REACTION_ITERATIONS = 100;
    reactionScheduler = function reactionScheduler2(f6) {
      return f6();
    };
    isReaction = createInstanceofPredicate("Reaction", Reaction);
    END_EVENT = {
      type: "report-end",
      spyReportEnd: true
    };
    ACTION = "action";
    ACTION_BOUND = "action.bound";
    AUTOACTION = "autoAction";
    AUTOACTION_BOUND = "autoAction.bound";
    DEFAULT_ACTION_NAME = "<unnamed action>";
    actionAnnotation = createActionAnnotation(ACTION);
    actionBoundAnnotation = createActionAnnotation(ACTION_BOUND, {
      bound: true
    });
    autoActionAnnotation = createActionAnnotation(AUTOACTION, {
      autoAction: true
    });
    autoActionBoundAnnotation = createActionAnnotation(AUTOACTION_BOUND, {
      autoAction: true,
      bound: true
    });
    action = createActionFactory(false);
    Object.assign(action, actionAnnotation);
    autoAction = createActionFactory(true);
    Object.assign(autoAction, autoActionAnnotation);
    action.bound = createDecoratorAnnotation(actionBoundAnnotation);
    autoAction.bound = createDecoratorAnnotation(autoActionBoundAnnotation);
    run = function run2(f6) {
      return f6();
    };
    ON_BECOME_OBSERVED = "onBO";
    ON_BECOME_UNOBSERVED = "onBUO";
    NEVER = "never";
    ALWAYS = "always";
    OBSERVED = "observed";
    generatorId = 0;
    FlowCancellationError.prototype = Object.create(Error.prototype);
    flowAnnotation = createFlowAnnotation("flow");
    flowBoundAnnotation = createFlowAnnotation("flow.bound", {
      bound: true
    });
    flow = Object.assign(function flow2(arg1, arg2) {
      if (is20223Decorator(arg2)) {
        return flowAnnotation.decorate_20223_(arg1, arg2);
      }
      if (isStringish(arg2)) {
        return storeAnnotation(arg1, arg2, flowAnnotation);
      }
      if (arguments.length !== 1) {
        die("Flow expects single argument with generator function");
      }
      var generator = arg1;
      var name = generator.name || "<unnamed flow>";
      var res = function res2() {
        var ctx = this;
        var args = arguments;
        var runId = ++generatorId;
        var gen = action(name + " - runid: " + runId + " - init", generator).apply(ctx, args);
        var rejector;
        var pendingPromise = void 0;
        var promise = new Promise(function(resolve, reject) {
          var stepId = 0;
          rejector = reject;
          function onFulfilled(res3) {
            pendingPromise = void 0;
            var ret;
            try {
              ret = action(name + " - runid: " + runId + " - yield " + stepId++, gen.next).call(gen, res3);
            } catch (e2) {
              return reject(e2);
            }
            next(ret);
          }
          function onRejected(err) {
            pendingPromise = void 0;
            var ret;
            try {
              ret = action(name + " - runid: " + runId + " - yield " + stepId++, gen["throw"]).call(gen, err);
            } catch (e2) {
              return reject(e2);
            }
            next(ret);
          }
          function next(ret) {
            if (isFunction(ret == null ? void 0 : ret.then)) {
              ret.then(next, reject);
              return;
            }
            if (ret.done) {
              return resolve(ret.value);
            }
            pendingPromise = Promise.resolve(ret.value);
            return pendingPromise.then(onFulfilled, onRejected);
          }
          onFulfilled(void 0);
        });
        promise.cancel = action(name + " - runid: " + runId + " - cancel", function() {
          try {
            if (pendingPromise) {
              cancelPromise(pendingPromise);
            }
            var _res = gen["return"](void 0);
            var yieldedPromise = Promise.resolve(_res.value);
            yieldedPromise.then(noop, noop);
            cancelPromise(yieldedPromise);
            rejector(new FlowCancellationError());
          } catch (e2) {
            rejector(e2);
          }
        });
        return promise;
      };
      res.isMobXFlow = true;
      return res;
    }, flowAnnotation);
    flow.bound = createDecoratorAnnotation(flowBoundAnnotation);
    objectProxyTraps = {
      has: function has2(target, name) {
        if (globalState.trackingDerivation) {
          warnAboutProxyRequirement("detect new properties using the 'in' operator. Use 'has' from 'mobx' instead.");
        }
        return getAdm(target).has_(name);
      },
      get: function get2(target, name) {
        return getAdm(target).get_(name);
      },
      set: function set3(target, name, value) {
        var _getAdm$set_;
        if (!isStringish(name)) {
          return false;
        }
        if (!getAdm(target).values_.has(name)) {
          warnAboutProxyRequirement("add a new observable property through direct assignment. Use 'set' from 'mobx' instead.");
        }
        return (_getAdm$set_ = getAdm(target).set_(name, value, true)) != null ? _getAdm$set_ : true;
      },
      deleteProperty: function deleteProperty(target, name) {
        var _getAdm$delete_;
        if (true) {
          warnAboutProxyRequirement("delete properties from an observable object. Use 'remove' from 'mobx' instead.");
        }
        if (!isStringish(name)) {
          return false;
        }
        return (_getAdm$delete_ = getAdm(target).delete_(name, true)) != null ? _getAdm$delete_ : true;
      },
      defineProperty: function defineProperty2(target, name, descriptor) {
        var _getAdm$definePropert;
        if (true) {
          warnAboutProxyRequirement("define property on an observable object. Use 'defineProperty' from 'mobx' instead.");
        }
        return (_getAdm$definePropert = getAdm(target).defineProperty_(name, descriptor)) != null ? _getAdm$definePropert : true;
      },
      ownKeys: function ownKeys2(target) {
        if (globalState.trackingDerivation) {
          warnAboutProxyRequirement("iterate keys to detect added / removed properties. Use 'keys' from 'mobx' instead.");
        }
        return getAdm(target).ownKeys_();
      },
      preventExtensions: function preventExtensions(target) {
        die(13);
      }
    };
    keysSymbol = Symbol("mobx-keys");
    SPLICE = "splice";
    UPDATE = "update";
    MAX_SPLICE_SIZE = 1e4;
    arrayTraps = {
      get: function get3(target, name) {
        var adm = target[$mobx];
        if (name === $mobx) {
          return adm;
        }
        if (name === "length") {
          return adm.getArrayLength_();
        }
        if (typeof name === "string" && !isNaN(name)) {
          return adm.get_(parseInt(name));
        }
        if (hasProp(arrayExtensions, name)) {
          return arrayExtensions[name];
        }
        return target[name];
      },
      set: function set4(target, name, value) {
        var adm = target[$mobx];
        if (name === "length") {
          adm.setArrayLength_(value);
        }
        if (typeof name === "symbol" || isNaN(name)) {
          target[name] = value;
        } else {
          adm.set_(parseInt(name), value);
        }
        return true;
      },
      preventExtensions: function preventExtensions2() {
        die(15);
      }
    };
    ObservableArrayAdministration = function() {
      function ObservableArrayAdministration2(name, enhancer, owned_, legacyMode_) {
        if (name === void 0) {
          name = true ? "ObservableArray@" + getNextId() : "ObservableArray";
        }
        this.owned_ = void 0;
        this.legacyMode_ = void 0;
        this.atom_ = void 0;
        this.values_ = [];
        this.interceptors_ = void 0;
        this.changeListeners_ = void 0;
        this.enhancer_ = void 0;
        this.dehancer = void 0;
        this.proxy_ = void 0;
        this.lastKnownLength_ = 0;
        this.owned_ = owned_;
        this.legacyMode_ = legacyMode_;
        this.atom_ = new Atom(name);
        this.enhancer_ = function(newV, oldV) {
          return enhancer(newV, oldV, true ? name + "[..]" : "ObservableArray[..]");
        };
      }
      var _proto = ObservableArrayAdministration2.prototype;
      _proto.dehanceValue_ = function dehanceValue_(value) {
        if (this.dehancer !== void 0) {
          return this.dehancer(value);
        }
        return value;
      };
      _proto.dehanceValues_ = function dehanceValues_(values2) {
        if (this.dehancer !== void 0 && values2.length > 0) {
          return values2.map(this.dehancer);
        }
        return values2;
      };
      _proto.intercept_ = function intercept_(handler) {
        return registerInterceptor(this, handler);
      };
      _proto.observe_ = function observe_(listener, fireImmediately) {
        if (fireImmediately === void 0) {
          fireImmediately = false;
        }
        if (fireImmediately) {
          listener({
            observableKind: "array",
            object: this.proxy_,
            debugObjectName: this.atom_.name_,
            type: "splice",
            index: 0,
            added: this.values_.slice(),
            addedCount: this.values_.length,
            removed: [],
            removedCount: 0
          });
        }
        return registerListener(this, listener);
      };
      _proto.getArrayLength_ = function getArrayLength_() {
        this.atom_.reportObserved();
        return this.values_.length;
      };
      _proto.setArrayLength_ = function setArrayLength_(newLength) {
        if (typeof newLength !== "number" || isNaN(newLength) || newLength < 0) {
          die("Out of range: " + newLength);
        }
        var currentLength = this.values_.length;
        if (newLength === currentLength) {
          return;
        } else if (newLength > currentLength) {
          var newItems = new Array(newLength - currentLength);
          for (var i4 = 0; i4 < newLength - currentLength; i4++) {
            newItems[i4] = void 0;
          }
          this.spliceWithArray_(currentLength, 0, newItems);
        } else {
          this.spliceWithArray_(newLength, currentLength - newLength);
        }
      };
      _proto.updateArrayLength_ = function updateArrayLength_(oldLength, delta) {
        if (oldLength !== this.lastKnownLength_) {
          die(16);
        }
        this.lastKnownLength_ += delta;
        if (this.legacyMode_ && delta > 0) {
          reserveArrayBuffer(oldLength + delta + 1);
        }
      };
      _proto.spliceWithArray_ = function spliceWithArray_(index, deleteCount, newItems) {
        var _this = this;
        checkIfStateModificationsAreAllowed(this.atom_);
        var length = this.values_.length;
        if (index === void 0) {
          index = 0;
        } else if (index > length) {
          index = length;
        } else if (index < 0) {
          index = Math.max(0, length + index);
        }
        if (arguments.length === 1) {
          deleteCount = length - index;
        } else if (deleteCount === void 0 || deleteCount === null) {
          deleteCount = 0;
        } else {
          deleteCount = Math.max(0, Math.min(deleteCount, length - index));
        }
        if (newItems === void 0) {
          newItems = EMPTY_ARRAY;
        }
        if (hasInterceptors(this)) {
          var change = interceptChange(this, {
            object: this.proxy_,
            type: SPLICE,
            index,
            removedCount: deleteCount,
            added: newItems
          });
          if (!change) {
            return EMPTY_ARRAY;
          }
          deleteCount = change.removedCount;
          newItems = change.added;
        }
        newItems = newItems.length === 0 ? newItems : newItems.map(function(v5) {
          return _this.enhancer_(v5, void 0);
        });
        if (this.legacyMode_ || true) {
          var lengthDelta = newItems.length - deleteCount;
          this.updateArrayLength_(length, lengthDelta);
        }
        var res = this.spliceItemsIntoValues_(index, deleteCount, newItems);
        if (deleteCount !== 0 || newItems.length !== 0) {
          this.notifyArraySplice_(index, newItems, res);
        }
        return this.dehanceValues_(res);
      };
      _proto.spliceItemsIntoValues_ = function spliceItemsIntoValues_(index, deleteCount, newItems) {
        if (newItems.length < MAX_SPLICE_SIZE) {
          var _this$values_;
          return (_this$values_ = this.values_).splice.apply(_this$values_, [index, deleteCount].concat(newItems));
        } else {
          var res = this.values_.slice(index, index + deleteCount);
          var oldItems = this.values_.slice(index + deleteCount);
          this.values_.length += newItems.length - deleteCount;
          for (var i4 = 0; i4 < newItems.length; i4++) {
            this.values_[index + i4] = newItems[i4];
          }
          for (var _i2 = 0; _i2 < oldItems.length; _i2++) {
            this.values_[index + newItems.length + _i2] = oldItems[_i2];
          }
          return res;
        }
      };
      _proto.notifyArrayChildUpdate_ = function notifyArrayChildUpdate_(index, newValue, oldValue) {
        var notifySpy = !this.owned_ && isSpyEnabled();
        var notify = hasListeners(this);
        var change = notify || notifySpy ? {
          observableKind: "array",
          object: this.proxy_,
          type: UPDATE,
          debugObjectName: this.atom_.name_,
          index,
          newValue,
          oldValue
        } : null;
        if (notifySpy) {
          spyReportStart(change);
        }
        this.atom_.reportChanged();
        if (notify) {
          notifyListeners(this, change);
        }
        if (notifySpy) {
          spyReportEnd();
        }
      };
      _proto.notifyArraySplice_ = function notifyArraySplice_(index, added, removed) {
        var notifySpy = !this.owned_ && isSpyEnabled();
        var notify = hasListeners(this);
        var change = notify || notifySpy ? {
          observableKind: "array",
          object: this.proxy_,
          debugObjectName: this.atom_.name_,
          type: SPLICE,
          index,
          removed,
          added,
          removedCount: removed.length,
          addedCount: added.length
        } : null;
        if (notifySpy) {
          spyReportStart(change);
        }
        this.atom_.reportChanged();
        if (notify) {
          notifyListeners(this, change);
        }
        if (notifySpy) {
          spyReportEnd();
        }
      };
      _proto.get_ = function get_(index) {
        if (this.legacyMode_ && index >= this.values_.length) {
          console.warn(true ? "[mobx.array] Attempt to read an array index (" + index + ") that is out of bounds (" + this.values_.length + "). Please check length first. Out of bound indices will not be tracked by MobX" : "[mobx] Out of bounds read: " + index);
          return void 0;
        }
        this.atom_.reportObserved();
        return this.dehanceValue_(this.values_[index]);
      };
      _proto.set_ = function set_(index, newValue) {
        var values2 = this.values_;
        if (this.legacyMode_ && index > values2.length) {
          die(17, index, values2.length);
        }
        if (index < values2.length) {
          checkIfStateModificationsAreAllowed(this.atom_);
          var oldValue = values2[index];
          if (hasInterceptors(this)) {
            var change = interceptChange(this, {
              type: UPDATE,
              object: this.proxy_,
              // since "this" is the real array we need to pass its proxy
              index,
              newValue
            });
            if (!change) {
              return;
            }
            newValue = change.newValue;
          }
          newValue = this.enhancer_(newValue, oldValue);
          var changed = newValue !== oldValue;
          if (changed) {
            values2[index] = newValue;
            this.notifyArrayChildUpdate_(index, newValue, oldValue);
          }
        } else {
          var newItems = new Array(index + 1 - values2.length);
          for (var i4 = 0; i4 < newItems.length - 1; i4++) {
            newItems[i4] = void 0;
          }
          newItems[newItems.length - 1] = newValue;
          this.spliceWithArray_(values2.length, 0, newItems);
        }
      };
      return ObservableArrayAdministration2;
    }();
    arrayExtensions = {
      clear: function clear() {
        return this.splice(0);
      },
      replace: function replace(newItems) {
        var adm = this[$mobx];
        return adm.spliceWithArray_(0, adm.values_.length, newItems);
      },
      // Used by JSON.stringify
      toJSON: function toJSON() {
        return this.slice();
      },
      /*
       * functions that do alter the internal structure of the array, (based on lib.es6.d.ts)
       * since these functions alter the inner structure of the array, the have side effects.
       * Because the have side effects, they should not be used in computed function,
       * and for that reason the do not call dependencyState.notifyObserved
       */
      splice: function splice(index, deleteCount) {
        for (var _len = arguments.length, newItems = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
          newItems[_key - 2] = arguments[_key];
        }
        var adm = this[$mobx];
        switch (arguments.length) {
          case 0:
            return [];
          case 1:
            return adm.spliceWithArray_(index);
          case 2:
            return adm.spliceWithArray_(index, deleteCount);
        }
        return adm.spliceWithArray_(index, deleteCount, newItems);
      },
      spliceWithArray: function spliceWithArray(index, deleteCount, newItems) {
        return this[$mobx].spliceWithArray_(index, deleteCount, newItems);
      },
      push: function push() {
        var adm = this[$mobx];
        for (var _len2 = arguments.length, items = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          items[_key2] = arguments[_key2];
        }
        adm.spliceWithArray_(adm.values_.length, 0, items);
        return adm.values_.length;
      },
      pop: function pop() {
        return this.splice(Math.max(this[$mobx].values_.length - 1, 0), 1)[0];
      },
      shift: function shift() {
        return this.splice(0, 1)[0];
      },
      unshift: function unshift() {
        var adm = this[$mobx];
        for (var _len3 = arguments.length, items = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
          items[_key3] = arguments[_key3];
        }
        adm.spliceWithArray_(0, 0, items);
        return adm.values_.length;
      },
      reverse: function reverse() {
        if (globalState.trackingDerivation) {
          die(37, "reverse");
        }
        this.replace(this.slice().reverse());
        return this;
      },
      sort: function sort() {
        if (globalState.trackingDerivation) {
          die(37, "sort");
        }
        var copy = this.slice();
        copy.sort.apply(copy, arguments);
        this.replace(copy);
        return this;
      },
      remove: function remove2(value) {
        var adm = this[$mobx];
        var idx = adm.dehanceValues_(adm.values_).indexOf(value);
        if (idx > -1) {
          this.splice(idx, 1);
          return true;
        }
        return false;
      }
    };
    addArrayExtension("at", simpleFunc);
    addArrayExtension("concat", simpleFunc);
    addArrayExtension("flat", simpleFunc);
    addArrayExtension("includes", simpleFunc);
    addArrayExtension("indexOf", simpleFunc);
    addArrayExtension("join", simpleFunc);
    addArrayExtension("lastIndexOf", simpleFunc);
    addArrayExtension("slice", simpleFunc);
    addArrayExtension("toString", simpleFunc);
    addArrayExtension("toLocaleString", simpleFunc);
    addArrayExtension("toSorted", simpleFunc);
    addArrayExtension("toSpliced", simpleFunc);
    addArrayExtension("with", simpleFunc);
    addArrayExtension("every", mapLikeFunc);
    addArrayExtension("filter", mapLikeFunc);
    addArrayExtension("find", mapLikeFunc);
    addArrayExtension("findIndex", mapLikeFunc);
    addArrayExtension("findLast", mapLikeFunc);
    addArrayExtension("findLastIndex", mapLikeFunc);
    addArrayExtension("flatMap", mapLikeFunc);
    addArrayExtension("forEach", mapLikeFunc);
    addArrayExtension("map", mapLikeFunc);
    addArrayExtension("some", mapLikeFunc);
    addArrayExtension("toReversed", mapLikeFunc);
    addArrayExtension("reduce", reduceLikeFunc);
    addArrayExtension("reduceRight", reduceLikeFunc);
    isObservableArrayAdministration = createInstanceofPredicate("ObservableArrayAdministration", ObservableArrayAdministration);
    ObservableMapMarker = {};
    ADD = "add";
    DELETE = "delete";
    ObservableMap = function() {
      function ObservableMap2(initialData, enhancer_, name_) {
        var _this = this;
        if (enhancer_ === void 0) {
          enhancer_ = deepEnhancer;
        }
        if (name_ === void 0) {
          name_ = true ? "ObservableMap@" + getNextId() : "ObservableMap";
        }
        this.enhancer_ = void 0;
        this.name_ = void 0;
        this[$mobx] = ObservableMapMarker;
        this.data_ = void 0;
        this.hasMap_ = void 0;
        this.keysAtom_ = void 0;
        this.interceptors_ = void 0;
        this.changeListeners_ = void 0;
        this.dehancer = void 0;
        this.enhancer_ = enhancer_;
        this.name_ = name_;
        if (!isFunction(Map)) {
          die(18);
        }
        initObservable(function() {
          _this.keysAtom_ = createAtom(true ? _this.name_ + ".keys()" : "ObservableMap.keys()");
          _this.data_ = /* @__PURE__ */ new Map();
          _this.hasMap_ = /* @__PURE__ */ new Map();
          if (initialData) {
            _this.merge(initialData);
          }
        });
      }
      var _proto = ObservableMap2.prototype;
      _proto.has_ = function has_(key) {
        return this.data_.has(key);
      };
      _proto.has = function has3(key) {
        var _this2 = this;
        if (!globalState.trackingDerivation) {
          return this.has_(key);
        }
        var entry = this.hasMap_.get(key);
        if (!entry) {
          var newEntry = entry = new ObservableValue(this.has_(key), referenceEnhancer, true ? this.name_ + "." + stringifyKey(key) + "?" : "ObservableMap.key?", false);
          this.hasMap_.set(key, newEntry);
          onBecomeUnobserved(newEntry, function() {
            return _this2.hasMap_["delete"](key);
          });
        }
        return entry.get();
      };
      _proto.set = function set6(key, value) {
        var hasKey = this.has_(key);
        if (hasInterceptors(this)) {
          var change = interceptChange(this, {
            type: hasKey ? UPDATE : ADD,
            object: this,
            newValue: value,
            name: key
          });
          if (!change) {
            return this;
          }
          value = change.newValue;
        }
        if (hasKey) {
          this.updateValue_(key, value);
        } else {
          this.addValue_(key, value);
        }
        return this;
      };
      _proto["delete"] = function _delete(key) {
        var _this3 = this;
        checkIfStateModificationsAreAllowed(this.keysAtom_);
        if (hasInterceptors(this)) {
          var change = interceptChange(this, {
            type: DELETE,
            object: this,
            name: key
          });
          if (!change) {
            return false;
          }
        }
        if (this.has_(key)) {
          var notifySpy = isSpyEnabled();
          var notify = hasListeners(this);
          var _change = notify || notifySpy ? {
            observableKind: "map",
            debugObjectName: this.name_,
            type: DELETE,
            object: this,
            oldValue: this.data_.get(key).value_,
            name: key
          } : null;
          if (notifySpy) {
            spyReportStart(_change);
          }
          transaction(function() {
            var _this3$hasMap_$get;
            _this3.keysAtom_.reportChanged();
            (_this3$hasMap_$get = _this3.hasMap_.get(key)) == null || _this3$hasMap_$get.setNewValue_(false);
            var observable2 = _this3.data_.get(key);
            observable2.setNewValue_(void 0);
            _this3.data_["delete"](key);
          });
          if (notify) {
            notifyListeners(this, _change);
          }
          if (notifySpy) {
            spyReportEnd();
          }
          return true;
        }
        return false;
      };
      _proto.updateValue_ = function updateValue_(key, newValue) {
        var observable2 = this.data_.get(key);
        newValue = observable2.prepareNewValue_(newValue);
        if (newValue !== globalState.UNCHANGED) {
          var notifySpy = isSpyEnabled();
          var notify = hasListeners(this);
          var change = notify || notifySpy ? {
            observableKind: "map",
            debugObjectName: this.name_,
            type: UPDATE,
            object: this,
            oldValue: observable2.value_,
            name: key,
            newValue
          } : null;
          if (notifySpy) {
            spyReportStart(change);
          }
          observable2.setNewValue_(newValue);
          if (notify) {
            notifyListeners(this, change);
          }
          if (notifySpy) {
            spyReportEnd();
          }
        }
      };
      _proto.addValue_ = function addValue_(key, newValue) {
        var _this4 = this;
        checkIfStateModificationsAreAllowed(this.keysAtom_);
        transaction(function() {
          var _this4$hasMap_$get;
          var observable2 = new ObservableValue(newValue, _this4.enhancer_, true ? _this4.name_ + "." + stringifyKey(key) : "ObservableMap.key", false);
          _this4.data_.set(key, observable2);
          newValue = observable2.value_;
          (_this4$hasMap_$get = _this4.hasMap_.get(key)) == null || _this4$hasMap_$get.setNewValue_(true);
          _this4.keysAtom_.reportChanged();
        });
        var notifySpy = isSpyEnabled();
        var notify = hasListeners(this);
        var change = notify || notifySpy ? {
          observableKind: "map",
          debugObjectName: this.name_,
          type: ADD,
          object: this,
          name: key,
          newValue
        } : null;
        if (notifySpy) {
          spyReportStart(change);
        }
        if (notify) {
          notifyListeners(this, change);
        }
        if (notifySpy) {
          spyReportEnd();
        }
      };
      _proto.get = function get5(key) {
        if (this.has(key)) {
          return this.dehanceValue_(this.data_.get(key).get());
        }
        return this.dehanceValue_(void 0);
      };
      _proto.dehanceValue_ = function dehanceValue_(value) {
        if (this.dehancer !== void 0) {
          return this.dehancer(value);
        }
        return value;
      };
      _proto.keys = function keys3() {
        this.keysAtom_.reportObserved();
        return this.data_.keys();
      };
      _proto.values = function values2() {
        var self2 = this;
        var keys3 = this.keys();
        return makeIterableForMap({
          next: function next() {
            var _keys$next = keys3.next(), done = _keys$next.done, value = _keys$next.value;
            return {
              done,
              value: done ? void 0 : self2.get(value)
            };
          }
        });
      };
      _proto.entries = function entries2() {
        var self2 = this;
        var keys3 = this.keys();
        return makeIterableForMap({
          next: function next() {
            var _keys$next2 = keys3.next(), done = _keys$next2.done, value = _keys$next2.value;
            return {
              done,
              value: done ? void 0 : [value, self2.get(value)]
            };
          }
        });
      };
      _proto[Symbol.iterator] = function() {
        return this.entries();
      };
      _proto.forEach = function forEach(callback, thisArg) {
        for (var _iterator = _createForOfIteratorHelperLoose(this), _step; !(_step = _iterator()).done; ) {
          var _step$value = _step.value, key = _step$value[0], value = _step$value[1];
          callback.call(thisArg, value, key, this);
        }
      };
      _proto.merge = function merge(other) {
        var _this5 = this;
        if (isObservableMap(other)) {
          other = new Map(other);
        }
        transaction(function() {
          if (isPlainObject(other)) {
            getPlainObjectKeys(other).forEach(function(key) {
              return _this5.set(key, other[key]);
            });
          } else if (Array.isArray(other)) {
            other.forEach(function(_ref) {
              var key = _ref[0], value = _ref[1];
              return _this5.set(key, value);
            });
          } else if (isES6Map(other)) {
            if (!isPlainES6Map(other)) {
              die(19, other);
            }
            other.forEach(function(value, key) {
              return _this5.set(key, value);
            });
          } else if (other !== null && other !== void 0) {
            die(20, other);
          }
        });
        return this;
      };
      _proto.clear = function clear3() {
        var _this6 = this;
        transaction(function() {
          untracked(function() {
            for (var _iterator2 = _createForOfIteratorHelperLoose(_this6.keys()), _step2; !(_step2 = _iterator2()).done; ) {
              var key = _step2.value;
              _this6["delete"](key);
            }
          });
        });
      };
      _proto.replace = function replace2(values2) {
        var _this7 = this;
        transaction(function() {
          var replacementMap = convertToMap(values2);
          var orderedData = /* @__PURE__ */ new Map();
          var keysReportChangedCalled = false;
          for (var _iterator3 = _createForOfIteratorHelperLoose(_this7.data_.keys()), _step3; !(_step3 = _iterator3()).done; ) {
            var key = _step3.value;
            if (!replacementMap.has(key)) {
              var deleted = _this7["delete"](key);
              if (deleted) {
                keysReportChangedCalled = true;
              } else {
                var value = _this7.data_.get(key);
                orderedData.set(key, value);
              }
            }
          }
          for (var _iterator4 = _createForOfIteratorHelperLoose(replacementMap.entries()), _step4; !(_step4 = _iterator4()).done; ) {
            var _step4$value = _step4.value, _key = _step4$value[0], _value = _step4$value[1];
            var keyExisted = _this7.data_.has(_key);
            _this7.set(_key, _value);
            if (_this7.data_.has(_key)) {
              var _value2 = _this7.data_.get(_key);
              orderedData.set(_key, _value2);
              if (!keyExisted) {
                keysReportChangedCalled = true;
              }
            }
          }
          if (!keysReportChangedCalled) {
            if (_this7.data_.size !== orderedData.size) {
              _this7.keysAtom_.reportChanged();
            } else {
              var iter1 = _this7.data_.keys();
              var iter2 = orderedData.keys();
              var next1 = iter1.next();
              var next2 = iter2.next();
              while (!next1.done) {
                if (next1.value !== next2.value) {
                  _this7.keysAtom_.reportChanged();
                  break;
                }
                next1 = iter1.next();
                next2 = iter2.next();
              }
            }
          }
          _this7.data_ = orderedData;
        });
        return this;
      };
      _proto.toString = function toString3() {
        return "[object ObservableMap]";
      };
      _proto.toJSON = function toJSON2() {
        return Array.from(this);
      };
      _proto.observe_ = function observe_(listener, fireImmediately) {
        if (fireImmediately === true) {
          die("`observe` doesn't support fireImmediately=true in combination with maps.");
        }
        return registerListener(this, listener);
      };
      _proto.intercept_ = function intercept_(handler) {
        return registerInterceptor(this, handler);
      };
      return _createClass(ObservableMap2, [{
        key: "size",
        get: function get5() {
          this.keysAtom_.reportObserved();
          return this.data_.size;
        }
      }, {
        key: Symbol.toStringTag,
        get: function get5() {
          return "Map";
        }
      }]);
    }();
    isObservableMap = createInstanceofPredicate("ObservableMap", ObservableMap);
    ObservableSetMarker = {};
    ObservableSet = function() {
      function ObservableSet2(initialData, enhancer, name_) {
        var _this = this;
        if (enhancer === void 0) {
          enhancer = deepEnhancer;
        }
        if (name_ === void 0) {
          name_ = true ? "ObservableSet@" + getNextId() : "ObservableSet";
        }
        this.name_ = void 0;
        this[$mobx] = ObservableSetMarker;
        this.data_ = /* @__PURE__ */ new Set();
        this.atom_ = void 0;
        this.changeListeners_ = void 0;
        this.interceptors_ = void 0;
        this.dehancer = void 0;
        this.enhancer_ = void 0;
        this.name_ = name_;
        if (!isFunction(Set)) {
          die(22);
        }
        this.enhancer_ = function(newV, oldV) {
          return enhancer(newV, oldV, name_);
        };
        initObservable(function() {
          _this.atom_ = createAtom(_this.name_);
          if (initialData) {
            _this.replace(initialData);
          }
        });
      }
      var _proto = ObservableSet2.prototype;
      _proto.dehanceValue_ = function dehanceValue_(value) {
        if (this.dehancer !== void 0) {
          return this.dehancer(value);
        }
        return value;
      };
      _proto.clear = function clear3() {
        var _this2 = this;
        transaction(function() {
          untracked(function() {
            for (var _iterator = _createForOfIteratorHelperLoose(_this2.data_.values()), _step; !(_step = _iterator()).done; ) {
              var value = _step.value;
              _this2["delete"](value);
            }
          });
        });
      };
      _proto.forEach = function forEach(callbackFn, thisArg) {
        for (var _iterator2 = _createForOfIteratorHelperLoose(this), _step2; !(_step2 = _iterator2()).done; ) {
          var value = _step2.value;
          callbackFn.call(thisArg, value, value, this);
        }
      };
      _proto.add = function add(value) {
        var _this3 = this;
        checkIfStateModificationsAreAllowed(this.atom_);
        if (hasInterceptors(this)) {
          var change = interceptChange(this, {
            type: ADD,
            object: this,
            newValue: value
          });
          if (!change) {
            return this;
          }
          value = change.newValue;
        }
        if (!this.has(value)) {
          transaction(function() {
            _this3.data_.add(_this3.enhancer_(value, void 0));
            _this3.atom_.reportChanged();
          });
          var notifySpy = isSpyEnabled();
          var notify = hasListeners(this);
          var _change = notify || notifySpy ? {
            observableKind: "set",
            debugObjectName: this.name_,
            type: ADD,
            object: this,
            newValue: value
          } : null;
          if (notifySpy && true) {
            spyReportStart(_change);
          }
          if (notify) {
            notifyListeners(this, _change);
          }
          if (notifySpy && true) {
            spyReportEnd();
          }
        }
        return this;
      };
      _proto["delete"] = function _delete(value) {
        var _this4 = this;
        if (hasInterceptors(this)) {
          var change = interceptChange(this, {
            type: DELETE,
            object: this,
            oldValue: value
          });
          if (!change) {
            return false;
          }
        }
        if (this.has(value)) {
          var notifySpy = isSpyEnabled();
          var notify = hasListeners(this);
          var _change2 = notify || notifySpy ? {
            observableKind: "set",
            debugObjectName: this.name_,
            type: DELETE,
            object: this,
            oldValue: value
          } : null;
          if (notifySpy && true) {
            spyReportStart(_change2);
          }
          transaction(function() {
            _this4.atom_.reportChanged();
            _this4.data_["delete"](value);
          });
          if (notify) {
            notifyListeners(this, _change2);
          }
          if (notifySpy && true) {
            spyReportEnd();
          }
          return true;
        }
        return false;
      };
      _proto.has = function has3(value) {
        this.atom_.reportObserved();
        return this.data_.has(this.dehanceValue_(value));
      };
      _proto.entries = function entries2() {
        var values2 = this.values();
        return makeIterableForSet({
          next: function next() {
            var _values$next = values2.next(), value = _values$next.value, done = _values$next.done;
            return !done ? {
              value: [value, value],
              done
            } : {
              value: void 0,
              done
            };
          }
        });
      };
      _proto.keys = function keys3() {
        return this.values();
      };
      _proto.values = function values2() {
        this.atom_.reportObserved();
        var self2 = this;
        var values3 = this.data_.values();
        return makeIterableForSet({
          next: function next() {
            var _values$next2 = values3.next(), value = _values$next2.value, done = _values$next2.done;
            return !done ? {
              value: self2.dehanceValue_(value),
              done
            } : {
              value: void 0,
              done
            };
          }
        });
      };
      _proto.intersection = function intersection(otherSet) {
        if (isES6Set(otherSet) && !isObservableSet(otherSet)) {
          return otherSet.intersection(this);
        } else {
          var dehancedSet = new Set(this);
          return dehancedSet.intersection(otherSet);
        }
      };
      _proto.union = function union(otherSet) {
        if (isES6Set(otherSet) && !isObservableSet(otherSet)) {
          return otherSet.union(this);
        } else {
          var dehancedSet = new Set(this);
          return dehancedSet.union(otherSet);
        }
      };
      _proto.difference = function difference(otherSet) {
        return new Set(this).difference(otherSet);
      };
      _proto.symmetricDifference = function symmetricDifference(otherSet) {
        if (isES6Set(otherSet) && !isObservableSet(otherSet)) {
          return otherSet.symmetricDifference(this);
        } else {
          var dehancedSet = new Set(this);
          return dehancedSet.symmetricDifference(otherSet);
        }
      };
      _proto.isSubsetOf = function isSubsetOf(otherSet) {
        return new Set(this).isSubsetOf(otherSet);
      };
      _proto.isSupersetOf = function isSupersetOf(otherSet) {
        return new Set(this).isSupersetOf(otherSet);
      };
      _proto.isDisjointFrom = function isDisjointFrom(otherSet) {
        if (isES6Set(otherSet) && !isObservableSet(otherSet)) {
          return otherSet.isDisjointFrom(this);
        } else {
          var dehancedSet = new Set(this);
          return dehancedSet.isDisjointFrom(otherSet);
        }
      };
      _proto.replace = function replace2(other) {
        var _this5 = this;
        if (isObservableSet(other)) {
          other = new Set(other);
        }
        transaction(function() {
          if (Array.isArray(other)) {
            _this5.clear();
            other.forEach(function(value) {
              return _this5.add(value);
            });
          } else if (isES6Set(other)) {
            _this5.clear();
            other.forEach(function(value) {
              return _this5.add(value);
            });
          } else if (other !== null && other !== void 0) {
            die("Cannot initialize set from " + other);
          }
        });
        return this;
      };
      _proto.observe_ = function observe_(listener, fireImmediately) {
        if (fireImmediately === true) {
          die("`observe` doesn't support fireImmediately=true in combination with sets.");
        }
        return registerListener(this, listener);
      };
      _proto.intercept_ = function intercept_(handler) {
        return registerInterceptor(this, handler);
      };
      _proto.toJSON = function toJSON2() {
        return Array.from(this);
      };
      _proto.toString = function toString3() {
        return "[object ObservableSet]";
      };
      _proto[Symbol.iterator] = function() {
        return this.values();
      };
      return _createClass(ObservableSet2, [{
        key: "size",
        get: function get5() {
          this.atom_.reportObserved();
          return this.data_.size;
        }
      }, {
        key: Symbol.toStringTag,
        get: function get5() {
          return "Set";
        }
      }]);
    }();
    isObservableSet = createInstanceofPredicate("ObservableSet", ObservableSet);
    descriptorCache = /* @__PURE__ */ Object.create(null);
    REMOVE = "remove";
    ObservableObjectAdministration = function() {
      function ObservableObjectAdministration2(target_, values_, name_, defaultAnnotation_) {
        if (values_ === void 0) {
          values_ = /* @__PURE__ */ new Map();
        }
        if (defaultAnnotation_ === void 0) {
          defaultAnnotation_ = autoAnnotation;
        }
        this.target_ = void 0;
        this.values_ = void 0;
        this.name_ = void 0;
        this.defaultAnnotation_ = void 0;
        this.keysAtom_ = void 0;
        this.changeListeners_ = void 0;
        this.interceptors_ = void 0;
        this.proxy_ = void 0;
        this.isPlainObject_ = void 0;
        this.appliedAnnotations_ = void 0;
        this.pendingKeys_ = void 0;
        this.target_ = target_;
        this.values_ = values_;
        this.name_ = name_;
        this.defaultAnnotation_ = defaultAnnotation_;
        this.keysAtom_ = new Atom(true ? this.name_ + ".keys" : "ObservableObject.keys");
        this.isPlainObject_ = isPlainObject(this.target_);
        if (!isAnnotation(this.defaultAnnotation_)) {
          die("defaultAnnotation must be valid annotation");
        }
        if (true) {
          this.appliedAnnotations_ = {};
        }
      }
      var _proto = ObservableObjectAdministration2.prototype;
      _proto.getObservablePropValue_ = function getObservablePropValue_(key) {
        return this.values_.get(key).get();
      };
      _proto.setObservablePropValue_ = function setObservablePropValue_(key, newValue) {
        var observable2 = this.values_.get(key);
        if (observable2 instanceof ComputedValue) {
          observable2.set(newValue);
          return true;
        }
        if (hasInterceptors(this)) {
          var change = interceptChange(this, {
            type: UPDATE,
            object: this.proxy_ || this.target_,
            name: key,
            newValue
          });
          if (!change) {
            return null;
          }
          newValue = change.newValue;
        }
        newValue = observable2.prepareNewValue_(newValue);
        if (newValue !== globalState.UNCHANGED) {
          var notify = hasListeners(this);
          var notifySpy = isSpyEnabled();
          var _change = notify || notifySpy ? {
            type: UPDATE,
            observableKind: "object",
            debugObjectName: this.name_,
            object: this.proxy_ || this.target_,
            oldValue: observable2.value_,
            name: key,
            newValue
          } : null;
          if (notifySpy) {
            spyReportStart(_change);
          }
          observable2.setNewValue_(newValue);
          if (notify) {
            notifyListeners(this, _change);
          }
          if (notifySpy) {
            spyReportEnd();
          }
        }
        return true;
      };
      _proto.get_ = function get_(key) {
        if (globalState.trackingDerivation && !hasProp(this.target_, key)) {
          this.has_(key);
        }
        return this.target_[key];
      };
      _proto.set_ = function set_(key, value, proxyTrap) {
        if (proxyTrap === void 0) {
          proxyTrap = false;
        }
        if (hasProp(this.target_, key)) {
          if (this.values_.has(key)) {
            return this.setObservablePropValue_(key, value);
          } else if (proxyTrap) {
            return Reflect.set(this.target_, key, value);
          } else {
            this.target_[key] = value;
            return true;
          }
        } else {
          return this.extend_(key, {
            value,
            enumerable: true,
            writable: true,
            configurable: true
          }, this.defaultAnnotation_, proxyTrap);
        }
      };
      _proto.has_ = function has_(key) {
        if (!globalState.trackingDerivation) {
          return key in this.target_;
        }
        this.pendingKeys_ || (this.pendingKeys_ = /* @__PURE__ */ new Map());
        var entry = this.pendingKeys_.get(key);
        if (!entry) {
          entry = new ObservableValue(key in this.target_, referenceEnhancer, true ? this.name_ + "." + stringifyKey(key) + "?" : "ObservableObject.key?", false);
          this.pendingKeys_.set(key, entry);
        }
        return entry.get();
      };
      _proto.make_ = function make_2(key, annotation) {
        if (annotation === true) {
          annotation = this.defaultAnnotation_;
        }
        if (annotation === false) {
          return;
        }
        assertAnnotable(this, annotation, key);
        if (!(key in this.target_)) {
          var _this$target_$storedA;
          if ((_this$target_$storedA = this.target_[storedAnnotationsSymbol]) != null && _this$target_$storedA[key]) {
            return;
          } else {
            die(1, annotation.annotationType_, this.name_ + "." + key.toString());
          }
        }
        var source = this.target_;
        while (source && source !== objectPrototype) {
          var descriptor = getDescriptor(source, key);
          if (descriptor) {
            var outcome = annotation.make_(this, key, descriptor, source);
            if (outcome === 0) {
              return;
            }
            if (outcome === 1) {
              break;
            }
          }
          source = Object.getPrototypeOf(source);
        }
        recordAnnotationApplied(this, annotation, key);
      };
      _proto.extend_ = function extend_2(key, descriptor, annotation, proxyTrap) {
        if (proxyTrap === void 0) {
          proxyTrap = false;
        }
        if (annotation === true) {
          annotation = this.defaultAnnotation_;
        }
        if (annotation === false) {
          return this.defineProperty_(key, descriptor, proxyTrap);
        }
        assertAnnotable(this, annotation, key);
        var outcome = annotation.extend_(this, key, descriptor, proxyTrap);
        if (outcome) {
          recordAnnotationApplied(this, annotation, key);
        }
        return outcome;
      };
      _proto.defineProperty_ = function defineProperty_(key, descriptor, proxyTrap) {
        if (proxyTrap === void 0) {
          proxyTrap = false;
        }
        checkIfStateModificationsAreAllowed(this.keysAtom_);
        try {
          startBatch();
          var deleteOutcome = this.delete_(key);
          if (!deleteOutcome) {
            return deleteOutcome;
          }
          if (hasInterceptors(this)) {
            var change = interceptChange(this, {
              object: this.proxy_ || this.target_,
              name: key,
              type: ADD,
              newValue: descriptor.value
            });
            if (!change) {
              return null;
            }
            var newValue = change.newValue;
            if (descriptor.value !== newValue) {
              descriptor = _extends({}, descriptor, {
                value: newValue
              });
            }
          }
          if (proxyTrap) {
            if (!Reflect.defineProperty(this.target_, key, descriptor)) {
              return false;
            }
          } else {
            defineProperty(this.target_, key, descriptor);
          }
          this.notifyPropertyAddition_(key, descriptor.value);
        } finally {
          endBatch();
        }
        return true;
      };
      _proto.defineObservableProperty_ = function defineObservableProperty_(key, value, enhancer, proxyTrap) {
        if (proxyTrap === void 0) {
          proxyTrap = false;
        }
        checkIfStateModificationsAreAllowed(this.keysAtom_);
        try {
          startBatch();
          var deleteOutcome = this.delete_(key);
          if (!deleteOutcome) {
            return deleteOutcome;
          }
          if (hasInterceptors(this)) {
            var change = interceptChange(this, {
              object: this.proxy_ || this.target_,
              name: key,
              type: ADD,
              newValue: value
            });
            if (!change) {
              return null;
            }
            value = change.newValue;
          }
          var cachedDescriptor = getCachedObservablePropDescriptor(key);
          var descriptor = {
            configurable: globalState.safeDescriptors ? this.isPlainObject_ : true,
            enumerable: true,
            get: cachedDescriptor.get,
            set: cachedDescriptor.set
          };
          if (proxyTrap) {
            if (!Reflect.defineProperty(this.target_, key, descriptor)) {
              return false;
            }
          } else {
            defineProperty(this.target_, key, descriptor);
          }
          var observable2 = new ObservableValue(value, enhancer, true ? this.name_ + "." + key.toString() : "ObservableObject.key", false);
          this.values_.set(key, observable2);
          this.notifyPropertyAddition_(key, observable2.value_);
        } finally {
          endBatch();
        }
        return true;
      };
      _proto.defineComputedProperty_ = function defineComputedProperty_(key, options, proxyTrap) {
        if (proxyTrap === void 0) {
          proxyTrap = false;
        }
        checkIfStateModificationsAreAllowed(this.keysAtom_);
        try {
          startBatch();
          var deleteOutcome = this.delete_(key);
          if (!deleteOutcome) {
            return deleteOutcome;
          }
          if (hasInterceptors(this)) {
            var change = interceptChange(this, {
              object: this.proxy_ || this.target_,
              name: key,
              type: ADD,
              newValue: void 0
            });
            if (!change) {
              return null;
            }
          }
          options.name || (options.name = true ? this.name_ + "." + key.toString() : "ObservableObject.key");
          options.context = this.proxy_ || this.target_;
          var cachedDescriptor = getCachedObservablePropDescriptor(key);
          var descriptor = {
            configurable: globalState.safeDescriptors ? this.isPlainObject_ : true,
            enumerable: false,
            get: cachedDescriptor.get,
            set: cachedDescriptor.set
          };
          if (proxyTrap) {
            if (!Reflect.defineProperty(this.target_, key, descriptor)) {
              return false;
            }
          } else {
            defineProperty(this.target_, key, descriptor);
          }
          this.values_.set(key, new ComputedValue(options));
          this.notifyPropertyAddition_(key, void 0);
        } finally {
          endBatch();
        }
        return true;
      };
      _proto.delete_ = function delete_(key, proxyTrap) {
        if (proxyTrap === void 0) {
          proxyTrap = false;
        }
        checkIfStateModificationsAreAllowed(this.keysAtom_);
        if (!hasProp(this.target_, key)) {
          return true;
        }
        if (hasInterceptors(this)) {
          var change = interceptChange(this, {
            object: this.proxy_ || this.target_,
            name: key,
            type: REMOVE
          });
          if (!change) {
            return null;
          }
        }
        try {
          var _this$pendingKeys_;
          startBatch();
          var notify = hasListeners(this);
          var notifySpy = isSpyEnabled();
          var observable2 = this.values_.get(key);
          var value = void 0;
          if (!observable2 && (notify || notifySpy)) {
            var _getDescriptor2;
            value = (_getDescriptor2 = getDescriptor(this.target_, key)) == null ? void 0 : _getDescriptor2.value;
          }
          if (proxyTrap) {
            if (!Reflect.deleteProperty(this.target_, key)) {
              return false;
            }
          } else {
            delete this.target_[key];
          }
          if (true) {
            delete this.appliedAnnotations_[key];
          }
          if (observable2) {
            this.values_["delete"](key);
            if (observable2 instanceof ObservableValue) {
              value = observable2.value_;
            }
            propagateChanged(observable2);
          }
          this.keysAtom_.reportChanged();
          (_this$pendingKeys_ = this.pendingKeys_) == null || (_this$pendingKeys_ = _this$pendingKeys_.get(key)) == null || _this$pendingKeys_.set(key in this.target_);
          if (notify || notifySpy) {
            var _change2 = {
              type: REMOVE,
              observableKind: "object",
              object: this.proxy_ || this.target_,
              debugObjectName: this.name_,
              oldValue: value,
              name: key
            };
            if (notifySpy) {
              spyReportStart(_change2);
            }
            if (notify) {
              notifyListeners(this, _change2);
            }
            if (notifySpy) {
              spyReportEnd();
            }
          }
        } finally {
          endBatch();
        }
        return true;
      };
      _proto.observe_ = function observe_(callback, fireImmediately) {
        if (fireImmediately === true) {
          die("`observe` doesn't support the fire immediately property for observable objects.");
        }
        return registerListener(this, callback);
      };
      _proto.intercept_ = function intercept_(handler) {
        return registerInterceptor(this, handler);
      };
      _proto.notifyPropertyAddition_ = function notifyPropertyAddition_(key, value) {
        var _this$pendingKeys_2;
        var notify = hasListeners(this);
        var notifySpy = isSpyEnabled();
        if (notify || notifySpy) {
          var change = notify || notifySpy ? {
            type: ADD,
            observableKind: "object",
            debugObjectName: this.name_,
            object: this.proxy_ || this.target_,
            name: key,
            newValue: value
          } : null;
          if (notifySpy) {
            spyReportStart(change);
          }
          if (notify) {
            notifyListeners(this, change);
          }
          if (notifySpy) {
            spyReportEnd();
          }
        }
        (_this$pendingKeys_2 = this.pendingKeys_) == null || (_this$pendingKeys_2 = _this$pendingKeys_2.get(key)) == null || _this$pendingKeys_2.set(true);
        this.keysAtom_.reportChanged();
      };
      _proto.ownKeys_ = function ownKeys_() {
        this.keysAtom_.reportObserved();
        return ownKeys(this.target_);
      };
      _proto.keys_ = function keys_() {
        this.keysAtom_.reportObserved();
        return Object.keys(this.target_);
      };
      return ObservableObjectAdministration2;
    }();
    isObservableObjectAdministration = createInstanceofPredicate("ObservableObjectAdministration", ObservableObjectAdministration);
    ENTRY_0 = createArrayEntryDescriptor(0);
    safariPrototypeSetterInheritanceBug = function() {
      var v5 = false;
      var p4 = {};
      Object.defineProperty(p4, "0", {
        set: function set6() {
          v5 = true;
        }
      });
      Object.create(p4)["0"] = 1;
      return v5 === false;
    }();
    OBSERVABLE_ARRAY_BUFFER_SIZE = 0;
    StubArray = function StubArray2() {
    };
    inherit(StubArray, Array.prototype);
    LegacyObservableArray = function(_StubArray) {
      function LegacyObservableArray2(initialValues, enhancer, name, owned) {
        var _this;
        if (name === void 0) {
          name = true ? "ObservableArray@" + getNextId() : "ObservableArray";
        }
        if (owned === void 0) {
          owned = false;
        }
        _this = _StubArray.call(this) || this;
        initObservable(function() {
          var adm = new ObservableArrayAdministration(name, enhancer, owned, true);
          adm.proxy_ = _this;
          addHiddenFinalProp(_this, $mobx, adm);
          if (initialValues && initialValues.length) {
            _this.spliceWithArray(0, 0, initialValues);
          }
          if (safariPrototypeSetterInheritanceBug) {
            Object.defineProperty(_this, "0", ENTRY_0);
          }
        });
        return _this;
      }
      _inheritsLoose(LegacyObservableArray2, _StubArray);
      var _proto = LegacyObservableArray2.prototype;
      _proto.concat = function concat2() {
        this[$mobx].atom_.reportObserved();
        for (var _len = arguments.length, arrays = new Array(_len), _key = 0; _key < _len; _key++) {
          arrays[_key] = arguments[_key];
        }
        return Array.prototype.concat.apply(
          this.slice(),
          //@ts-ignore
          arrays.map(function(a3) {
            return isObservableArray(a3) ? a3.slice() : a3;
          })
        );
      };
      _proto[Symbol.iterator] = function() {
        var self2 = this;
        var nextIndex = 0;
        return makeIterable({
          next: function next() {
            return nextIndex < self2.length ? {
              value: self2[nextIndex++],
              done: false
            } : {
              done: true,
              value: void 0
            };
          }
        });
      };
      return _createClass(LegacyObservableArray2, [{
        key: "length",
        get: function get5() {
          return this[$mobx].getArrayLength_();
        },
        set: function set6(newLength) {
          this[$mobx].setArrayLength_(newLength);
        }
      }, {
        key: Symbol.toStringTag,
        get: function get5() {
          return "Array";
        }
      }]);
    }(StubArray);
    Object.entries(arrayExtensions).forEach(function(_ref) {
      var prop = _ref[0], fn2 = _ref[1];
      if (prop !== "concat") {
        addHiddenProp(LegacyObservableArray.prototype, prop, fn2);
      }
    });
    reserveArrayBuffer(1e3);
    toString2 = objectPrototype.toString;
    maybeIteratorPrototype = ((_getGlobal$Iterator = getGlobal().Iterator) == null ? void 0 : _getGlobal$Iterator.prototype) || {};
    ["Symbol", "Map", "Set"].forEach(function(m3) {
      var g3 = getGlobal();
      if (typeof g3[m3] === "undefined") {
        die("MobX requires global '" + m3 + "' to be available or polyfilled");
      }
    });
    if (typeof __MOBX_DEVTOOLS_GLOBAL_HOOK__ === "object") {
      __MOBX_DEVTOOLS_GLOBAL_HOOK__.injectMobx({
        spy,
        extras: {
          getDebugName
        },
        $mobx
      });
    }
  }
});

// ../../node_modules/.pnpm/@keplr-wallet+common@0.12.28/node_modules/@keplr-wallet/common/build/mobx/debounce.js
var require_debounce = __commonJS({
  "../../node_modules/.pnpm/@keplr-wallet+common@0.12.28/node_modules/@keplr-wallet/common/build/mobx/debounce.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DebounceActionTimer = void 0;
    var mobx_1 = (init_mobx_esm(), __toCommonJS(mobx_esm_exports));
    var DebounceActionTimer = class {
      constructor(debounceMs, handler) {
        this.debounceMs = debounceMs;
        this.handler = handler;
        this.requests = [];
        this.startTime = 0;
        this.tick = () => {
          let shouldExec = this.debounceMs <= 0;
          if (this.debounceMs > 0) {
            const now = Date.now();
            if (now - this.startTime >= this.debounceMs) {
              shouldExec = true;
            }
          }
          if (shouldExec) {
            const requests = this.requests.slice();
            const responses = this.handler(requests);
            if (typeof responses === "object" && "then" in responses) {
              Promise.resolve(responses).then((responses2) => {
                this.handleResponses(requests, responses2);
              });
            } else {
              this.handleResponses(requests, responses);
            }
            this.requests = [];
          } else {
            this.nextTick(this.tick);
          }
        };
        this.handleResponses = (requests, responses) => {
          (0, mobx_1.runInAction)(() => {
            for (let i4 = 0; i4 < requests.length; i4++) {
              const req = requests[i4];
              const res = responses[i4];
              req.action(res);
            }
          });
          for (const req of requests) {
            req.resolver();
          }
        };
      }
      call(args, action2) {
        return new Promise((resolve) => {
          const newStart = this.requests.length === 0;
          this.requests.push({ args, action: action2, resolver: resolve });
          if (newStart) {
            this.startTimer();
          }
        });
      }
      startTimer() {
        this.startTime = Date.now();
        this.nextTick(this.tick);
      }
      nextTick(fn2) {
        if (this.debounceMs <= 0) {
          Promise.resolve().then(fn2);
          return;
        }
        if (typeof window !== "undefined" && window.requestAnimationFrame) {
          window.requestAnimationFrame(fn2);
        } else {
          setTimeout(fn2, this.debounceMs);
        }
      }
    };
    exports.DebounceActionTimer = DebounceActionTimer;
  }
});

// ../../node_modules/.pnpm/@keplr-wallet+common@0.12.28/node_modules/@keplr-wallet/common/build/mobx/index.js
var require_mobx = __commonJS({
  "../../node_modules/.pnpm/@keplr-wallet+common@0.12.28/node_modules/@keplr-wallet/common/build/mobx/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o4, m3, k5, k22) {
      if (k22 === void 0)
        k22 = k5;
      var desc = Object.getOwnPropertyDescriptor(m3, k5);
      if (!desc || ("get" in desc ? !m3.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m3[k5];
        } };
      }
      Object.defineProperty(o4, k22, desc);
    } : function(o4, m3, k5, k22) {
      if (k22 === void 0)
        k22 = k5;
      o4[k22] = m3[k5];
    });
    var __exportStar = exports && exports.__exportStar || function(m3, exports2) {
      for (var p4 in m3)
        if (p4 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p4))
          __createBinding(exports2, m3, p4);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_etc2(), exports);
    __exportStar(require_debounce(), exports);
  }
});

// ../../node_modules/.pnpm/@keplr-wallet+common@0.12.28/node_modules/@keplr-wallet/common/build/utils/debouncer.js
var require_debouncer = __commonJS({
  "../../node_modules/.pnpm/@keplr-wallet+common@0.12.28/node_modules/@keplr-wallet/common/build/utils/debouncer.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P3, generator) {
      function adopt(value) {
        return value instanceof P3 ? value : new P3(function(resolve) {
          resolve(value);
        });
      }
      return new (P3 || (P3 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e2) {
            reject(e2);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e2) {
            reject(e2);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Debouncer = void 0;
    var Debouncer = class {
      static promise(fn2) {
        let currentPromise;
        return (...arguments_) => __awaiter(this, void 0, void 0, function* () {
          if (currentPromise) {
            return currentPromise;
          }
          try {
            currentPromise = fn2.apply(this, arguments_);
            return yield currentPromise;
          } finally {
            currentPromise = void 0;
          }
        });
      }
    };
    exports.Debouncer = Debouncer;
  }
});

// ../../node_modules/.pnpm/@keplr-wallet+common@0.12.28/node_modules/@keplr-wallet/common/build/utils/index.js
var require_utils3 = __commonJS({
  "../../node_modules/.pnpm/@keplr-wallet+common@0.12.28/node_modules/@keplr-wallet/common/build/utils/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o4, m3, k5, k22) {
      if (k22 === void 0)
        k22 = k5;
      var desc = Object.getOwnPropertyDescriptor(m3, k5);
      if (!desc || ("get" in desc ? !m3.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m3[k5];
        } };
      }
      Object.defineProperty(o4, k22, desc);
    } : function(o4, m3, k5, k22) {
      if (k22 === void 0)
        k22 = k5;
      o4[k22] = m3[k5];
    });
    var __exportStar = exports && exports.__exportStar || function(m3, exports2) {
      for (var p4 in m3)
        if (p4 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p4))
          __createBinding(exports2, m3, p4);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_debouncer(), exports);
  }
});

// ../../node_modules/.pnpm/@keplr-wallet+common@0.12.28/node_modules/@keplr-wallet/common/build/escape/index.js
var require_escape = __commonJS({
  "../../node_modules/.pnpm/@keplr-wallet+common@0.12.28/node_modules/@keplr-wallet/common/build/escape/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.unescapeHTML = exports.escapeHTML = void 0;
    function escapeHTML(str) {
      return str.replace(/</g, "\\u003c").replace(/>/g, "\\u003e").replace(/&/g, "\\u0026");
    }
    exports.escapeHTML = escapeHTML;
    function unescapeHTML(str) {
      return str.replace(/\\u003c/g, "<").replace(/\\u003e/g, ">").replace(/\\u0026/g, "&");
    }
    exports.unescapeHTML = unescapeHTML;
  }
});

// ../../node_modules/.pnpm/@keplr-wallet+common@0.12.28/node_modules/@keplr-wallet/common/build/json/sort.js
var require_sort = __commonJS({
  "../../node_modules/.pnpm/@keplr-wallet+common@0.12.28/node_modules/@keplr-wallet/common/build/json/sort.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.sortedJsonByKeyStringify = exports.sortObjectByKey = void 0;
    function sortObjectByKey(obj) {
      if (typeof obj !== "object" || obj === null) {
        return obj;
      }
      if (Array.isArray(obj)) {
        return obj.map(sortObjectByKey);
      }
      const sortedKeys = Object.keys(obj).sort();
      const result = {};
      sortedKeys.forEach((key) => {
        result[key] = sortObjectByKey(obj[key]);
      });
      return result;
    }
    exports.sortObjectByKey = sortObjectByKey;
    function sortedJsonByKeyStringify(obj) {
      return JSON.stringify(sortObjectByKey(obj));
    }
    exports.sortedJsonByKeyStringify = sortedJsonByKeyStringify;
  }
});

// ../../node_modules/.pnpm/@keplr-wallet+common@0.12.28/node_modules/@keplr-wallet/common/build/json/index.js
var require_json = __commonJS({
  "../../node_modules/.pnpm/@keplr-wallet+common@0.12.28/node_modules/@keplr-wallet/common/build/json/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o4, m3, k5, k22) {
      if (k22 === void 0)
        k22 = k5;
      var desc = Object.getOwnPropertyDescriptor(m3, k5);
      if (!desc || ("get" in desc ? !m3.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m3[k5];
        } };
      }
      Object.defineProperty(o4, k22, desc);
    } : function(o4, m3, k5, k22) {
      if (k22 === void 0)
        k22 = k5;
      o4[k22] = m3[k5];
    });
    var __exportStar = exports && exports.__exportStar || function(m3, exports2) {
      for (var p4 in m3)
        if (p4 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p4))
          __createBinding(exports2, m3, p4);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_sort(), exports);
  }
});

// ../../node_modules/.pnpm/@keplr-wallet+common@0.12.28/node_modules/@keplr-wallet/common/build/icns/index.js
var require_icns = __commonJS({
  "../../node_modules/.pnpm/@keplr-wallet+common@0.12.28/node_modules/@keplr-wallet/common/build/icns/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateICNSName = exports.parseICNSName = void 0;
    function parseICNSName(name) {
      const split = name.split(".");
      if (split.length === 2) {
        if (split[0].length > 0 && split[1].length > 0) {
          return [split[0], split[1]];
        }
      }
      return void 0;
    }
    exports.parseICNSName = parseICNSName;
    function validateICNSName(name, bech32Prefix) {
      const parsed = parseICNSName(name);
      if (!parsed) {
        return false;
      }
      return parsed[1] === bech32Prefix;
    }
    exports.validateICNSName = validateICNSName;
  }
});

// ../../node_modules/.pnpm/@keplr-wallet+common@0.12.28/node_modules/@keplr-wallet/common/build/index.js
var require_build6 = __commonJS({
  "../../node_modules/.pnpm/@keplr-wallet+common@0.12.28/node_modules/@keplr-wallet/common/build/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o4, m3, k5, k22) {
      if (k22 === void 0)
        k22 = k5;
      var desc = Object.getOwnPropertyDescriptor(m3, k5);
      if (!desc || ("get" in desc ? !m3.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m3[k5];
        } };
      }
      Object.defineProperty(o4, k22, desc);
    } : function(o4, m3, k5, k22) {
      if (k22 === void 0)
        k22 = k5;
      o4[k22] = m3[k5];
    });
    var __exportStar = exports && exports.__exportStar || function(m3, exports2) {
      for (var p4 in m3)
        if (p4 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p4))
          __createBinding(exports2, m3, p4);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_kv_store(), exports);
    __exportStar(require_denom(), exports);
    __exportStar(require_mobx(), exports);
    __exportStar(require_utils3(), exports);
    __exportStar(require_escape(), exports);
    __exportStar(require_json(), exports);
    __exportStar(require_icns(), exports);
  }
});

// ../../node_modules/.pnpm/@keplr-wallet+cosmos@0.12.28/node_modules/@keplr-wallet/cosmos/build/signing/encode.js
var require_encode = __commonJS({
  "../../node_modules/.pnpm/@keplr-wallet+cosmos@0.12.28/node_modules/@keplr-wallet/cosmos/build/signing/encode.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.serializeSignDoc = exports.encodeSecp256k1Signature = exports.encodeSecp256k1Pubkey = void 0;
    var buffer_1 = require_buffer();
    var common_1 = require_build6();
    function encodeSecp256k1Pubkey(pubkey) {
      if (pubkey.length !== 33 || pubkey[0] !== 2 && pubkey[0] !== 3) {
        throw new Error("Public key must be compressed secp256k1, i.e. 33 bytes starting with 0x02 or 0x03");
      }
      return {
        type: "tendermint/PubKeySecp256k1",
        value: buffer_1.Buffer.from(pubkey).toString("base64")
      };
    }
    exports.encodeSecp256k1Pubkey = encodeSecp256k1Pubkey;
    function encodeSecp256k1Signature(pubkey, signature) {
      if (signature.length !== 64) {
        throw new Error("Signature must be 64 bytes long. Cosmos SDK uses a 2x32 byte fixed length encoding for the secp256k1 signature integers r and s.");
      }
      return {
        pub_key: encodeSecp256k1Pubkey(pubkey),
        signature: buffer_1.Buffer.from(signature).toString("base64")
      };
    }
    exports.encodeSecp256k1Signature = encodeSecp256k1Signature;
    function serializeSignDoc(signDoc) {
      return buffer_1.Buffer.from((0, common_1.escapeHTML)((0, common_1.sortedJsonByKeyStringify)(signDoc)));
    }
    exports.serializeSignDoc = serializeSignDoc;
  }
});

// ../../node_modules/.pnpm/@keplr-wallet+cosmos@0.12.28/node_modules/@keplr-wallet/cosmos/build/signing/index.js
var require_signing2 = __commonJS({
  "../../node_modules/.pnpm/@keplr-wallet+cosmos@0.12.28/node_modules/@keplr-wallet/cosmos/build/signing/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o4, m3, k5, k22) {
      if (k22 === void 0)
        k22 = k5;
      var desc = Object.getOwnPropertyDescriptor(m3, k5);
      if (!desc || ("get" in desc ? !m3.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m3[k5];
        } };
      }
      Object.defineProperty(o4, k22, desc);
    } : function(o4, m3, k5, k22) {
      if (k22 === void 0)
        k22 = k5;
      o4[k22] = m3[k5];
    });
    var __exportStar = exports && exports.__exportStar || function(m3, exports2) {
      for (var p4 in m3)
        if (p4 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p4))
          __createBinding(exports2, m3, p4);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_encode(), exports);
  }
});

// ../../node_modules/.pnpm/@keplr-wallet+cosmos@0.12.28/node_modules/@keplr-wallet/cosmos/build/adr-36/amino.js
var require_amino = __commonJS({
  "../../node_modules/.pnpm/@keplr-wallet+cosmos@0.12.28/node_modules/@keplr-wallet/cosmos/build/adr-36/amino.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.verifyADR36Amino = exports.verifyADR36AminoSignDoc = exports.makeADR36AminoSignDoc = exports.checkAndValidateADR36AminoSignDoc = void 0;
    var signing_1 = require_signing2();
    var bech32_1 = require_bech323();
    var buffer_1 = require_buffer();
    var crypto_1 = require_build5();
    function checkAndValidateADR36AminoSignDoc(signDoc, bech32PrefixAccAddr) {
      const hasOnlyMsgSignData = (() => {
        if (signDoc && signDoc.msgs && Array.isArray(signDoc.msgs) && signDoc.msgs.length === 1) {
          const msg2 = signDoc.msgs[0];
          return msg2.type === "sign/MsgSignData";
        } else {
          return false;
        }
      })();
      if (!hasOnlyMsgSignData) {
        return false;
      }
      if (signDoc.chain_id !== "") {
        throw new Error("Chain id should be empty string for ADR-36 signing");
      }
      if (signDoc.memo !== "") {
        throw new Error("Memo should be empty string for ADR-36 signing");
      }
      if (signDoc.account_number !== "0") {
        throw new Error('Account number should be "0" for ADR-36 signing');
      }
      if (signDoc.sequence !== "0") {
        throw new Error('Sequence should be "0" for ADR-36 signing');
      }
      if (signDoc.fee.gas !== "0") {
        throw new Error('Gas should be "0" for ADR-36 signing');
      }
      if (signDoc.fee.amount.length !== 0) {
        throw new Error("Fee amount should be empty array for ADR-36 signing");
      }
      const msg = signDoc.msgs[0];
      if (msg.type !== "sign/MsgSignData") {
        throw new Error(`Invalid type of ADR-36 sign msg: ${msg.type}`);
      }
      if (!msg.value) {
        throw new Error("Empty value in the msg");
      }
      const signer = msg.value.signer;
      if (!signer) {
        throw new Error("Empty signer in the ADR-36 msg");
      }
      bech32_1.Bech32Address.validate(signer, bech32PrefixAccAddr);
      const data = msg.value.data;
      if (!data) {
        throw new Error("Empty data in the ADR-36 msg");
      }
      const rawData = buffer_1.Buffer.from(data, "base64");
      if (rawData.toString("base64") !== data) {
        throw new Error("Data is not encoded by base64");
      }
      if (rawData.length === 0) {
        throw new Error("Empty data in the ADR-36 msg");
      }
      return true;
    }
    exports.checkAndValidateADR36AminoSignDoc = checkAndValidateADR36AminoSignDoc;
    function makeADR36AminoSignDoc(signer, data) {
      if (typeof data === "string") {
        data = buffer_1.Buffer.from(data).toString("base64");
      } else {
        data = buffer_1.Buffer.from(data).toString("base64");
      }
      return {
        chain_id: "",
        account_number: "0",
        sequence: "0",
        fee: {
          gas: "0",
          amount: []
        },
        msgs: [
          {
            type: "sign/MsgSignData",
            value: {
              signer,
              data
            }
          }
        ],
        memo: ""
      };
    }
    exports.makeADR36AminoSignDoc = makeADR36AminoSignDoc;
    function verifyADR36AminoSignDoc(bech32PrefixAccAddr, signDoc, pubKey, signature, algo = "secp256k1") {
      if (!checkAndValidateADR36AminoSignDoc(signDoc, bech32PrefixAccAddr)) {
        throw new Error("Invalid sign doc for ADR-36");
      }
      const cryptoPubKey = new crypto_1.PubKeySecp256k1(pubKey);
      const expectedSigner = (() => {
        if (algo === "ethsecp256k1") {
          return new bech32_1.Bech32Address(cryptoPubKey.getEthAddress()).toBech32(bech32PrefixAccAddr);
        }
        return new bech32_1.Bech32Address(cryptoPubKey.getCosmosAddress()).toBech32(bech32PrefixAccAddr);
      })();
      const signer = signDoc.msgs[0].value.signer;
      if (expectedSigner !== signer) {
        throw new Error("Unmatched signer");
      }
      const msg = (0, signing_1.serializeSignDoc)(signDoc);
      return cryptoPubKey.verifyDigest32((() => {
        if (algo === "ethsecp256k1") {
          return crypto_1.Hash.keccak256(msg);
        }
        return crypto_1.Hash.sha256(msg);
      })(), signature);
    }
    exports.verifyADR36AminoSignDoc = verifyADR36AminoSignDoc;
    function verifyADR36Amino(bech32PrefixAccAddr, signer, data, pubKey, signature, algo = "secp256k1") {
      const signDoc = makeADR36AminoSignDoc(signer, data);
      return verifyADR36AminoSignDoc(bech32PrefixAccAddr, signDoc, pubKey, signature, algo);
    }
    exports.verifyADR36Amino = verifyADR36Amino;
  }
});

// ../../node_modules/.pnpm/@keplr-wallet+cosmos@0.12.28/node_modules/@keplr-wallet/cosmos/build/adr-36/index.js
var require_adr_36 = __commonJS({
  "../../node_modules/.pnpm/@keplr-wallet+cosmos@0.12.28/node_modules/@keplr-wallet/cosmos/build/adr-36/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o4, m3, k5, k22) {
      if (k22 === void 0)
        k22 = k5;
      var desc = Object.getOwnPropertyDescriptor(m3, k5);
      if (!desc || ("get" in desc ? !m3.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m3[k5];
        } };
      }
      Object.defineProperty(o4, k22, desc);
    } : function(o4, m3, k5, k22) {
      if (k22 === void 0)
        k22 = k5;
      o4[k22] = m3[k5];
    });
    var __exportStar = exports && exports.__exportStar || function(m3, exports2) {
      for (var p4 in m3)
        if (p4 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p4))
          __createBinding(exports2, m3, p4);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_amino(), exports);
  }
});

// ../../node_modules/.pnpm/@keplr-wallet+cosmos@0.12.28/node_modules/@keplr-wallet/cosmos/build/stargate/wrapper/index.js
var require_wrapper = __commonJS({
  "../../node_modules/.pnpm/@keplr-wallet+cosmos@0.12.28/node_modules/@keplr-wallet/cosmos/build/stargate/wrapper/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SignDocWrapper = void 0;
    var decoder_1 = require_decoder();
    var tx_1 = require_tx8();
    var adr_36_1 = require_adr_36();
    var SignDocWrapper = class _SignDocWrapper {
      constructor(signDoc) {
        this.signDoc = signDoc;
        if ("msgs" in signDoc) {
          this.mode = "amino";
        } else {
          this.mode = "direct";
        }
        if (this.mode === "amino") {
          this.isADR36SignDoc = (0, adr_36_1.checkAndValidateADR36AminoSignDoc)(this.aminoSignDoc);
        } else {
          this.isADR36SignDoc = false;
        }
      }
      static fromAminoSignDoc(signDoc) {
        return new _SignDocWrapper(signDoc);
      }
      static fromDirectSignDoc(signDoc) {
        return new _SignDocWrapper(signDoc);
      }
      static fromDirectSignDocBytes(signDocBytes) {
        return new _SignDocWrapper(tx_1.SignDoc.decode(signDocBytes));
      }
      clone() {
        return new _SignDocWrapper(this.signDoc);
      }
      get protoSignDoc() {
        if (this.mode === "amino") {
          throw new Error("Sign doc is encoded as Amino Json");
        }
        if ("msgs" in this.signDoc) {
          throw new Error("Unexpected error");
        }
        if (!this._protoSignDoc) {
          this._protoSignDoc = new decoder_1.ProtoSignDocDecoder(this.signDoc);
        }
        return this._protoSignDoc;
      }
      get aminoSignDoc() {
        if (this.mode === "direct") {
          throw new Error("Sign doc is encoded as Protobuf");
        }
        if (!("msgs" in this.signDoc)) {
          throw new Error("Unexpected error");
        }
        return this.signDoc;
      }
      get chainId() {
        if (this.mode === "direct") {
          return this.protoSignDoc.chainId;
        }
        return this.aminoSignDoc.chain_id;
      }
      get memo() {
        if (this.mode === "direct") {
          return this.protoSignDoc.txBody.memo;
        }
        return this.aminoSignDoc.memo;
      }
      get fees() {
        var _a2, _b;
        if (this.mode === "direct") {
          const fees = [];
          for (const coinObj of (_b = (_a2 = this.protoSignDoc.authInfo.fee) === null || _a2 === void 0 ? void 0 : _a2.amount) !== null && _b !== void 0 ? _b : []) {
            if (coinObj.denom == null || coinObj.amount == null) {
              throw new Error("Invalid fee");
            }
            fees.push({
              denom: coinObj.denom,
              amount: coinObj.amount
            });
          }
          return fees;
        }
        return this.aminoSignDoc.fee.amount;
      }
      get payer() {
        var _a2;
        if (this.mode === "direct") {
          return (_a2 = this.protoSignDoc.authInfo.fee) === null || _a2 === void 0 ? void 0 : _a2.payer;
        }
        return this.aminoSignDoc.fee.payer;
      }
      get granter() {
        var _a2;
        if (this.mode === "direct") {
          return (_a2 = this.protoSignDoc.authInfo.fee) === null || _a2 === void 0 ? void 0 : _a2.granter;
        }
        return this.aminoSignDoc.fee.granter;
      }
      get gas() {
        var _a2;
        if (this.mode === "direct") {
          if ((_a2 = this.protoSignDoc.authInfo.fee) === null || _a2 === void 0 ? void 0 : _a2.gasLimit) {
            return parseInt(this.protoSignDoc.authInfo.fee.gasLimit);
          } else {
            return 0;
          }
        }
        return parseInt(this.aminoSignDoc.fee.gas);
      }
    };
    exports.SignDocWrapper = SignDocWrapper;
  }
});

// ../../node_modules/.pnpm/@keplr-wallet+cosmos@0.12.28/node_modules/@keplr-wallet/cosmos/build/stargate/index.js
var require_stargate = __commonJS({
  "../../node_modules/.pnpm/@keplr-wallet+cosmos@0.12.28/node_modules/@keplr-wallet/cosmos/build/stargate/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o4, m3, k5, k22) {
      if (k22 === void 0)
        k22 = k5;
      var desc = Object.getOwnPropertyDescriptor(m3, k5);
      if (!desc || ("get" in desc ? !m3.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m3[k5];
        } };
      }
      Object.defineProperty(o4, k22, desc);
    } : function(o4, m3, k5, k22) {
      if (k22 === void 0)
        k22 = k5;
      o4[k22] = m3[k5];
    });
    var __exportStar = exports && exports.__exportStar || function(m3, exports2) {
      for (var p4 in m3)
        if (p4 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p4))
          __createBinding(exports2, m3, p4);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_codec(), exports);
    __exportStar(require_decoder(), exports);
    __exportStar(require_wrapper(), exports);
  }
});

// ../../node_modules/.pnpm/@keplr-wallet+cosmos@0.12.28/node_modules/@keplr-wallet/cosmos/build/index.js
var require_build7 = __commonJS({
  "../../node_modules/.pnpm/@keplr-wallet+cosmos@0.12.28/node_modules/@keplr-wallet/cosmos/build/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o4, m3, k5, k22) {
      if (k22 === void 0)
        k22 = k5;
      var desc = Object.getOwnPropertyDescriptor(m3, k5);
      if (!desc || ("get" in desc ? !m3.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m3[k5];
        } };
      }
      Object.defineProperty(o4, k22, desc);
    } : function(o4, m3, k5, k22) {
      if (k22 === void 0)
        k22 = k5;
      o4[k22] = m3[k5];
    });
    var __exportStar = exports && exports.__exportStar || function(m3, exports2) {
      for (var p4 in m3)
        if (p4 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p4))
          __createBinding(exports2, m3, p4);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_account(), exports);
    __exportStar(require_bech323(), exports);
    __exportStar(require_chain_id(), exports);
    __exportStar(require_tx_tracer(), exports);
    __exportStar(require_stargate(), exports);
    __exportStar(require_adr_36(), exports);
    __exportStar(require_signing2(), exports);
  }
});

// ../../node_modules/.pnpm/semver@7.7.2/node_modules/semver/internal/constants.js
var require_constants2 = __commonJS({
  "../../node_modules/.pnpm/semver@7.7.2/node_modules/semver/internal/constants.js"(exports, module) {
    "use strict";
    var SEMVER_SPEC_VERSION = "2.0.0";
    var MAX_LENGTH = 256;
    var MAX_SAFE_INTEGER2 = Number.MAX_SAFE_INTEGER || /* istanbul ignore next */
    9007199254740991;
    var MAX_SAFE_COMPONENT_LENGTH = 16;
    var MAX_SAFE_BUILD_LENGTH = MAX_LENGTH - 6;
    var RELEASE_TYPES = [
      "major",
      "premajor",
      "minor",
      "preminor",
      "patch",
      "prepatch",
      "prerelease"
    ];
    module.exports = {
      MAX_LENGTH,
      MAX_SAFE_COMPONENT_LENGTH,
      MAX_SAFE_BUILD_LENGTH,
      MAX_SAFE_INTEGER: MAX_SAFE_INTEGER2,
      RELEASE_TYPES,
      SEMVER_SPEC_VERSION,
      FLAG_INCLUDE_PRERELEASE: 1,
      FLAG_LOOSE: 2
    };
  }
});

// ../../node_modules/.pnpm/semver@7.7.2/node_modules/semver/internal/debug.js
var require_debug = __commonJS({
  "../../node_modules/.pnpm/semver@7.7.2/node_modules/semver/internal/debug.js"(exports, module) {
    "use strict";
    var debug = typeof process === "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? (...args) => console.error("SEMVER", ...args) : () => {
    };
    module.exports = debug;
  }
});

// ../../node_modules/.pnpm/semver@7.7.2/node_modules/semver/internal/re.js
var require_re = __commonJS({
  "../../node_modules/.pnpm/semver@7.7.2/node_modules/semver/internal/re.js"(exports, module) {
    "use strict";
    var {
      MAX_SAFE_COMPONENT_LENGTH,
      MAX_SAFE_BUILD_LENGTH,
      MAX_LENGTH
    } = require_constants2();
    var debug = require_debug();
    exports = module.exports = {};
    var re2 = exports.re = [];
    var safeRe = exports.safeRe = [];
    var src = exports.src = [];
    var safeSrc = exports.safeSrc = [];
    var t = exports.t = {};
    var R3 = 0;
    var LETTERDASHNUMBER = "[a-zA-Z0-9-]";
    var safeRegexReplacements = [
      ["\\s", 1],
      ["\\d", MAX_LENGTH],
      [LETTERDASHNUMBER, MAX_SAFE_BUILD_LENGTH]
    ];
    var makeSafeRegex = (value) => {
      for (const [token, max] of safeRegexReplacements) {
        value = value.split(`${token}*`).join(`${token}{0,${max}}`).split(`${token}+`).join(`${token}{1,${max}}`);
      }
      return value;
    };
    var createToken = (name, value, isGlobal) => {
      const safe = makeSafeRegex(value);
      const index = R3++;
      debug(name, index, value);
      t[name] = index;
      src[index] = value;
      safeSrc[index] = safe;
      re2[index] = new RegExp(value, isGlobal ? "g" : void 0);
      safeRe[index] = new RegExp(safe, isGlobal ? "g" : void 0);
    };
    createToken("NUMERICIDENTIFIER", "0|[1-9]\\d*");
    createToken("NUMERICIDENTIFIERLOOSE", "\\d+");
    createToken("NONNUMERICIDENTIFIER", `\\d*[a-zA-Z-]${LETTERDASHNUMBER}*`);
    createToken("MAINVERSION", `(${src[t.NUMERICIDENTIFIER]})\\.(${src[t.NUMERICIDENTIFIER]})\\.(${src[t.NUMERICIDENTIFIER]})`);
    createToken("MAINVERSIONLOOSE", `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.(${src[t.NUMERICIDENTIFIERLOOSE]})\\.(${src[t.NUMERICIDENTIFIERLOOSE]})`);
    createToken("PRERELEASEIDENTIFIER", `(?:${src[t.NONNUMERICIDENTIFIER]}|${src[t.NUMERICIDENTIFIER]})`);
    createToken("PRERELEASEIDENTIFIERLOOSE", `(?:${src[t.NONNUMERICIDENTIFIER]}|${src[t.NUMERICIDENTIFIERLOOSE]})`);
    createToken("PRERELEASE", `(?:-(${src[t.PRERELEASEIDENTIFIER]}(?:\\.${src[t.PRERELEASEIDENTIFIER]})*))`);
    createToken("PRERELEASELOOSE", `(?:-?(${src[t.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${src[t.PRERELEASEIDENTIFIERLOOSE]})*))`);
    createToken("BUILDIDENTIFIER", `${LETTERDASHNUMBER}+`);
    createToken("BUILD", `(?:\\+(${src[t.BUILDIDENTIFIER]}(?:\\.${src[t.BUILDIDENTIFIER]})*))`);
    createToken("FULLPLAIN", `v?${src[t.MAINVERSION]}${src[t.PRERELEASE]}?${src[t.BUILD]}?`);
    createToken("FULL", `^${src[t.FULLPLAIN]}$`);
    createToken("LOOSEPLAIN", `[v=\\s]*${src[t.MAINVERSIONLOOSE]}${src[t.PRERELEASELOOSE]}?${src[t.BUILD]}?`);
    createToken("LOOSE", `^${src[t.LOOSEPLAIN]}$`);
    createToken("GTLT", "((?:<|>)?=?)");
    createToken("XRANGEIDENTIFIERLOOSE", `${src[t.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`);
    createToken("XRANGEIDENTIFIER", `${src[t.NUMERICIDENTIFIER]}|x|X|\\*`);
    createToken("XRANGEPLAIN", `[v=\\s]*(${src[t.XRANGEIDENTIFIER]})(?:\\.(${src[t.XRANGEIDENTIFIER]})(?:\\.(${src[t.XRANGEIDENTIFIER]})(?:${src[t.PRERELEASE]})?${src[t.BUILD]}?)?)?`);
    createToken("XRANGEPLAINLOOSE", `[v=\\s]*(${src[t.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})(?:${src[t.PRERELEASELOOSE]})?${src[t.BUILD]}?)?)?`);
    createToken("XRANGE", `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAIN]}$`);
    createToken("XRANGELOOSE", `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAINLOOSE]}$`);
    createToken("COERCEPLAIN", `${"(^|[^\\d])(\\d{1,"}${MAX_SAFE_COMPONENT_LENGTH}})(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?`);
    createToken("COERCE", `${src[t.COERCEPLAIN]}(?:$|[^\\d])`);
    createToken("COERCEFULL", src[t.COERCEPLAIN] + `(?:${src[t.PRERELEASE]})?(?:${src[t.BUILD]})?(?:$|[^\\d])`);
    createToken("COERCERTL", src[t.COERCE], true);
    createToken("COERCERTLFULL", src[t.COERCEFULL], true);
    createToken("LONETILDE", "(?:~>?)");
    createToken("TILDETRIM", `(\\s*)${src[t.LONETILDE]}\\s+`, true);
    exports.tildeTrimReplace = "$1~";
    createToken("TILDE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAIN]}$`);
    createToken("TILDELOOSE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAINLOOSE]}$`);
    createToken("LONECARET", "(?:\\^)");
    createToken("CARETTRIM", `(\\s*)${src[t.LONECARET]}\\s+`, true);
    exports.caretTrimReplace = "$1^";
    createToken("CARET", `^${src[t.LONECARET]}${src[t.XRANGEPLAIN]}$`);
    createToken("CARETLOOSE", `^${src[t.LONECARET]}${src[t.XRANGEPLAINLOOSE]}$`);
    createToken("COMPARATORLOOSE", `^${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]})$|^$`);
    createToken("COMPARATOR", `^${src[t.GTLT]}\\s*(${src[t.FULLPLAIN]})$|^$`);
    createToken("COMPARATORTRIM", `(\\s*)${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]}|${src[t.XRANGEPLAIN]})`, true);
    exports.comparatorTrimReplace = "$1$2$3";
    createToken("HYPHENRANGE", `^\\s*(${src[t.XRANGEPLAIN]})\\s+-\\s+(${src[t.XRANGEPLAIN]})\\s*$`);
    createToken("HYPHENRANGELOOSE", `^\\s*(${src[t.XRANGEPLAINLOOSE]})\\s+-\\s+(${src[t.XRANGEPLAINLOOSE]})\\s*$`);
    createToken("STAR", "(<|>)?=?\\s*\\*");
    createToken("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$");
    createToken("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
  }
});

// ../../node_modules/.pnpm/semver@7.7.2/node_modules/semver/internal/parse-options.js
var require_parse_options = __commonJS({
  "../../node_modules/.pnpm/semver@7.7.2/node_modules/semver/internal/parse-options.js"(exports, module) {
    "use strict";
    var looseOption = Object.freeze({ loose: true });
    var emptyOpts = Object.freeze({});
    var parseOptions = (options) => {
      if (!options) {
        return emptyOpts;
      }
      if (typeof options !== "object") {
        return looseOption;
      }
      return options;
    };
    module.exports = parseOptions;
  }
});

// ../../node_modules/.pnpm/semver@7.7.2/node_modules/semver/internal/identifiers.js
var require_identifiers = __commonJS({
  "../../node_modules/.pnpm/semver@7.7.2/node_modules/semver/internal/identifiers.js"(exports, module) {
    "use strict";
    var numeric = /^[0-9]+$/;
    var compareIdentifiers = (a3, b4) => {
      const anum = numeric.test(a3);
      const bnum = numeric.test(b4);
      if (anum && bnum) {
        a3 = +a3;
        b4 = +b4;
      }
      return a3 === b4 ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a3 < b4 ? -1 : 1;
    };
    var rcompareIdentifiers = (a3, b4) => compareIdentifiers(b4, a3);
    module.exports = {
      compareIdentifiers,
      rcompareIdentifiers
    };
  }
});

// ../../node_modules/.pnpm/semver@7.7.2/node_modules/semver/classes/semver.js
var require_semver = __commonJS({
  "../../node_modules/.pnpm/semver@7.7.2/node_modules/semver/classes/semver.js"(exports, module) {
    "use strict";
    var debug = require_debug();
    var { MAX_LENGTH, MAX_SAFE_INTEGER: MAX_SAFE_INTEGER2 } = require_constants2();
    var { safeRe: re2, t } = require_re();
    var parseOptions = require_parse_options();
    var { compareIdentifiers } = require_identifiers();
    var SemVer = class _SemVer {
      constructor(version6, options) {
        options = parseOptions(options);
        if (version6 instanceof _SemVer) {
          if (version6.loose === !!options.loose && version6.includePrerelease === !!options.includePrerelease) {
            return version6;
          } else {
            version6 = version6.version;
          }
        } else if (typeof version6 !== "string") {
          throw new TypeError(`Invalid version. Must be a string. Got type "${typeof version6}".`);
        }
        if (version6.length > MAX_LENGTH) {
          throw new TypeError(
            `version is longer than ${MAX_LENGTH} characters`
          );
        }
        debug("SemVer", version6, options);
        this.options = options;
        this.loose = !!options.loose;
        this.includePrerelease = !!options.includePrerelease;
        const m3 = version6.trim().match(options.loose ? re2[t.LOOSE] : re2[t.FULL]);
        if (!m3) {
          throw new TypeError(`Invalid Version: ${version6}`);
        }
        this.raw = version6;
        this.major = +m3[1];
        this.minor = +m3[2];
        this.patch = +m3[3];
        if (this.major > MAX_SAFE_INTEGER2 || this.major < 0) {
          throw new TypeError("Invalid major version");
        }
        if (this.minor > MAX_SAFE_INTEGER2 || this.minor < 0) {
          throw new TypeError("Invalid minor version");
        }
        if (this.patch > MAX_SAFE_INTEGER2 || this.patch < 0) {
          throw new TypeError("Invalid patch version");
        }
        if (!m3[4]) {
          this.prerelease = [];
        } else {
          this.prerelease = m3[4].split(".").map((id) => {
            if (/^[0-9]+$/.test(id)) {
              const num = +id;
              if (num >= 0 && num < MAX_SAFE_INTEGER2) {
                return num;
              }
            }
            return id;
          });
        }
        this.build = m3[5] ? m3[5].split(".") : [];
        this.format();
      }
      format() {
        this.version = `${this.major}.${this.minor}.${this.patch}`;
        if (this.prerelease.length) {
          this.version += `-${this.prerelease.join(".")}`;
        }
        return this.version;
      }
      toString() {
        return this.version;
      }
      compare(other) {
        debug("SemVer.compare", this.version, this.options, other);
        if (!(other instanceof _SemVer)) {
          if (typeof other === "string" && other === this.version) {
            return 0;
          }
          other = new _SemVer(other, this.options);
        }
        if (other.version === this.version) {
          return 0;
        }
        return this.compareMain(other) || this.comparePre(other);
      }
      compareMain(other) {
        if (!(other instanceof _SemVer)) {
          other = new _SemVer(other, this.options);
        }
        return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
      }
      comparePre(other) {
        if (!(other instanceof _SemVer)) {
          other = new _SemVer(other, this.options);
        }
        if (this.prerelease.length && !other.prerelease.length) {
          return -1;
        } else if (!this.prerelease.length && other.prerelease.length) {
          return 1;
        } else if (!this.prerelease.length && !other.prerelease.length) {
          return 0;
        }
        let i4 = 0;
        do {
          const a3 = this.prerelease[i4];
          const b4 = other.prerelease[i4];
          debug("prerelease compare", i4, a3, b4);
          if (a3 === void 0 && b4 === void 0) {
            return 0;
          } else if (b4 === void 0) {
            return 1;
          } else if (a3 === void 0) {
            return -1;
          } else if (a3 === b4) {
            continue;
          } else {
            return compareIdentifiers(a3, b4);
          }
        } while (++i4);
      }
      compareBuild(other) {
        if (!(other instanceof _SemVer)) {
          other = new _SemVer(other, this.options);
        }
        let i4 = 0;
        do {
          const a3 = this.build[i4];
          const b4 = other.build[i4];
          debug("build compare", i4, a3, b4);
          if (a3 === void 0 && b4 === void 0) {
            return 0;
          } else if (b4 === void 0) {
            return 1;
          } else if (a3 === void 0) {
            return -1;
          } else if (a3 === b4) {
            continue;
          } else {
            return compareIdentifiers(a3, b4);
          }
        } while (++i4);
      }
      // preminor will bump the version up to the next minor release, and immediately
      // down to pre-release. premajor and prepatch work the same way.
      inc(release, identifier, identifierBase) {
        if (release.startsWith("pre")) {
          if (!identifier && identifierBase === false) {
            throw new Error("invalid increment argument: identifier is empty");
          }
          if (identifier) {
            const match = `-${identifier}`.match(this.options.loose ? re2[t.PRERELEASELOOSE] : re2[t.PRERELEASE]);
            if (!match || match[1] !== identifier) {
              throw new Error(`invalid identifier: ${identifier}`);
            }
          }
        }
        switch (release) {
          case "premajor":
            this.prerelease.length = 0;
            this.patch = 0;
            this.minor = 0;
            this.major++;
            this.inc("pre", identifier, identifierBase);
            break;
          case "preminor":
            this.prerelease.length = 0;
            this.patch = 0;
            this.minor++;
            this.inc("pre", identifier, identifierBase);
            break;
          case "prepatch":
            this.prerelease.length = 0;
            this.inc("patch", identifier, identifierBase);
            this.inc("pre", identifier, identifierBase);
            break;
          case "prerelease":
            if (this.prerelease.length === 0) {
              this.inc("patch", identifier, identifierBase);
            }
            this.inc("pre", identifier, identifierBase);
            break;
          case "release":
            if (this.prerelease.length === 0) {
              throw new Error(`version ${this.raw} is not a prerelease`);
            }
            this.prerelease.length = 0;
            break;
          case "major":
            if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
              this.major++;
            }
            this.minor = 0;
            this.patch = 0;
            this.prerelease = [];
            break;
          case "minor":
            if (this.patch !== 0 || this.prerelease.length === 0) {
              this.minor++;
            }
            this.patch = 0;
            this.prerelease = [];
            break;
          case "patch":
            if (this.prerelease.length === 0) {
              this.patch++;
            }
            this.prerelease = [];
            break;
          case "pre": {
            const base = Number(identifierBase) ? 1 : 0;
            if (this.prerelease.length === 0) {
              this.prerelease = [base];
            } else {
              let i4 = this.prerelease.length;
              while (--i4 >= 0) {
                if (typeof this.prerelease[i4] === "number") {
                  this.prerelease[i4]++;
                  i4 = -2;
                }
              }
              if (i4 === -1) {
                if (identifier === this.prerelease.join(".") && identifierBase === false) {
                  throw new Error("invalid increment argument: identifier already exists");
                }
                this.prerelease.push(base);
              }
            }
            if (identifier) {
              let prerelease = [identifier, base];
              if (identifierBase === false) {
                prerelease = [identifier];
              }
              if (compareIdentifiers(this.prerelease[0], identifier) === 0) {
                if (isNaN(this.prerelease[1])) {
                  this.prerelease = prerelease;
                }
              } else {
                this.prerelease = prerelease;
              }
            }
            break;
          }
          default:
            throw new Error(`invalid increment argument: ${release}`);
        }
        this.raw = this.format();
        if (this.build.length) {
          this.raw += `+${this.build.join(".")}`;
        }
        return this;
      }
    };
    module.exports = SemVer;
  }
});

// ../../node_modules/.pnpm/semver@7.7.2/node_modules/semver/functions/parse.js
var require_parse = __commonJS({
  "../../node_modules/.pnpm/semver@7.7.2/node_modules/semver/functions/parse.js"(exports, module) {
    "use strict";
    var SemVer = require_semver();
    var parse = (version6, options, throwErrors = false) => {
      if (version6 instanceof SemVer) {
        return version6;
      }
      try {
        return new SemVer(version6, options);
      } catch (er) {
        if (!throwErrors) {
          return null;
        }
        throw er;
      }
    };
    module.exports = parse;
  }
});

// ../../node_modules/.pnpm/semver@7.7.2/node_modules/semver/functions/valid.js
var require_valid = __commonJS({
  "../../node_modules/.pnpm/semver@7.7.2/node_modules/semver/functions/valid.js"(exports, module) {
    "use strict";
    var parse = require_parse();
    var valid = (version6, options) => {
      const v5 = parse(version6, options);
      return v5 ? v5.version : null;
    };
    module.exports = valid;
  }
});

// ../../node_modules/.pnpm/semver@7.7.2/node_modules/semver/functions/clean.js
var require_clean = __commonJS({
  "../../node_modules/.pnpm/semver@7.7.2/node_modules/semver/functions/clean.js"(exports, module) {
    "use strict";
    var parse = require_parse();
    var clean = (version6, options) => {
      const s3 = parse(version6.trim().replace(/^[=v]+/, ""), options);
      return s3 ? s3.version : null;
    };
    module.exports = clean;
  }
});

// ../../node_modules/.pnpm/semver@7.7.2/node_modules/semver/functions/inc.js
var require_inc = __commonJS({
  "../../node_modules/.pnpm/semver@7.7.2/node_modules/semver/functions/inc.js"(exports, module) {
    "use strict";
    var SemVer = require_semver();
    var inc = (version6, release, options, identifier, identifierBase) => {
      if (typeof options === "string") {
        identifierBase = identifier;
        identifier = options;
        options = void 0;
      }
      try {
        return new SemVer(
          version6 instanceof SemVer ? version6.version : version6,
          options
        ).inc(release, identifier, identifierBase).version;
      } catch (er) {
        return null;
      }
    };
    module.exports = inc;
  }
});

// ../../node_modules/.pnpm/semver@7.7.2/node_modules/semver/functions/diff.js
var require_diff = __commonJS({
  "../../node_modules/.pnpm/semver@7.7.2/node_modules/semver/functions/diff.js"(exports, module) {
    "use strict";
    var parse = require_parse();
    var diff = (version1, version22) => {
      const v1 = parse(version1, null, true);
      const v22 = parse(version22, null, true);
      const comparison = v1.compare(v22);
      if (comparison === 0) {
        return null;
      }
      const v1Higher = comparison > 0;
      const highVersion = v1Higher ? v1 : v22;
      const lowVersion = v1Higher ? v22 : v1;
      const highHasPre = !!highVersion.prerelease.length;
      const lowHasPre = !!lowVersion.prerelease.length;
      if (lowHasPre && !highHasPre) {
        if (!lowVersion.patch && !lowVersion.minor) {
          return "major";
        }
        if (lowVersion.compareMain(highVersion) === 0) {
          if (lowVersion.minor && !lowVersion.patch) {
            return "minor";
          }
          return "patch";
        }
      }
      const prefix = highHasPre ? "pre" : "";
      if (v1.major !== v22.major) {
        return prefix + "major";
      }
      if (v1.minor !== v22.minor) {
        return prefix + "minor";
      }
      if (v1.patch !== v22.patch) {
        return prefix + "patch";
      }
      return "prerelease";
    };
    module.exports = diff;
  }
});

// ../../node_modules/.pnpm/semver@7.7.2/node_modules/semver/functions/major.js
var require_major = __commonJS({
  "../../node_modules/.pnpm/semver@7.7.2/node_modules/semver/functions/major.js"(exports, module) {
    "use strict";
    var SemVer = require_semver();
    var major = (a3, loose) => new SemVer(a3, loose).major;
    module.exports = major;
  }
});

// ../../node_modules/.pnpm/semver@7.7.2/node_modules/semver/functions/minor.js
var require_minor = __commonJS({
  "../../node_modules/.pnpm/semver@7.7.2/node_modules/semver/functions/minor.js"(exports, module) {
    "use strict";
    var SemVer = require_semver();
    var minor = (a3, loose) => new SemVer(a3, loose).minor;
    module.exports = minor;
  }
});

// ../../node_modules/.pnpm/semver@7.7.2/node_modules/semver/functions/patch.js
var require_patch = __commonJS({
  "../../node_modules/.pnpm/semver@7.7.2/node_modules/semver/functions/patch.js"(exports, module) {
    "use strict";
    var SemVer = require_semver();
    var patch = (a3, loose) => new SemVer(a3, loose).patch;
    module.exports = patch;
  }
});

// ../../node_modules/.pnpm/semver@7.7.2/node_modules/semver/functions/prerelease.js
var require_prerelease = __commonJS({
  "../../node_modules/.pnpm/semver@7.7.2/node_modules/semver/functions/prerelease.js"(exports, module) {
    "use strict";
    var parse = require_parse();
    var prerelease = (version6, options) => {
      const parsed = parse(version6, options);
      return parsed && parsed.prerelease.length ? parsed.prerelease : null;
    };
    module.exports = prerelease;
  }
});

// ../../node_modules/.pnpm/semver@7.7.2/node_modules/semver/functions/compare.js
var require_compare = __commonJS({
  "../../node_modules/.pnpm/semver@7.7.2/node_modules/semver/functions/compare.js"(exports, module) {
    "use strict";
    var SemVer = require_semver();
    var compare = (a3, b4, loose) => new SemVer(a3, loose).compare(new SemVer(b4, loose));
    module.exports = compare;
  }
});

// ../../node_modules/.pnpm/semver@7.7.2/node_modules/semver/functions/rcompare.js
var require_rcompare = __commonJS({
  "../../node_modules/.pnpm/semver@7.7.2/node_modules/semver/functions/rcompare.js"(exports, module) {
    "use strict";
    var compare = require_compare();
    var rcompare = (a3, b4, loose) => compare(b4, a3, loose);
    module.exports = rcompare;
  }
});

// ../../node_modules/.pnpm/semver@7.7.2/node_modules/semver/functions/compare-loose.js
var require_compare_loose = __commonJS({
  "../../node_modules/.pnpm/semver@7.7.2/node_modules/semver/functions/compare-loose.js"(exports, module) {
    "use strict";
    var compare = require_compare();
    var compareLoose = (a3, b4) => compare(a3, b4, true);
    module.exports = compareLoose;
  }
});

// ../../node_modules/.pnpm/semver@7.7.2/node_modules/semver/functions/compare-build.js
var require_compare_build = __commonJS({
  "../../node_modules/.pnpm/semver@7.7.2/node_modules/semver/functions/compare-build.js"(exports, module) {
    "use strict";
    var SemVer = require_semver();
    var compareBuild = (a3, b4, loose) => {
      const versionA = new SemVer(a3, loose);
      const versionB = new SemVer(b4, loose);
      return versionA.compare(versionB) || versionA.compareBuild(versionB);
    };
    module.exports = compareBuild;
  }
});

// ../../node_modules/.pnpm/semver@7.7.2/node_modules/semver/functions/sort.js
var require_sort2 = __commonJS({
  "../../node_modules/.pnpm/semver@7.7.2/node_modules/semver/functions/sort.js"(exports, module) {
    "use strict";
    var compareBuild = require_compare_build();
    var sort2 = (list, loose) => list.sort((a3, b4) => compareBuild(a3, b4, loose));
    module.exports = sort2;
  }
});

// ../../node_modules/.pnpm/semver@7.7.2/node_modules/semver/functions/rsort.js
var require_rsort = __commonJS({
  "../../node_modules/.pnpm/semver@7.7.2/node_modules/semver/functions/rsort.js"(exports, module) {
    "use strict";
    var compareBuild = require_compare_build();
    var rsort = (list, loose) => list.sort((a3, b4) => compareBuild(b4, a3, loose));
    module.exports = rsort;
  }
});

// ../../node_modules/.pnpm/semver@7.7.2/node_modules/semver/functions/gt.js
var require_gt = __commonJS({
  "../../node_modules/.pnpm/semver@7.7.2/node_modules/semver/functions/gt.js"(exports, module) {
    "use strict";
    var compare = require_compare();
    var gt2 = (a3, b4, loose) => compare(a3, b4, loose) > 0;
    module.exports = gt2;
  }
});

// ../../node_modules/.pnpm/semver@7.7.2/node_modules/semver/functions/lt.js
var require_lt = __commonJS({
  "../../node_modules/.pnpm/semver@7.7.2/node_modules/semver/functions/lt.js"(exports, module) {
    "use strict";
    var compare = require_compare();
    var lt2 = (a3, b4, loose) => compare(a3, b4, loose) < 0;
    module.exports = lt2;
  }
});

// ../../node_modules/.pnpm/semver@7.7.2/node_modules/semver/functions/eq.js
var require_eq = __commonJS({
  "../../node_modules/.pnpm/semver@7.7.2/node_modules/semver/functions/eq.js"(exports, module) {
    "use strict";
    var compare = require_compare();
    var eq2 = (a3, b4, loose) => compare(a3, b4, loose) === 0;
    module.exports = eq2;
  }
});

// ../../node_modules/.pnpm/semver@7.7.2/node_modules/semver/functions/neq.js
var require_neq = __commonJS({
  "../../node_modules/.pnpm/semver@7.7.2/node_modules/semver/functions/neq.js"(exports, module) {
    "use strict";
    var compare = require_compare();
    var neq = (a3, b4, loose) => compare(a3, b4, loose) !== 0;
    module.exports = neq;
  }
});

// ../../node_modules/.pnpm/semver@7.7.2/node_modules/semver/functions/gte.js
var require_gte = __commonJS({
  "../../node_modules/.pnpm/semver@7.7.2/node_modules/semver/functions/gte.js"(exports, module) {
    "use strict";
    var compare = require_compare();
    var gte = (a3, b4, loose) => compare(a3, b4, loose) >= 0;
    module.exports = gte;
  }
});

// ../../node_modules/.pnpm/semver@7.7.2/node_modules/semver/functions/lte.js
var require_lte = __commonJS({
  "../../node_modules/.pnpm/semver@7.7.2/node_modules/semver/functions/lte.js"(exports, module) {
    "use strict";
    var compare = require_compare();
    var lte = (a3, b4, loose) => compare(a3, b4, loose) <= 0;
    module.exports = lte;
  }
});

// ../../node_modules/.pnpm/semver@7.7.2/node_modules/semver/functions/cmp.js
var require_cmp = __commonJS({
  "../../node_modules/.pnpm/semver@7.7.2/node_modules/semver/functions/cmp.js"(exports, module) {
    "use strict";
    var eq2 = require_eq();
    var neq = require_neq();
    var gt2 = require_gt();
    var gte = require_gte();
    var lt2 = require_lt();
    var lte = require_lte();
    var cmp = (a3, op, b4, loose) => {
      switch (op) {
        case "===":
          if (typeof a3 === "object") {
            a3 = a3.version;
          }
          if (typeof b4 === "object") {
            b4 = b4.version;
          }
          return a3 === b4;
        case "!==":
          if (typeof a3 === "object") {
            a3 = a3.version;
          }
          if (typeof b4 === "object") {
            b4 = b4.version;
          }
          return a3 !== b4;
        case "":
        case "=":
        case "==":
          return eq2(a3, b4, loose);
        case "!=":
          return neq(a3, b4, loose);
        case ">":
          return gt2(a3, b4, loose);
        case ">=":
          return gte(a3, b4, loose);
        case "<":
          return lt2(a3, b4, loose);
        case "<=":
          return lte(a3, b4, loose);
        default:
          throw new TypeError(`Invalid operator: ${op}`);
      }
    };
    module.exports = cmp;
  }
});

// ../../node_modules/.pnpm/semver@7.7.2/node_modules/semver/functions/coerce.js
var require_coerce = __commonJS({
  "../../node_modules/.pnpm/semver@7.7.2/node_modules/semver/functions/coerce.js"(exports, module) {
    "use strict";
    var SemVer = require_semver();
    var parse = require_parse();
    var { safeRe: re2, t } = require_re();
    var coerce = (version6, options) => {
      if (version6 instanceof SemVer) {
        return version6;
      }
      if (typeof version6 === "number") {
        version6 = String(version6);
      }
      if (typeof version6 !== "string") {
        return null;
      }
      options = options || {};
      let match = null;
      if (!options.rtl) {
        match = version6.match(options.includePrerelease ? re2[t.COERCEFULL] : re2[t.COERCE]);
      } else {
        const coerceRtlRegex = options.includePrerelease ? re2[t.COERCERTLFULL] : re2[t.COERCERTL];
        let next;
        while ((next = coerceRtlRegex.exec(version6)) && (!match || match.index + match[0].length !== version6.length)) {
          if (!match || next.index + next[0].length !== match.index + match[0].length) {
            match = next;
          }
          coerceRtlRegex.lastIndex = next.index + next[1].length + next[2].length;
        }
        coerceRtlRegex.lastIndex = -1;
      }
      if (match === null) {
        return null;
      }
      const major = match[2];
      const minor = match[3] || "0";
      const patch = match[4] || "0";
      const prerelease = options.includePrerelease && match[5] ? `-${match[5]}` : "";
      const build = options.includePrerelease && match[6] ? `+${match[6]}` : "";
      return parse(`${major}.${minor}.${patch}${prerelease}${build}`, options);
    };
    module.exports = coerce;
  }
});

// ../../node_modules/.pnpm/semver@7.7.2/node_modules/semver/internal/lrucache.js
var require_lrucache = __commonJS({
  "../../node_modules/.pnpm/semver@7.7.2/node_modules/semver/internal/lrucache.js"(exports, module) {
    "use strict";
    var LRUCache = class {
      constructor() {
        this.max = 1e3;
        this.map = /* @__PURE__ */ new Map();
      }
      get(key) {
        const value = this.map.get(key);
        if (value === void 0) {
          return void 0;
        } else {
          this.map.delete(key);
          this.map.set(key, value);
          return value;
        }
      }
      delete(key) {
        return this.map.delete(key);
      }
      set(key, value) {
        const deleted = this.delete(key);
        if (!deleted && value !== void 0) {
          if (this.map.size >= this.max) {
            const firstKey = this.map.keys().next().value;
            this.delete(firstKey);
          }
          this.map.set(key, value);
        }
        return this;
      }
    };
    module.exports = LRUCache;
  }
});

// ../../node_modules/.pnpm/semver@7.7.2/node_modules/semver/classes/range.js
var require_range = __commonJS({
  "../../node_modules/.pnpm/semver@7.7.2/node_modules/semver/classes/range.js"(exports, module) {
    "use strict";
    var SPACE_CHARACTERS = /\s+/g;
    var Range = class _Range {
      constructor(range, options) {
        options = parseOptions(options);
        if (range instanceof _Range) {
          if (range.loose === !!options.loose && range.includePrerelease === !!options.includePrerelease) {
            return range;
          } else {
            return new _Range(range.raw, options);
          }
        }
        if (range instanceof Comparator) {
          this.raw = range.value;
          this.set = [[range]];
          this.formatted = void 0;
          return this;
        }
        this.options = options;
        this.loose = !!options.loose;
        this.includePrerelease = !!options.includePrerelease;
        this.raw = range.trim().replace(SPACE_CHARACTERS, " ");
        this.set = this.raw.split("||").map((r3) => this.parseRange(r3.trim())).filter((c6) => c6.length);
        if (!this.set.length) {
          throw new TypeError(`Invalid SemVer Range: ${this.raw}`);
        }
        if (this.set.length > 1) {
          const first = this.set[0];
          this.set = this.set.filter((c6) => !isNullSet(c6[0]));
          if (this.set.length === 0) {
            this.set = [first];
          } else if (this.set.length > 1) {
            for (const c6 of this.set) {
              if (c6.length === 1 && isAny(c6[0])) {
                this.set = [c6];
                break;
              }
            }
          }
        }
        this.formatted = void 0;
      }
      get range() {
        if (this.formatted === void 0) {
          this.formatted = "";
          for (let i4 = 0; i4 < this.set.length; i4++) {
            if (i4 > 0) {
              this.formatted += "||";
            }
            const comps = this.set[i4];
            for (let k5 = 0; k5 < comps.length; k5++) {
              if (k5 > 0) {
                this.formatted += " ";
              }
              this.formatted += comps[k5].toString().trim();
            }
          }
        }
        return this.formatted;
      }
      format() {
        return this.range;
      }
      toString() {
        return this.range;
      }
      parseRange(range) {
        const memoOpts = (this.options.includePrerelease && FLAG_INCLUDE_PRERELEASE) | (this.options.loose && FLAG_LOOSE);
        const memoKey = memoOpts + ":" + range;
        const cached = cache2.get(memoKey);
        if (cached) {
          return cached;
        }
        const loose = this.options.loose;
        const hr2 = loose ? re2[t.HYPHENRANGELOOSE] : re2[t.HYPHENRANGE];
        range = range.replace(hr2, hyphenReplace(this.options.includePrerelease));
        debug("hyphen replace", range);
        range = range.replace(re2[t.COMPARATORTRIM], comparatorTrimReplace);
        debug("comparator trim", range);
        range = range.replace(re2[t.TILDETRIM], tildeTrimReplace);
        debug("tilde trim", range);
        range = range.replace(re2[t.CARETTRIM], caretTrimReplace);
        debug("caret trim", range);
        let rangeList = range.split(" ").map((comp) => parseComparator(comp, this.options)).join(" ").split(/\s+/).map((comp) => replaceGTE0(comp, this.options));
        if (loose) {
          rangeList = rangeList.filter((comp) => {
            debug("loose invalid filter", comp, this.options);
            return !!comp.match(re2[t.COMPARATORLOOSE]);
          });
        }
        debug("range list", rangeList);
        const rangeMap = /* @__PURE__ */ new Map();
        const comparators = rangeList.map((comp) => new Comparator(comp, this.options));
        for (const comp of comparators) {
          if (isNullSet(comp)) {
            return [comp];
          }
          rangeMap.set(comp.value, comp);
        }
        if (rangeMap.size > 1 && rangeMap.has("")) {
          rangeMap.delete("");
        }
        const result = [...rangeMap.values()];
        cache2.set(memoKey, result);
        return result;
      }
      intersects(range, options) {
        if (!(range instanceof _Range)) {
          throw new TypeError("a Range is required");
        }
        return this.set.some((thisComparators) => {
          return isSatisfiable(thisComparators, options) && range.set.some((rangeComparators) => {
            return isSatisfiable(rangeComparators, options) && thisComparators.every((thisComparator) => {
              return rangeComparators.every((rangeComparator) => {
                return thisComparator.intersects(rangeComparator, options);
              });
            });
          });
        });
      }
      // if ANY of the sets match ALL of its comparators, then pass
      test(version6) {
        if (!version6) {
          return false;
        }
        if (typeof version6 === "string") {
          try {
            version6 = new SemVer(version6, this.options);
          } catch (er) {
            return false;
          }
        }
        for (let i4 = 0; i4 < this.set.length; i4++) {
          if (testSet(this.set[i4], version6, this.options)) {
            return true;
          }
        }
        return false;
      }
    };
    module.exports = Range;
    var LRU = require_lrucache();
    var cache2 = new LRU();
    var parseOptions = require_parse_options();
    var Comparator = require_comparator();
    var debug = require_debug();
    var SemVer = require_semver();
    var {
      safeRe: re2,
      t,
      comparatorTrimReplace,
      tildeTrimReplace,
      caretTrimReplace
    } = require_re();
    var { FLAG_INCLUDE_PRERELEASE, FLAG_LOOSE } = require_constants2();
    var isNullSet = (c6) => c6.value === "<0.0.0-0";
    var isAny = (c6) => c6.value === "";
    var isSatisfiable = (comparators, options) => {
      let result = true;
      const remainingComparators = comparators.slice();
      let testComparator = remainingComparators.pop();
      while (result && remainingComparators.length) {
        result = remainingComparators.every((otherComparator) => {
          return testComparator.intersects(otherComparator, options);
        });
        testComparator = remainingComparators.pop();
      }
      return result;
    };
    var parseComparator = (comp, options) => {
      debug("comp", comp, options);
      comp = replaceCarets(comp, options);
      debug("caret", comp);
      comp = replaceTildes(comp, options);
      debug("tildes", comp);
      comp = replaceXRanges(comp, options);
      debug("xrange", comp);
      comp = replaceStars(comp, options);
      debug("stars", comp);
      return comp;
    };
    var isX = (id) => !id || id.toLowerCase() === "x" || id === "*";
    var replaceTildes = (comp, options) => {
      return comp.trim().split(/\s+/).map((c6) => replaceTilde(c6, options)).join(" ");
    };
    var replaceTilde = (comp, options) => {
      const r3 = options.loose ? re2[t.TILDELOOSE] : re2[t.TILDE];
      return comp.replace(r3, (_16, M3, m3, p4, pr2) => {
        debug("tilde", comp, _16, M3, m3, p4, pr2);
        let ret;
        if (isX(M3)) {
          ret = "";
        } else if (isX(m3)) {
          ret = `>=${M3}.0.0 <${+M3 + 1}.0.0-0`;
        } else if (isX(p4)) {
          ret = `>=${M3}.${m3}.0 <${M3}.${+m3 + 1}.0-0`;
        } else if (pr2) {
          debug("replaceTilde pr", pr2);
          ret = `>=${M3}.${m3}.${p4}-${pr2} <${M3}.${+m3 + 1}.0-0`;
        } else {
          ret = `>=${M3}.${m3}.${p4} <${M3}.${+m3 + 1}.0-0`;
        }
        debug("tilde return", ret);
        return ret;
      });
    };
    var replaceCarets = (comp, options) => {
      return comp.trim().split(/\s+/).map((c6) => replaceCaret(c6, options)).join(" ");
    };
    var replaceCaret = (comp, options) => {
      debug("caret", comp, options);
      const r3 = options.loose ? re2[t.CARETLOOSE] : re2[t.CARET];
      const z4 = options.includePrerelease ? "-0" : "";
      return comp.replace(r3, (_16, M3, m3, p4, pr2) => {
        debug("caret", comp, _16, M3, m3, p4, pr2);
        let ret;
        if (isX(M3)) {
          ret = "";
        } else if (isX(m3)) {
          ret = `>=${M3}.0.0${z4} <${+M3 + 1}.0.0-0`;
        } else if (isX(p4)) {
          if (M3 === "0") {
            ret = `>=${M3}.${m3}.0${z4} <${M3}.${+m3 + 1}.0-0`;
          } else {
            ret = `>=${M3}.${m3}.0${z4} <${+M3 + 1}.0.0-0`;
          }
        } else if (pr2) {
          debug("replaceCaret pr", pr2);
          if (M3 === "0") {
            if (m3 === "0") {
              ret = `>=${M3}.${m3}.${p4}-${pr2} <${M3}.${m3}.${+p4 + 1}-0`;
            } else {
              ret = `>=${M3}.${m3}.${p4}-${pr2} <${M3}.${+m3 + 1}.0-0`;
            }
          } else {
            ret = `>=${M3}.${m3}.${p4}-${pr2} <${+M3 + 1}.0.0-0`;
          }
        } else {
          debug("no pr");
          if (M3 === "0") {
            if (m3 === "0") {
              ret = `>=${M3}.${m3}.${p4}${z4} <${M3}.${m3}.${+p4 + 1}-0`;
            } else {
              ret = `>=${M3}.${m3}.${p4}${z4} <${M3}.${+m3 + 1}.0-0`;
            }
          } else {
            ret = `>=${M3}.${m3}.${p4} <${+M3 + 1}.0.0-0`;
          }
        }
        debug("caret return", ret);
        return ret;
      });
    };
    var replaceXRanges = (comp, options) => {
      debug("replaceXRanges", comp, options);
      return comp.split(/\s+/).map((c6) => replaceXRange(c6, options)).join(" ");
    };
    var replaceXRange = (comp, options) => {
      comp = comp.trim();
      const r3 = options.loose ? re2[t.XRANGELOOSE] : re2[t.XRANGE];
      return comp.replace(r3, (ret, gtlt, M3, m3, p4, pr2) => {
        debug("xRange", comp, ret, gtlt, M3, m3, p4, pr2);
        const xM = isX(M3);
        const xm = xM || isX(m3);
        const xp = xm || isX(p4);
        const anyX = xp;
        if (gtlt === "=" && anyX) {
          gtlt = "";
        }
        pr2 = options.includePrerelease ? "-0" : "";
        if (xM) {
          if (gtlt === ">" || gtlt === "<") {
            ret = "<0.0.0-0";
          } else {
            ret = "*";
          }
        } else if (gtlt && anyX) {
          if (xm) {
            m3 = 0;
          }
          p4 = 0;
          if (gtlt === ">") {
            gtlt = ">=";
            if (xm) {
              M3 = +M3 + 1;
              m3 = 0;
              p4 = 0;
            } else {
              m3 = +m3 + 1;
              p4 = 0;
            }
          } else if (gtlt === "<=") {
            gtlt = "<";
            if (xm) {
              M3 = +M3 + 1;
            } else {
              m3 = +m3 + 1;
            }
          }
          if (gtlt === "<") {
            pr2 = "-0";
          }
          ret = `${gtlt + M3}.${m3}.${p4}${pr2}`;
        } else if (xm) {
          ret = `>=${M3}.0.0${pr2} <${+M3 + 1}.0.0-0`;
        } else if (xp) {
          ret = `>=${M3}.${m3}.0${pr2} <${M3}.${+m3 + 1}.0-0`;
        }
        debug("xRange return", ret);
        return ret;
      });
    };
    var replaceStars = (comp, options) => {
      debug("replaceStars", comp, options);
      return comp.trim().replace(re2[t.STAR], "");
    };
    var replaceGTE0 = (comp, options) => {
      debug("replaceGTE0", comp, options);
      return comp.trim().replace(re2[options.includePrerelease ? t.GTE0PRE : t.GTE0], "");
    };
    var hyphenReplace = (incPr) => ($0, from, fM, fm, fp, fpr, fb, to2, tM, tm, tp, tpr) => {
      if (isX(fM)) {
        from = "";
      } else if (isX(fm)) {
        from = `>=${fM}.0.0${incPr ? "-0" : ""}`;
      } else if (isX(fp)) {
        from = `>=${fM}.${fm}.0${incPr ? "-0" : ""}`;
      } else if (fpr) {
        from = `>=${from}`;
      } else {
        from = `>=${from}${incPr ? "-0" : ""}`;
      }
      if (isX(tM)) {
        to2 = "";
      } else if (isX(tm)) {
        to2 = `<${+tM + 1}.0.0-0`;
      } else if (isX(tp)) {
        to2 = `<${tM}.${+tm + 1}.0-0`;
      } else if (tpr) {
        to2 = `<=${tM}.${tm}.${tp}-${tpr}`;
      } else if (incPr) {
        to2 = `<${tM}.${tm}.${+tp + 1}-0`;
      } else {
        to2 = `<=${to2}`;
      }
      return `${from} ${to2}`.trim();
    };
    var testSet = (set6, version6, options) => {
      for (let i4 = 0; i4 < set6.length; i4++) {
        if (!set6[i4].test(version6)) {
          return false;
        }
      }
      if (version6.prerelease.length && !options.includePrerelease) {
        for (let i4 = 0; i4 < set6.length; i4++) {
          debug(set6[i4].semver);
          if (set6[i4].semver === Comparator.ANY) {
            continue;
          }
          if (set6[i4].semver.prerelease.length > 0) {
            const allowed = set6[i4].semver;
            if (allowed.major === version6.major && allowed.minor === version6.minor && allowed.patch === version6.patch) {
              return true;
            }
          }
        }
        return false;
      }
      return true;
    };
  }
});

// ../../node_modules/.pnpm/semver@7.7.2/node_modules/semver/classes/comparator.js
var require_comparator = __commonJS({
  "../../node_modules/.pnpm/semver@7.7.2/node_modules/semver/classes/comparator.js"(exports, module) {
    "use strict";
    var ANY = Symbol("SemVer ANY");
    var Comparator = class _Comparator {
      static get ANY() {
        return ANY;
      }
      constructor(comp, options) {
        options = parseOptions(options);
        if (comp instanceof _Comparator) {
          if (comp.loose === !!options.loose) {
            return comp;
          } else {
            comp = comp.value;
          }
        }
        comp = comp.trim().split(/\s+/).join(" ");
        debug("comparator", comp, options);
        this.options = options;
        this.loose = !!options.loose;
        this.parse(comp);
        if (this.semver === ANY) {
          this.value = "";
        } else {
          this.value = this.operator + this.semver.version;
        }
        debug("comp", this);
      }
      parse(comp) {
        const r3 = this.options.loose ? re2[t.COMPARATORLOOSE] : re2[t.COMPARATOR];
        const m3 = comp.match(r3);
        if (!m3) {
          throw new TypeError(`Invalid comparator: ${comp}`);
        }
        this.operator = m3[1] !== void 0 ? m3[1] : "";
        if (this.operator === "=") {
          this.operator = "";
        }
        if (!m3[2]) {
          this.semver = ANY;
        } else {
          this.semver = new SemVer(m3[2], this.options.loose);
        }
      }
      toString() {
        return this.value;
      }
      test(version6) {
        debug("Comparator.test", version6, this.options.loose);
        if (this.semver === ANY || version6 === ANY) {
          return true;
        }
        if (typeof version6 === "string") {
          try {
            version6 = new SemVer(version6, this.options);
          } catch (er) {
            return false;
          }
        }
        return cmp(version6, this.operator, this.semver, this.options);
      }
      intersects(comp, options) {
        if (!(comp instanceof _Comparator)) {
          throw new TypeError("a Comparator is required");
        }
        if (this.operator === "") {
          if (this.value === "") {
            return true;
          }
          return new Range(comp.value, options).test(this.value);
        } else if (comp.operator === "") {
          if (comp.value === "") {
            return true;
          }
          return new Range(this.value, options).test(comp.semver);
        }
        options = parseOptions(options);
        if (options.includePrerelease && (this.value === "<0.0.0-0" || comp.value === "<0.0.0-0")) {
          return false;
        }
        if (!options.includePrerelease && (this.value.startsWith("<0.0.0") || comp.value.startsWith("<0.0.0"))) {
          return false;
        }
        if (this.operator.startsWith(">") && comp.operator.startsWith(">")) {
          return true;
        }
        if (this.operator.startsWith("<") && comp.operator.startsWith("<")) {
          return true;
        }
        if (this.semver.version === comp.semver.version && this.operator.includes("=") && comp.operator.includes("=")) {
          return true;
        }
        if (cmp(this.semver, "<", comp.semver, options) && this.operator.startsWith(">") && comp.operator.startsWith("<")) {
          return true;
        }
        if (cmp(this.semver, ">", comp.semver, options) && this.operator.startsWith("<") && comp.operator.startsWith(">")) {
          return true;
        }
        return false;
      }
    };
    module.exports = Comparator;
    var parseOptions = require_parse_options();
    var { safeRe: re2, t } = require_re();
    var cmp = require_cmp();
    var debug = require_debug();
    var SemVer = require_semver();
    var Range = require_range();
  }
});

// ../../node_modules/.pnpm/semver@7.7.2/node_modules/semver/functions/satisfies.js
var require_satisfies = __commonJS({
  "../../node_modules/.pnpm/semver@7.7.2/node_modules/semver/functions/satisfies.js"(exports, module) {
    "use strict";
    var Range = require_range();
    var satisfies = (version6, range, options) => {
      try {
        range = new Range(range, options);
      } catch (er) {
        return false;
      }
      return range.test(version6);
    };
    module.exports = satisfies;
  }
});

// ../../node_modules/.pnpm/semver@7.7.2/node_modules/semver/ranges/to-comparators.js
var require_to_comparators = __commonJS({
  "../../node_modules/.pnpm/semver@7.7.2/node_modules/semver/ranges/to-comparators.js"(exports, module) {
    "use strict";
    var Range = require_range();
    var toComparators = (range, options) => new Range(range, options).set.map((comp) => comp.map((c6) => c6.value).join(" ").trim().split(" "));
    module.exports = toComparators;
  }
});

// ../../node_modules/.pnpm/semver@7.7.2/node_modules/semver/ranges/max-satisfying.js
var require_max_satisfying = __commonJS({
  "../../node_modules/.pnpm/semver@7.7.2/node_modules/semver/ranges/max-satisfying.js"(exports, module) {
    "use strict";
    var SemVer = require_semver();
    var Range = require_range();
    var maxSatisfying = (versions, range, options) => {
      let max = null;
      let maxSV = null;
      let rangeObj = null;
      try {
        rangeObj = new Range(range, options);
      } catch (er) {
        return null;
      }
      versions.forEach((v5) => {
        if (rangeObj.test(v5)) {
          if (!max || maxSV.compare(v5) === -1) {
            max = v5;
            maxSV = new SemVer(max, options);
          }
        }
      });
      return max;
    };
    module.exports = maxSatisfying;
  }
});

// ../../node_modules/.pnpm/semver@7.7.2/node_modules/semver/ranges/min-satisfying.js
var require_min_satisfying = __commonJS({
  "../../node_modules/.pnpm/semver@7.7.2/node_modules/semver/ranges/min-satisfying.js"(exports, module) {
    "use strict";
    var SemVer = require_semver();
    var Range = require_range();
    var minSatisfying = (versions, range, options) => {
      let min = null;
      let minSV = null;
      let rangeObj = null;
      try {
        rangeObj = new Range(range, options);
      } catch (er) {
        return null;
      }
      versions.forEach((v5) => {
        if (rangeObj.test(v5)) {
          if (!min || minSV.compare(v5) === 1) {
            min = v5;
            minSV = new SemVer(min, options);
          }
        }
      });
      return min;
    };
    module.exports = minSatisfying;
  }
});

// ../../node_modules/.pnpm/semver@7.7.2/node_modules/semver/ranges/min-version.js
var require_min_version = __commonJS({
  "../../node_modules/.pnpm/semver@7.7.2/node_modules/semver/ranges/min-version.js"(exports, module) {
    "use strict";
    var SemVer = require_semver();
    var Range = require_range();
    var gt2 = require_gt();
    var minVersion = (range, loose) => {
      range = new Range(range, loose);
      let minver = new SemVer("0.0.0");
      if (range.test(minver)) {
        return minver;
      }
      minver = new SemVer("0.0.0-0");
      if (range.test(minver)) {
        return minver;
      }
      minver = null;
      for (let i4 = 0; i4 < range.set.length; ++i4) {
        const comparators = range.set[i4];
        let setMin = null;
        comparators.forEach((comparator) => {
          const compver = new SemVer(comparator.semver.version);
          switch (comparator.operator) {
            case ">":
              if (compver.prerelease.length === 0) {
                compver.patch++;
              } else {
                compver.prerelease.push(0);
              }
              compver.raw = compver.format();
            case "":
            case ">=":
              if (!setMin || gt2(compver, setMin)) {
                setMin = compver;
              }
              break;
            case "<":
            case "<=":
              break;
            default:
              throw new Error(`Unexpected operation: ${comparator.operator}`);
          }
        });
        if (setMin && (!minver || gt2(minver, setMin))) {
          minver = setMin;
        }
      }
      if (minver && range.test(minver)) {
        return minver;
      }
      return null;
    };
    module.exports = minVersion;
  }
});

// ../../node_modules/.pnpm/semver@7.7.2/node_modules/semver/ranges/valid.js
var require_valid2 = __commonJS({
  "../../node_modules/.pnpm/semver@7.7.2/node_modules/semver/ranges/valid.js"(exports, module) {
    "use strict";
    var Range = require_range();
    var validRange = (range, options) => {
      try {
        return new Range(range, options).range || "*";
      } catch (er) {
        return null;
      }
    };
    module.exports = validRange;
  }
});

// ../../node_modules/.pnpm/semver@7.7.2/node_modules/semver/ranges/outside.js
var require_outside = __commonJS({
  "../../node_modules/.pnpm/semver@7.7.2/node_modules/semver/ranges/outside.js"(exports, module) {
    "use strict";
    var SemVer = require_semver();
    var Comparator = require_comparator();
    var { ANY } = Comparator;
    var Range = require_range();
    var satisfies = require_satisfies();
    var gt2 = require_gt();
    var lt2 = require_lt();
    var lte = require_lte();
    var gte = require_gte();
    var outside = (version6, range, hilo, options) => {
      version6 = new SemVer(version6, options);
      range = new Range(range, options);
      let gtfn, ltefn, ltfn, comp, ecomp;
      switch (hilo) {
        case ">":
          gtfn = gt2;
          ltefn = lte;
          ltfn = lt2;
          comp = ">";
          ecomp = ">=";
          break;
        case "<":
          gtfn = lt2;
          ltefn = gte;
          ltfn = gt2;
          comp = "<";
          ecomp = "<=";
          break;
        default:
          throw new TypeError('Must provide a hilo val of "<" or ">"');
      }
      if (satisfies(version6, range, options)) {
        return false;
      }
      for (let i4 = 0; i4 < range.set.length; ++i4) {
        const comparators = range.set[i4];
        let high = null;
        let low = null;
        comparators.forEach((comparator) => {
          if (comparator.semver === ANY) {
            comparator = new Comparator(">=0.0.0");
          }
          high = high || comparator;
          low = low || comparator;
          if (gtfn(comparator.semver, high.semver, options)) {
            high = comparator;
          } else if (ltfn(comparator.semver, low.semver, options)) {
            low = comparator;
          }
        });
        if (high.operator === comp || high.operator === ecomp) {
          return false;
        }
        if ((!low.operator || low.operator === comp) && ltefn(version6, low.semver)) {
          return false;
        } else if (low.operator === ecomp && ltfn(version6, low.semver)) {
          return false;
        }
      }
      return true;
    };
    module.exports = outside;
  }
});

// ../../node_modules/.pnpm/semver@7.7.2/node_modules/semver/ranges/gtr.js
var require_gtr = __commonJS({
  "../../node_modules/.pnpm/semver@7.7.2/node_modules/semver/ranges/gtr.js"(exports, module) {
    "use strict";
    var outside = require_outside();
    var gtr = (version6, range, options) => outside(version6, range, ">", options);
    module.exports = gtr;
  }
});

// ../../node_modules/.pnpm/semver@7.7.2/node_modules/semver/ranges/ltr.js
var require_ltr = __commonJS({
  "../../node_modules/.pnpm/semver@7.7.2/node_modules/semver/ranges/ltr.js"(exports, module) {
    "use strict";
    var outside = require_outside();
    var ltr = (version6, range, options) => outside(version6, range, "<", options);
    module.exports = ltr;
  }
});

// ../../node_modules/.pnpm/semver@7.7.2/node_modules/semver/ranges/intersects.js
var require_intersects = __commonJS({
  "../../node_modules/.pnpm/semver@7.7.2/node_modules/semver/ranges/intersects.js"(exports, module) {
    "use strict";
    var Range = require_range();
    var intersects = (r1, r22, options) => {
      r1 = new Range(r1, options);
      r22 = new Range(r22, options);
      return r1.intersects(r22, options);
    };
    module.exports = intersects;
  }
});

// ../../node_modules/.pnpm/semver@7.7.2/node_modules/semver/ranges/simplify.js
var require_simplify = __commonJS({
  "../../node_modules/.pnpm/semver@7.7.2/node_modules/semver/ranges/simplify.js"(exports, module) {
    "use strict";
    var satisfies = require_satisfies();
    var compare = require_compare();
    module.exports = (versions, range, options) => {
      const set6 = [];
      let first = null;
      let prev = null;
      const v5 = versions.sort((a3, b4) => compare(a3, b4, options));
      for (const version6 of v5) {
        const included = satisfies(version6, range, options);
        if (included) {
          prev = version6;
          if (!first) {
            first = version6;
          }
        } else {
          if (prev) {
            set6.push([first, prev]);
          }
          prev = null;
          first = null;
        }
      }
      if (first) {
        set6.push([first, null]);
      }
      const ranges = [];
      for (const [min, max] of set6) {
        if (min === max) {
          ranges.push(min);
        } else if (!max && min === v5[0]) {
          ranges.push("*");
        } else if (!max) {
          ranges.push(`>=${min}`);
        } else if (min === v5[0]) {
          ranges.push(`<=${max}`);
        } else {
          ranges.push(`${min} - ${max}`);
        }
      }
      const simplified = ranges.join(" || ");
      const original = typeof range.raw === "string" ? range.raw : String(range);
      return simplified.length < original.length ? simplified : range;
    };
  }
});

// ../../node_modules/.pnpm/semver@7.7.2/node_modules/semver/ranges/subset.js
var require_subset = __commonJS({
  "../../node_modules/.pnpm/semver@7.7.2/node_modules/semver/ranges/subset.js"(exports, module) {
    "use strict";
    var Range = require_range();
    var Comparator = require_comparator();
    var { ANY } = Comparator;
    var satisfies = require_satisfies();
    var compare = require_compare();
    var subset = (sub, dom, options = {}) => {
      if (sub === dom) {
        return true;
      }
      sub = new Range(sub, options);
      dom = new Range(dom, options);
      let sawNonNull = false;
      OUTER:
        for (const simpleSub of sub.set) {
          for (const simpleDom of dom.set) {
            const isSub = simpleSubset(simpleSub, simpleDom, options);
            sawNonNull = sawNonNull || isSub !== null;
            if (isSub) {
              continue OUTER;
            }
          }
          if (sawNonNull) {
            return false;
          }
        }
      return true;
    };
    var minimumVersionWithPreRelease = [new Comparator(">=0.0.0-0")];
    var minimumVersion = [new Comparator(">=0.0.0")];
    var simpleSubset = (sub, dom, options) => {
      if (sub === dom) {
        return true;
      }
      if (sub.length === 1 && sub[0].semver === ANY) {
        if (dom.length === 1 && dom[0].semver === ANY) {
          return true;
        } else if (options.includePrerelease) {
          sub = minimumVersionWithPreRelease;
        } else {
          sub = minimumVersion;
        }
      }
      if (dom.length === 1 && dom[0].semver === ANY) {
        if (options.includePrerelease) {
          return true;
        } else {
          dom = minimumVersion;
        }
      }
      const eqSet = /* @__PURE__ */ new Set();
      let gt2, lt2;
      for (const c6 of sub) {
        if (c6.operator === ">" || c6.operator === ">=") {
          gt2 = higherGT(gt2, c6, options);
        } else if (c6.operator === "<" || c6.operator === "<=") {
          lt2 = lowerLT(lt2, c6, options);
        } else {
          eqSet.add(c6.semver);
        }
      }
      if (eqSet.size > 1) {
        return null;
      }
      let gtltComp;
      if (gt2 && lt2) {
        gtltComp = compare(gt2.semver, lt2.semver, options);
        if (gtltComp > 0) {
          return null;
        } else if (gtltComp === 0 && (gt2.operator !== ">=" || lt2.operator !== "<=")) {
          return null;
        }
      }
      for (const eq2 of eqSet) {
        if (gt2 && !satisfies(eq2, String(gt2), options)) {
          return null;
        }
        if (lt2 && !satisfies(eq2, String(lt2), options)) {
          return null;
        }
        for (const c6 of dom) {
          if (!satisfies(eq2, String(c6), options)) {
            return false;
          }
        }
        return true;
      }
      let higher, lower;
      let hasDomLT, hasDomGT;
      let needDomLTPre = lt2 && !options.includePrerelease && lt2.semver.prerelease.length ? lt2.semver : false;
      let needDomGTPre = gt2 && !options.includePrerelease && gt2.semver.prerelease.length ? gt2.semver : false;
      if (needDomLTPre && needDomLTPre.prerelease.length === 1 && lt2.operator === "<" && needDomLTPre.prerelease[0] === 0) {
        needDomLTPre = false;
      }
      for (const c6 of dom) {
        hasDomGT = hasDomGT || c6.operator === ">" || c6.operator === ">=";
        hasDomLT = hasDomLT || c6.operator === "<" || c6.operator === "<=";
        if (gt2) {
          if (needDomGTPre) {
            if (c6.semver.prerelease && c6.semver.prerelease.length && c6.semver.major === needDomGTPre.major && c6.semver.minor === needDomGTPre.minor && c6.semver.patch === needDomGTPre.patch) {
              needDomGTPre = false;
            }
          }
          if (c6.operator === ">" || c6.operator === ">=") {
            higher = higherGT(gt2, c6, options);
            if (higher === c6 && higher !== gt2) {
              return false;
            }
          } else if (gt2.operator === ">=" && !satisfies(gt2.semver, String(c6), options)) {
            return false;
          }
        }
        if (lt2) {
          if (needDomLTPre) {
            if (c6.semver.prerelease && c6.semver.prerelease.length && c6.semver.major === needDomLTPre.major && c6.semver.minor === needDomLTPre.minor && c6.semver.patch === needDomLTPre.patch) {
              needDomLTPre = false;
            }
          }
          if (c6.operator === "<" || c6.operator === "<=") {
            lower = lowerLT(lt2, c6, options);
            if (lower === c6 && lower !== lt2) {
              return false;
            }
          } else if (lt2.operator === "<=" && !satisfies(lt2.semver, String(c6), options)) {
            return false;
          }
        }
        if (!c6.operator && (lt2 || gt2) && gtltComp !== 0) {
          return false;
        }
      }
      if (gt2 && hasDomLT && !lt2 && gtltComp !== 0) {
        return false;
      }
      if (lt2 && hasDomGT && !gt2 && gtltComp !== 0) {
        return false;
      }
      if (needDomGTPre || needDomLTPre) {
        return false;
      }
      return true;
    };
    var higherGT = (a3, b4, options) => {
      if (!a3) {
        return b4;
      }
      const comp = compare(a3.semver, b4.semver, options);
      return comp > 0 ? a3 : comp < 0 ? b4 : b4.operator === ">" && a3.operator === ">=" ? b4 : a3;
    };
    var lowerLT = (a3, b4, options) => {
      if (!a3) {
        return b4;
      }
      const comp = compare(a3.semver, b4.semver, options);
      return comp < 0 ? a3 : comp > 0 ? b4 : b4.operator === "<" && a3.operator === "<=" ? b4 : a3;
    };
    module.exports = subset;
  }
});

// ../../node_modules/.pnpm/semver@7.7.2/node_modules/semver/index.js
var require_semver2 = __commonJS({
  "../../node_modules/.pnpm/semver@7.7.2/node_modules/semver/index.js"(exports, module) {
    "use strict";
    var internalRe = require_re();
    var constants = require_constants2();
    var SemVer = require_semver();
    var identifiers = require_identifiers();
    var parse = require_parse();
    var valid = require_valid();
    var clean = require_clean();
    var inc = require_inc();
    var diff = require_diff();
    var major = require_major();
    var minor = require_minor();
    var patch = require_patch();
    var prerelease = require_prerelease();
    var compare = require_compare();
    var rcompare = require_rcompare();
    var compareLoose = require_compare_loose();
    var compareBuild = require_compare_build();
    var sort2 = require_sort2();
    var rsort = require_rsort();
    var gt2 = require_gt();
    var lt2 = require_lt();
    var eq2 = require_eq();
    var neq = require_neq();
    var gte = require_gte();
    var lte = require_lte();
    var cmp = require_cmp();
    var coerce = require_coerce();
    var Comparator = require_comparator();
    var Range = require_range();
    var satisfies = require_satisfies();
    var toComparators = require_to_comparators();
    var maxSatisfying = require_max_satisfying();
    var minSatisfying = require_min_satisfying();
    var minVersion = require_min_version();
    var validRange = require_valid2();
    var outside = require_outside();
    var gtr = require_gtr();
    var ltr = require_ltr();
    var intersects = require_intersects();
    var simplifyRange = require_simplify();
    var subset = require_subset();
    module.exports = {
      parse,
      valid,
      clean,
      inc,
      diff,
      major,
      minor,
      patch,
      prerelease,
      compare,
      rcompare,
      compareLoose,
      compareBuild,
      sort: sort2,
      rsort,
      gt: gt2,
      lt: lt2,
      eq: eq2,
      neq,
      gte,
      lte,
      cmp,
      coerce,
      Comparator,
      Range,
      satisfies,
      toComparators,
      maxSatisfying,
      minSatisfying,
      minVersion,
      validRange,
      outside,
      gtr,
      ltr,
      intersects,
      simplifyRange,
      subset,
      SemVer,
      re: internalRe.re,
      src: internalRe.src,
      tokens: internalRe.t,
      SEMVER_SPEC_VERSION: constants.SEMVER_SPEC_VERSION,
      RELEASE_TYPES: constants.RELEASE_TYPES,
      compareIdentifiers: identifiers.compareIdentifiers,
      rcompareIdentifiers: identifiers.rcompareIdentifiers
    };
  }
});

// ../../node_modules/.pnpm/quick-format-unescaped@4.0.4/node_modules/quick-format-unescaped/index.js
var require_quick_format_unescaped = __commonJS({
  "../../node_modules/.pnpm/quick-format-unescaped@4.0.4/node_modules/quick-format-unescaped/index.js"(exports, module) {
    "use strict";
    function tryStringify(o4) {
      try {
        return JSON.stringify(o4);
      } catch (e2) {
        return '"[Circular]"';
      }
    }
    module.exports = format;
    function format(f6, args, opts) {
      var ss = opts && opts.stringify || tryStringify;
      var offset = 1;
      if (typeof f6 === "object" && f6 !== null) {
        var len = args.length + offset;
        if (len === 1)
          return f6;
        var objects = new Array(len);
        objects[0] = ss(f6);
        for (var index = 1; index < len; index++) {
          objects[index] = ss(args[index]);
        }
        return objects.join(" ");
      }
      if (typeof f6 !== "string") {
        return f6;
      }
      var argLen = args.length;
      if (argLen === 0)
        return f6;
      var str = "";
      var a3 = 1 - offset;
      var lastPos = -1;
      var flen = f6 && f6.length || 0;
      for (var i4 = 0; i4 < flen; ) {
        if (f6.charCodeAt(i4) === 37 && i4 + 1 < flen) {
          lastPos = lastPos > -1 ? lastPos : 0;
          switch (f6.charCodeAt(i4 + 1)) {
            case 100:
            case 102:
              if (a3 >= argLen)
                break;
              if (args[a3] == null)
                break;
              if (lastPos < i4)
                str += f6.slice(lastPos, i4);
              str += Number(args[a3]);
              lastPos = i4 + 2;
              i4++;
              break;
            case 105:
              if (a3 >= argLen)
                break;
              if (args[a3] == null)
                break;
              if (lastPos < i4)
                str += f6.slice(lastPos, i4);
              str += Math.floor(Number(args[a3]));
              lastPos = i4 + 2;
              i4++;
              break;
            case 79:
            case 111:
            case 106:
              if (a3 >= argLen)
                break;
              if (args[a3] === void 0)
                break;
              if (lastPos < i4)
                str += f6.slice(lastPos, i4);
              var type = typeof args[a3];
              if (type === "string") {
                str += "'" + args[a3] + "'";
                lastPos = i4 + 2;
                i4++;
                break;
              }
              if (type === "function") {
                str += args[a3].name || "<anonymous>";
                lastPos = i4 + 2;
                i4++;
                break;
              }
              str += ss(args[a3]);
              lastPos = i4 + 2;
              i4++;
              break;
            case 115:
              if (a3 >= argLen)
                break;
              if (lastPos < i4)
                str += f6.slice(lastPos, i4);
              str += String(args[a3]);
              lastPos = i4 + 2;
              i4++;
              break;
            case 37:
              if (lastPos < i4)
                str += f6.slice(lastPos, i4);
              str += "%";
              lastPos = i4 + 2;
              i4++;
              a3--;
              break;
          }
          ++a3;
        }
        ++i4;
      }
      if (lastPos === -1)
        return f6;
      else if (lastPos < flen) {
        str += f6.slice(lastPos);
      }
      return str;
    }
  }
});

// ../../node_modules/.pnpm/pino@7.11.0/node_modules/pino/browser.js
var require_browser4 = __commonJS({
  "../../node_modules/.pnpm/pino@7.11.0/node_modules/pino/browser.js"(exports, module) {
    "use strict";
    var format = require_quick_format_unescaped();
    module.exports = pino;
    var _console = pfGlobalThisOrFallback().console || {};
    var stdSerializers = {
      mapHttpRequest: mock,
      mapHttpResponse: mock,
      wrapRequestSerializer: passthrough,
      wrapResponseSerializer: passthrough,
      wrapErrorSerializer: passthrough,
      req: mock,
      res: mock,
      err: asErrValue
    };
    function shouldSerialize(serialize, serializers) {
      if (Array.isArray(serialize)) {
        const hasToFilter = serialize.filter(function(k5) {
          return k5 !== "!stdSerializers.err";
        });
        return hasToFilter;
      } else if (serialize === true) {
        return Object.keys(serializers);
      }
      return false;
    }
    function pino(opts) {
      opts = opts || {};
      opts.browser = opts.browser || {};
      const transmit2 = opts.browser.transmit;
      if (transmit2 && typeof transmit2.send !== "function") {
        throw Error("pino: transmit option must have a send function");
      }
      const proto = opts.browser.write || _console;
      if (opts.browser.write)
        opts.browser.asObject = true;
      const serializers = opts.serializers || {};
      const serialize = shouldSerialize(opts.browser.serialize, serializers);
      let stdErrSerialize = opts.browser.serialize;
      if (Array.isArray(opts.browser.serialize) && opts.browser.serialize.indexOf("!stdSerializers.err") > -1)
        stdErrSerialize = false;
      const levels = ["error", "fatal", "warn", "info", "debug", "trace"];
      if (typeof proto === "function") {
        proto.error = proto.fatal = proto.warn = proto.info = proto.debug = proto.trace = proto;
      }
      if (opts.enabled === false)
        opts.level = "silent";
      const level = opts.level || "info";
      const logger6 = Object.create(proto);
      if (!logger6.log)
        logger6.log = noop3;
      Object.defineProperty(logger6, "levelVal", {
        get: getLevelVal
      });
      Object.defineProperty(logger6, "level", {
        get: getLevel,
        set: setLevel
      });
      const setOpts = {
        transmit: transmit2,
        serialize,
        asObject: opts.browser.asObject,
        levels,
        timestamp: getTimeFunction(opts)
      };
      logger6.levels = pino.levels;
      logger6.level = level;
      logger6.setMaxListeners = logger6.getMaxListeners = logger6.emit = logger6.addListener = logger6.on = logger6.prependListener = logger6.once = logger6.prependOnceListener = logger6.removeListener = logger6.removeAllListeners = logger6.listeners = logger6.listenerCount = logger6.eventNames = logger6.write = logger6.flush = noop3;
      logger6.serializers = serializers;
      logger6._serialize = serialize;
      logger6._stdErrSerialize = stdErrSerialize;
      logger6.child = child;
      if (transmit2)
        logger6._logEvent = createLogEventShape();
      function getLevelVal() {
        return this.level === "silent" ? Infinity : this.levels.values[this.level];
      }
      function getLevel() {
        return this._level;
      }
      function setLevel(level2) {
        if (level2 !== "silent" && !this.levels.values[level2]) {
          throw Error("unknown level " + level2);
        }
        this._level = level2;
        set6(setOpts, logger6, "error", "log");
        set6(setOpts, logger6, "fatal", "error");
        set6(setOpts, logger6, "warn", "error");
        set6(setOpts, logger6, "info", "log");
        set6(setOpts, logger6, "debug", "log");
        set6(setOpts, logger6, "trace", "log");
      }
      function child(bindings, childOptions) {
        if (!bindings) {
          throw new Error("missing bindings for child Pino");
        }
        childOptions = childOptions || {};
        if (serialize && bindings.serializers) {
          childOptions.serializers = bindings.serializers;
        }
        const childOptionsSerializers = childOptions.serializers;
        if (serialize && childOptionsSerializers) {
          var childSerializers = Object.assign({}, serializers, childOptionsSerializers);
          var childSerialize = opts.browser.serialize === true ? Object.keys(childSerializers) : serialize;
          delete bindings.serializers;
          applySerializers([bindings], childSerialize, childSerializers, this._stdErrSerialize);
        }
        function Child(parent) {
          this._childLevel = (parent._childLevel | 0) + 1;
          this.error = bind(parent, bindings, "error");
          this.fatal = bind(parent, bindings, "fatal");
          this.warn = bind(parent, bindings, "warn");
          this.info = bind(parent, bindings, "info");
          this.debug = bind(parent, bindings, "debug");
          this.trace = bind(parent, bindings, "trace");
          if (childSerializers) {
            this.serializers = childSerializers;
            this._serialize = childSerialize;
          }
          if (transmit2) {
            this._logEvent = createLogEventShape(
              [].concat(parent._logEvent.bindings, bindings)
            );
          }
        }
        Child.prototype = this;
        return new Child(this);
      }
      return logger6;
    }
    pino.levels = {
      values: {
        fatal: 60,
        error: 50,
        warn: 40,
        info: 30,
        debug: 20,
        trace: 10
      },
      labels: {
        10: "trace",
        20: "debug",
        30: "info",
        40: "warn",
        50: "error",
        60: "fatal"
      }
    };
    pino.stdSerializers = stdSerializers;
    pino.stdTimeFunctions = Object.assign({}, { nullTime, epochTime, unixTime, isoTime });
    function set6(opts, logger6, level, fallback) {
      const proto = Object.getPrototypeOf(logger6);
      logger6[level] = logger6.levelVal > logger6.levels.values[level] ? noop3 : proto[level] ? proto[level] : _console[level] || _console[fallback] || noop3;
      wrap(opts, logger6, level);
    }
    function wrap(opts, logger6, level) {
      if (!opts.transmit && logger6[level] === noop3)
        return;
      logger6[level] = function(write) {
        return function LOG() {
          const ts = opts.timestamp();
          const args = new Array(arguments.length);
          const proto = Object.getPrototypeOf && Object.getPrototypeOf(this) === _console ? _console : this;
          for (var i4 = 0; i4 < args.length; i4++)
            args[i4] = arguments[i4];
          if (opts.serialize && !opts.asObject) {
            applySerializers(args, this._serialize, this.serializers, this._stdErrSerialize);
          }
          if (opts.asObject)
            write.call(proto, asObject(this, level, args, ts));
          else
            write.apply(proto, args);
          if (opts.transmit) {
            const transmitLevel = opts.transmit.level || logger6.level;
            const transmitValue = pino.levels.values[transmitLevel];
            const methodValue = pino.levels.values[level];
            if (methodValue < transmitValue)
              return;
            transmit(this, {
              ts,
              methodLevel: level,
              methodValue,
              transmitLevel,
              transmitValue: pino.levels.values[opts.transmit.level || logger6.level],
              send: opts.transmit.send,
              val: logger6.levelVal
            }, args);
          }
        };
      }(logger6[level]);
    }
    function asObject(logger6, level, args, ts) {
      if (logger6._serialize)
        applySerializers(args, logger6._serialize, logger6.serializers, logger6._stdErrSerialize);
      const argsCloned = args.slice();
      let msg = argsCloned[0];
      const o4 = {};
      if (ts) {
        o4.time = ts;
      }
      o4.level = pino.levels.values[level];
      let lvl = (logger6._childLevel | 0) + 1;
      if (lvl < 1)
        lvl = 1;
      if (msg !== null && typeof msg === "object") {
        while (lvl-- && typeof argsCloned[0] === "object") {
          Object.assign(o4, argsCloned.shift());
        }
        msg = argsCloned.length ? format(argsCloned.shift(), argsCloned) : void 0;
      } else if (typeof msg === "string")
        msg = format(argsCloned.shift(), argsCloned);
      if (msg !== void 0)
        o4.msg = msg;
      return o4;
    }
    function applySerializers(args, serialize, serializers, stdErrSerialize) {
      for (const i4 in args) {
        if (stdErrSerialize && args[i4] instanceof Error) {
          args[i4] = pino.stdSerializers.err(args[i4]);
        } else if (typeof args[i4] === "object" && !Array.isArray(args[i4])) {
          for (const k5 in args[i4]) {
            if (serialize && serialize.indexOf(k5) > -1 && k5 in serializers) {
              args[i4][k5] = serializers[k5](args[i4][k5]);
            }
          }
        }
      }
    }
    function bind(parent, bindings, level) {
      return function() {
        const args = new Array(1 + arguments.length);
        args[0] = bindings;
        for (var i4 = 1; i4 < args.length; i4++) {
          args[i4] = arguments[i4 - 1];
        }
        return parent[level].apply(this, args);
      };
    }
    function transmit(logger6, opts, args) {
      const send = opts.send;
      const ts = opts.ts;
      const methodLevel = opts.methodLevel;
      const methodValue = opts.methodValue;
      const val = opts.val;
      const bindings = logger6._logEvent.bindings;
      applySerializers(
        args,
        logger6._serialize || Object.keys(logger6.serializers),
        logger6.serializers,
        logger6._stdErrSerialize === void 0 ? true : logger6._stdErrSerialize
      );
      logger6._logEvent.ts = ts;
      logger6._logEvent.messages = args.filter(function(arg) {
        return bindings.indexOf(arg) === -1;
      });
      logger6._logEvent.level.label = methodLevel;
      logger6._logEvent.level.value = methodValue;
      send(methodLevel, logger6._logEvent, val);
      logger6._logEvent = createLogEventShape(bindings);
    }
    function createLogEventShape(bindings) {
      return {
        ts: 0,
        messages: [],
        bindings: bindings || [],
        level: { label: "", value: 0 }
      };
    }
    function asErrValue(err) {
      const obj = {
        type: err.constructor.name,
        msg: err.message,
        stack: err.stack
      };
      for (const key in err) {
        if (obj[key] === void 0) {
          obj[key] = err[key];
        }
      }
      return obj;
    }
    function getTimeFunction(opts) {
      if (typeof opts.timestamp === "function") {
        return opts.timestamp;
      }
      if (opts.timestamp === false) {
        return nullTime;
      }
      return epochTime;
    }
    function mock() {
      return {};
    }
    function passthrough(a3) {
      return a3;
    }
    function noop3() {
    }
    function nullTime() {
      return false;
    }
    function epochTime() {
      return Date.now();
    }
    function unixTime() {
      return Math.round(Date.now() / 1e3);
    }
    function isoTime() {
      return new Date(Date.now()).toISOString();
    }
    function pfGlobalThisOrFallback() {
      function defd(o4) {
        return typeof o4 !== "undefined" && o4;
      }
      try {
        if (typeof globalThis !== "undefined")
          return globalThis;
        Object.defineProperty(Object.prototype, "globalThis", {
          get: function() {
            delete Object.prototype.globalThis;
            return this.globalThis = this;
          },
          configurable: true
        });
        return globalThis;
      } catch (e2) {
        return defd(self) || defd(window) || defd(this) || {};
      }
    }
  }
});

// ../../node_modules/.pnpm/@walletconnect+environment@1.0.1/node_modules/@walletconnect/environment/dist/cjs/crypto.js
var require_crypto3 = __commonJS({
  "../../node_modules/.pnpm/@walletconnect+environment@1.0.1/node_modules/@walletconnect/environment/dist/cjs/crypto.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isBrowserCryptoAvailable = exports.getSubtleCrypto = exports.getBrowerCrypto = void 0;
    function getBrowerCrypto() {
      return (global === null || global === void 0 ? void 0 : global.crypto) || (global === null || global === void 0 ? void 0 : global.msCrypto) || {};
    }
    exports.getBrowerCrypto = getBrowerCrypto;
    function getSubtleCrypto() {
      const browserCrypto = getBrowerCrypto();
      return browserCrypto.subtle || browserCrypto.webkitSubtle;
    }
    exports.getSubtleCrypto = getSubtleCrypto;
    function isBrowserCryptoAvailable() {
      return !!getBrowerCrypto() && !!getSubtleCrypto();
    }
    exports.isBrowserCryptoAvailable = isBrowserCryptoAvailable;
  }
});

// ../../node_modules/.pnpm/@walletconnect+environment@1.0.1/node_modules/@walletconnect/environment/dist/cjs/env.js
var require_env = __commonJS({
  "../../node_modules/.pnpm/@walletconnect+environment@1.0.1/node_modules/@walletconnect/environment/dist/cjs/env.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isBrowser = exports.isNode = exports.isReactNative = void 0;
    function isReactNative() {
      return typeof document === "undefined" && typeof navigator !== "undefined" && navigator.product === "ReactNative";
    }
    exports.isReactNative = isReactNative;
    function isNode2() {
      return typeof process !== "undefined" && typeof process.versions !== "undefined" && typeof process.versions.node !== "undefined";
    }
    exports.isNode = isNode2;
    function isBrowser() {
      return !isReactNative() && !isNode2();
    }
    exports.isBrowser = isBrowser;
  }
});

// ../../node_modules/.pnpm/@walletconnect+environment@1.0.1/node_modules/@walletconnect/environment/dist/cjs/index.js
var require_cjs4 = __commonJS({
  "../../node_modules/.pnpm/@walletconnect+environment@1.0.1/node_modules/@walletconnect/environment/dist/cjs/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    tslib_1.__exportStar(require_crypto3(), exports);
    tslib_1.__exportStar(require_env(), exports);
  }
});

// ../../node_modules/.pnpm/ws@7.5.10/node_modules/ws/browser.js
var require_browser5 = __commonJS({
  "../../node_modules/.pnpm/ws@7.5.10/node_modules/ws/browser.js"(exports, module) {
    "use strict";
    module.exports = function() {
      throw new Error(
        "ws does not work in the browser. Browser clients must use the native WebSocket object"
      );
    };
  }
});

// ../../node_modules/.pnpm/@keplr-wallet+router@0.12.252/node_modules/@keplr-wallet/router/build/encoding/index.js
var require_encoding = __commonJS({
  "../../node_modules/.pnpm/@keplr-wallet+router@0.12.252/node_modules/@keplr-wallet/router/build/encoding/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MessageRegistry = void 0;
    var MessageRegistry = class {
      constructor() {
        this.registeredMsgType = /* @__PURE__ */ new Map();
      }
      registerMessage(msgCls) {
        if (this.registeredMsgType.has(msgCls.type())) {
          throw new Error(`Already registered type ${msgCls.type()}`);
        }
        this.registeredMsgType.set(msgCls.type(), msgCls);
      }
      parseMessage(message) {
        if (!message.type) {
          throw new Error("Null type");
        }
        const msgCls = this.registeredMsgType.get(message.type);
        if (!msgCls) {
          throw new Error(`Unregistered msg type ${message.type}`);
        }
        return Object.setPrototypeOf(message.msg, msgCls.prototype);
      }
    };
    exports.MessageRegistry = MessageRegistry;
  }
});

// ../../node_modules/.pnpm/@keplr-wallet+router@0.12.252/node_modules/@keplr-wallet/router/build/hex.js
var require_hex2 = __commonJS({
  "../../node_modules/.pnpm/@keplr-wallet+router@0.12.252/node_modules/@keplr-wallet/router/build/hex.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.fromHex = exports.toHex = void 0;
    function toHex2(data) {
      let out = "";
      for (const byte of data) {
        out += ("0" + byte.toString(16)).slice(-2);
      }
      return out;
    }
    exports.toHex = toHex2;
    function fromHex(hexstring) {
      if (hexstring.length % 2 !== 0) {
        throw new Error("hex string length must be a multiple of 2");
      }
      const listOfInts = [];
      for (let i4 = 0; i4 < hexstring.length; i4 += 2) {
        const hexByteAsString = hexstring.substr(i4, 2);
        if (!hexByteAsString.match(/[0-9a-f]{2}/i)) {
          throw new Error("hex string contains invalid characters");
        }
        listOfInts.push(parseInt(hexByteAsString, 16));
      }
      return new Uint8Array(listOfInts);
    }
    exports.fromHex = fromHex;
  }
});

// ../../node_modules/.pnpm/@keplr-wallet+router@0.12.252/node_modules/@keplr-wallet/router/build/uint8-array.js
var require_uint8_array2 = __commonJS({
  "../../node_modules/.pnpm/@keplr-wallet+router@0.12.252/node_modules/@keplr-wallet/router/build/uint8-array.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.JSONUint8Array = void 0;
    var hex_1 = require_hex2();
    var JSONUint8Array = class _JSONUint8Array {
      static parse(text) {
        return JSON.parse(text, (key, value) => {
          if (key === "__proto__") {
            throw new Error("__proto__ is disallowed");
          }
          if (value && typeof value === "string" && value.startsWith("__uint8array__")) {
            return (0, hex_1.fromHex)(value.replace("__uint8array__", ""));
          }
          if (typeof BigInt !== "undefined" && value && typeof value === "string" && value.startsWith("__bigint__")) {
            return BigInt(value.replace("__bigint__", ""));
          }
          return value;
        });
      }
      static stringify(obj) {
        return JSON.stringify(obj, (key, value) => {
          if (key === "__proto__") {
            throw new Error("__proto__ is disallowed");
          }
          if (value && (value instanceof Uint8Array || typeof value === "object" && "type" in value && "data" in value && value.type === "Buffer" && Array.isArray(value.data))) {
            const array2 = value instanceof Uint8Array ? value : new Uint8Array(value.data);
            return `__uint8array__${(0, hex_1.toHex)(array2)}`;
          }
          if (typeof value === "bigint") {
            return `__bigint__${value.toString()}`;
          }
          return value;
        });
      }
      static wrap(obj) {
        if (obj === void 0)
          return void 0;
        return JSON.parse(_JSONUint8Array.stringify(obj));
      }
      static unwrap(obj) {
        if (obj === void 0)
          return void 0;
        return _JSONUint8Array.parse(_JSONUint8Array.stringify(obj));
      }
    };
    exports.JSONUint8Array = JSONUint8Array;
  }
});

// ../../node_modules/.pnpm/@keplr-wallet+router@0.12.252/node_modules/@keplr-wallet/router/build/router/index.js
var require_router = __commonJS({
  "../../node_modules/.pnpm/@keplr-wallet+router@0.12.252/node_modules/@keplr-wallet/router/build/router/index.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P3, generator) {
      function adopt(value) {
        return value instanceof P3 ? value : new P3(function(resolve) {
          resolve(value);
        });
      }
      return new (P3 || (P3 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e2) {
            reject(e2);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e2) {
            reject(e2);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Router = void 0;
    var encoding_1 = require_encoding();
    var uint8_array_1 = require_uint8_array2();
    var Router = class {
      constructor(envProducer) {
        this.envProducer = envProducer;
        this.msgRegistry = new encoding_1.MessageRegistry();
        this.registeredHandler = /* @__PURE__ */ new Map();
        this.guards = [];
        this.port = "";
        this._isInitialized = false;
      }
      get isInitialized() {
        return this._isInitialized;
      }
      registerMessage(msgCls) {
        this.msgRegistry.registerMessage(msgCls);
      }
      addHandler(route, handler) {
        if (this.registeredHandler.has(route)) {
          throw new Error(`Already registered type ${route}`);
        }
        this.registeredHandler.set(route, handler);
      }
      addGuard(guard) {
        this.guards.push(guard);
      }
      listen(port, initFn) {
        return __awaiter(this, void 0, void 0, function* () {
          this.port = port;
          this.attachHandler();
          if (initFn) {
            let initWaiter;
            this._initWaiter = new Promise((resolve) => {
              initWaiter = resolve;
            });
            yield initFn();
            initWaiter();
          }
          this._isInitialized = true;
          return;
        });
      }
      unlisten() {
        this.port = "";
        this.detachHandler();
      }
      handleMessage(message, sender) {
        var _a2;
        return __awaiter(this, void 0, void 0, function* () {
          if (!this.isInitialized) {
            yield this._initWaiter;
          }
          const msg = this.msgRegistry.parseMessage(uint8_array_1.JSONUint8Array.unwrap(message));
          const env = this.envProducer(sender, (_a2 = msg.routerMeta) !== null && _a2 !== void 0 ? _a2 : {});
          for (const guard of this.guards) {
            yield guard(env, msg, sender);
          }
          msg.validateBasic();
          const route = msg.route();
          if (!route) {
            throw new Error("Null router");
          }
          const handler = this.registeredHandler.get(route);
          if (!handler) {
            throw new Error("Can't get handler");
          }
          return uint8_array_1.JSONUint8Array.wrap(yield handler(env, msg));
        });
      }
    };
    exports.Router = Router;
  }
});

// ../../node_modules/.pnpm/@keplr-wallet+router@0.12.252/node_modules/@keplr-wallet/router/build/handler.js
var require_handler = __commonJS({
  "../../node_modules/.pnpm/@keplr-wallet+router@0.12.252/node_modules/@keplr-wallet/router/build/handler.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// ../../node_modules/.pnpm/@keplr-wallet+router@0.12.252/node_modules/@keplr-wallet/router/build/interfaces.js
var require_interfaces = __commonJS({
  "../../node_modules/.pnpm/@keplr-wallet+router@0.12.252/node_modules/@keplr-wallet/router/build/interfaces.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// ../../node_modules/.pnpm/@keplr-wallet+router@0.12.252/node_modules/@keplr-wallet/router/build/types.js
var require_types6 = __commonJS({
  "../../node_modules/.pnpm/@keplr-wallet+router@0.12.252/node_modules/@keplr-wallet/router/build/types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// ../../node_modules/.pnpm/@keplr-wallet+router@0.12.252/node_modules/@keplr-wallet/router/build/error.js
var require_error2 = __commonJS({
  "../../node_modules/.pnpm/@keplr-wallet+router@0.12.252/node_modules/@keplr-wallet/router/build/error.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.EthereumProviderRpcError = exports.KeplrError = void 0;
    var KeplrError = class _KeplrError extends Error {
      constructor(module2, code, message) {
        super(message);
        this.module = module2;
        this.code = code;
        Object.setPrototypeOf(this, _KeplrError.prototype);
      }
    };
    exports.KeplrError = KeplrError;
    var EthereumProviderRpcError = class _EthereumProviderRpcError extends Error {
      constructor(code, message, data) {
        super(message);
        this.code = code;
        this.data = data;
        Object.setPrototypeOf(this, _EthereumProviderRpcError.prototype);
      }
    };
    exports.EthereumProviderRpcError = EthereumProviderRpcError;
  }
});

// ../../node_modules/.pnpm/@keplr-wallet+router@0.12.252/node_modules/@keplr-wallet/router/build/message.js
var require_message = __commonJS({
  "../../node_modules/.pnpm/@keplr-wallet+router@0.12.252/node_modules/@keplr-wallet/router/build/message.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Message = void 0;
    var Message = class {
      /**
       * Ask for approval if message is sent externally.
       */
      approveExternal(_env, _sender) {
        return false;
      }
    };
    exports.Message = Message;
  }
});

// ../../node_modules/.pnpm/@keplr-wallet+router@0.12.252/node_modules/@keplr-wallet/router/build/constant.js
var require_constant = __commonJS({
  "../../node_modules/.pnpm/@keplr-wallet+router@0.12.252/node_modules/@keplr-wallet/router/build/constant.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WEBPAGE_PORT = exports.APP_PORT = exports.BACKGROUND_PORT = void 0;
    exports.BACKGROUND_PORT = "background";
    exports.APP_PORT = "popup";
    exports.WEBPAGE_PORT = "webpage";
  }
});

// ../../node_modules/.pnpm/@keplr-wallet+router@0.12.252/node_modules/@keplr-wallet/router/build/simple.js
var require_simple = __commonJS({
  "../../node_modules/.pnpm/@keplr-wallet+router@0.12.252/node_modules/@keplr-wallet/router/build/simple.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P3, generator) {
      function adopt(value) {
        return value instanceof P3 ? value : new P3(function(resolve) {
          resolve(value);
        });
      }
      return new (P3 || (P3 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e2) {
            reject(e2);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e2) {
            reject(e2);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.sendSimpleMessage = exports.SimpleMessage = void 0;
    var message_1 = require_message();
    var symbolRoute = Symbol();
    var symbolType = Symbol();
    var SimpleMessage = class extends message_1.Message {
      constructor(route, type, data) {
        super();
        this[symbolRoute] = route;
        this[symbolType] = type;
        for (const key of Object.keys(data)) {
          this[key] = data[key];
        }
      }
      route() {
        return this[symbolRoute];
      }
      type() {
        return this[symbolType];
      }
      // validateBasic should be handled in background.
      validateBasic() {
      }
      // approveExternal should be handled in background.
      approveExternal() {
        return true;
      }
    };
    exports.SimpleMessage = SimpleMessage;
    function sendSimpleMessage(requester, port, route, type, data) {
      return __awaiter(this, void 0, void 0, function* () {
        return yield requester.sendMessage(port, new SimpleMessage(route, type, data));
      });
    }
    exports.sendSimpleMessage = sendSimpleMessage;
  }
});

// ../../node_modules/.pnpm/@keplr-wallet+router@0.12.252/node_modules/@keplr-wallet/router/build/index.js
var require_build8 = __commonJS({
  "../../node_modules/.pnpm/@keplr-wallet+router@0.12.252/node_modules/@keplr-wallet/router/build/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o4, m3, k5, k22) {
      if (k22 === void 0)
        k22 = k5;
      var desc = Object.getOwnPropertyDescriptor(m3, k5);
      if (!desc || ("get" in desc ? !m3.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m3[k5];
        } };
      }
      Object.defineProperty(o4, k22, desc);
    } : function(o4, m3, k5, k22) {
      if (k22 === void 0)
        k22 = k5;
      o4[k22] = m3[k5];
    });
    var __exportStar = exports && exports.__exportStar || function(m3, exports2) {
      for (var p4 in m3)
        if (p4 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p4))
          __createBinding(exports2, m3, p4);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_router(), exports);
    __exportStar(require_handler(), exports);
    __exportStar(require_interfaces(), exports);
    __exportStar(require_types6(), exports);
    __exportStar(require_error2(), exports);
    __exportStar(require_message(), exports);
    __exportStar(require_constant(), exports);
    __exportStar(require_encoding(), exports);
    __exportStar(require_simple(), exports);
    __exportStar(require_uint8_array2(), exports);
  }
});

// ../../node_modules/.pnpm/@keplr-wallet+provider@0.12.252_starknet@7.6.4/node_modules/@keplr-wallet/provider/build/enigma.js
var require_enigma2 = __commonJS({
  "../../node_modules/.pnpm/@keplr-wallet+provider@0.12.252_starknet@7.6.4/node_modules/@keplr-wallet/provider/build/enigma.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P3, generator) {
      function adopt(value) {
        return value instanceof P3 ? value : new P3(function(resolve) {
          resolve(value);
        });
      }
      return new (P3 || (P3 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e2) {
            reject(e2);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e2) {
            reject(e2);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.KeplrEnigmaUtils = void 0;
    var KeplrEnigmaUtils = class {
      constructor(chainId, keplr) {
        this.chainId = chainId;
        this.keplr = keplr;
      }
      getPubkey() {
        return __awaiter(this, void 0, void 0, function* () {
          return yield this.keplr.getEnigmaPubKey(this.chainId);
        });
      }
      getTxEncryptionKey(nonce) {
        return __awaiter(this, void 0, void 0, function* () {
          return yield this.keplr.getEnigmaTxEncryptionKey(this.chainId, nonce);
        });
      }
      encrypt(contractCodeHash, msg) {
        return __awaiter(this, void 0, void 0, function* () {
          return yield this.keplr.enigmaEncrypt(this.chainId, contractCodeHash, msg);
        });
      }
      decrypt(ciphertext, nonce) {
        return __awaiter(this, void 0, void 0, function* () {
          return yield this.keplr.enigmaDecrypt(this.chainId, ciphertext, nonce);
        });
      }
    };
    exports.KeplrEnigmaUtils = KeplrEnigmaUtils;
  }
});

// ../../node_modules/.pnpm/@keplr-wallet+provider@0.12.252_starknet@7.6.4/node_modules/@keplr-wallet/provider/build/cosmjs.js
var require_cosmjs3 = __commonJS({
  "../../node_modules/.pnpm/@keplr-wallet+provider@0.12.252_starknet@7.6.4/node_modules/@keplr-wallet/provider/build/cosmjs.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P3, generator) {
      function adopt(value) {
        return value instanceof P3 ? value : new P3(function(resolve) {
          resolve(value);
        });
      }
      return new (P3 || (P3 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e2) {
            reject(e2);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e2) {
            reject(e2);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CosmJSOfflineSigner = exports.CosmJSOfflineSignerOnlyAmino = void 0;
    var CosmJSOfflineSignerOnlyAmino = class {
      constructor(chainId, keplr, signOptions) {
        this.chainId = chainId;
        this.keplr = keplr;
        this.signOptions = signOptions;
      }
      getAccounts() {
        return __awaiter(this, void 0, void 0, function* () {
          const key = yield this.keplr.getKey(this.chainId);
          return [
            {
              address: key.bech32Address,
              // Currently, only secp256k1 is supported.
              algo: "secp256k1",
              pubkey: key.pubKey
            }
          ];
        });
      }
      signAmino(signerAddress, signDoc) {
        return __awaiter(this, void 0, void 0, function* () {
          if (this.chainId !== signDoc.chain_id) {
            throw new Error("Unmatched chain id with the offline signer");
          }
          const key = yield this.keplr.getKey(signDoc.chain_id);
          if (key.bech32Address !== signerAddress) {
            throw new Error("Unknown signer address");
          }
          return yield this.keplr.signAmino(this.chainId, signerAddress, signDoc, this.signOptions);
        });
      }
      // Fallback function for the legacy cosmjs implementation before the stargate.
      sign(signerAddress, signDoc) {
        return __awaiter(this, void 0, void 0, function* () {
          return yield this.signAmino(signerAddress, signDoc);
        });
      }
    };
    exports.CosmJSOfflineSignerOnlyAmino = CosmJSOfflineSignerOnlyAmino;
    var CosmJSOfflineSigner = class extends CosmJSOfflineSignerOnlyAmino {
      constructor(chainId, keplr, signOptions) {
        super(chainId, keplr, signOptions);
      }
      signDirect(signerAddress, signDoc) {
        return __awaiter(this, void 0, void 0, function* () {
          if (this.chainId !== signDoc.chainId) {
            throw new Error("Unmatched chain id with the offline signer");
          }
          const key = yield this.keplr.getKey(signDoc.chainId);
          if (key.bech32Address !== signerAddress) {
            throw new Error("Unknown signer address");
          }
          return yield this.keplr.signDirect(this.chainId, signerAddress, signDoc, this.signOptions);
        });
      }
    };
    exports.CosmJSOfflineSigner = CosmJSOfflineSigner;
  }
});

// ../../node_modules/.pnpm/@keplr-wallet+provider@0.12.252_starknet@7.6.4/node_modules/@keplr-wallet/provider/build/core.js
var require_core2 = __commonJS({
  "../../node_modules/.pnpm/@keplr-wallet+provider@0.12.252_starknet@7.6.4/node_modules/@keplr-wallet/provider/build/core.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P3, generator) {
      function adopt(value) {
        return value instanceof P3 ? value : new P3(function(resolve) {
          resolve(value);
        });
      }
      return new (P3 || (P3 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e2) {
            reject(e2);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e2) {
            reject(e2);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Keplr = void 0;
    var router_1 = require_build8();
    var enigma_1 = require_enigma2();
    var cosmjs_1 = require_cosmjs3();
    var deepmerge_1 = __importDefault(require_cjs());
    var long_1 = __importDefault(require_long());
    var buffer_1 = require_buffer();
    var events_1 = __importDefault(require_events());
    var Keplr3 = class {
      constructor(version6, mode, requester) {
        this.version = version6;
        this.mode = mode;
        this.requester = requester;
        this.enigmaUtils = /* @__PURE__ */ new Map();
        this.defaultOptions = {};
        this.ethereum = new EthereumProvider(this, this.requester);
        this.starknet = new StarknetProvider(this, this.requester);
        this.bitcoin = new BitcoinProvider(this, this.requester);
      }
      ping() {
        return __awaiter(this, void 0, void 0, function* () {
          yield (0, router_1.sendSimpleMessage)(this.requester, router_1.BACKGROUND_PORT, "chains", "keplr-ping", {});
        });
      }
      enable(chainIds) {
        if (typeof chainIds === "string") {
          chainIds = [chainIds];
        }
        return new Promise((resolve, reject) => {
          let f6 = false;
          (0, router_1.sendSimpleMessage)(this.requester, router_1.BACKGROUND_PORT, "permission-interactive", "enable-access", {
            chainIds
          }).then(resolve).catch(reject).finally(() => f6 = true);
          setTimeout(() => {
            if (!f6) {
              this.protectedTryOpenSidePanelIfEnabled();
            }
          }, 300);
        });
      }
      // TODO:       keplr API .
      isEnabled(chainIds) {
        return __awaiter(this, void 0, void 0, function* () {
          if (typeof chainIds === "string") {
            chainIds = [chainIds];
          }
          return yield (0, router_1.sendSimpleMessage)(this.requester, router_1.BACKGROUND_PORT, "permission-interactive", "is-enabled-access", {
            chainIds
          });
        });
      }
      disable(chainIds) {
        return __awaiter(this, void 0, void 0, function* () {
          if (typeof chainIds === "string") {
            chainIds = [chainIds];
          }
          return new Promise((resolve, reject) => {
            let f6 = false;
            (0, router_1.sendSimpleMessage)(this.requester, router_1.BACKGROUND_PORT, "permission-interactive", "disable-access", {
              chainIds: chainIds !== null && chainIds !== void 0 ? chainIds : []
            }).then(resolve).catch(reject).finally(() => f6 = true);
            setTimeout(() => {
              if (!f6) {
                this.protectedTryOpenSidePanelIfEnabled();
              }
            }, 300);
          });
        });
      }
      experimentalSuggestChain(chainInfo) {
        return __awaiter(this, void 0, void 0, function* () {
          if (chainInfo.hideInUI) {
            throw new Error("hideInUI is not allowed");
          }
          if (chainInfo.gasPriceStep) {
            const gasPriceStep = Object.assign({}, chainInfo.gasPriceStep);
            for (const feeCurrency of chainInfo.feeCurrencies) {
              if (!feeCurrency.gasPriceStep) {
                feeCurrency.gasPriceStep = gasPriceStep;
              }
            }
            delete chainInfo.gasPriceStep;
            console.warn("The `gasPriceStep` field of the `ChainInfo` has been moved under `feeCurrencies`. This is automatically handled as of right now, but the upcoming update would potentially cause errors.");
          }
          if (chainInfo.coinType) {
            console.warn("The `coinType` field of the `ChainInfo` is removed. This is automatically handled as of right now, but the upcoming update would potentially cause errors.");
            delete chainInfo.coinType;
          }
          return new Promise((resolve, reject) => {
            let f6 = false;
            (0, router_1.sendSimpleMessage)(this.requester, router_1.BACKGROUND_PORT, "chains", "need-suggest-chain-info-interaction", {
              chainInfo
            }).then((needInteraction) => {
              if (!needInteraction) {
                f6 = true;
              }
              (0, router_1.sendSimpleMessage)(this.requester, router_1.BACKGROUND_PORT, "chains", "suggest-chain-info", {
                chainInfo
              }).then(resolve).catch(reject).finally(() => f6 = true);
              setTimeout(() => {
                if (!f6) {
                  this.protectedTryOpenSidePanelIfEnabled();
                }
              }, 300);
            });
          });
        });
      }
      getKey(chainId) {
        return __awaiter(this, void 0, void 0, function* () {
          return new Promise((resolve, reject) => {
            let f6 = false;
            (0, router_1.sendSimpleMessage)(this.requester, router_1.BACKGROUND_PORT, "keyring-cosmos", "get-cosmos-key", {
              chainId
            }).then(resolve).catch(reject).finally(() => f6 = true);
            setTimeout(() => {
              if (!f6) {
                this.protectedTryOpenSidePanelIfEnabled();
              }
            }, 300);
          });
        });
      }
      getKeysSettled(chainIds) {
        return __awaiter(this, void 0, void 0, function* () {
          return new Promise((resolve, reject) => {
            let f6 = false;
            (0, router_1.sendSimpleMessage)(this.requester, router_1.BACKGROUND_PORT, "keyring-cosmos", "get-cosmos-keys-settled", {
              chainIds
            }).then(resolve).catch(reject).finally(() => f6 = true);
            setTimeout(() => {
              if (!f6) {
                this.protectedTryOpenSidePanelIfEnabled();
              }
            }, 300);
          });
        });
      }
      getChainInfosWithoutEndpoints() {
        return __awaiter(this, void 0, void 0, function* () {
          return new Promise((resolve, reject) => {
            let f6 = false;
            (0, router_1.sendSimpleMessage)(this.requester, router_1.BACKGROUND_PORT, "chains", "get-chain-infos-without-endpoints", {}).then((r3) => resolve(r3.chainInfos)).catch(reject).finally(() => f6 = true);
            setTimeout(() => {
              if (!f6) {
                this.protectedTryOpenSidePanelIfEnabled();
              }
            }, 300);
          });
        });
      }
      getChainInfoWithoutEndpoints(chainId) {
        return __awaiter(this, void 0, void 0, function* () {
          return new Promise((resolve, reject) => {
            let f6 = false;
            (0, router_1.sendSimpleMessage)(this.requester, router_1.BACKGROUND_PORT, "chains", "get-chain-info-without-endpoints", {
              chainId
            }).then((r3) => resolve(r3.chainInfo)).catch(reject).finally(() => f6 = true);
            setTimeout(() => {
              if (!f6) {
                this.protectedTryOpenSidePanelIfEnabled();
              }
            }, 300);
          });
        });
      }
      sendTx(chainId, tx, mode) {
        return __awaiter(this, void 0, void 0, function* () {
          yield this.enable(chainId);
          return yield (0, router_1.sendSimpleMessage)(this.requester, router_1.BACKGROUND_PORT, "background-tx", "send-tx-to-background", {
            chainId,
            tx,
            mode
          });
        });
      }
      signAmino(chainId, signer, signDoc, signOptions = {}) {
        return __awaiter(this, void 0, void 0, function* () {
          return new Promise((resolve, reject) => {
            var _a2;
            let f6 = false;
            (0, router_1.sendSimpleMessage)(this.requester, router_1.BACKGROUND_PORT, "keyring-cosmos", "request-cosmos-sign-amino", {
              chainId,
              signer,
              signDoc,
              signOptions: (0, deepmerge_1.default)((_a2 = this.defaultOptions.sign) !== null && _a2 !== void 0 ? _a2 : {}, signOptions)
            }).then(resolve).catch(reject).finally(() => f6 = true);
            setTimeout(() => {
              if (!f6) {
                this.protectedTryOpenSidePanelIfEnabled();
              }
            }, 300);
          });
        });
      }
      signDirect(chainId, signer, signDoc, signOptions = {}) {
        return __awaiter(this, void 0, void 0, function* () {
          return new Promise((resolve, reject) => {
            var _a2;
            let f6 = false;
            (0, router_1.sendSimpleMessage)(this.requester, router_1.BACKGROUND_PORT, "keyring-cosmos", "request-cosmos-sign-direct", {
              chainId,
              signer,
              signDoc: {
                bodyBytes: signDoc.bodyBytes,
                authInfoBytes: signDoc.authInfoBytes,
                chainId: signDoc.chainId,
                accountNumber: signDoc.accountNumber ? signDoc.accountNumber.toString() : null
              },
              signOptions: (0, deepmerge_1.default)((_a2 = this.defaultOptions.sign) !== null && _a2 !== void 0 ? _a2 : {}, signOptions)
            }).then((r3) => resolve({
              signed: {
                bodyBytes: r3.signed.bodyBytes,
                authInfoBytes: r3.signed.authInfoBytes,
                chainId: r3.signed.chainId,
                accountNumber: long_1.default.fromString(r3.signed.accountNumber)
              },
              signature: r3.signature
            })).catch(reject).finally(() => f6 = true);
            setTimeout(() => {
              if (!f6) {
                this.protectedTryOpenSidePanelIfEnabled();
              }
            }, 300);
          });
        });
      }
      signDirectAux(chainId, signer, signDoc, signOptions = {}) {
        return __awaiter(this, void 0, void 0, function* () {
          return new Promise((resolve, reject) => {
            var _a2;
            let f6 = false;
            (0, router_1.sendSimpleMessage)(this.requester, router_1.BACKGROUND_PORT, "keyring-cosmos", "request-cosmos-sign-direct-aux", {
              chainId,
              signer,
              signDoc: {
                bodyBytes: signDoc.bodyBytes,
                publicKey: signDoc.publicKey,
                chainId: signDoc.chainId,
                accountNumber: signDoc.accountNumber ? signDoc.accountNumber.toString() : null,
                sequence: signDoc.sequence ? signDoc.sequence.toString() : null
              },
              signOptions: (0, deepmerge_1.default)({
                preferNoSetMemo: (_a2 = this.defaultOptions.sign) === null || _a2 === void 0 ? void 0 : _a2.preferNoSetMemo
              }, signOptions)
            }).then((r3) => resolve({
              signed: {
                bodyBytes: r3.signed.bodyBytes,
                publicKey: r3.signed.publicKey,
                chainId: r3.signed.chainId,
                accountNumber: long_1.default.fromString(r3.signed.accountNumber),
                sequence: long_1.default.fromString(r3.signed.sequence)
              },
              signature: r3.signature
            })).catch(reject).finally(() => f6 = true);
            setTimeout(() => {
              if (!f6) {
                this.protectedTryOpenSidePanelIfEnabled();
              }
            }, 300);
          });
        });
      }
      signArbitrary(chainId, signer, data) {
        return __awaiter(this, void 0, void 0, function* () {
          return new Promise((resolve, reject) => {
            let f6 = false;
            (0, router_1.sendSimpleMessage)(this.requester, router_1.BACKGROUND_PORT, "keyring-cosmos", "request-cosmos-sign-amino-adr-36", {
              chainId,
              signer,
              data: typeof data === "string" ? buffer_1.Buffer.from(data) : data,
              signOptions: {
                isADR36WithString: typeof data === "string"
              }
            }).then(resolve).catch(reject).finally(() => f6 = true);
            setTimeout(() => {
              if (!f6) {
                this.protectedTryOpenSidePanelIfEnabled();
              }
            }, 300);
          });
        });
      }
      verifyArbitrary(chainId, signer, data, signature) {
        return __awaiter(this, void 0, void 0, function* () {
          if (typeof data === "string") {
            data = buffer_1.Buffer.from(data);
          }
          return new Promise((resolve, reject) => {
            let f6 = false;
            (0, router_1.sendSimpleMessage)(this.requester, router_1.BACKGROUND_PORT, "keyring-cosmos", "verify-cosmos-sign-amino-adr-36", {
              chainId,
              signer,
              data,
              signature
            }).then(resolve).catch(reject).finally(() => f6 = true);
            setTimeout(() => {
              if (!f6) {
                this.protectedTryOpenSidePanelIfEnabled();
              }
            }, 300);
          });
        });
      }
      signEthereum(chainId, signer, message, signType) {
        return __awaiter(this, void 0, void 0, function* () {
          return new Promise((resolve, reject) => {
            let f6 = false;
            (0, router_1.sendSimpleMessage)(this.requester, router_1.BACKGROUND_PORT, "keyring-ethereum", "request-sign-ethereum", {
              chainId,
              signer,
              message: typeof message === "string" ? buffer_1.Buffer.from(message) : message,
              signType
            }).then(resolve).catch(reject).finally(() => f6 = true);
            setTimeout(() => {
              if (!f6) {
                this.protectedTryOpenSidePanelIfEnabled();
              }
            }, 300);
          });
        });
      }
      signICNSAdr36(chainId, contractAddress, owner, username, addressChainIds) {
        return __awaiter(this, void 0, void 0, function* () {
          return new Promise((resolve, reject) => {
            let f6 = false;
            (0, router_1.sendSimpleMessage)(this.requester, router_1.BACKGROUND_PORT, "keyring-cosmos", "request-icns-adr-36-signatures-v2", {
              chainId,
              contractAddress,
              owner,
              username,
              addressChainIds
            }).then(resolve).catch(reject).finally(() => f6 = true);
            setTimeout(() => {
              if (!f6) {
                this.protectedTryOpenSidePanelIfEnabled();
              }
            }, 300);
          });
        });
      }
      getOfflineSigner(chainId, signOptions) {
        return new cosmjs_1.CosmJSOfflineSigner(chainId, this, signOptions);
      }
      getOfflineSignerOnlyAmino(chainId, signOptions) {
        return new cosmjs_1.CosmJSOfflineSignerOnlyAmino(chainId, this, signOptions);
      }
      getOfflineSignerAuto(chainId, signOptions) {
        return __awaiter(this, void 0, void 0, function* () {
          const key = yield this.getKey(chainId);
          if (key.isNanoLedger) {
            return new cosmjs_1.CosmJSOfflineSignerOnlyAmino(chainId, this, signOptions);
          }
          return new cosmjs_1.CosmJSOfflineSigner(chainId, this, signOptions);
        });
      }
      suggestToken(chainId, contractAddress, viewingKey) {
        return __awaiter(this, void 0, void 0, function* () {
          return new Promise((resolve, reject) => {
            let f6 = false;
            (0, router_1.sendSimpleMessage)(this.requester, router_1.BACKGROUND_PORT, "token-cw20", "SuggestTokenMsg", {
              chainId,
              contractAddress,
              viewingKey
            }).then(resolve).catch(reject).finally(() => f6 = true);
            setTimeout(() => {
              if (!f6) {
                this.protectedTryOpenSidePanelIfEnabled();
              }
            }, 300);
          });
        });
      }
      getSecret20ViewingKey(chainId, contractAddress) {
        return __awaiter(this, void 0, void 0, function* () {
          return new Promise((resolve, reject) => {
            let f6 = false;
            (0, router_1.sendSimpleMessage)(this.requester, router_1.BACKGROUND_PORT, "token-cw20", "get-secret20-viewing-key", {
              chainId,
              contractAddress
            }).then(resolve).catch(reject).finally(() => f6 = true);
            setTimeout(() => {
              if (!f6) {
                this.protectedTryOpenSidePanelIfEnabled();
              }
            }, 300);
          });
        });
      }
      getEnigmaPubKey(chainId) {
        return __awaiter(this, void 0, void 0, function* () {
          return new Promise((resolve, reject) => {
            let f6 = false;
            (0, router_1.sendSimpleMessage)(this.requester, router_1.BACKGROUND_PORT, "secret-wasm", "get-pubkey-msg", {
              chainId
            }).then(resolve).catch(reject).finally(() => f6 = true);
            setTimeout(() => {
              if (!f6) {
                this.protectedTryOpenSidePanelIfEnabled();
              }
            }, 300);
          });
        });
      }
      getEnigmaTxEncryptionKey(chainId, nonce) {
        return __awaiter(this, void 0, void 0, function* () {
          return new Promise((resolve, reject) => {
            let f6 = false;
            (0, router_1.sendSimpleMessage)(this.requester, router_1.BACKGROUND_PORT, "secret-wasm", "get-tx-encryption-key-msg", {
              chainId,
              nonce
            }).then(resolve).catch(reject).finally(() => f6 = true);
            setTimeout(() => {
              if (!f6) {
                this.protectedTryOpenSidePanelIfEnabled();
              }
            }, 300);
          });
        });
      }
      enigmaEncrypt(chainId, contractCodeHash, msg) {
        return __awaiter(this, void 0, void 0, function* () {
          return new Promise((resolve, reject) => {
            let f6 = false;
            (0, router_1.sendSimpleMessage)(this.requester, router_1.BACKGROUND_PORT, "secret-wasm", "request-encrypt-msg", {
              chainId,
              contractCodeHash,
              msg
            }).then(resolve).catch(reject).finally(() => f6 = true);
            setTimeout(() => {
              if (!f6) {
                this.protectedTryOpenSidePanelIfEnabled();
              }
            }, 300);
          });
        });
      }
      enigmaDecrypt(chainId, cipherText, nonce) {
        return __awaiter(this, void 0, void 0, function* () {
          if (!cipherText || cipherText.length === 0) {
            return new Uint8Array();
          }
          return new Promise((resolve, reject) => {
            let f6 = false;
            (0, router_1.sendSimpleMessage)(this.requester, router_1.BACKGROUND_PORT, "secret-wasm", "request-decrypt-msg", {
              chainId,
              cipherText,
              nonce
            }).then(resolve).catch(reject).finally(() => f6 = true);
            setTimeout(() => {
              if (!f6) {
                this.protectedTryOpenSidePanelIfEnabled();
              }
            }, 300);
          });
        });
      }
      getEnigmaUtils(chainId) {
        if (this.enigmaUtils.has(chainId)) {
          return this.enigmaUtils.get(chainId);
        }
        const enigmaUtils = new enigma_1.KeplrEnigmaUtils(chainId, this);
        this.enigmaUtils.set(chainId, enigmaUtils);
        return enigmaUtils;
      }
      experimentalSignEIP712CosmosTx_v0(chainId, signer, eip712, signDoc, signOptions = {}) {
        return __awaiter(this, void 0, void 0, function* () {
          return new Promise((resolve, reject) => {
            var _a2;
            let f6 = false;
            (0, router_1.sendSimpleMessage)(this.requester, router_1.BACKGROUND_PORT, "keyring-cosmos", "request-sign-eip-712-cosmos-tx-v0", {
              chainId,
              signer,
              eip712,
              signDoc,
              signOptions: (0, deepmerge_1.default)((_a2 = this.defaultOptions.sign) !== null && _a2 !== void 0 ? _a2 : {}, signOptions)
            }).then(resolve).catch(reject).finally(() => f6 = true);
            setTimeout(() => {
              if (!f6) {
                this.protectedTryOpenSidePanelIfEnabled();
              }
            }, 300);
          });
        });
      }
      __core__getAnalyticsId() {
        return __awaiter(this, void 0, void 0, function* () {
          return yield (0, router_1.sendSimpleMessage)(this.requester, router_1.BACKGROUND_PORT, "analytics", "get-analytics-id", {});
        });
      }
      changeKeyRingName({ defaultName, editable = true }) {
        return __awaiter(this, void 0, void 0, function* () {
          return new Promise((resolve, reject) => {
            let f6 = false;
            (0, router_1.sendSimpleMessage)(this.requester, router_1.BACKGROUND_PORT, "keyring-v2", "change-keyring-name-interactive", {
              defaultName,
              editable
            }).then(resolve).catch(reject).finally(() => f6 = true);
            setTimeout(() => {
              if (!f6) {
                this.protectedTryOpenSidePanelIfEnabled();
              }
            }, 300);
          });
        });
      }
      __core__privilageSignAminoWithdrawRewards(chainId, signer, signDoc) {
        return __awaiter(this, void 0, void 0, function* () {
          return yield (0, router_1.sendSimpleMessage)(this.requester, router_1.BACKGROUND_PORT, "keyring-cosmos", "PrivilegeCosmosSignAminoWithdrawRewards", {
            chainId,
            signer,
            signDoc
          });
        });
      }
      __core__privilageSignAminoDelegate(chainId, signer, signDoc) {
        return __awaiter(this, void 0, void 0, function* () {
          return yield (0, router_1.sendSimpleMessage)(this.requester, router_1.BACKGROUND_PORT, "keyring-cosmos", "PrivilegeCosmosSignAminoDelegate", {
            chainId,
            signer,
            signDoc
          });
        });
      }
      __core__privilageSignAminoExecuteCosmWasm(chainId, signer, signDoc) {
        return __awaiter(this, void 0, void 0, function* () {
          return yield (0, router_1.sendSimpleMessage)(this.requester, router_1.BACKGROUND_PORT, "keyring-cosmos", "PrivilegeCosmosSignAminoExecuteCosmWasm", {
            chainId,
            signer,
            signDoc
          });
        });
      }
      sendEthereumTx(chainId, tx) {
        return __awaiter(this, void 0, void 0, function* () {
          yield this.enable(chainId);
          return yield (0, router_1.sendSimpleMessage)(this.requester, router_1.BACKGROUND_PORT, "background-tx-ethereum", "send-ethereum-tx-to-background", {
            chainId,
            tx
          });
        });
      }
      suggestERC20(chainId, contractAddress) {
        return __awaiter(this, void 0, void 0, function* () {
          return new Promise((resolve, reject) => {
            let f6 = false;
            (0, router_1.sendSimpleMessage)(this.requester, router_1.BACKGROUND_PORT, "token-erc20", "SuggestERC20TokenMsg", {
              chainId,
              contractAddress
            }).then(resolve).catch(reject).finally(() => f6 = true);
            setTimeout(() => {
              if (!f6) {
                this.protectedTryOpenSidePanelIfEnabled();
              }
            }, 300);
          });
        });
      }
      __core__webpageClosed() {
        return __awaiter(this, void 0, void 0, function* () {
          yield (0, router_1.sendSimpleMessage)(this.requester, router_1.BACKGROUND_PORT, "interaction", "injected-webpage-closed", {});
        });
      }
      getStarknetKey(chainId) {
        return __awaiter(this, void 0, void 0, function* () {
          return new Promise((resolve, reject) => {
            let f6 = false;
            (0, router_1.sendSimpleMessage)(this.requester, router_1.BACKGROUND_PORT, "keyring-starknet", "get-starknet-key", {
              chainId
            }).then(resolve).catch(reject).finally(() => f6 = true);
            setTimeout(() => {
              if (!f6) {
                this.protectedTryOpenSidePanelIfEnabled();
              }
            }, 300);
          });
        });
      }
      getStarknetKeysSettled(chainIds) {
        return __awaiter(this, void 0, void 0, function* () {
          return new Promise((resolve, reject) => {
            let f6 = false;
            (0, router_1.sendSimpleMessage)(this.requester, router_1.BACKGROUND_PORT, "keyring-starknet", "get-starknet-keys-settled", {
              chainIds
            }).then(resolve).catch(reject).finally(() => f6 = true);
            setTimeout(() => {
              if (!f6) {
                this.protectedTryOpenSidePanelIfEnabled();
              }
            }, 300);
          });
        });
      }
      signStarknetTx(chainId, transactions, details) {
        return __awaiter(this, void 0, void 0, function* () {
          return new Promise((resolve, reject) => {
            let f6 = false;
            (0, router_1.sendSimpleMessage)(this.requester, router_1.BACKGROUND_PORT, "keyring-starknet", "request-sign-starknet-tx", {
              chainId,
              transactions,
              details
            }).then(resolve).catch(reject).finally(() => f6 = true);
            setTimeout(() => {
              if (!f6) {
                this.protectedTryOpenSidePanelIfEnabled();
              }
            }, 300);
          });
        });
      }
      signStarknetDeployAccountTransaction(chainId, transaction2) {
        return __awaiter(this, void 0, void 0, function* () {
          return new Promise((resolve, reject) => {
            let f6 = false;
            (0, router_1.sendSimpleMessage)(this.requester, router_1.BACKGROUND_PORT, "keyring-starknet", "request-sign-starknet-deploy-account-tx", {
              chainId,
              transaction: transaction2
            }).then(resolve).catch(reject).finally(() => f6 = true);
            setTimeout(() => {
              if (!f6) {
                this.protectedTryOpenSidePanelIfEnabled();
              }
            });
          });
        });
      }
      getBitcoinKey(chainId) {
        return __awaiter(this, void 0, void 0, function* () {
          return new Promise((resolve, reject) => {
            let f6 = false;
            (0, router_1.sendSimpleMessage)(this.requester, router_1.BACKGROUND_PORT, "keyring-bitcoin", "get-bitcoin-key", {
              chainId
            }).then(resolve).catch(reject).finally(() => f6 = true);
            setTimeout(() => {
              if (!f6) {
                this.protectedTryOpenSidePanelIfEnabled();
              }
            }, 300);
          });
        });
      }
      getBitcoinKeysSettled(chainIds) {
        return __awaiter(this, void 0, void 0, function* () {
          return new Promise((resolve, reject) => {
            let f6 = false;
            (0, router_1.sendSimpleMessage)(this.requester, router_1.BACKGROUND_PORT, "keyring-bitcoin", "get-bitcoin-keys-settled", {
              chainIds
            }).then(resolve).catch(reject).finally(() => f6 = true);
            setTimeout(() => {
              if (!f6) {
                this.protectedTryOpenSidePanelIfEnabled();
              }
            }, 300);
          });
        });
      }
      signPsbt(chainId, psbtHex, options) {
        return __awaiter(this, void 0, void 0, function* () {
          return yield (0, router_1.sendSimpleMessage)(this.requester, router_1.BACKGROUND_PORT, "keyring-bitcoin", "request-sign-bitcoin-psbt", {
            chainId,
            psbtHex,
            options
          });
        });
      }
      signPsbts(chainId, psbtsHexes, options) {
        return __awaiter(this, void 0, void 0, function* () {
          return yield (0, router_1.sendSimpleMessage)(this.requester, router_1.BACKGROUND_PORT, "keyring-bitcoin", "request-sign-bitcoin-psbts", {
            chainId,
            psbtsHexes,
            options
          });
        });
      }
      // IMPORTANT: protected  method InjectedKeplr.startProxy() injected  event system    .
      //            protected   method injected keplr  event system     .
      //               method  protected  .
      protectedTryOpenSidePanelIfEnabled(ignoreGestureFailure = false) {
        return __awaiter(this, void 0, void 0, function* () {
          let isInContentScript = false;
          if (typeof window !== "undefined" && window.__keplr_content_script === true) {
            isInContentScript = true;
          }
          if (isInContentScript) {
            const isEnabled = yield (0, router_1.sendSimpleMessage)(this.requester, router_1.BACKGROUND_PORT, "side-panel", "GetSidePanelEnabledMsg", {});
            if (isEnabled.enabled) {
              try {
                return yield (0, router_1.sendSimpleMessage)(this.requester, router_1.BACKGROUND_PORT, "router-extension/src/router/extension.ts", "tryOpenSidePanelIfEnabled", {});
              } catch (e2) {
                console.log(e2);
                if (!ignoreGestureFailure && e2.message && e2.message.includes("in response to a user gesture")) {
                  if (!document.getElementById("__open_keplr_side_panel__")) {
                    const sidePanelPing = yield (0, router_1.sendSimpleMessage)(this.requester, router_1.BACKGROUND_PORT, "interaction", "ping-content-script-tab-has-opened-side-panel", {});
                    if (sidePanelPing) {
                      return;
                    }
                    const isKeplrLocked = yield (0, router_1.sendSimpleMessage)(this.requester, router_1.BACKGROUND_PORT, "keyring", "GetIsLockedMsg", {});
                    const keplrThemeOption = yield (0, router_1.sendSimpleMessage)(this.requester, router_1.BACKGROUND_PORT, "settings", "GetThemeOptionMsg", {});
                    const fontUrl = chrome.runtime.getURL("/assets/Inter-SemiBold.ttf");
                    const fontFaceAndKeyFrames = `
                @font-face {
                  font-family: 'Inter-SemiBold-Keplr';
                  src: url('${fontUrl}') format('truetype');
                  font-weight: 600;
                  font-style: normal;
                }

                @keyframes slide-left {
                  0% {
                    transform: translateY(0%) translateX(100%);
                  }
                  100% {
                    transform: translateY(0%) translateX(0);
                  }
                }
                    
                @keyframes tada {
                  0% {
                    transform: scale3d(1, 1, 1);
                  }
                  10%, 20% {
                    transform: scale3d(.9, .9, .9) rotate3d(0, 0, 1, -3deg);
                  }
                  30%, 50%, 70%, 90% {
                    transform: scale3d(1.1, 1.1, 1.1) rotate3d(0, 0, 1, 3deg);
                  }
                  40%, 60%, 80% {
                    transform: scale3d(1.1, 1.1, 1.1) rotate3d(0, 0, 1, -3deg);
                  }
                  100% {
                    transform: scale3d(1, 1, 1);
                  }
                }
                  
            `;
                    const isLightMode = keplrThemeOption === "auto" ? !window.matchMedia("(prefers-color-scheme: dark)").matches : keplrThemeOption === "light";
                    const styleElement = document.createElement("style");
                    styleElement.appendChild(document.createTextNode(fontFaceAndKeyFrames));
                    document.head.appendChild(styleElement);
                    const button = document.createElement("div");
                    button.id = "__open_keplr_side_panel__";
                    button.style.boxSizing = "border-box";
                    button.style.animation = "slide-left 0.5s forwards";
                    button.style.position = "fixed";
                    button.style.right = "1.5rem";
                    button.style.top = "1.5rem";
                    button.style.padding = "1rem 1.75rem 1rem 0.75rem";
                    button.style.zIndex = "2147483647";
                    button.style.borderRadius = "1rem";
                    button.style.display = "flex";
                    button.style.alignItems = "center";
                    button.style.fontFamily = "Inter-SemiBold-Keplr";
                    button.style.fontWeight = "600";
                    button.style.background = isLightMode ? "#FEFEFE" : "#1D1D1F";
                    const arrowTop = document.createElement("div");
                    arrowTop.style.boxSizing = "border-box";
                    arrowTop.style.transform = "translateY(-0.65rem)";
                    arrowTop.style.marginRight = "0.35rem";
                    arrowTop.innerHTML = `
                <svg width="31" height="31" viewBox="0 0 31 31" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <path d="M30 29.7522C25.1484 31.0691 16.7109 27.1184 18.6093 18.3391C20.5078 9.55979 25.5703 11.5351 26.414 12.852C27.2578 14.1689 28.3125 22.2898 15.8672 19.2171C5.9109 16.7589 7.15625 6.04811 8 1M8 1L14 8M8 1L1 7.5" stroke="${isLightMode ? "#2C4BE2" : "#72747B"}"/>
                </svg>
              `;
                    const keplrLogoWrap = document.createElement("div");
                    keplrLogoWrap.style.boxSizing = "border-box";
                    keplrLogoWrap.style.position = "relative";
                    keplrLogoWrap.style.marginRight = "1rem";
                    const keplrLogo = document.createElement("img");
                    const keplrLogoUrl = chrome.runtime.getURL(`/assets/${isKeplrLocked ? "locked-keplr-logo" : "icon"}-128.png`);
                    keplrLogo.src = keplrLogoUrl;
                    keplrLogo.style.boxSizing = "border-box";
                    keplrLogo.style.width = "3rem";
                    keplrLogo.style.height = "3rem";
                    keplrLogoWrap.appendChild(keplrLogo);
                    const logoClickCursor = document.createElement("img");
                    const logoClickCursorUrl = chrome.runtime.getURL("assets/icon-click-cursor.png");
                    logoClickCursor.src = logoClickCursorUrl;
                    logoClickCursor.style.boxSizing = "border-box";
                    logoClickCursor.style.position = "absolute";
                    logoClickCursor.style.right = "-0.2rem";
                    logoClickCursor.style.bottom = "-0.2rem";
                    logoClickCursor.style.aspectRatio = "78/98";
                    logoClickCursor.style.height = "1.375rem";
                    keplrLogoWrap.appendChild(logoClickCursor);
                    const mainText = document.createElement("span");
                    mainText.style.boxSizing = "border-box";
                    mainText.style.fontSize = "1rem";
                    mainText.style.color = isLightMode ? "#020202" : "#FEFEFE";
                    mainText.textContent = isKeplrLocked ? "Unlock Keplr to proceed" : "Open Keplr to approve request(s)";
                    button.appendChild(arrowTop);
                    button.appendChild(keplrLogoWrap);
                    button.appendChild(mainText);
                    const hasAlready = document.getElementById("__open_keplr_side_panel__");
                    if (!hasAlready) {
                      let removed = false;
                      const intervalId = setInterval(() => {
                        (0, router_1.sendSimpleMessage)(this.requester, router_1.BACKGROUND_PORT, "interaction", "ping-content-script-tab-has-opened-side-panel", {}).then((sidePanelPing2) => {
                          if (sidePanelPing2) {
                            clearInterval(intervalId);
                            if (!removed) {
                              button.remove();
                              removed = true;
                            }
                          }
                        });
                      }, 300);
                      document.body.appendChild(button);
                    }
                  }
                }
              }
            }
          }
        });
      }
    };
    exports.Keplr = Keplr3;
    var sidePanelOpenNeededJSONRPCMethods = [
      "eth_signTransaction",
      "eth_sendTransaction",
      "personal_sign",
      "eth_signTypedData_v3",
      "eth_signTypedData_v4",
      "wallet_addEthereumChain",
      "wallet_switchEthereumChain",
      "wallet_watchAsset"
    ];
    var EthereumProvider = class extends events_1.default {
      constructor(keplr, requester) {
        super();
        this.keplr = keplr;
        this.requester = requester;
        this.chainId = null;
        this.selectedAddress = null;
        this.networkVersion = null;
        this.isKeplr = true;
        this.isMetaMask = true;
      }
      protectedEnableAccess(newCurrentChainId) {
        return __awaiter(this, void 0, void 0, function* () {
          return new Promise((resolve, reject) => {
            let f6 = false;
            (0, router_1.sendSimpleMessage)(this.requester, router_1.BACKGROUND_PORT, "permission-interactive", "enable-access-for-evm", {
              chainId: newCurrentChainId
            }).then(resolve).catch(reject).finally(() => f6 = true);
            setTimeout(() => {
              if (!f6) {
                this.keplr.protectedTryOpenSidePanelIfEnabled();
              }
            }, 300);
          });
        });
      }
      protectedGetNewCurrentChainIdFromRequest(method, params) {
        return __awaiter(this, void 0, void 0, function* () {
          return yield (0, router_1.sendSimpleMessage)(this.requester, router_1.BACKGROUND_PORT, "keyring-ethereum", "get-new-current-chain-id-for-evm", {
            method,
            params
          });
        });
      }
      protectedCheckNeedEnableAccess(method) {
        return __awaiter(this, void 0, void 0, function* () {
          return yield (0, router_1.sendSimpleMessage)(this.requester, router_1.BACKGROUND_PORT, "keyring-ethereum", "check-need-enable-access-for-evm", {
            method
          });
        });
      }
      isConnected() {
        return true;
      }
      request({ method, params, providerId, chainId }) {
        return __awaiter(this, void 0, void 0, function* () {
          if (typeof method !== "string") {
            throw new Error("Invalid paramater: `method` must be a string");
          }
          if (yield this.protectedCheckNeedEnableAccess(method)) {
            const newCurrentChainId = yield this.protectedGetNewCurrentChainIdFromRequest(method, params);
            yield this.protectedEnableAccess(newCurrentChainId);
          }
          return new Promise((resolve, reject) => {
            let f6 = false;
            (0, router_1.sendSimpleMessage)(this.requester, router_1.BACKGROUND_PORT, "keyring-ethereum", "request-json-rpc-to-evm", {
              method,
              params,
              providerId,
              chainId
            }).then(resolve).catch(reject).finally(() => f6 = true);
            setTimeout(() => {
              if (!f6 && sidePanelOpenNeededJSONRPCMethods.includes(method)) {
                this.keplr.protectedTryOpenSidePanelIfEnabled();
              }
            }, 300);
          });
        });
      }
      /**
       * Legacy methods
       */
      enable() {
        return __awaiter(this, void 0, void 0, function* () {
          return yield this.request({ method: "eth_requestAccounts" });
        });
      }
      net_version() {
        return __awaiter(this, void 0, void 0, function* () {
          return yield this.request({ method: "net_version" });
        });
      }
    };
    var sidePanelOpenNeededStarknetJSONRPCMethods = [
      "wallet_watchAsset",
      "wallet_switchStarknetChain",
      "wallet_addInvokeTransaction",
      "wallet_addDeclareTransaction",
      "wallet_signTypedData"
    ];
    var StarknetProvider = class {
      constructor(keplr, requester) {
        this.keplr = keplr;
        this.requester = requester;
        this.id = "";
        this.name = "";
        this.version = "";
        this.icon = "";
        this.isConnected = false;
      }
      protectedEnableAccess(newCurrentChainId) {
        return __awaiter(this, void 0, void 0, function* () {
          return new Promise((resolve, reject) => {
            let f6 = false;
            (0, router_1.sendSimpleMessage)(this.requester, router_1.BACKGROUND_PORT, "permission-interactive", "enable-access-for-starknet", {
              chainId: newCurrentChainId
            }).then(resolve).catch(reject).finally(() => f6 = true);
            setTimeout(() => {
              if (!f6) {
                this.keplr.protectedTryOpenSidePanelIfEnabled();
              }
            }, 300);
          });
        });
      }
      protectedGetNewCurrentChainIdFromRequest(method, params) {
        return __awaiter(this, void 0, void 0, function* () {
          return yield (0, router_1.sendSimpleMessage)(this.requester, router_1.BACKGROUND_PORT, "keyring-starknet", "get-new-current-chain-id-for-starknet", {
            method,
            params
          });
        });
      }
      protectedCheckNeedEnableAccess(method, params) {
        return __awaiter(this, void 0, void 0, function* () {
          return yield (0, router_1.sendSimpleMessage)(this.requester, router_1.BACKGROUND_PORT, "keyring-starknet", "check-need-enable-access-for-starknet", {
            method,
            params
          });
        });
      }
      request({ type, params }) {
        return __awaiter(this, void 0, void 0, function* () {
          if (typeof type !== "string") {
            throw new Error("Invalid parameter: `type` must be a string");
          }
          if (yield this.protectedCheckNeedEnableAccess(type, params)) {
            const newCurrentChainId = yield this.protectedGetNewCurrentChainIdFromRequest(type, params);
            yield this.protectedEnableAccess(newCurrentChainId);
          }
          return new Promise((resolve, reject) => {
            let f6 = false;
            (0, router_1.sendSimpleMessage)(this.requester, router_1.BACKGROUND_PORT, "keyring-starknet", "request-json-rpc-to-starknet", {
              //  type    method .
              method: type,
              params
            }).then(resolve).catch(reject).finally(() => f6 = true);
            setTimeout(() => {
              if (!f6 && sidePanelOpenNeededStarknetJSONRPCMethods.includes(type)) {
                this.keplr.protectedTryOpenSidePanelIfEnabled();
              }
            }, 300);
          });
        });
      }
      enable(_options) {
        return __awaiter(this, void 0, void 0, function* () {
          throw new Error("Method not implemented.");
        });
      }
      isPreauthorized() {
        throw new Error("Method not implemented.");
      }
      on(_event, _handleEvent) {
        throw new Error("Method not implemented.");
      }
      off(_event, _handleEvent) {
        throw new Error("Method not implemented.");
      }
    };
    var BitcoinProvider = class extends events_1.default {
      constructor(keplr, requester) {
        super();
        this.keplr = keplr;
        this.requester = requester;
      }
      protectedEnableAccess() {
        return __awaiter(this, void 0, void 0, function* () {
          return new Promise((resolve, reject) => {
            let f6 = false;
            (0, router_1.sendSimpleMessage)(this.requester, router_1.BACKGROUND_PORT, "permission-interactive", "enable-access-for-bitcoin", {}).then(resolve).catch(reject).finally(() => f6 = true);
            setTimeout(() => {
              if (!f6) {
                this.keplr.protectedTryOpenSidePanelIfEnabled();
              }
            }, 300);
          });
        });
      }
      getAccounts() {
        return __awaiter(this, void 0, void 0, function* () {
          return yield (0, router_1.sendSimpleMessage)(this.requester, router_1.BACKGROUND_PORT, "keyring-bitcoin", "request-bitcoin-get-accounts", {});
        });
      }
      requestAccounts() {
        return __awaiter(this, void 0, void 0, function* () {
          yield this.protectedEnableAccess();
          return yield (0, router_1.sendSimpleMessage)(this.requester, router_1.BACKGROUND_PORT, "keyring-bitcoin", "request-bitcoin-request-accounts", {});
        });
      }
      disconnect() {
        return __awaiter(this, void 0, void 0, function* () {
          return yield (0, router_1.sendSimpleMessage)(this.requester, router_1.BACKGROUND_PORT, "keyring-bitcoin", "request-bitcoin-disconnect", {});
        });
      }
      getNetwork() {
        return __awaiter(this, void 0, void 0, function* () {
          yield this.protectedEnableAccess();
          return yield (0, router_1.sendSimpleMessage)(this.requester, router_1.BACKGROUND_PORT, "keyring-bitcoin", "request-bitcoin-get-network", {});
        });
      }
      switchNetwork(network) {
        return __awaiter(this, void 0, void 0, function* () {
          return new Promise((resolve, reject) => {
            let f6 = false;
            (0, router_1.sendSimpleMessage)(this.requester, router_1.BACKGROUND_PORT, "keyring-bitcoin", "request-bitcoin-switch-network", {
              network
            }).then(resolve).catch(reject).finally(() => f6 = true);
            setTimeout(() => {
              if (!f6) {
                this.keplr.protectedTryOpenSidePanelIfEnabled();
              }
            }, 300);
          });
        });
      }
      getChain() {
        return __awaiter(this, void 0, void 0, function* () {
          yield this.protectedEnableAccess();
          return yield (0, router_1.sendSimpleMessage)(this.requester, router_1.BACKGROUND_PORT, "keyring-bitcoin", "request-bitcoin-get-chain", {});
        });
      }
      switchChain(chain) {
        return __awaiter(this, void 0, void 0, function* () {
          return new Promise((resolve, reject) => {
            let f6 = false;
            (0, router_1.sendSimpleMessage)(this.requester, router_1.BACKGROUND_PORT, "keyring-bitcoin", "request-bitcoin-switch-chain", {
              chainType: chain
            }).then(resolve).catch(reject).finally(() => f6 = true);
            setTimeout(() => {
              if (!f6) {
                this.keplr.protectedTryOpenSidePanelIfEnabled();
              }
            }, 300);
          });
        });
      }
      getPublicKey() {
        return __awaiter(this, void 0, void 0, function* () {
          yield this.protectedEnableAccess();
          return yield (0, router_1.sendSimpleMessage)(this.requester, router_1.BACKGROUND_PORT, "keyring-bitcoin", "request-bitcoin-get-public-key", {});
        });
      }
      getBalance() {
        return __awaiter(this, void 0, void 0, function* () {
          yield this.protectedEnableAccess();
          return yield (0, router_1.sendSimpleMessage)(this.requester, router_1.BACKGROUND_PORT, "keyring-bitcoin", "request-bitcoin-get-balance", {});
        });
      }
      getInscriptions(offset, limit) {
        return __awaiter(this, void 0, void 0, function* () {
          yield this.protectedEnableAccess();
          return yield (0, router_1.sendSimpleMessage)(this.requester, router_1.BACKGROUND_PORT, "keyring-bitcoin", "request-bitcoin-get-inscriptions", {
            offset,
            limit
          });
        });
      }
      signMessage(message, signType) {
        return __awaiter(this, void 0, void 0, function* () {
          return new Promise((resolve, reject) => {
            let f6 = false;
            (0, router_1.sendSimpleMessage)(this.requester, router_1.BACKGROUND_PORT, "keyring-bitcoin", "request-sign-bitcoin-message", {
              message,
              signType
            }).then(resolve).catch(reject).finally(() => f6 = true);
            setTimeout(() => {
              if (!f6) {
                this.keplr.protectedTryOpenSidePanelIfEnabled();
              }
            }, 300);
          });
        });
      }
      sendBitcoin(to2, amount) {
        return __awaiter(this, void 0, void 0, function* () {
          return new Promise((resolve, reject) => {
            let f6 = false;
            (0, router_1.sendSimpleMessage)(this.requester, router_1.BACKGROUND_PORT, "keyring-bitcoin", "request-bitcoin-send-bitcoin", {
              to: to2,
              amount
            }).then(resolve).catch(reject).finally(() => f6 = true);
            setTimeout(() => {
              if (!f6) {
                this.keplr.protectedTryOpenSidePanelIfEnabled();
              }
            }, 300);
          });
        });
      }
      pushTx(rawTxHex) {
        return __awaiter(this, void 0, void 0, function* () {
          yield this.protectedEnableAccess();
          return yield (0, router_1.sendSimpleMessage)(this.requester, router_1.BACKGROUND_PORT, "keyring-bitcoin", "request-bitcoin-push-tx", {
            rawTxHex
          });
        });
      }
      pushPsbt(psbtHex) {
        return __awaiter(this, void 0, void 0, function* () {
          yield this.protectedEnableAccess();
          return yield (0, router_1.sendSimpleMessage)(this.requester, router_1.BACKGROUND_PORT, "keyring-bitcoin", "request-bitcoin-push-psbt", {
            psbtHex
          });
        });
      }
      signPsbt(psbtHex, options) {
        return __awaiter(this, void 0, void 0, function* () {
          return new Promise((resolve, reject) => {
            let f6 = false;
            (0, router_1.sendSimpleMessage)(this.requester, router_1.BACKGROUND_PORT, "keyring-bitcoin", "request-sign-bitcoin-psbt", {
              psbtHex,
              options
            }).then(resolve).catch(reject).finally(() => f6 = true);
            setTimeout(() => {
              if (!f6) {
                this.keplr.protectedTryOpenSidePanelIfEnabled();
              }
            }, 300);
          });
        });
      }
      signPsbts(psbtsHexes, options) {
        return __awaiter(this, void 0, void 0, function* () {
          return new Promise((resolve, reject) => {
            let f6 = false;
            (0, router_1.sendSimpleMessage)(this.requester, router_1.BACKGROUND_PORT, "keyring-bitcoin", "request-sign-bitcoin-psbts", {
              psbtsHexes,
              options
            }).then(resolve).catch(reject).finally(() => f6 = true);
            setTimeout(() => {
              if (!f6) {
                this.keplr.protectedTryOpenSidePanelIfEnabled();
              }
            }, 300);
          });
        });
      }
      getAddress() {
        return __awaiter(this, void 0, void 0, function* () {
          throw new Error("This method should not be called");
        });
      }
      connectWallet() {
        return __awaiter(this, void 0, void 0, function* () {
          throw new Error("This method should not be called");
        });
      }
    };
  }
});

// ../../node_modules/.pnpm/@keplr-wallet+provider@0.12.252_starknet@7.6.4/node_modules/@keplr-wallet/provider/build/inject.js
var require_inject = __commonJS({
  "../../node_modules/.pnpm/@keplr-wallet+provider@0.12.252_starknet@7.6.4/node_modules/@keplr-wallet/provider/build/inject.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P3, generator) {
      function adopt(value) {
        return value instanceof P3 ? value : new P3(function(resolve) {
          resolve(value);
        });
      }
      return new (P3 || (P3 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e2) {
            reject(e2);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e2) {
            reject(e2);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BitcoinProvider = exports.InjectedKeplr = exports.injectKeplrToWindow = void 0;
    var types_1 = require_build();
    var router_1 = require_build8();
    var enigma_1 = require_enigma2();
    var cosmjs_1 = require_cosmjs3();
    var deepmerge_1 = __importDefault(require_cjs());
    var long_1 = __importDefault(require_long());
    var events_1 = __importDefault(require_events());
    function defineUnwritablePropertyIfPossible(o4, p4, value) {
      const descriptor = Object.getOwnPropertyDescriptor(o4, p4);
      if (!descriptor || descriptor.writable) {
        if (!descriptor || descriptor.configurable) {
          Object.defineProperty(o4, p4, {
            value,
            writable: false
          });
        } else {
          o4[p4] = value;
        }
      } else {
        console.warn(`Failed to inject ${p4} from keplr. Probably, other wallet is trying to intercept Keplr`);
      }
    }
    function injectKeplrToWindow(keplr) {
      defineUnwritablePropertyIfPossible(window, "keplr", keplr);
      defineUnwritablePropertyIfPossible(window, "getOfflineSigner", keplr.getOfflineSigner);
      defineUnwritablePropertyIfPossible(window, "getOfflineSignerOnlyAmino", keplr.getOfflineSignerOnlyAmino);
      defineUnwritablePropertyIfPossible(window, "getOfflineSignerAuto", keplr.getOfflineSignerAuto);
      defineUnwritablePropertyIfPossible(window, "getEnigmaUtils", keplr.getEnigmaUtils);
      defineUnwritablePropertyIfPossible(window, "starknet_keplr", keplr.starknet);
      defineUnwritablePropertyIfPossible(window, "bitcoin_keplr", keplr.bitcoin);
    }
    exports.injectKeplrToWindow = injectKeplrToWindow;
    var InjectedKeplr = class _InjectedKeplr {
      static startProxy(keplr, metaId, eventListener = {
        addMessageListener: (fn2) => window.addEventListener("message", fn2),
        removeMessageListener: (fn2) => window.removeEventListener("message", fn2),
        postMessage: (message) => window.postMessage(message, window.location.origin)
      }, parseMessage) {
        const proxyRequestType = `proxy-request${metaId ? `-${metaId}` : ""}`;
        const fn2 = (e2) => __awaiter(this, void 0, void 0, function* () {
          const message = parseMessage ? parseMessage(e2.data) : e2.data;
          if (!message || // "proxy-request" legacy support  .
          message.type !== proxyRequestType && message.type !== "proxy-request") {
            return;
          }
          try {
            if (!message.id) {
              throw new Error("Empty id");
            }
            if (message.method.startsWith("protected")) {
              throw new Error("Rejected");
            }
            if (message.method === "version") {
              throw new Error("Version is not function");
            }
            if (message.method === "mode") {
              throw new Error("Mode is not function");
            }
            if (message.method === "defaultOptions") {
              throw new Error("DefaultOptions is not function");
            }
            if (!keplr[message.method] || message.method !== "ethereum" && message.method !== "starknet" && message.method !== "bitcoin" && typeof keplr[message.method] !== "function") {
              throw new Error(`Invalid method: ${message.method}`);
            }
            if (message.method === "getOfflineSigner") {
              throw new Error("GetOfflineSigner method can't be proxy request");
            }
            if (message.method === "getOfflineSignerOnlyAmino") {
              throw new Error("GetOfflineSignerOnlyAmino method can't be proxy request");
            }
            if (message.method === "getOfflineSignerAuto") {
              throw new Error("GetOfflineSignerAuto method can't be proxy request");
            }
            if (message.method === "getEnigmaUtils") {
              throw new Error("GetEnigmaUtils method can't be proxy request");
            }
            const method = message.method;
            const result = yield (() => __awaiter(this, void 0, void 0, function* () {
              var _a2, _b;
              if (method === "signDirect") {
                return yield (() => __awaiter(this, void 0, void 0, function* () {
                  const receivedSignDoc = message.args[2];
                  const result2 = yield keplr.signDirect(message.args[0], message.args[1], {
                    bodyBytes: receivedSignDoc.bodyBytes,
                    authInfoBytes: receivedSignDoc.authInfoBytes,
                    chainId: receivedSignDoc.chainId,
                    accountNumber: receivedSignDoc.accountNumber ? long_1.default.fromString(receivedSignDoc.accountNumber) : null
                  }, message.args[3]);
                  return {
                    signed: {
                      bodyBytes: result2.signed.bodyBytes,
                      authInfoBytes: result2.signed.authInfoBytes,
                      chainId: result2.signed.chainId,
                      accountNumber: result2.signed.accountNumber.toString()
                    },
                    signature: result2.signature
                  };
                }))();
              }
              if (method === "signDirectAux") {
                return yield (() => __awaiter(this, void 0, void 0, function* () {
                  const receivedSignDoc = message.args[2];
                  const result2 = yield keplr.signDirectAux(message.args[0], message.args[1], {
                    bodyBytes: receivedSignDoc.bodyBytes,
                    publicKey: receivedSignDoc.publicKey,
                    chainId: receivedSignDoc.chainId,
                    accountNumber: receivedSignDoc.accountNumber ? long_1.default.fromString(receivedSignDoc.accountNumber) : null,
                    sequence: receivedSignDoc.sequence ? long_1.default.fromString(receivedSignDoc.sequence) : null
                  }, message.args[3]);
                  return {
                    signed: {
                      bodyBytes: result2.signed.bodyBytes,
                      publicKey: result2.signed.publicKey,
                      chainId: result2.signed.chainId,
                      accountNumber: result2.signed.accountNumber.toString(),
                      sequence: result2.signed.sequence.toString()
                    },
                    signature: result2.signature
                  };
                }))();
              }
              if (method === "ethereum") {
                const ethereumProviderMethod = message.ethereumProviderMethod;
                if (ethereumProviderMethod === null || ethereumProviderMethod === void 0 ? void 0 : ethereumProviderMethod.startsWith("protected")) {
                  throw new Error("Rejected");
                }
                if (ethereumProviderMethod === "chainId") {
                  throw new Error("chainId is not function");
                }
                if (ethereumProviderMethod === "selectedAddress") {
                  throw new Error("selectedAddress is not function");
                }
                if (ethereumProviderMethod === "networkVersion") {
                  throw new Error("networkVersion is not function");
                }
                if (ethereumProviderMethod === "isKeplr") {
                  throw new Error("isKeplr is not function");
                }
                if (ethereumProviderMethod === "isMetaMask") {
                  throw new Error("isMetaMask is not function");
                }
                if (ethereumProviderMethod === void 0 || typeof keplr.ethereum[ethereumProviderMethod] !== "function") {
                  throw new Error(`${message.ethereumProviderMethod} is not function or invalid Ethereum provider method`);
                }
                const messageArgs = router_1.JSONUint8Array.unwrap(message.args);
                if (ethereumProviderMethod === "request") {
                  return yield keplr.ethereum.request(typeof messageArgs === "string" ? JSON.parse(messageArgs) : messageArgs);
                }
                return yield keplr.ethereum[ethereumProviderMethod](
                  ...typeof messageArgs === "string" ? JSON.parse(messageArgs) : messageArgs
                );
              }
              if (method === "starknet") {
                const starknetProviderMethod = message.starknetProviderMethod;
                if (starknetProviderMethod === null || starknetProviderMethod === void 0 ? void 0 : starknetProviderMethod.startsWith("protected")) {
                  throw new Error("Rejected");
                }
                if (starknetProviderMethod === "id") {
                  throw new Error("id is not function");
                }
                if (starknetProviderMethod === "name") {
                  throw new Error("name is not function");
                }
                if (starknetProviderMethod === "version") {
                  throw new Error("version is not function");
                }
                if (starknetProviderMethod === "icon") {
                  throw new Error("icon is not function");
                }
                if (starknetProviderMethod === "chainId") {
                  throw new Error("chainId is not function");
                }
                if (starknetProviderMethod === "selectedAddress") {
                  throw new Error("selectedAddress is not function");
                }
                if (starknetProviderMethod === "isConnected") {
                  throw new Error("isConnected is not function");
                }
                if (starknetProviderMethod === "account") {
                  throw new Error("account is not function");
                }
                if (starknetProviderMethod === "provider") {
                  throw new Error("provider is not function");
                }
                if (starknetProviderMethod === void 0 || typeof ((_a2 = keplr.starknet) === null || _a2 === void 0 ? void 0 : _a2[starknetProviderMethod]) !== "function") {
                  throw new Error(`${message.starknetProviderMethod} is not function or invalid Starknet provider method`);
                }
                const messageArgs = router_1.JSONUint8Array.unwrap(message.args);
                if (starknetProviderMethod === "request") {
                  return yield keplr.starknet.request(typeof messageArgs === "string" ? JSON.parse(messageArgs) : messageArgs);
                }
                return yield keplr.starknet[starknetProviderMethod](
                  ...typeof messageArgs === "string" ? JSON.parse(messageArgs) : messageArgs
                );
              }
              if (method === "bitcoin") {
                const bitcoinProviderMethod = message.bitcoinProviderMethod;
                if (bitcoinProviderMethod === null || bitcoinProviderMethod === void 0 ? void 0 : bitcoinProviderMethod.startsWith("protected")) {
                  throw new Error("Rejected");
                }
                if (bitcoinProviderMethod === void 0 || typeof ((_b = keplr.bitcoin) === null || _b === void 0 ? void 0 : _b[bitcoinProviderMethod]) !== "function") {
                  throw new Error(`${message.bitcoinProviderMethod} is not function or invalid Bitcoin provider method`);
                }
                const messageArgs = router_1.JSONUint8Array.unwrap(message.args);
                return yield keplr.bitcoin[bitcoinProviderMethod](
                  ...typeof messageArgs === "string" ? JSON.parse(messageArgs) : messageArgs
                );
              }
              return yield keplr[method](
                ...router_1.JSONUint8Array.unwrap(message.args)
              );
            }))();
            const proxyResponse = {
              type: "proxy-request-response",
              id: message.id,
              result: {
                return: router_1.JSONUint8Array.wrap(result)
              }
            };
            eventListener.postMessage(proxyResponse);
          } catch (e3) {
            const proxyResponse = {
              type: "proxy-request-response",
              id: message.id,
              result: {
                error: e3.code && !e3.module ? {
                  code: e3.code,
                  message: e3.message,
                  data: e3.data
                } : e3.message || e3.toString()
              }
            };
            eventListener.postMessage(proxyResponse);
          }
        });
        eventListener.addMessageListener(fn2);
        return () => {
          eventListener.removeMessageListener(fn2);
        };
      }
      requestMethod(method, args) {
        const bytes = new Uint8Array(8);
        const id = Array.from(crypto.getRandomValues(bytes)).map((value) => {
          return value.toString(16);
        }).join("");
        const proxyRequestType = `proxy-request${this.metaId ? `-${this.metaId}` : ""}`;
        const proxyMessage = {
          type: proxyRequestType,
          id,
          method,
          args: router_1.JSONUint8Array.wrap(args)
        };
        return new Promise((resolve, reject) => {
          const receiveResponse = (e2) => {
            const proxyResponse = this.parseMessage ? this.parseMessage(e2.data) : e2.data;
            if (!proxyResponse || proxyResponse.type !== "proxy-request-response") {
              return;
            }
            if (proxyResponse.id !== id) {
              return;
            }
            this.eventListener.removeMessageListener(receiveResponse);
            const result = router_1.JSONUint8Array.unwrap(proxyResponse.result);
            if (!result) {
              reject(new Error("Result is null"));
              return;
            }
            if (result.error) {
              reject(new Error(result.error));
              return;
            }
            resolve(result.return);
          };
          this.eventListener.addMessageListener(receiveResponse);
          this.eventListener.postMessage(proxyMessage);
        });
      }
      constructor(metaId, version6, mode, onStarknetStateChange, onStarknetAccountChange, eventListener = {
        addMessageListener: (fn2) => window.addEventListener("message", fn2),
        removeMessageListener: (fn2) => window.removeEventListener("message", fn2),
        postMessage: (message) => window.postMessage(message, window.location.origin)
      }, parseMessage, eip6963ProviderInfo, starknetProviderInfo) {
        this.metaId = metaId;
        this.version = version6;
        this.mode = mode;
        this.onStarknetStateChange = onStarknetStateChange;
        this.onStarknetAccountChange = onStarknetAccountChange;
        this.eventListener = eventListener;
        this.parseMessage = parseMessage;
        this.eip6963ProviderInfo = eip6963ProviderInfo;
        this.starknetProviderInfo = starknetProviderInfo;
        this.enigmaUtils = /* @__PURE__ */ new Map();
        this.defaultOptions = {};
        this.ethereum = new EthereumProvider(this.metaId, () => this, this.eventListener, this.parseMessage, this.eip6963ProviderInfo);
        this.starknet = this.generateStarknetProvider();
        this.bitcoin = new BitcoinProvider(() => this, this.eventListener, this.parseMessage);
        const fieldNames = Object.keys(this);
        for (const fieldName of fieldNames) {
          if (fieldName !== "defaultOptions") {
            Object.defineProperty(this, fieldName, {
              value: this[fieldName],
              writable: false
            });
          }
          if (fieldName === "eventListener") {
            const fieldNames2 = Object.keys(this.eventListener);
            for (const fieldName2 of fieldNames2) {
              Object.defineProperty(this.eventListener, fieldName2, {
                value: this.eventListener[fieldName2],
                writable: false
              });
            }
          }
        }
        const methodNames = Object.getOwnPropertyNames(_InjectedKeplr.prototype);
        for (const methodName of methodNames) {
          if (methodName !== "constructor" && typeof this[methodName] === "function") {
            Object.defineProperty(this, methodName, {
              value: this[methodName].bind(this),
              writable: false
            });
          }
        }
      }
      ping() {
        return __awaiter(this, void 0, void 0, function* () {
          yield this.requestMethod("ping", []);
        });
      }
      enable(chainIds) {
        return __awaiter(this, void 0, void 0, function* () {
          yield this.requestMethod("enable", [chainIds]);
        });
      }
      disable(chainIds) {
        return __awaiter(this, void 0, void 0, function* () {
          yield this.requestMethod("disable", [chainIds]);
        });
      }
      experimentalSuggestChain(chainInfo) {
        var _a2, _b;
        return __awaiter(this, void 0, void 0, function* () {
          if (chainInfo.hideInUI) {
            throw new Error("hideInUI is not allowed");
          }
          if (((_a2 = chainInfo.features) === null || _a2 === void 0 ? void 0 : _a2.includes("stargate")) || ((_b = chainInfo.features) === null || _b === void 0 ? void 0 : _b.includes("no-legacy-stdTx"))) {
            console.warn("stargate, no-legacy-stdTx feature has been deprecated. The launchpad is no longer supported, thus works without the two features. We would keep the aforementioned two feature for a while, but the upcoming update would potentially cause errors. Remove the two feature.");
          }
          yield this.requestMethod("experimentalSuggestChain", [chainInfo]);
        });
      }
      getKey(chainId) {
        return __awaiter(this, void 0, void 0, function* () {
          return yield this.requestMethod("getKey", [chainId]);
        });
      }
      getKeysSettled(chainIds) {
        return __awaiter(this, void 0, void 0, function* () {
          return yield this.requestMethod("getKeysSettled", [chainIds]);
        });
      }
      sendTx(chainId, tx, mode) {
        return __awaiter(this, void 0, void 0, function* () {
          if (!("length" in tx)) {
            console.warn("Do not send legacy std tx via `sendTx` API. We now only support protobuf tx. The usage of legeacy std tx would throw an error in the near future.");
          }
          return yield this.requestMethod("sendTx", [chainId, tx, mode]);
        });
      }
      signAmino(chainId, signer, signDoc, signOptions = {}) {
        var _a2;
        return __awaiter(this, void 0, void 0, function* () {
          return yield this.requestMethod("signAmino", [
            chainId,
            signer,
            signDoc,
            (0, deepmerge_1.default)((_a2 = this.defaultOptions.sign) !== null && _a2 !== void 0 ? _a2 : {}, signOptions)
          ]);
        });
      }
      signDirect(chainId, signer, signDoc, signOptions = {}) {
        var _a2;
        return __awaiter(this, void 0, void 0, function* () {
          const result = yield this.requestMethod("signDirect", [
            chainId,
            signer,
            // We can't send the `Long` with remaing the type.
            // Receiver should change the `string` to `Long`.
            {
              bodyBytes: signDoc.bodyBytes,
              authInfoBytes: signDoc.authInfoBytes,
              chainId: signDoc.chainId,
              accountNumber: signDoc.accountNumber ? signDoc.accountNumber.toString() : null
            },
            (0, deepmerge_1.default)((_a2 = this.defaultOptions.sign) !== null && _a2 !== void 0 ? _a2 : {}, signOptions)
          ]);
          const signed = result.signed;
          return {
            signed: {
              bodyBytes: signed.bodyBytes,
              authInfoBytes: signed.authInfoBytes,
              chainId: signed.chainId,
              // We can't send the `Long` with remaing the type.
              // Sender should change the `Long` to `string`.
              accountNumber: long_1.default.fromString(signed.accountNumber)
            },
            signature: result.signature
          };
        });
      }
      signDirectAux(chainId, signer, signDoc, signOptions = {}) {
        var _a2;
        return __awaiter(this, void 0, void 0, function* () {
          const result = yield this.requestMethod("signDirectAux", [
            chainId,
            signer,
            // We can't send the `Long` with remaing the type.
            // Receiver should change the `string` to `Long`.
            {
              bodyBytes: signDoc.bodyBytes,
              publicKey: signDoc.publicKey,
              chainId: signDoc.chainId,
              accountNumber: signDoc.accountNumber ? signDoc.accountNumber.toString() : null,
              sequence: signDoc.sequence ? signDoc.sequence.toString() : null
            },
            (0, deepmerge_1.default)({
              preferNoSetMemo: (_a2 = this.defaultOptions.sign) === null || _a2 === void 0 ? void 0 : _a2.preferNoSetMemo
            }, signOptions)
          ]);
          const signed = result.signed;
          return {
            signed: {
              bodyBytes: signed.bodyBytes,
              publicKey: signed.publicKey || void 0,
              chainId: signed.chainId,
              // We can't send the `Long` with remaing the type.
              // Sender should change the `Long` to `string`.
              accountNumber: long_1.default.fromString(signed.accountNumber),
              sequence: long_1.default.fromString(signed.sequence)
            },
            signature: result.signature
          };
        });
      }
      signArbitrary(chainId, signer, data) {
        return __awaiter(this, void 0, void 0, function* () {
          return yield this.requestMethod("signArbitrary", [chainId, signer, data]);
        });
      }
      signICNSAdr36(chainId, contractAddress, owner, username, addressChainIds) {
        return this.requestMethod("signICNSAdr36", [
          chainId,
          contractAddress,
          owner,
          username,
          addressChainIds
        ]);
      }
      verifyArbitrary(chainId, signer, data, signature) {
        return __awaiter(this, void 0, void 0, function* () {
          return yield this.requestMethod("verifyArbitrary", [
            chainId,
            signer,
            data,
            signature
          ]);
        });
      }
      signEthereum(chainId, signer, data, type) {
        return __awaiter(this, void 0, void 0, function* () {
          return yield this.requestMethod("signEthereum", [
            chainId,
            signer,
            data,
            type
          ]);
        });
      }
      getOfflineSigner(chainId, signOptions) {
        return new cosmjs_1.CosmJSOfflineSigner(chainId, this, signOptions);
      }
      getOfflineSignerOnlyAmino(chainId, signOptions) {
        return new cosmjs_1.CosmJSOfflineSignerOnlyAmino(chainId, this, signOptions);
      }
      getOfflineSignerAuto(chainId, signOptions) {
        return __awaiter(this, void 0, void 0, function* () {
          const key = yield this.getKey(chainId);
          if (key.isNanoLedger) {
            return new cosmjs_1.CosmJSOfflineSignerOnlyAmino(chainId, this, signOptions);
          }
          return new cosmjs_1.CosmJSOfflineSigner(chainId, this, signOptions);
        });
      }
      suggestToken(chainId, contractAddress, viewingKey) {
        return __awaiter(this, void 0, void 0, function* () {
          return yield this.requestMethod("suggestToken", [
            chainId,
            contractAddress,
            viewingKey
          ]);
        });
      }
      getSecret20ViewingKey(chainId, contractAddress) {
        return __awaiter(this, void 0, void 0, function* () {
          return yield this.requestMethod("getSecret20ViewingKey", [
            chainId,
            contractAddress
          ]);
        });
      }
      getEnigmaPubKey(chainId) {
        return __awaiter(this, void 0, void 0, function* () {
          return yield this.requestMethod("getEnigmaPubKey", [chainId]);
        });
      }
      getEnigmaTxEncryptionKey(chainId, nonce) {
        return __awaiter(this, void 0, void 0, function* () {
          return yield this.requestMethod("getEnigmaTxEncryptionKey", [
            chainId,
            nonce
          ]);
        });
      }
      enigmaEncrypt(chainId, contractCodeHash, msg) {
        return __awaiter(this, void 0, void 0, function* () {
          return yield this.requestMethod("enigmaEncrypt", [
            chainId,
            contractCodeHash,
            msg
          ]);
        });
      }
      enigmaDecrypt(chainId, ciphertext, nonce) {
        return __awaiter(this, void 0, void 0, function* () {
          return yield this.requestMethod("enigmaDecrypt", [
            chainId,
            ciphertext,
            nonce
          ]);
        });
      }
      getEnigmaUtils(chainId) {
        if (this.enigmaUtils.has(chainId)) {
          return this.enigmaUtils.get(chainId);
        }
        const enigmaUtils = new enigma_1.KeplrEnigmaUtils(chainId, this);
        this.enigmaUtils.set(chainId, enigmaUtils);
        return enigmaUtils;
      }
      experimentalSignEIP712CosmosTx_v0(chainId, signer, eip712, signDoc, signOptions = {}) {
        var _a2;
        return __awaiter(this, void 0, void 0, function* () {
          return yield this.requestMethod("experimentalSignEIP712CosmosTx_v0", [
            chainId,
            signer,
            eip712,
            signDoc,
            (0, deepmerge_1.default)((_a2 = this.defaultOptions.sign) !== null && _a2 !== void 0 ? _a2 : {}, signOptions)
          ]);
        });
      }
      getChainInfosWithoutEndpoints() {
        return __awaiter(this, void 0, void 0, function* () {
          return yield this.requestMethod("getChainInfosWithoutEndpoints", []);
        });
      }
      getChainInfoWithoutEndpoints(chainId) {
        return __awaiter(this, void 0, void 0, function* () {
          return yield this.requestMethod("getChainInfoWithoutEndpoints", [chainId]);
        });
      }
      __core__getAnalyticsId() {
        return this.requestMethod("__core__getAnalyticsId", []);
      }
      changeKeyRingName({ defaultName, editable = true }) {
        return __awaiter(this, void 0, void 0, function* () {
          return yield this.requestMethod("changeKeyRingName", [
            { defaultName, editable }
          ]);
        });
      }
      __core__privilageSignAminoWithdrawRewards(chainId, signer, signDoc) {
        return __awaiter(this, void 0, void 0, function* () {
          return yield this.requestMethod("__core__privilageSignAminoWithdrawRewards", [chainId, signer, signDoc]);
        });
      }
      __core__privilageSignAminoDelegate(chainId, signer, signDoc) {
        return __awaiter(this, void 0, void 0, function* () {
          return yield this.requestMethod("__core__privilageSignAminoDelegate", [
            chainId,
            signer,
            signDoc
          ]);
        });
      }
      __core__privilageSignAminoExecuteCosmWasm(chainId, signer, signDoc) {
        return __awaiter(this, void 0, void 0, function* () {
          return yield this.requestMethod("__core__privilageSignAminoExecuteCosmWasm", [chainId, signer, signDoc]);
        });
      }
      sendEthereumTx(chainId, tx) {
        return __awaiter(this, void 0, void 0, function* () {
          return yield this.requestMethod("sendEthereumTx", [chainId, tx]);
        });
      }
      suggestERC20(chainId, contractAddress) {
        return __awaiter(this, void 0, void 0, function* () {
          return yield this.requestMethod("suggestERC20", [chainId, contractAddress]);
        });
      }
      __core__webpageClosed() {
        return __awaiter(this, void 0, void 0, function* () {
          return yield this.requestMethod("__core__webpageClosed", []);
        });
      }
      getStarknetKey(chainId) {
        return __awaiter(this, void 0, void 0, function* () {
          return yield this.requestMethod("getStarknetKey", [chainId]);
        });
      }
      getStarknetKeysSettled(chainIds) {
        return __awaiter(this, void 0, void 0, function* () {
          return yield this.requestMethod("getStarknetKeysSettled", [chainIds]);
        });
      }
      signStarknetTx(chainId, transactions, details) {
        return __awaiter(this, void 0, void 0, function* () {
          return yield this.requestMethod("signStarknetTx", [
            chainId,
            transactions,
            details
          ]);
        });
      }
      signStarknetDeployAccountTransaction(chainId, transaction2) {
        return __awaiter(this, void 0, void 0, function* () {
          return yield this.requestMethod("signStarknetDeployAccountTransaction", [
            chainId,
            transaction2
          ]);
        });
      }
      generateStarknetProvider() {
        return new StarknetProvider(this.metaId, this.starknetProviderInfo.id, this.starknetProviderInfo.name, this.version, this.starknetProviderInfo.icon, () => this, this.onStarknetStateChange, this.onStarknetAccountChange, this.eventListener, this.parseMessage);
      }
      getBitcoinKey(chainId) {
        return __awaiter(this, void 0, void 0, function* () {
          return yield this.requestMethod("getBitcoinKey", [chainId]);
        });
      }
      getBitcoinKeysSettled(chainIds) {
        return __awaiter(this, void 0, void 0, function* () {
          return yield this.requestMethod("getBitcoinKeysSettled", [chainIds]);
        });
      }
      signPsbt(chainId, psbtHex, options) {
        return __awaiter(this, void 0, void 0, function* () {
          return yield this.requestMethod("signPsbt", [chainId, psbtHex, options]);
        });
      }
      signPsbts(chainId, psbtsHexes, options) {
        return __awaiter(this, void 0, void 0, function* () {
          return yield this.requestMethod("signPsbts", [
            chainId,
            psbtsHexes,
            options
          ]);
        });
      }
    };
    exports.InjectedKeplr = InjectedKeplr;
    var EthereumProvider = class extends events_1.default {
      constructor(metaId, injectedKeplr, eventListener = {
        addMessageListener: (fn2) => window.addEventListener("message", fn2),
        removeMessageListener: (fn2) => window.removeEventListener("message", fn2),
        postMessage: (message) => window.postMessage(message, window.location.origin)
      }, parseMessage, eip6963ProviderInfo) {
        super();
        this.metaId = metaId;
        this.injectedKeplr = injectedKeplr;
        this.eventListener = eventListener;
        this.parseMessage = parseMessage;
        this.eip6963ProviderInfo = eip6963ProviderInfo;
        this.chainId = null;
        this.networkVersion = null;
        this.selectedAddress = null;
        this.isKeplr = true;
        this.isMetaMask = true;
        this._isConnected = false;
        this._currentChainId = null;
        this._requestMethod = (method, args) => __awaiter(this, void 0, void 0, function* () {
          const bytes = new Uint8Array(8);
          const id = Array.from(crypto.getRandomValues(bytes)).map((value) => {
            return value.toString(16);
          }).join("");
          const proxyRequestType = `proxy-request${this.metaId ? `-${this.metaId}` : ""}`;
          const proxyMessage = {
            type: proxyRequestType,
            id,
            method: "ethereum",
            args: router_1.JSONUint8Array.wrap(args),
            ethereumProviderMethod: method
          };
          return new Promise((resolve, reject) => {
            const receiveResponse = (e2) => {
              const proxyResponse = this.parseMessage ? this.parseMessage(e2.data) : e2.data;
              if (!proxyResponse || proxyResponse.type !== "proxy-request-response") {
                return;
              }
              if (proxyResponse.id !== id) {
                return;
              }
              this.eventListener.removeMessageListener(receiveResponse);
              const result = router_1.JSONUint8Array.unwrap(proxyResponse.result);
              if (!result) {
                reject(new Error("Result is null"));
                return;
              }
              if (result.error) {
                const error = result.error;
                reject(error.code && !error.module ? new router_1.EthereumProviderRpcError(error.code, error.message, error.data) : new Error(error));
                return;
              }
              resolve(result.return);
            };
            this.eventListener.addMessageListener(receiveResponse);
            this.eventListener.postMessage(proxyMessage);
          });
        });
        this._initProviderState = () => __awaiter(this, void 0, void 0, function* () {
          const initialProviderState = yield this._requestMethod("request", {
            method: "keplr_initProviderState"
          });
          if (initialProviderState) {
            const { currentEvmChainId, currentChainId, selectedAddress } = initialProviderState;
            if (currentChainId != null && currentEvmChainId != null && selectedAddress != null) {
              this._handleConnect(currentEvmChainId);
              this._handleChainChanged(currentEvmChainId);
              this._currentChainId = currentChainId;
              this._handleAccountsChanged(selectedAddress);
            }
          }
        });
        this._handleConnect = (evmChainId) => __awaiter(this, void 0, void 0, function* () {
          if (!this._isConnected) {
            this._isConnected = true;
            const evmChainIdHexString = `0x${evmChainId.toString(16)}`;
            this.emit("connect", { chainId: evmChainIdHexString });
          }
        });
        this._handleDisconnect = () => __awaiter(this, void 0, void 0, function* () {
          if (this._isConnected) {
            yield this._requestMethod("request", {
              method: "keplr_disconnect"
            });
            this._isConnected = false;
            this.chainId = null;
            this.selectedAddress = null;
            this.networkVersion = null;
            this.emit("disconnect");
          }
        });
        this._handleChainChanged = (evmChainId) => __awaiter(this, void 0, void 0, function* () {
          const evmChainIdHexString = `0x${evmChainId.toString(16)}`;
          if (evmChainIdHexString !== this.chainId) {
            this.chainId = evmChainIdHexString;
            this.networkVersion = evmChainId.toString(10);
            this.emit("chainChanged", evmChainIdHexString);
          }
        });
        this._handleAccountsChanged = (selectedAddress) => __awaiter(this, void 0, void 0, function* () {
          if (this.selectedAddress !== selectedAddress) {
            this.selectedAddress = selectedAddress;
            this.emit("accountsChanged", [selectedAddress]);
          }
        });
        this.request = ({ method, params, chainId }) => __awaiter(this, void 0, void 0, function* () {
          var _a2;
          if (typeof method !== "string") {
            throw new Error("Invalid paramater: `method` must be a string");
          }
          if (!this._isConnected) {
            yield this._initProviderState();
          }
          return yield this._requestMethod("request", {
            method,
            params,
            providerId: (_a2 = this.eip6963ProviderInfo) === null || _a2 === void 0 ? void 0 : _a2.uuid,
            chainId
          });
        });
        this.enable = () => __awaiter(this, void 0, void 0, function* () {
          return yield this.request({
            method: "eth_requestAccounts"
          });
        });
        this.net_version = () => __awaiter(this, void 0, void 0, function* () {
          return yield this.request({
            method: "net_version"
          });
        });
        this._initProviderState();
        window.addEventListener("keplr_keystorechange", () => __awaiter(this, void 0, void 0, function* () {
          if (this._currentChainId) {
            const chainInfo = yield injectedKeplr().getChainInfoWithoutEndpoints(this._currentChainId);
            if (chainInfo) {
              const selectedAddress = (yield injectedKeplr().getKey(this._currentChainId)).ethereumHexAddress;
              this._handleAccountsChanged(selectedAddress);
            }
          }
        }));
        window.addEventListener("keplr_chainChanged", (event) => {
          const origin = event.detail.origin;
          if (origin === window.location.origin) {
            const evmChainId = event.detail.evmChainId;
            this._handleChainChanged(evmChainId);
          }
        });
        window.addEventListener("keplr_ethSubscription", (event) => {
          var _a2;
          const origin = event.detail.origin;
          const providerId = event.detail.providerId;
          if (origin === window.location.origin && providerId === ((_a2 = this.eip6963ProviderInfo) === null || _a2 === void 0 ? void 0 : _a2.uuid)) {
            const data = event.detail.data;
            this.emit("message", {
              type: "eth_subscription",
              data
            });
          }
        });
        if (this.eip6963ProviderInfo) {
          const announceEvent = new CustomEvent(types_1.EIP6963EventNames.Announce, {
            detail: Object.freeze({
              info: this.eip6963ProviderInfo,
              provider: this
            })
          });
          window.addEventListener(types_1.EIP6963EventNames.Request, () => window.dispatchEvent(announceEvent));
          window.dispatchEvent(announceEvent);
        }
      }
      isConnected() {
        return this._isConnected;
      }
    };
    var StarknetProvider = class {
      constructor(metaId, id, name, version6, icon, _injectedKeplr, onStateChange, onAccountChange, _eventListener = {
        addMessageListener: (fn2) => window.addEventListener("message", fn2),
        removeMessageListener: (fn2) => window.removeEventListener("message", fn2),
        postMessage: (message) => window.postMessage(message, window.location.origin)
      }, _parseMessage) {
        this.metaId = metaId;
        this.id = id;
        this.name = name;
        this.version = version6;
        this.icon = icon;
        this._injectedKeplr = _injectedKeplr;
        this.onStateChange = onStateChange;
        this.onAccountChange = onAccountChange;
        this._eventListener = _eventListener;
        this._parseMessage = _parseMessage;
        this.isConnected = false;
        this.chainId = void 0;
        this.selectedAddress = void 0;
        this.account = void 0;
        this.provider = void 0;
        this._currentChainId = void 0;
        this._userWalletEvents = [];
        this._initProviderState();
        window.addEventListener("keplr_keystorechange", () => __awaiter(this, void 0, void 0, function* () {
          if (this._currentChainId) {
            const selectedAddress = (yield this._injectedKeplr().getStarknetKey(this._currentChainId)).hexAddress;
            this.selectedAddress = selectedAddress;
            this.onAccountChange({
              selectedAddress
            });
            this._userWalletEvents.forEach((userWalletEvent) => {
              if (userWalletEvent.type === "accountsChanged") {
                userWalletEvent.handler([selectedAddress]);
              }
            });
          }
        }));
        window.addEventListener("keplr_starknetChainChanged", (event) => {
          const origin = event.detail.origin;
          const starknetChainId = event.detail.starknetChainId;
          this.chainId = starknetChainId;
          if (origin === window.location.origin) {
            this._userWalletEvents.forEach((userWalletEvent) => {
              if (userWalletEvent.type === "networkChanged") {
                userWalletEvent.handler(starknetChainId);
              }
            });
          }
        });
      }
      _requestMethod(method, args) {
        return __awaiter(this, void 0, void 0, function* () {
          const bytes = new Uint8Array(8);
          const id = Array.from(crypto.getRandomValues(bytes)).map((value) => {
            return value.toString(16);
          }).join("");
          const proxyRequestType = `proxy-request${this.metaId ? `-${this.metaId}` : ""}`;
          const proxyMessage = {
            type: proxyRequestType,
            id,
            method: "starknet",
            args: router_1.JSONUint8Array.wrap(args),
            starknetProviderMethod: method
          };
          return new Promise((resolve, reject) => {
            const receiveResponse = (e2) => {
              const proxyResponse = this._parseMessage ? this._parseMessage(e2.data) : e2.data;
              if (!proxyResponse || proxyResponse.type !== "proxy-request-response") {
                return;
              }
              if (proxyResponse.id !== id) {
                return;
              }
              this._eventListener.removeMessageListener(receiveResponse);
              const result = router_1.JSONUint8Array.unwrap(proxyResponse.result);
              if (!result) {
                reject(new Error("Result is null"));
                return;
              }
              if (result.error) {
                const error = result.error;
                reject(error.code && !error.module ? new router_1.EthereumProviderRpcError(error.code, error.message, error.data) : new Error(error));
                return;
              }
              resolve(result.return);
            };
            this._eventListener.addMessageListener(receiveResponse);
            this._eventListener.postMessage(proxyMessage);
          });
        });
      }
      _initProviderState() {
        return __awaiter(this, void 0, void 0, function* () {
          const { currentChainId, selectedAddress, rpc } = yield this.request({
            type: "keplr_initStarknetProviderState"
          });
          if (currentChainId != null && selectedAddress != null && rpc != null) {
            this.onStateChange({
              selectedAddress,
              chainId: currentChainId,
              rpc
            });
            this._currentChainId = currentChainId;
            this.chainId = currentChainId.replace("starknet:", "");
            this.selectedAddress = selectedAddress;
            this.isConnected = true;
          } else {
            this.onStateChange({
              selectedAddress: null,
              chainId: null,
              rpc: null
            });
          }
        });
      }
      request({ type, params }) {
        return __awaiter(this, void 0, void 0, function* () {
          if (typeof type !== "string") {
            throw new Error("Invalid parameter: `type` must be a string");
          }
          return yield this._requestMethod("request", {
            type,
            params
          });
        });
      }
      enable(_options) {
        return __awaiter(this, void 0, void 0, function* () {
          const { currentChainId, selectedAddress, rpc } = yield this.request({
            type: "keplr_enableStarknetProvider"
          });
          this.onStateChange({
            selectedAddress,
            chainId: currentChainId,
            rpc
          });
          this._currentChainId = currentChainId;
          this.chainId = currentChainId.replace("starknet:", "");
          this.selectedAddress = selectedAddress;
          this.isConnected = true;
          return [selectedAddress];
        });
      }
      isPreauthorized() {
        return __awaiter(this, void 0, void 0, function* () {
          const { currentChainId, selectedAddress } = yield this.request({
            type: "keplr_initStarknetProviderState"
          });
          if (currentChainId != null && selectedAddress != null) {
            return true;
          }
          return false;
        });
      }
      on(event, handleEvent) {
        if (event === "accountsChanged") {
          this._userWalletEvents.push({
            type: "accountsChanged",
            handler: handleEvent
          });
        } else if (event === "networkChanged") {
          this._userWalletEvents.push({
            type: "networkChanged",
            handler: handleEvent
          });
        } else {
          throw new Error("Invalid event type");
        }
      }
      off(event, handleEvent) {
        if (event !== "accountsChanged" && event !== "networkChanged") {
          throw new Error("Invalid event type");
        }
        const eventIndex = this._userWalletEvents.findIndex((userEvent) => userEvent.type === event && userEvent.handler === handleEvent);
        if (eventIndex >= 0) {
          this._userWalletEvents.splice(eventIndex, 1);
        }
      }
    };
    var BitcoinProvider = class extends events_1.default {
      constructor(_injectedKeplr, _eventListener = {
        addMessageListener: (fn2) => window.addEventListener("message", fn2),
        removeMessageListener: (fn2) => window.removeEventListener("message", fn2),
        postMessage: (message) => window.postMessage(message, window.location.origin)
      }, _parseMessage) {
        super();
        this._injectedKeplr = _injectedKeplr;
        this._eventListener = _eventListener;
        this._parseMessage = _parseMessage;
        this._handleNetworkChanged = (network) => __awaiter(this, void 0, void 0, function* () {
          this.emit("networkChanged", network);
        });
        this._handleAccountsChanged = (selectedAddress) => __awaiter(this, void 0, void 0, function* () {
          this.emit("accountChanged", [selectedAddress]);
          this.emit("accountsChanged", [selectedAddress]);
        });
        window.addEventListener("keplr_keystorechange", () => __awaiter(this, void 0, void 0, function* () {
          const accounts = yield this.getAccounts();
          if (accounts && accounts.length > 0) {
            this._handleAccountsChanged(accounts[0]);
          }
        }));
        window.addEventListener("keplr_bitcoinChainChanged", (event) => __awaiter(this, void 0, void 0, function* () {
          const origin = event.detail.origin;
          if (origin === window.location.origin) {
            const network = event.detail.network;
            const accounts = yield this.getAccounts();
            this._handleNetworkChanged(network);
            this._handleAccountsChanged(accounts[0]);
          }
        }));
        window.addEventListener("keplr_bitcoinAccountsChanged", () => __awaiter(this, void 0, void 0, function* () {
          const accounts = yield this.getAccounts();
          if (accounts && accounts.length > 0) {
            this._handleAccountsChanged(accounts[0]);
          }
        }));
      }
      _requestMethod(method, args) {
        return __awaiter(this, void 0, void 0, function* () {
          const bytes = new Uint8Array(8);
          const id = Array.from(crypto.getRandomValues(bytes)).map((value) => {
            return value.toString(16);
          }).join("");
          const proxyMessage = {
            type: "proxy-request",
            id,
            method: "bitcoin",
            args: router_1.JSONUint8Array.wrap(args),
            bitcoinProviderMethod: method
          };
          return new Promise((resolve, reject) => {
            const receiveResponse = (e2) => {
              const proxyResponse = this._parseMessage ? this._parseMessage(e2.data) : e2.data;
              if (!proxyResponse || proxyResponse.type !== "proxy-request-response") {
                return;
              }
              if (proxyResponse.id !== id) {
                return;
              }
              this._eventListener.removeMessageListener(receiveResponse);
              const result = router_1.JSONUint8Array.unwrap(proxyResponse.result);
              if (!result) {
                reject(new Error("Result is null"));
                return;
              }
              if (result.error) {
                reject(new Error(result.error));
                return;
              }
              resolve(result.return);
            };
            this._eventListener.addMessageListener(receiveResponse);
            this._eventListener.postMessage(proxyMessage);
          });
        });
      }
      getAccounts() {
        return this._requestMethod("getAccounts", []);
      }
      requestAccounts() {
        return __awaiter(this, void 0, void 0, function* () {
          return this._requestMethod("requestAccounts", []);
        });
      }
      disconnect() {
        return __awaiter(this, void 0, void 0, function* () {
          return this._requestMethod("disconnect", []);
        });
      }
      getNetwork() {
        return __awaiter(this, void 0, void 0, function* () {
          return this._requestMethod("getNetwork", []);
        });
      }
      switchNetwork(network) {
        return __awaiter(this, void 0, void 0, function* () {
          return this._requestMethod("switchNetwork", [network]);
        });
      }
      getChain() {
        return __awaiter(this, void 0, void 0, function* () {
          return this._requestMethod("getChain", []);
        });
      }
      switchChain(chain) {
        return __awaiter(this, void 0, void 0, function* () {
          return this._requestMethod("switchChain", [chain]);
        });
      }
      getPublicKey() {
        return __awaiter(this, void 0, void 0, function* () {
          return this._requestMethod("getPublicKey", []);
        });
      }
      getBalance() {
        return __awaiter(this, void 0, void 0, function* () {
          return this._requestMethod("getBalance", []);
        });
      }
      getInscriptions(offset, limit) {
        return __awaiter(this, void 0, void 0, function* () {
          return this._requestMethod("getInscriptions", [offset, limit]);
        });
      }
      signMessage(message, type) {
        return __awaiter(this, void 0, void 0, function* () {
          return this._requestMethod("signMessage", [message, type]);
        });
      }
      sendBitcoin(to2, amount) {
        return __awaiter(this, void 0, void 0, function* () {
          return this._requestMethod("sendBitcoin", [to2, amount]);
        });
      }
      pushTx(rawTxHex) {
        return __awaiter(this, void 0, void 0, function* () {
          return this._requestMethod("pushTx", [rawTxHex]);
        });
      }
      pushPsbt(psbtHex) {
        return __awaiter(this, void 0, void 0, function* () {
          return this._requestMethod("pushPsbt", [psbtHex]);
        });
      }
      signPsbt(psbtHex, options) {
        return __awaiter(this, void 0, void 0, function* () {
          return this._requestMethod("signPsbt", [psbtHex, options]);
        });
      }
      signPsbts(psbtsHexes, options) {
        return __awaiter(this, void 0, void 0, function* () {
          return this._requestMethod("signPsbts", [psbtsHexes, options]);
        });
      }
      getAddress() {
        return __awaiter(this, void 0, void 0, function* () {
          const accounts = yield this.getAccounts();
          return accounts[0];
        });
      }
      connectWallet() {
        return __awaiter(this, void 0, void 0, function* () {
          return this.requestAccounts();
        });
      }
    };
    exports.BitcoinProvider = BitcoinProvider;
  }
});

// ../../node_modules/.pnpm/@keplr-wallet+provider@0.12.252_starknet@7.6.4/node_modules/@keplr-wallet/provider/build/index.js
var require_build9 = __commonJS({
  "../../node_modules/.pnpm/@keplr-wallet+provider@0.12.252_starknet@7.6.4/node_modules/@keplr-wallet/provider/build/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o4, m3, k5, k22) {
      if (k22 === void 0)
        k22 = k5;
      var desc = Object.getOwnPropertyDescriptor(m3, k5);
      if (!desc || ("get" in desc ? !m3.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m3[k5];
        } };
      }
      Object.defineProperty(o4, k22, desc);
    } : function(o4, m3, k5, k22) {
      if (k22 === void 0)
        k22 = k5;
      o4[k22] = m3[k5];
    });
    var __exportStar = exports && exports.__exportStar || function(m3, exports2) {
      for (var p4 in m3)
        if (p4 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p4))
          __createBinding(exports2, m3, p4);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_core2(), exports);
    __exportStar(require_cosmjs3(), exports);
    __exportStar(require_enigma2(), exports);
    __exportStar(require_inject(), exports);
  }
});

// ../../node_modules/.pnpm/@keplr-wallet+wc-client@0.12.252_@walletconnect+sign-client@2.21.5_@walletconnect+types@2.21.5_starknet@7.6.4/node_modules/@keplr-wallet/wc-client/build/index.js
var require_build10 = __commonJS({
  "../../node_modules/.pnpm/@keplr-wallet+wc-client@0.12.252_@walletconnect+sign-client@2.21.5_@walletconnect+types@2.21.5_starknet@7.6.4/node_modules/@keplr-wallet/wc-client/build/index.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P3, generator) {
      function adopt(value) {
        return value instanceof P3 ? value : new P3(function(resolve) {
          resolve(value);
        });
      }
      return new (P3 || (P3 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e2) {
            reject(e2);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e2) {
            reject(e2);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.KeplrWalletConnectV2 = void 0;
    var provider_1 = require_build9();
    var buffer_1 = require_buffer();
    var long_1 = __importDefault(require_long());
    var events_1 = __importDefault(require_events());
    var KeplrWalletConnectV22 = class {
      constructor(signClient, options) {
        this.signClient = signClient;
        this.options = options;
        this.defaultOptions = {};
        this.version = "0.12.20";
        this.mode = "walletconnect";
        this.storeKey = "keplr_wallet_connect_v2_key";
        this.storeSuggestChainKey = "keplr_wallet_connect_v2_suggest_chain_key";
        this.storeSuggestTokenKey = "keplr_wallet_connect_v2_suggest_token_key";
        this.ethereum = new MockEthereumProvider();
        this.starknet = {};
        this.bitcoin = {};
        if (options.sessionProperties) {
          this.saveKeys(options.sessionProperties);
        }
        signClient.on("session_event", (event) => {
          if (event.params.event.name === "keplr_accountsChanged") {
            this.saveKeys(event.params.event.data);
            window.dispatchEvent(new Event("keplr_keystorechange"));
          }
        });
        signClient.on("session_delete", () => __awaiter(this, void 0, void 0, function* () {
          localStorage.removeItem(this.getKeyLastSeenKey());
          localStorage.removeItem(this.getSuggestChainKey());
          localStorage.removeItem(this.getSuggestTokenKey());
        }));
      }
      saveKeys(sessionProperty) {
        if (sessionProperty.hasOwnProperty("keys")) {
          const keys3 = JSON.parse(sessionProperty["keys"]);
          if (keys3.length > 0) {
            keys3.forEach((key) => {
              if (key.hasOwnProperty("chainId")) {
                this.saveLastSeenKey(key["chainId"], this.convertToKeplrGetKeyWalletConnectV2Response(key));
              }
            });
          }
        }
      }
      convertToKeplrGetKeyWalletConnectV2Response(data) {
        if (!data.hasOwnProperty("name") || !data.hasOwnProperty("algo") || !data.hasOwnProperty("pubKey") || !data.hasOwnProperty("address") || !data.hasOwnProperty("bech32Address") || !data.hasOwnProperty("ethereumHexAddress") || !data.hasOwnProperty("isNanoLedger")) {
          throw new Error("Invalid data");
        }
        return {
          name: data.name,
          algo: data.algo,
          pubKey: data.pubKey,
          address: data.address,
          bech32Address: data.bech32Address,
          ethereumHexAddress: data.ethereumHexAddress,
          isNanoLedger: data.isNanoLedger === "true"
        };
      }
      getLastSession() {
        const lastKeyIndex = this.signClient.session.getAll().length - 1;
        return this.signClient.session.getAll()[lastKeyIndex];
      }
      getCurrentTopic() {
        const lastSession = this.getLastSession();
        if (!lastSession) {
          throw new Error("No session");
        }
        return lastSession.topic;
      }
      getKeyLastSeenKey() {
        const topic = this.getCurrentTopic();
        return `${this.storeKey}/${topic}-key`;
      }
      getLastSeenKey(chainId) {
        const saved = this.getAllLastSeenKey();
        if (!saved) {
          return void 0;
        }
        return saved[chainId];
      }
      getAllLastSeenKey() {
        const data = localStorage.getItem(this.getKeyLastSeenKey());
        if (!data) {
          return void 0;
        }
        return JSON.parse(data);
      }
      saveLastSeenKey(chainId, response) {
        let saved = this.getAllLastSeenKey();
        if (!saved) {
          saved = {};
        }
        saved[chainId] = response;
        this.saveAllLastSeenKey(saved);
      }
      saveAllLastSeenKey(data) {
        localStorage.setItem(this.getKeyLastSeenKey(), JSON.stringify(data));
      }
      getSuggestChainKey() {
        const topic = this.getCurrentTopic();
        return `${this.storeSuggestChainKey}/${topic}-key`;
      }
      getRegisteredSuggestChain(chainId) {
        const saved = this.getAllRegisteredSuggestChain();
        if (!saved) {
          return void 0;
        }
        return saved[chainId];
      }
      getAllRegisteredSuggestChain() {
        const data = localStorage.getItem(this.getSuggestChainKey());
        if (!data) {
          return void 0;
        }
        return JSON.parse(data);
      }
      saveRegisteredSuggestChain(chainInfo) {
        let saved = this.getAllRegisteredSuggestChain();
        if (!saved) {
          saved = {};
        }
        saved[chainInfo.chainId] = chainInfo;
        this.saveAllRegisteredSuggestChain(saved);
      }
      saveAllRegisteredSuggestChain(data) {
        localStorage.setItem(this.getSuggestChainKey(), JSON.stringify(data));
      }
      getSuggestTokenKey() {
        const topic = this.getCurrentTopic();
        return `${this.storeSuggestTokenKey}/${topic}-key`;
      }
      getRegisteredSuggestToken(contractAddress) {
        const saved = this.getAllRegisteredSuggestToken();
        if (!saved) {
          return void 0;
        }
        return saved[contractAddress];
      }
      getAllRegisteredSuggestToken() {
        const data = localStorage.getItem(this.getSuggestTokenKey());
        if (!data) {
          return void 0;
        }
        return JSON.parse(data);
      }
      saveRegisteredSuggestToken(chainId, contractAddress, viewingKey) {
        let saved = this.getAllRegisteredSuggestToken();
        if (!saved) {
          saved = {};
        }
        saved[contractAddress] = {
          chainId,
          contractAddress,
          viewingKey
        };
        this.saveAllRegisteredSuggestToken(saved);
      }
      saveAllRegisteredSuggestToken(data) {
        localStorage.setItem(this.getSuggestTokenKey(), JSON.stringify(data));
      }
      sendCustomRequest(requestParams) {
        return __awaiter(this, void 0, void 0, function* () {
          const response = yield this.signClient.request(requestParams);
          return response;
        });
      }
      getNamespaceChainId() {
        const lastSession = this.getLastSession();
        if (lastSession && lastSession.namespaces.hasOwnProperty("cosmos") && lastSession.namespaces["cosmos"].hasOwnProperty("accounts")) {
          const splitAccount = lastSession.namespaces["cosmos"]["accounts"][0].split(":");
          return `${splitAccount[0]}:${splitAccount[1]}`;
        }
        return "cosmos:cosmoshub-4";
      }
      checkDeepLink() {
        const mobileLinkInfo = localStorage.getItem("wallet-connect-v2-mobile-link");
        if (mobileLinkInfo) {
          window.location.href = JSON.parse(mobileLinkInfo).href;
        }
      }
      ping() {
        return Promise.resolve();
      }
      changeKeyRingName(_opts) {
        throw new Error("Not yet implemented");
      }
      disable(_chainIds) {
        throw new Error("Not yet implemented");
      }
      enable(chainIds) {
        return __awaiter(this, void 0, void 0, function* () {
          if (typeof chainIds === "string") {
            chainIds = [chainIds];
          }
          const keys3 = yield this.getAllLastSeenKey();
          if (keys3) {
            const hasChainId = chainIds.every((chainId2) => {
              return Object.keys(keys3).includes(chainId2);
            });
            if (hasChainId) {
              return;
            }
          }
          this.checkDeepLink();
          const topic = this.getCurrentTopic();
          const chainId = this.getNamespaceChainId();
          if (!chainId) {
            throw new Error("No Namespace chain id");
          }
          const param = {
            topic,
            chainId: this.getNamespaceChainId(),
            request: {
              method: "keplr_enable",
              params: {
                chainId: chainIds
              }
            }
          };
          yield this.sendCustomRequest(param);
          return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
            while (true) {
              yield new Promise((resolve2) => setTimeout(resolve2, 100));
              const lastSession = this.getLastSession();
              if (lastSession && lastSession.namespaces.hasOwnProperty("cosmos") && lastSession.namespaces["cosmos"].hasOwnProperty("accounts")) {
                const hasChainId = lastSession.namespaces["cosmos"]["accounts"].some((account) => {
                  const chainId2 = account.replace("cosmos:", "").split(":")[0];
                  return chainIds.includes(chainId2);
                });
                if (hasChainId) {
                  resolve();
                  return;
                }
              }
            }
          }));
        });
      }
      enigmaDecrypt(_chainId, _ciphertext, _nonce) {
        throw new Error("Not yet implemented");
      }
      enigmaEncrypt(_chainId, _contractCodeHash, _msg) {
        throw new Error("Not yet implemented");
      }
      experimentalSignEIP712CosmosTx_v0(_chainId, _signer, _eip712, _signDoc, _signOptions = {}) {
        throw new Error("Not yet implemented");
      }
      experimentalSuggestChain(_chainInfo) {
        var _a2, _b;
        return __awaiter(this, void 0, void 0, function* () {
          if (((_a2 = _chainInfo.features) === null || _a2 === void 0 ? void 0 : _a2.includes("stargate")) || ((_b = _chainInfo.features) === null || _b === void 0 ? void 0 : _b.includes("no-legacy-stdTx"))) {
            console.warn("stargate, no-legacy-stdTx feature has been deprecated. The launchpad is no longer supported, thus works without the two features. We would keep the aforementioned two feature for a while, but the upcoming update would potentially cause errors. Remove the two feature.");
          }
          const registeredChainInfo = this.getRegisteredSuggestChain(_chainInfo.chainId);
          if (registeredChainInfo) {
            return;
          }
          this.checkDeepLink();
          const topic = this.getCurrentTopic();
          const param = {
            topic,
            chainId: this.getNamespaceChainId(),
            request: {
              method: "keplr_experimentalSuggestChain",
              params: {
                chainInfo: _chainInfo
              }
            }
          };
          yield this.sendCustomRequest(param);
          this.saveRegisteredSuggestChain(_chainInfo);
        });
      }
      getChainInfosWithoutEndpoints() {
        throw new Error("Not yet implemented");
      }
      getChainInfoWithoutEndpoints(_chainId) {
        throw new Error("Not yet implemented");
      }
      getEnigmaPubKey(_chainId) {
        throw new Error("Not yet implemented");
      }
      getEnigmaTxEncryptionKey(_chainId, _nonce) {
        throw new Error("Not yet implemented");
      }
      getEnigmaUtils(_chainId) {
        throw new Error("Not yet implemented");
      }
      getKey(chainId) {
        return __awaiter(this, void 0, void 0, function* () {
          const lastSeenKey = this.getLastSeenKey(chainId);
          if (lastSeenKey) {
            return {
              algo: lastSeenKey.algo,
              bech32Address: lastSeenKey.bech32Address,
              ethereumHexAddress: lastSeenKey.ethereumHexAddress,
              address: buffer_1.Buffer.from(lastSeenKey.address, "base64"),
              name: lastSeenKey.name,
              pubKey: buffer_1.Buffer.from(lastSeenKey.pubKey, "base64"),
              isNanoLedger: lastSeenKey.isNanoLedger,
              isKeystone: false
            };
          }
          const lastSession = this.getLastSession();
          if (lastSession && lastSession.sessionProperties) {
            const sessionChainId = lastSession.sessionProperties["chainId"];
            if (sessionChainId === chainId) {
              return {
                algo: lastSession.sessionProperties["algo"],
                bech32Address: lastSession.sessionProperties["bech32Address"],
                ethereumHexAddress: lastSession.sessionProperties["ethereumHexAddress"],
                address: buffer_1.Buffer.from(lastSession.sessionProperties["address"], "base64"),
                name: lastSession.sessionProperties["name"],
                pubKey: buffer_1.Buffer.from(lastSession.sessionProperties["pubKey"], "base64"),
                isNanoLedger: lastSession.sessionProperties["isNanoLedger"] === "true",
                isKeystone: false
              };
            }
          }
          const topic = this.getCurrentTopic();
          const param = {
            topic,
            chainId: this.getNamespaceChainId(),
            request: {
              method: "keplr_getKey",
              params: {
                chainId
              }
            }
          };
          const response = yield this.sendCustomRequest(param);
          return Object.assign(Object.assign({}, response), { pubKey: buffer_1.Buffer.from(response.pubKey, "base64"), address: buffer_1.Buffer.from(response.address, "base64"), isKeystone: false });
        });
      }
      getKeysSettled(chainIds) {
        return __awaiter(this, void 0, void 0, function* () {
          const paramArray = chainIds.map((chainId) => __awaiter(this, void 0, void 0, function* () {
            return yield this.getKey(chainId);
          }));
          return yield Promise.allSettled(paramArray);
        });
      }
      getOfflineSigner(chainId, signOptions) {
        return new provider_1.CosmJSOfflineSigner(chainId, this, signOptions);
      }
      getOfflineSignerAuto(chainId, signOptions) {
        return __awaiter(this, void 0, void 0, function* () {
          const key = yield this.getKey(chainId);
          if (key.isNanoLedger) {
            return new provider_1.CosmJSOfflineSignerOnlyAmino(chainId, this, signOptions);
          }
          return new provider_1.CosmJSOfflineSigner(chainId, this, signOptions);
        });
      }
      getOfflineSignerOnlyAmino(chainId, signOptions) {
        return new provider_1.CosmJSOfflineSignerOnlyAmino(chainId, this, signOptions);
      }
      getSecret20ViewingKey(_chainId, _contractAddress) {
        throw new Error("Not yet implemented");
      }
      sendTx(chainId, tx, mode) {
        if (this.options.sendTx) {
          return this.options.sendTx(chainId, tx, mode);
        }
        throw new Error("send tx is not delivered by options");
      }
      signAmino(chainId, signer, signDoc, signOptions) {
        return __awaiter(this, void 0, void 0, function* () {
          this.checkDeepLink();
          const topic = this.getCurrentTopic();
          const param = {
            topic,
            chainId: this.getNamespaceChainId(),
            request: {
              method: "keplr_signAmino",
              params: {
                chainId,
                signer,
                signDoc,
                signOptions
              }
            }
          };
          return yield this.sendCustomRequest(param);
        });
      }
      signArbitrary(chainId, signer, data) {
        this.checkDeepLink();
        const topic = this.getCurrentTopic();
        const param = {
          topic,
          chainId: this.getNamespaceChainId(),
          request: {
            method: "keplr_signArbitrary",
            params: {
              chainId,
              signer,
              type: typeof data === "string" ? "string" : "Uint8Array",
              data: typeof data === "string" ? data : buffer_1.Buffer.from(data).toString("base64")
            }
          }
        };
        return this.sendCustomRequest(param);
      }
      signDirect(chainId, signer, signDoc, signOptions) {
        var _a2, _b;
        return __awaiter(this, void 0, void 0, function* () {
          this.checkDeepLink();
          const topic = this.getCurrentTopic();
          const param = {
            topic,
            chainId: this.getNamespaceChainId(),
            request: {
              method: "keplr_signDirect",
              params: {
                chainId,
                signer,
                signDoc: {
                  chainId: signDoc.chainId,
                  accountNumber: (_a2 = signDoc.accountNumber) === null || _a2 === void 0 ? void 0 : _a2.toString(),
                  bodyBytes: signDoc.bodyBytes ? buffer_1.Buffer.from(signDoc.bodyBytes).toString("base64") : null,
                  authInfoBytes: signDoc.authInfoBytes ? buffer_1.Buffer.from(signDoc.authInfoBytes).toString("base64") : null
                },
                signOptions
              }
            }
          };
          const response = yield this.sendCustomRequest(param);
          return {
            signature: response.signature,
            signed: {
              chainId: (_b = response.signed.chainId) !== null && _b !== void 0 ? _b : "",
              accountNumber: response.signed.accountNumber ? long_1.default.fromString(response.signed.accountNumber) : new long_1.default(0),
              bodyBytes: response.signed.bodyBytes ? buffer_1.Buffer.from(response.signed.bodyBytes, "base64") : new Uint8Array([]),
              authInfoBytes: response.signed.authInfoBytes ? buffer_1.Buffer.from(response.signed.authInfoBytes, "base64") : new Uint8Array([])
            }
          };
        });
      }
      signDirectAux(_chainId, _signer, _signDoc, _signOptions) {
        throw new Error("Not yet implemented");
      }
      signEthereum(chainId, signer, data, type) {
        return __awaiter(this, void 0, void 0, function* () {
          this.checkDeepLink();
          const topic = this.getCurrentTopic();
          const param = {
            topic,
            chainId: this.getNamespaceChainId(),
            request: {
              method: "keplr_signEthereum",
              params: {
                chainId,
                signer,
                data,
                type
              }
            }
          };
          return yield this.sendCustomRequest(param);
        });
      }
      signICNSAdr36(_chainId, _contractAddress, _owner, _username, _addressChainIds) {
        throw new Error("Not yet implemented");
      }
      suggestToken(_chainId, _contractAddress, _viewingKey) {
        return __awaiter(this, void 0, void 0, function* () {
          const registeredToken = this.getRegisteredSuggestToken(_contractAddress);
          if (registeredToken) {
            return;
          }
          this.checkDeepLink();
          const topic = this.getCurrentTopic();
          const param = {
            topic,
            chainId: this.getNamespaceChainId(),
            request: {
              method: "keplr_suggestToken",
              params: {
                chainId: _chainId,
                contractAddress: _contractAddress,
                viewingKey: _viewingKey
              }
            }
          };
          yield this.sendCustomRequest(param);
          this.saveRegisteredSuggestToken(_chainId, _contractAddress, _viewingKey);
        });
      }
      verifyArbitrary(_chainId, _signer, _data, _signature) {
        throw new Error("Not yet implemented");
      }
      sendEthereumTx(_chainId, _tx) {
        throw new Error("Not yet implemented");
      }
      suggestERC20(_chainId, _contractAddress) {
        throw new Error("Not yet implemented");
      }
      getStarknetKey(_chainId) {
        throw new Error("Not yet implemented");
      }
      getStarknetKeysSettled(_chainIds) {
        throw new Error("Not yet implemented");
      }
      signStarknetTx() {
        throw new Error("Not yet implemented");
      }
      signStarknetDeployAccountTransaction(_chainId, _transaction) {
        throw new Error("Not yet implemented");
      }
      getBitcoinKey(_chainId) {
        throw new Error("Not yet implemented");
      }
      getBitcoinKeysSettled(_chainIds) {
        throw new Error("Not yet implemented");
      }
      signPsbt(_chainId, _psbtHex, _options) {
        throw new Error("Method not implemented.");
      }
      signPsbts(_chainId, _psbtsHexes, _options) {
        throw new Error("Method not implemented.");
      }
    };
    exports.KeplrWalletConnectV2 = KeplrWalletConnectV22;
    var MockEthereumProvider = class extends events_1.default {
      constructor() {
        super();
        this.chainId = null;
        this.selectedAddress = null;
        this.networkVersion = null;
        this.isKeplr = true;
        this.isMetaMask = true;
      }
      isConnected() {
        throw new Error("Method not implemented.");
      }
      request({}) {
        throw new Error("Not yet implemented");
      }
      enable() {
        throw new Error("Method not implemented.");
      }
      net_version() {
        throw new Error("Method not implemented.");
      }
    };
  }
});

// ../../node_modules/.pnpm/@cosmos-kit+keplr-extension@2.15.1_@cosmjs+amino@0.34.0_@cosmjs+proto-signing@0.34.0_starknet@7.6.4/node_modules/@cosmos-kit/keplr-extension/esm/config.js
var preferredEndpoints = {
  osmosis: {
    rpc: ["https://rpc-osmosis.keplr.app/"],
    rest: ["https://lcd-osmosis.keplr.app/"]
  },
  osmosistestnet: {
    rpc: ["https://rpc-test.osmosis.zone/"],
    rest: ["https://lcd-test.osmosis.zone/"]
  },
  cosmoshub: {
    rpc: ["https://rpc-cosmoshub.keplr.app"],
    rest: ["https://lcd-cosmoshub.keplr.app"]
  },
  terra: {
    rpc: ["https://rpc-columbus.keplr.app"],
    rest: ["https://lcd-columbus.keplr.app"]
  },
  secretnetwork: {
    rpc: ["https://rpc-secret.keplr.app"],
    rest: ["https://lcd-secret.keplr.app"]
  },
  akash: {
    rpc: ["https://rpc-akash.keplr.app"],
    rest: ["https://lcd-akash.keplr.app"]
  },
  regen: {
    rpc: ["https://rpc-regen.keplr.app"],
    rest: ["https://lcd-regen.keplr.app"]
  },
  sentinel: {
    rpc: ["https://rpc-sentinel.keplr.app"],
    rest: ["https://lcd-sentinel.keplr.app"]
  },
  persistence: {
    rpc: ["https://rpc-persistence.keplr.app"],
    rest: ["https://lcd-persistence.keplr.app"]
  },
  irisnet: {
    rpc: ["https://rpc-iris.keplr.app"],
    rest: ["https://lcd-iris.keplr.app"]
  },
  cryptoorgchain: {
    rpc: ["https://rpc-crypto-org.keplr.app/"],
    rest: ["https://lcd-crypto-org.keplr.app/"]
  },
  starname: {
    rpc: ["https://rpc-iov.keplr.app"],
    rest: ["https://lcd-iov.keplr.app"]
  },
  emoney: {
    rpc: ["https://rpc-emoney.keplr.app"],
    rest: ["https://lcd-emoney.keplr.app"]
  },
  juno: {
    rpc: ["https://rpc-juno.itastakers.com"],
    rest: ["https://lcd-juno.itastakers.com"]
  },
  microtick: {
    rpc: ["https://rpc-microtick.keplr.app"],
    rest: ["https://lcd-microtick.keplr.app"]
  },
  likecoin: {
    rpc: ["https://mainnet-node.like.co/rpc"],
    rest: ["https://mainnet-node.like.co"]
  },
  impacthub: {
    rpc: ["https://rpc-impacthub.keplr.app"],
    rest: ["https://lcd-impacthub.keplr.app"]
  },
  bitcanna: {
    rpc: ["https://rpc.bitcanna.io"],
    rest: ["https://lcd.bitcanna.io"]
  },
  bitsong: {
    rpc: ["https://rpc.explorebitsong.com"],
    rest: ["https://lcd.explorebitsong.com"]
  },
  kichain: {
    rpc: ["https://rpc-mainnet.blockchain.ki"],
    rest: ["https://api-mainnet.blockchain.ki"]
  },
  panacea: {
    rpc: ["https://rpc.gopanacea.org"],
    rest: ["https://api.gopanacea.org"]
  },
  bostrom: {
    rpc: ["https://rpc.bostrom.cybernode.ai"],
    rest: ["https://lcd.bostrom.cybernode.ai"]
  },
  comdex: {
    rpc: ["https://rpc.comdex.one"],
    rest: ["https://rest.comdex.one"]
  },
  cheqd: {
    rpc: ["https://rpc.cheqd.net"],
    rest: ["https://api.cheqd.net"]
  },
  stargaze: {
    rpc: ["https://rpc.stargaze-apis.com"],
    rest: ["https://rest.stargaze-apis.com"]
  },
  chihuahua: {
    rpc: ["https://rpc.chihuahua.wtf"],
    rest: ["https://api.chihuahua.wtf"]
  },
  lumnetwork: {
    rpc: ["https://node0.mainnet.lum.network/rpc"],
    rest: ["https://node0.mainnet.lum.network/rest"]
  },
  vidulum: {
    rpc: ["https://mainnet-rpc.vidulum.app"],
    rest: ["https://mainnet-lcd.vidulum.app"]
  },
  desmos: {
    rpc: ["https://rpc.mainnet.desmos.network"],
    rest: ["https://api.mainnet.desmos.network"]
  },
  dig: {
    rpc: ["https://rpc-1-dig.notional.ventures"],
    rest: ["https://api-1-dig.notional.ventures"]
  },
  sommelier: {
    rpc: ["https://rpc-sommelier.keplr.app"],
    rest: ["https://lcd-sommelier.keplr.app"]
  },
  sifchain: {
    rpc: ["https://rpc.sifchain.finance"],
    rest: ["https://api-int.sifchain.finance"]
  },
  bandchain: {
    rpc: ["https://rpc.laozi3.bandchain.org"],
    rest: ["https://laozi1.bandchain.org/api"]
  },
  konstellation: {
    rpc: ["https://node1.konstellation.tech:26657"],
    rest: ["https://node1.konstellation.tech:1318"]
  },
  umee: {
    rpc: ["https://rpc.aphrodite.main.network.umee.cc"],
    rest: ["https://api.aphrodite.main.network.umee.cc"]
  },
  gravitybridge: {
    rpc: ["https://gravitychain.io:26657"],
    rest: ["https://gravitychain.io:1317"]
  },
  decentr: {
    rpc: ["https://poseidon.mainnet.decentr.xyz"],
    rest: ["https://rest.mainnet.decentr.xyz"]
  },
  shentu: {
    rpc: ["https://shenturpc.certikpowered.info"],
    rest: ["https://azuredragon.noopsbycertik.com"]
  },
  carbon: {
    rpc: ["https://tm-api.carbon.network"],
    rest: ["https://api.carbon.network"]
  },
  injective: {
    rpc: ["https://public.api.injective.network"],
    rest: ["https://public.lcd.injective.network"]
  },
  cerberus: {
    rpc: ["https://rpc.cerberus.zone:26657"],
    rest: ["https://api.cerberus.zone:1317"]
  },
  fetchhub: {
    rpc: ["https://rpc-fetchhub.fetch.ai:443"],
    rest: ["https://rest-fetchhub.fetch.ai"]
  },
  assetmantle: {
    rpc: ["https://rpc.assetmantle.one/"],
    rest: ["https://rest.assetmantle.one/"]
  },
  provenance: {
    rpc: ["https://rpc.provenance.io/"],
    rest: ["https://api.provenance.io"]
  },
  galaxy: {
    rpc: ["https://rpc.galaxychain.zone"],
    rest: ["https://rest.galaxychain.zone"]
  },
  meme: {
    rpc: ["https://rpc-meme-1.meme.sx:443"],
    rest: ["https://api-meme-1.meme.sx:443"]
  },
  evmos: {
    rpc: ["https://rpc-evmos.keplr.app/"],
    rest: ["https://lcd-evmos.keplr.app/"]
  },
  terra2: {
    rpc: ["https://rpc.terrav2.ccvalidators.com/"],
    rest: ["https://phoenix-lcd.terra.dev/"]
  },
  rizon: {
    rpc: ["https://rpcapi.rizon.world/"],
    rest: ["https://restapi.rizon.world/"]
  },
  kava: {
    rpc: ["https://rpc-kava.keplr.app"],
    rest: ["https://lcd-kava.keplr.app"]
  },
  genesisl1: {
    rpc: ["https://26657.genesisl1.org"],
    rest: ["https://api.genesisl1.org"]
  }
};

// ../../node_modules/.pnpm/@cosmos-kit+keplr-extension@2.15.1_@cosmjs+amino@0.34.0_@cosmjs+proto-signing@0.34.0_starknet@7.6.4/node_modules/@cosmos-kit/keplr-extension/esm/extension/chain-wallet.js
var ChainKeplrExtension = class extends ChainWalletBase {
  constructor(walletInfo, chainInfo) {
    super(walletInfo, chainInfo);
  }
};

// ../../node_modules/.pnpm/@cosmos-kit+keplr-extension@2.15.1_@cosmjs+amino@0.34.0_@cosmjs+proto-signing@0.34.0_starknet@7.6.4/node_modules/@cosmos-kit/keplr-extension/esm/extension/main-wallet.js
var import_provider_extension = __toESM(require_build2());

// ../../node_modules/.pnpm/@chain-registry+keplr@1.74.281/node_modules/@chain-registry/keplr/esm/index.js
var import_cosmos = __toESM(require_build7());
var import_semver = __toESM(require_semver2());
var getRpc = (chain) => {
  var _a2, _b, _c;
  return ((_c = (_b = (_a2 = chain.apis) == null ? void 0 : _a2.rpc) == null ? void 0 : _b[0]) == null ? void 0 : _c.address) ?? "";
};
var getRest = (chain) => {
  var _a2, _b, _c;
  return ((_c = (_b = (_a2 = chain.apis) == null ? void 0 : _a2.rest) == null ? void 0 : _b[0]) == null ? void 0 : _c.address) ?? "";
};
var getExplr = (chain) => {
  var _a2, _b;
  return ((_b = (_a2 = chain.explorers) == null ? void 0 : _a2[0]) == null ? void 0 : _b.url) ?? "";
};
var versionPatterns = {
  fullSemver: /v?(\d+\.\d+\.\d+)(?=-[\w.-]+|$)/,
  // Matches complete semver patterns like '0.47.20' or 'v0.47.20'
  partialSemver: /v?(\d+\.\d+)(?=(?:\.\d+)?(?=-[\w.-]+|$))/,
  // Matches partial semver patterns like '0.47' or 'v0.47'
  basicVersion: /v?(\d+)(?=(?:\.\d+)?(?:\.\d+)?(?=-[\w.-]+|$))/,
  // Matches basic versions like '0' or 'v0'
  tagged: /@v(\d+\.\d+)(?:\.x)?(?=-[\w.-]+|$)/,
  // Specific for tagged formats
  embedded: /\/v(\d+\.\d+\.\d+)(?=-[\w.-]+|$)/,
  // For versions embedded in paths
  simple: /v?(\d+)(?:\.(\d+))?(?:\.(\d+))?$/,
  // General simple versions
  complexEmbedded: /[\w-]+\/[\w-]+ v(\d+)(?:\.(\d+))?(?:\.(\d+))?(?:-\d+[\w.-]*)/,
  // Complex formats with namespaces
  taggedVersion: /[\w-]+\/[\w-]+ v(\d+)(?:\.(\d+))?(?:\.(\d+))?(?=-[\w.-]+|$)/
  // Versions with descriptive tags
};
function extractVersion(input) {
  var _a2, _b, _c, _d, _e3, _f, _g, _h;
  let version6 = null;
  if (versionPatterns.fullSemver.test(input)) {
    version6 = (_a2 = input.match(versionPatterns.fullSemver)) == null ? void 0 : _a2[1];
  } else if (versionPatterns.partialSemver.test(input)) {
    version6 = (_b = input.match(versionPatterns.partialSemver)) == null ? void 0 : _b[1];
  } else if (versionPatterns.basicVersion.test(input)) {
    version6 = (_c = input.match(versionPatterns.basicVersion)) == null ? void 0 : _c[1];
  } else if (versionPatterns.taggedVersion.test(input)) {
    version6 = (_d = input.match(versionPatterns.taggedVersion)) == null ? void 0 : _d[1];
  } else if (versionPatterns.complexEmbedded.test(input)) {
    version6 = (_e3 = input.match(versionPatterns.complexEmbedded)) == null ? void 0 : _e3[1];
  } else if (versionPatterns.simple.test(input)) {
    version6 = (_f = input.match(versionPatterns.simple)) == null ? void 0 : _f[1];
  } else if (versionPatterns.tagged.test(input)) {
    version6 = (_g = input.match(versionPatterns.tagged)) == null ? void 0 : _g[1];
  } else if (versionPatterns.embedded.test(input)) {
    version6 = (_h = input.match(versionPatterns.embedded)) == null ? void 0 : _h[1];
  }
  return version6 ? normalizeVersion(version6) : null;
}
function normalizeVersion(version6) {
  const parts = version6.split(".");
  while (parts.length < 3) {
    parts.push("0");
  }
  return parts.join(".");
}
var chainRegistryChainToKeplr = (chain, assets, options = {
  getRpcEndpoint: getRpc,
  getRestEndpoint: getRest,
  getExplorer: getExplr
}) => {
  var _a2, _b, _c, _d, _e3, _f, _g, _h, _i2, _j, _k, _l, _m, _n2, _o2, _p, _q;
  if (!options.getRestEndpoint)
    options.getRestEndpoint = getRest;
  if (!options.getRpcEndpoint)
    options.getRpcEndpoint = getRpc;
  if (!options.getExplorer)
    options.getExplorer = getExplr;
  const features = [];
  const isCosmosSDKChain = ((_b = (_a2 = chain.codebase) == null ? void 0 : _a2.sdk) == null ? void 0 : _b.type) === "cosmos" || !!((_c = chain.codebase) == null ? void 0 : _c.cosmos_sdk_version);
  if (isCosmosSDKChain) {
    let sdkVer;
    if (((_e3 = (_d = chain.codebase) == null ? void 0 : _d.sdk) == null ? void 0 : _e3.type) === "cosmos" && chain.codebase.sdk.version) {
      sdkVer = extractVersion(chain.codebase.sdk.version);
    } else if ((_f = chain.codebase) == null ? void 0 : _f.cosmos_sdk_version) {
      sdkVer = extractVersion(chain.codebase.cosmos_sdk_version);
    } else {
      sdkVer = "0.40.0";
    }
    if (import_semver.default.satisfies(sdkVer, ">=0.40"))
      features.push("stargate");
    if (import_semver.default.satisfies(sdkVer, ">=0.43"))
      features.push("no-legacy-stdTx");
    features.push("ibc-transfer");
    if (import_semver.default.satisfies(sdkVer, ">=0.45"))
      features.push("ibc-go");
    const cosmwasmEnabled = ((_h = (_g = chain.codebase) == null ? void 0 : _g.cosmwasm) == null ? void 0 : _h.enabled) ?? ((_i2 = chain.codebase) == null ? void 0 : _i2.cosmwasm_enabled) ?? false;
    if (cosmwasmEnabled) {
      features.push("cosmwasm");
      const wasmVer = extractVersion(((_k = (_j = chain.codebase) == null ? void 0 : _j.cosmwasm) == null ? void 0 : _k.version) ?? ((_l = chain.codebase) == null ? void 0 : _l.cosmwasm_version) ?? "0.24.0");
      if (import_semver.default.satisfies(wasmVer, ">=0.24.0"))
        features.push("wasmd_0.24+");
    }
  }
  const chainAssets = ((_m = assets.find((asset) => asset.chain_name === chain.chain_name)) == null ? void 0 : _m.assets) || [];
  const feeDenoms = ((_n2 = chain.fees) == null ? void 0 : _n2.fee_tokens.map((feeToken) => feeToken.denom)) || [];
  const gasPriceSteps = (_p = (_o2 = chain.fees) == null ? void 0 : _o2.fee_tokens) == null ? void 0 : _p.reduce((m3, feeToken) => {
    m3[feeToken.denom] = {
      low: feeToken.low_gas_price ?? 0.01,
      average: feeToken.average_gas_price ?? 0.025,
      high: feeToken.high_gas_price ?? 0.04
    };
    return m3;
  }, {});
  const stakingDenoms = ((_q = chain.staking) == null ? void 0 : _q.staking_tokens.map((stakingToken) => stakingToken.denom)) || [];
  const currencies = chainAssets.map((currency) => {
    var _a3, _b2, _c2;
    return {
      coinDenom: currency.symbol,
      coinMinimalDenom: currency.base,
      coinDecimals: (_a3 = currency.denom_units.filter((denomUnit) => denomUnit.denom === currency.display)[0]) == null ? void 0 : _a3.exponent,
      coinGeckoId: currency.coingecko_id || void 0,
      coinImageUrl: ((_b2 = currency.logo_URIs) == null ? void 0 : _b2.svg) ?? ((_c2 = currency.logo_URIs) == null ? void 0 : _c2.png)
    };
  });
  const stakeCurrency = currencies.find((currency) => stakingDenoms.includes(currency.coinDenom)) ?? currencies[0];
  const feeCurrencies = currencies.filter((currency) => feeDenoms.includes(currency.coinMinimalDenom)).map((feeCurrency) => {
    if (!(feeCurrency.coinMinimalDenom in gasPriceSteps)) {
      return feeCurrency;
    }
    const gasPriceStep = gasPriceSteps[feeCurrency.coinMinimalDenom];
    return {
      ...feeCurrency,
      gasPriceStep
    };
  });
  const feeCurrenciesDefault = currencies.filter((currency) => stakeCurrency.coinDenom === currency.coinDenom).map((feeCurrency) => {
    if (!(feeCurrency.coinMinimalDenom in gasPriceSteps)) {
      return feeCurrency;
    }
    const gasPriceStep = gasPriceSteps[feeCurrency.coinMinimalDenom];
    return {
      ...feeCurrency,
      gasPriceStep
    };
  });
  const chainInfo = {
    rpc: options.getRpcEndpoint(chain),
    rest: options.getRestEndpoint(chain),
    chainId: chain.chain_id,
    chainName: chain.pretty_name,
    bip44: {
      coinType: chain.slip44
    },
    bech32Config: import_cosmos.Bech32Address.defaultBech32Config(chain.bech32_prefix),
    currencies,
    stakeCurrency: stakeCurrency || currencies[0],
    feeCurrencies: feeCurrencies.length !== 0 ? feeCurrencies : feeCurrenciesDefault,
    features
  };
  return chainInfo;
};

// ../../node_modules/.pnpm/@cosmos-kit+keplr-extension@2.15.1_@cosmjs+amino@0.34.0_@cosmjs+proto-signing@0.34.0_starknet@7.6.4/node_modules/@cosmos-kit/keplr-extension/esm/extension/client.js
var import_long = __toESM(require_long());

// ../../node_modules/.pnpm/@cosmos-kit+keplr-extension@2.15.1_@cosmjs+amino@0.34.0_@cosmjs+proto-signing@0.34.0_starknet@7.6.4/node_modules/@cosmos-kit/keplr-extension/esm/extension/session.js
var ExpiringLocalStorage = class {
  /**
   * Add an item to an array in local storage with an expiration time.
   * @param {string} key - The key under which the array is stored.
   * @param {*} value - The value to be added.
   * @param {number} ttl - Time to live in milliseconds.
   */
  static addItem(key, value, ttl) {
    const now = /* @__PURE__ */ new Date();
    const newItem = {
      value,
      expiry: now.getTime() + ttl
    };
    const itemStr = localStorage.getItem(key);
    const items = itemStr ? JSON.parse(itemStr) : [];
    items.push(newItem);
    localStorage.setItem(key, JSON.stringify(items));
  }
  /**
   * Get all valid (non-expired) items from an array in local storage.
   * @param {string} key - The key of the array to retrieve.
   * @returns {Array} An array of valid items.
   */
  static getItems(key) {
    const itemStr = localStorage.getItem(key);
    if (!itemStr) {
      return [];
    }
    const items = JSON.parse(itemStr);
    const now = /* @__PURE__ */ new Date();
    const validItems = [];
    for (const item of items) {
      if (now.getTime() <= item.expiry) {
        validItems.push(item.value);
      }
    }
    localStorage.setItem(key, JSON.stringify(validItems.map((value) => ({
      value,
      expiry: items.find((item) => item.value === value).expiry
    }))));
    return validItems;
  }
  /**
   * Remove a specific item from the array in local storage.
   * @param {string} key - The key of the array.
   * @param {*} value - The value to be removed.
   */
  static removeItem(key, value) {
    const itemStr = localStorage.getItem(key);
    if (!itemStr) {
      return;
    }
    let items = JSON.parse(itemStr);
    items = items.filter((item) => item.value !== value);
    localStorage.setItem(key, JSON.stringify(items));
  }
};

// ../../node_modules/.pnpm/@cosmos-kit+keplr-extension@2.15.1_@cosmjs+amino@0.34.0_@cosmjs+proto-signing@0.34.0_starknet@7.6.4/node_modules/@cosmos-kit/keplr-extension/esm/extension/client.js
var KeplrClient = class {
  constructor(client) {
    __publicField(this, "client");
    __publicField(this, "_defaultSignOptions", {
      preferNoSetFee: false,
      preferNoSetMemo: true,
      disableBalanceCheck: true
    });
    this.client = client;
  }
  get defaultSignOptions() {
    return this._defaultSignOptions;
  }
  setDefaultSignOptions(options) {
    this._defaultSignOptions = options;
  }
  async enable(chainIds) {
    await this.client.enable(chainIds);
  }
  async suggestToken({ chainId, tokens, type }) {
    if (type === "cw20") {
      for (const { contractAddress, viewingKey } of tokens) {
        await this.client.suggestToken(chainId, contractAddress, viewingKey);
      }
    }
  }
  async getSimpleAccount(chainId) {
    const { address, username } = await this.getAccount(chainId);
    return {
      namespace: "cosmos",
      chainId,
      address,
      username
    };
  }
  async getAccount(chainId) {
    const key = await this.client.getKey(chainId);
    return {
      username: key.name,
      address: key.bech32Address,
      algo: key.algo,
      pubkey: key.pubKey,
      isNanoLedger: key.isNanoLedger
    };
  }
  getOfflineSigner(chainId, preferredSignType) {
    switch (preferredSignType) {
      case "amino":
        return this.getOfflineSignerAmino(chainId);
      case "direct":
        return this.getOfflineSignerDirect(chainId);
      default:
        return this.getOfflineSignerAmino(chainId);
    }
  }
  getOfflineSignerAmino(chainId) {
    return {
      getAccounts: async () => {
        return [await this.getAccount(chainId)];
      },
      signAmino: async (signerAddress, signDoc) => {
        return this.signAmino(chainId, signerAddress, signDoc, this.defaultSignOptions);
      }
    };
  }
  getOfflineSignerDirect(chainId) {
    return {
      getAccounts: async () => {
        return [await this.getAccount(chainId)];
      },
      signDirect: async (signerAddress, signDoc) => {
        const resp = await this.signDirect(chainId, signerAddress, signDoc, this.defaultSignOptions);
        return {
          ...resp,
          signed: {
            ...resp.signed,
            accountNumber: BigInt(resp.signed.accountNumber.toString())
          }
        };
      }
    };
  }
  async addChain(chainInfo) {
    var _a2, _b, _c, _d, _e3, _f, _g, _h;
    const chainsAlreadyAdded = ExpiringLocalStorage.getItems("cosmos-kit@2:keplr/supported-chain");
    if (chainsAlreadyAdded && chainsAlreadyAdded.length > 0) {
      if (chainsAlreadyAdded.includes(chainInfo.name)) {
        return;
      }
    }
    const suggestChain = chainRegistryChainToKeplr(chainInfo.chain, chainInfo.assetList ? [chainInfo.assetList] : []);
    if ((_b = (_a2 = chainInfo.preferredEndpoints) == null ? void 0 : _a2.rest) == null ? void 0 : _b[0]) {
      suggestChain.rest = (_d = (_c = chainInfo.preferredEndpoints) == null ? void 0 : _c.rest) == null ? void 0 : _d[0];
    }
    if ((_f = (_e3 = chainInfo.preferredEndpoints) == null ? void 0 : _e3.rpc) == null ? void 0 : _f[0]) {
      suggestChain.rpc = (_h = (_g = chainInfo.preferredEndpoints) == null ? void 0 : _g.rpc) == null ? void 0 : _h[0];
    }
    try {
      await this.client.experimentalSuggestChain(suggestChain);
      ExpiringLocalStorage.addItem("cosmos-kit@2:keplr/supported-chain", chainInfo.name, 1e3 * 60);
    } catch (error) {
      console.log("Error while adding chain", error);
      throw error;
    }
  }
  async signAmino(chainId, signer, signDoc, signOptions) {
    return await this.client.signAmino(chainId, signer, signDoc, signOptions || this.defaultSignOptions);
  }
  async signArbitrary(chainId, signer, data) {
    return await this.client.signArbitrary(chainId, signer, data);
  }
  async signDirect(chainId, signer, signDoc, signOptions) {
    const resp = await this.client.signDirect(chainId, signer, {
      ...signDoc,
      accountNumber: import_long.default.fromString(signDoc.accountNumber.toString())
    }, signOptions || this.defaultSignOptions);
    return {
      ...resp,
      signed: {
        ...resp.signed,
        accountNumber: BigInt(resp.signed.accountNumber.toString())
      }
    };
  }
  async sendTx(chainId, tx, mode) {
    return await this.client.sendTx(chainId, tx, mode);
  }
};

// ../../node_modules/.pnpm/@cosmos-kit+keplr-extension@2.15.1_@cosmjs+amino@0.34.0_@cosmjs+proto-signing@0.34.0_starknet@7.6.4/node_modules/@cosmos-kit/keplr-extension/esm/extension/main-wallet.js
var KeplrExtensionWallet = class extends MainWalletBase {
  constructor(walletInfo, preferredEndpoints3) {
    super(walletInfo, ChainKeplrExtension);
    this.preferredEndpoints = preferredEndpoints3;
  }
  async initClient() {
    this.initingClient();
    try {
      const keplr = await import_provider_extension.Keplr.getKeplr();
      this.initClientDone(keplr ? new KeplrClient(keplr) : void 0);
    } catch (error) {
      this.initClientError(error);
    }
  }
};

// ../../node_modules/.pnpm/@cosmos-kit+keplr-extension@2.15.1_@cosmjs+amino@0.34.0_@cosmjs+proto-signing@0.34.0_starknet@7.6.4/node_modules/@cosmos-kit/keplr-extension/esm/constant.js
var ICON = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQAAAAEACAYAAABccqhmAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAGAzSURBVHgB3b0L1G3HUR5Ydf5fb8kWCZMMYKOr8IgHCLETQ4BAJMPMQGBlbDMLAyuAJdYM2IQsbDI8bAKWCEwmAwMWhlhmCL7yygoJhtjGAQMx6BqZYMwASgIE2xBdxy8CA77W6+px79/Z55z96K76qrp6n9eVSjr3P7vruXv3V13de59zmJ7IdHe6nujxU0SPPZOITxEvbuj+dm0nH91xj9evdFy1k8Z/IoIrYmqlE4ratvg8SzdwXsrwiW+PHV5OCwr4Tk6EG8TBqiUQF4okXehivECJL3R6F7qGs3Tx4nu79/d24Z2jz77xDD2BqX0cH5LuPn+K6OLNdHR0E6V0c9dyauSZo6gCgBSUy2TmAXHJbgQq529TXK+Vx1G9GTrs8FZ8KwEEE40Vh5kA2hJHQWye47204GVCeFuXHM50SeEsPUHo0k8Ad5+/mRbpeV2oz6UV4MVFqOI2BVk7TgDVKsP3z7zDBLByMEMvohNIAFgCA7nOt/VGT802e2LvPAobZ7sK4Qw9nu661CuESzMBjKCnF65L+pwSfGvTdhMAV/jzfdg8lvw5YK3xLrkE0LduMQGsuR4/kHTcCiGzMdElnQwunQSwWs+fv4WOupk+0c224JYSQArKCZlQApi1HGlIAAVjSwlgckRbTQAruYo9Ht9pnvKzGS9tBPJZCWCiRZcMTtLt9Jk3nqZLhA6fAJbAP37km7qOeYme7RHVQGbIV5vrBnmjGb7GT4bPmm5glmzhtSaVSNIIJgDRSiGQQ76vl0weUR3ktWVAjb/6e7bbVHwjXTi549D7BYdLAM3AHyg1gL+XDzRV1+BIpjmJtAGSQ7pBkLTweM8JoLCjeRiwgQTg8NLcBLBxghC2iF7Z3Vs4WCI4TAK45/wr2oHfU2pCP9VBW2XgWXhGEmkBJM/V3db+QLSqiC4bNtnRJ5QEggnA0Uv72wcQfOXr7CoJfNaNr6Q9034TwGpzj1/bnfgpmkNp/KdVKaBWK8F7mdRuI8ZPwF+b7kita3mLF60qqv42LOWHIy+5zeFx675Dz98kAYwyQG6ZCC7SS+lv3PhG2hPtJwEsy/2jR1/Rne9L1g2tIM5VGnXDFYORALa2xvf5vMXqYTK6pwQwym6YAJQMTjapVS/AS4g/q0KgSr9T5BxP0+N0+z6WBbtPAOOsv7yHP1ADiJvX2VJ0fgLgra7xDR8b6NZ5M4AsebXyOqdZa30M8hovzdSDfM45XvLIdDfZJyj0zYR6tmPdSp+x21uHkYc159OvPPKDHfjvpgL8AUrZaw5totsTb6gf8kF7on31ZUQ2YiuYR1pyUzzfcWWCZqNdyGw+V5zq/r2bfuO+V9AOaTdjcPnI7lE365v381OoKazrsoKGU20NHrEV429lnb8JL7pmh3pzZnmgV42h4k/wUkQnZNOzq/nVzc1QJVAdo/d2m4TP38WSYPsJ4O4Hn0mL4zeQN+s37+QXyu5hVd5kpUBnbJAAUnCdXxtQ2+RlZU78roMfIwZMr6f8O7yRH+fFk0A8AYwt4T0GIFNNAgE8LJcEj9Nztp0EtrsEuPvR53Xgv5sk+JN4bUpbXiLAcnKuTeMVtl+xM4fYeqX+RY2UAr42LfVr/OT79pfoHLY52k7SU02PK3wRT2RJcEy/Tf/ffc+jLdL2EsDbH3th10tv6AK9fuuApy3YM/Q3An4gpq0kF8vntnzP6dvIpJXs5BO205gEcp57/slrx1o8t0CL8Id9A19uia030DvuewltibaTAN7W3eK7cHKatk2bgD4Ako1n5Qptf31lUCpn842STkt/R2QNmSLOHSYBmtMncxOL0mMYj02RDcaOjugHt7U5uPkYXYI/pduoidIs1jxdLO+ueVOTA8Wft8lX42te9RZidNPO4rVMd1Eke8iB4z8JH74uBXU3+1AQFedbWwG0zUBNJept3W3C22kD2iwBvO2Rb+rinfH4YnIPw7ohvVLIvt7bWbTu7i6Cl1wCII9NWZvpzb5L4IFc3Jn3dBXf5yXYLvTdJJCQBvDn9Em0f604eHELPfuGu2gmzU8Ayw2/5Zp/Dm16F2BmwvDHzmYJgEM25vHrtht5kYHZAiypF6kcavYcfgrr1mbTVL6z+P6OIuTrRFC59tH+Zdj2fHr2vMeH5yWA1Vdz8W/TclNiFs1MAGn8J0zjrbdNlhaOTHndtpcAzCXK3Jkc0ZxHhVuWFZvM1gXfjiW1xhnwmSx+8xIkl0gxtIWSs5Slc534c+gzb7yXGql9E3AN/rtpNviDlMCrQXfYFGvWDdiG9rfko7pZlWizvrFs7UKnJrcFvrnBh6d0YZNdm3ATTxEDu0iC432W263Jrl9LLL6Bfu2+U9RI7Qlg+UUG1N2T3BZtY0AL3XlljW8zt70V+xmZg7iFtpQMvFt36lWRL2zXfM/lZ+sB5buWXDxecs5lbuEU0S9kmkbE8jmB11IjtSWAu7sdf6a/SnNoG0C37PU0C0SBuLYCUEC7sLmi4lwY9tH6xRi0QK8ktv0RBuQ6WbAzY1f8NYJu8svkfp9q1S4X9kpe7q1ut/iUQVM1EKTlo/e/cd8PtqjEx9/yU31pVfpvgYJnluK6XDNSdZkCNgOpO/l8dp0E7De0s8dvnSbZ4SnbFZvs8HpfyeL1/DivtAs0KjERxXb7vf7Q2snlI/KuoaCLq0eGz1CAYglgue5PMz7VZ1JyD1t0a2MpbrxiN2mZmg1tay7AAR8EWE2CFq/eiSXVBjwAnOJBPii9Ml6CccR0bZ6w7PWFsaUw6UWTQAoXV45HT/csXUbPomfdeI4qFFsCXKTbaFPwJ+c1g8aSbIs2V3YT6c29sD3GMRr8jShla/C0oeXW84zKR0rsMJ/hHoSrS5OuzSuXQhS2OVkuxqGna5wLlHMzBLs+un45tXiMXkEBqo+b5f3+k5n3+01qQKi6WK3oTlu0G5Ph2TbqiGqa5VvLfKXboFdbykRiqc6iMV5qsevElZqXGmuZ5PJz3/b54HNATY6Nk/pSoP67eSepaVNhNtXGxQ7sbmzbstWaowxjG8eWsN1m3UgsaZJd/yMAOfJLnm3D4Ju83i6INQ2IRIBz4mIRT0J6GX84WE0mma45HMYMk1TQXu4pBdgU4gW9tmu5kRzylwB3P/JNtLV1f08NJbtT7Gxkd2u2p5JrK88cFLvyDefSRMIWR17QP4fsE7BVvdVoni/HSm0y/DfqFbxUXh9ft9xtDC3RWq8xHB8qulP0a394m2fGjmu58XfSbfylLSeAFfln6nbWhl8Lbleq7UsADshE+BzWn1cec8QmV/ilQZuX60Vschvf/86+eXaTlKmhlZUGtOvObJDr9fVM4nQuXd5VAcaGoF0BnPA37Qb8NpkzX5HlGimbobf15F5T9VCxsamdkUBFEtscZKXf4mueHGuZmo1MU1ULnt0aH9isx8RmTC39oishNmVnj9fE19MjZH5/AB4fy9n/It9H26KEG+YN/uQe5lTbJAkbQrbSXDuR0VEo2LyCHbRbmxkRb9ZM7s9+Pr92UWO6qcW308+psUpREtFvmK30TXJ1nMvEdO7k8gSrAFwBrGd/2tqL8FovRAHb+nwbwF+xv9ltwTKeWQnPiGf2rb855zH4Jn/dXq7vGV/zmt9N+Cve1CtWjHW7Zc/iPq9XMcpvrb9Tfg5s2yPc7+Y4PqHrF0YVAMcQv/WR+6gv/2sxzxuEjQgqlU2OTuItfpJty5Dx7HCFX9PHsdSQoRQwX9n2dB2ftdmaUr16CPJTk37Ndhkbnlkr1ymbre1KA/jMZOKjM3I+VTp3cqWuAnQF8Ivnb+kyxik444AXzXltg0B8m/qAM3XjuW3UL1nsMJYoBWyatlUfct1PJBZFHLMx9Cv5M6BrO7XZXvM4FBcReKjH9FtWDfKOiE29hHFdg3T94jzdIhsX2hW/gnZKCTe1Ao22Bw4XtAHaCKzAxryNULbtWTZrFJUNDvgIGM3EU+FbtxeVvhdbxhmXMaG4/WWHe16Z//ot0uE/gksA97WUZX6udF1G85bzN/NiWx/4sSiIKkCqXK2aTRVbMVkkwwGZeTbi+srORje6iUKlq5Jz7NaWCNUyO9AXPE8/VWMTfgQvWfEoXUMqujEo/BrW4iYupudc+Lzp6cDiScDFgm6ZD88tkTfWNqSqrcDJbyMeDjc26C8ptSrkAqnUZ8eEnEk5kJRRDMPTexV+svgrJHr6ZPJ4NIqTSHJ0C5VstQH7EdhY5x6mXNNOKqVfRcwBoYlOjmj5uwJniljGg1/oNv+oW//PpVD2qAvxhvqT6HRZAsIulwMylh2u8Jv1mzMA4KtBWakQOGB3WxUER3VLfqrwsb6QMc4hVauNUlq/o7brts2Zr7w+5y58zqmPGjjTHsBblp/378Cfr1laXxsQXLchaognZC8Y1751Xf2ZfW+uHSOaET/ReKJ2GnnjeVG5bg7bJs82+/1lnDvqc+0DXOktYmu0v9rY5OuP77nv5oEzLgG6THDLxn6iFBp08yhsN23BxrZ0Gb5tI28SqxlNDfJQljWjWv5nTHcJYfA9feHbnfT7+IubeWbsU4nPgD+qOR/yGVXMfiSC3xbggbN10CymZcDxZJ9v2jzTYNo62EGW3QZtMtNv5LO139k91BQCeAZi2b/RhGDJZZ/Um2UjOTyi6nrdW+tP1TFONNq2SHYZX5vvEkvyMrOOY4pFNFJMN0S8WN4NeMna15Lecv5U5/Q+2pBiQEjuYYt+3V/dOEdlk5ZhW9BxuJ0fD2HHfk0XqlUHXG0g17LyofmTTDL5mZ3Kej81lZDJsVOjBPU2paOjkxsf+ewbz64qgKMTuvkky2CRpH4oMvZa5tvYk+6oV40Zz1YbL224+FPXYyMuKbvprL41vjEzF/prmSLXqRJ+KvMlPxdkp6pQD7oyQpahXm1I9THUJxZvzFx8nG7u/pxebQJ2FdrNXOqPr51Rantt42m/Tc5pji7ux6AV77wD58/ytbLD8f6L+hplWBUJ0rf5kEuA7z6ZV4vT42ftk0/jexkUMewnGX/ZR5XrX73WAXR6Y2YYV4ujm5ai6z2AxPO+6nuHNKu8Ti225sawfZ1cqa6PZ2I27LmUgG1jCcHRsrAmN5PPIX0m9FxAcUbWfoRTUfi+OV9YQBkV5raeAVAdVLWS2Us3j2qLn32kQXMmJfVGUX3cxsPkRnl1sR0Z258vY9nhCl87m/kNwJVBAvuMA7a5wg/4rtoI8w0ZjcLpnXfRo0/sVc4vjTKQ49jcBiX9rrN99YWTjzqmN6/u/++JagN/c2pNhIXeLnXYPWxTTxEhQAmIBXXWskzQeT6qugM2Z3Zj9i1sUIVvVClZU0JxJmk7m+E930ncIrT6q3J+5rjM9gcStOlQeBCxftfZfojo1PERLa5P28oA+0hmW7S7c9DnlDYA/eySPqtmG3S8Qc5BOVcmWsZH9IEMp6Aus4YdLOHxsgsvM0T8QBb76x9ZavmMwIYJ4ujo6JnHiU6eWd2YaKBdAV352CBn7RP4PEPRqVarwuEqkx2DKbUD3ZJz1taYX9OP2gBABOt+L8mmWvUj85QyVsaYJBtRgcVA5eFRDSMn6dTx6rP/7T8ROtKcDzXN9kXzaTaAqZ1C5Xouv8mJqcqCKxelH8iVwS99TOoACIWc43+LZb67HKklLJXdkjHzS127xE/jP2QmAi6EBVnVxNhYGUizBurRDcfMfIP3gapDUyimyL7Qpj55hk5UviWJcsBX61KgpUJAtrkis2mZ38qXU6380ZCNqhLWRrh2PXksW81LbXUHzNKV5BildPGjjnn92+KXFG2aiHYy26dG+aiPgJFwsmBDx9MNAr3tcWAHUKMMVfj1dbc3e1v22UsWLITF4VgEUOabqO4/U2ZqnG0h1mWJ0o7+votv6PYADp8AmoC0j9k+qhNUbk0sSieaJILJwfI/nZcAMMlDuxQOJY4UtQGWAipZRGbvEqxJ8UFcgK/72I5PdZc8SPMHssZ9MItrS9cf054rgLlA3batjUr2gVKjfEXI1KmNlYgzMSLZAp+SJSjHQbl5s7/Bn70U6JnsrMVnVBbrlUC2zrcqMLPCAQLJuNyzBntV6frlk4A7TQDVmWmuzT3pcYNAs30Tg2JWkxVfrcQWeuKtr1ed9QiX+VKu+swA1SsNbykw8jOZarKwZ/emyiIXyR06t/+S56u4wKl5spFmGmhVAWyNfP+bOQqfW6QElfKijGvpx1lf7da6dKhWcrqBzamE7Bkd+YrM6kgO2GHPTutSQOlXABtMFql4g2d36IOFvJAp3FuUgI2WwZjqTdJcOAG0J5fNaSszfeT8Gvu6OS6Ox8TVBqATAWSzPAAKlANVggSb5COZrSwFeltVsNrJosBx3hq4a5GkQC1pCRewIdUULX23eaTjfd7Hr9EmFcRWkgVsCLF8+ei1i862NR2hx1DRlrdkFdAjM7MhwyFA5zKRZNIfBB4Acmd3YD8FkpmucLg0WJ391VvnQif3MErHdECaC9pt6Ju6KSjXYpsDMsC3kg8mCFO2kLfXw5ssBzgEZslnsjNWbsOY4b19A8gXwYSfGDRm9mrynGbzZF4w49AcEwzetmeBre4B1GhTwG9qJ6THjfIUkPfGNjfYdMpHPftgOaheK8+FTVZyht9aElIgSQ4/6KNp3wD4NmVyG3byhDYyOZa+HNkwpX4ri7j/awiRdrXTCmBbgJ9nK83Sa10ScYDpytQnBMNA9lCJkxikr5BtNCHWZmXD38SwZ+4Jhw4Qi0CCYK1WHoIZTBjFyIp+8CcBAb2mArIOgcmKK8KSv3EFEAPYPCc7nennyEcAnYs2XMhIkjDygG00pTrgUXUSSAohW6zjier7/CmhoAppLCDkV3HJiRcuRTLBWsJaOymZ4u0kB9qSZOiL4Q6hDbG7pOPQDLQn2tQvNzBmJYmsr77jUy5fvXZN1/30R7IAAFmYCshzZWbWRkVTQ7n98Vcf0T03XU9PvexQo4voo97yR8WxvRHZ90ugH8qk1DcEEqjCvnSQ1v+0jOk5dHy4y7GmnYE+p9QoP0N25+Rk+9DGG6FZ2ZbNMwlHylxn2bAE/5s/56kHBf/f+w/3ty0XUFILzew8gteTq1aI6mIFYplBe90EXNI2hsCs2btB4JIEvhejcQ25GezZ29pgr63fe5kB/B9/9QafOd+QXv57D9BPvO98vyTAywGcGCtLAmRnlONMJMX3aUy71TJsFu00AWwPSGC9t03fKa7jAmSHVP2IP4H4A4POHEOgJGYPNMDGUy9n+uef+ZSDgv+fvOchuvO+h9cHed3dNLtvsuHXL7Wsjg5cV5NSRGgUhLS1uwA8w3mT3aCZXVQHh6wIag/MuJNASJ6p+qCOZc8pm5eiS/D/lace0aHon7z7Ifq/3/0gXvokULFU90JYM0LLArI3/JzBlaLQiQxig6oVwL4H/xx/TToc19lChbVdar0bkLJbhY4sRxOIs86XMj/y16+jz/3oy+hQNIB/IDZvKS4puCwIbPih5T+0NVYVyvgkER3YG4zRS+JR4O0DONmqyZetVjINCWQrpNbaQTlHnptmrYGNKwU0S37b/3AVfeXHX0GHotf854fp+971oF7F5CSrIJpzN0Rv+MGkiGwpu6A6aMXmjEG53T2AYABzwTNnRo76qgJsYA/+95Q4/XV9vzY3hSmYGLioN017TuIYRL/1GVfTtz3jKjoU/cv3PULf8TsP1vc5AmCOn3+lkrDsmXYZvA0MuGQ3W663+ySgMbtuNlumuD7Dt1GVwV1Mbl/kDNxa7C1f48U1mdGguB6ZzIs+6crV7H8oessfPUp//7fv7wG/jnVFkRm5yHoAyCHwsj9LRSsvqNOS3eMutn4XYGOgiBmliVLD2n6XceyIvLG14sMZiwkt3i0Q5zLZn6rcF3/s5fS9n34NHYr+40cu0Df+1v3itumwzq7vg+jKisoljzUxwKU8KOdlM2BjBwGmaaMO7lkJgKsNG9jcRjyeXHSZ4gFt+c+WE2dzHFGAIlkI5ClRmOdn+Py064/ph599LR2K/svDJ/T8X/0wPfB4Ms4R7F9UlwRELc8ByBUVPJBLDCiP7YdoBjC38yRgCjcWtIlvDjKiJT6URfytdFgDgQWcm4Aiy8eoPZg4yori6dce0es+57qDPeW3Av/bP0z3P6arnIIkmDOZ2vm7lUQhp11oWVAdbFQFaHMt9MT5ODAH9VM2i8XMVhtDs+wuKTUkvDRTJpOrJ451Enj6NUf0ppsO96DP+zrwf2kH/vc/dFFhNbRhV6sC0Oac6Jx68vBsymzdsHfQQg4Y9vck4Cz0J3sw1vxVBNkzmgK29r0EcAZUtfKrPA/AmRzaL1CxdLQC/81PoacfEPzPv+fc6m9BXn9sZVkAjLpyAZujfCVrzJ1BnbG6lbsAHPHYAJiW82xJMpFkEq0I5l6L2eRVuGDmqiWFtrK/5D+lK/df9zevOxj47+/W+l/agX+a+RvBOIrrzIAqdEWy85Oh0JIYPB13s2+zmeh4qzPrBtQ+ewMKLtFMvpmA25YVWyW5ZHUGlQf62WW/sLPk//BnXttt/B3mEd8V+H+lm/kfvDg1jufARDM+uTgNqhQr56vLC8eWZdOz7drYbFTu4EnAuMEq8JB80DwHmEqmJYFsvd+Cvq1JpnGGt2VwaTyofc9fu5r+9scd7hHfJfh/99wFZ18Gx68IgnqoJ0RGnZUUKh0dGT81XGxhDO71S0HbZu45s24KJZVI0vNK7M1ybiNZE5oxAN0qwLCnzs+Q+ZZPu4q+7pOvpEPRS37jAfrdD1/AzGLyZb3HE57Fszfotp2XFHo+TtrRC6ZFwjRjYG55E7A0NhsoQxJvqQz8UICccTuoYmuv4B98o/iKzahE3vKAMzlfJjMpaAn+5etQ9F33Pkj/6uwjq/fV7zlQs0CCfPZsjAKVsj6SWJBckWRsZfO6IpqB5e0lAN4MHHBwpwYdozESE7f42XMGMGdtIvdnuc2YkYyykyWVjr7uGVceFPz/z+8+TD/2nkea9ilYMgNP9cWWR4IRXedHNxQLSr6uaytGzUsAe5ZszyR2vMnXCZRNIeCbB3mTsXbbauXkkJi52OKRB2ghE0kc/Zsvetrl9I+6df+haAn+5YvGoFL1HEjw15hlLVizYcpoZIe/fUnadcdRrTQVBuZUAPv8OHBzgmL4drM9A/aXDFH9Gcl2NrkzHwUrgVoVAGQ+7c8d06s++3DP9y+B/wO/87AA/DoJqOsVBvOEvHlfekLYcTKErYHSsgkYSRIRAqJbWgKkqL8KQ4htsuNvzegtO/3s6O8pcXJkEzBSCYRK/6lp+Yjv6b917eqe/yHo/33XIxP4+9gmGmZGPPvFkkI+u1Zm0cDsvr4mwGFtnASq2SZqtLeFBJBs3zOyHwcDMmcu4IMdJgdsHAYCZQy18n8lYgx4b5ZH1+zp1y7oX/9P19HTrznMgz4/ed+jdPtvP2gm5SkpVMr64AzPcqp1E4dvyxQQmYxNnaAvixrxfBzOeHUWzQ0mbJOt8t3YPW2xY82iEd0dUlP5Xy3tmdSPhYiTWc74hwT/L3zgMfrmdzywel+rZCYek9ww85Keoko5b04S0cRQyLI9IW27GgjQsbcertP8qNizx4ZswB1XGr1lgNZPtu6OLoiiRHZ/DHzJg7OcYSDjPeXyw4L/dz98kb751x6oJueyCsgah4YKUGtLKOTEHTfRxGDJF4nHosCvPM2gDZYAbYrcwkht51brmHIdXdmvqIHnEGRNEGy0zyz9v/szrqZP/XOHecT3fQ+d0Ave+hG6/3HNCwF27AtWMzhJfaLGDUBbuTahWOO7ShG0N0EQC89MAL5SU6ZK05tWoK0HRjJtVu1xEDxCx+VvmbyvBQ9tEA6U/OvyDz79KvryT9j9T50hen8H/i/vwP/AY8MY6Et6AHovqRWsyu8CamPU8O3IRqaYA/ZKEp9FtTI4oxkJAKy3a2gIl9wV4npHNYHeApBk5suAfS8Bckr2tbWWBWZlk9n7B8+8qnsd5hHfJfhf8G8/Qu9/8EShm1PjLA4TAmf/JjdpWH7q+y+yhHcHVsh2WB+Jipsanmrjg0BiB7NsDtOcTZBqqUWVwd77sbI8e3qHXAZUZj7YL5VEmZ/rJQN+QoCeZnHrPAuSfYVKHrk8cBKjKyPMVByT+4nSyOCaOeG445qyCqAew2ZTHlcbqClx5gpcydheOc+OntI9QBZAXwjC7hqY7PMY/0mr/1/wSVccDPzLj/V++S9+hD7QgV/iRldoeklgTgiVGZ4lIho/PsxBOWjUTCTzvvk6TE5cwScB28FfyzxWuRQ6vwBwTVsVoChdMaD04NwTJTuJemCw+unT/vwRvfJzD/OI7/L7+5bgf/8DJ9Uv4CjK7ASEAAitfiKoDjppxtKAa7JC3hV2cZNCYlE6rt16CJGV3OLqIYESfClmTyA29MEf8ITZNjp7DnnrXK6B3sDK0687op/629fRoejrzjxA/+nPLqrEZSXdknjMeF7iKw6bKoVszyDyvQLIXibLUXmgi0W53Z5Dx6EIan5mzIZsKQIHTY8Et14IpBfI7HtLCGIXp7X8l6B6+nULev0XX7u6538I+j9+9SF6x4cez0MidYDOQfG5EK5+lVfr8mElg6CXQrO7eW6GvEnRyzRzosqWADNQ3EhcbSAffEDIA+/EwokGl8dgswYBcPfdNdGM8h/1ywD+5aO+h6DvfufD9NPveXRdds+8zaf5fUsCS8lgUmBPphfg/EDJNW4qGj4g7Wqc9f6O53yMd4YfcJCiBQAUwuCt2KjNpKRnzMF+a2bdFlnPAZjxG3E/5Qqm13/J4cD/ynvP02t/75GsBdzmWzdPlCozaRLAlEgOLi/gta0kD7aMwuviJwizIqnRJoOy97f7nwaDHZl8HccwG4nDtJM/tVXb9JszOHZN2RIgCnoiDZyDgv+3z9MdXQLoQ5ko+zWikTdjz2OkMSHoxsgs78YhzQIZe+zXEgQwykrTFN2ENkoAbnYeaO4snwnWMmR8ljB0x+VkMs0MjWMsW06cHkU3+6x++IGbrqZP/fOHecT3jg78P9S9EBZ4XMvrGdIFrANolchVyR78QpFoLEK2aIqMEStrbHN8OQDY3teCRzZeTEFSTjDoncqBtYj30eLQp+iyhloS2hXJQcTwPOWbSe+lz76SXvDJh3nE97W/+yjd8Vvn/T7s0cigbB/46ppUEp6Z9HPkFzaSaQeakHKGLFa09ao4CwHR9yFpe98INAPAiAWzcybgXXTULIOyZw5sgI013d6+SalfAqC40bIlP1yC/5v/+mEe9Pnpdz9G3/OOh8zEqRPZULw3bg4OTZEJyJRhYCeZthC7EEUDcFY1IFg7GHPb+1pwdKE8YucwUiQwVW69aCPhD89Y58JG+w4JXXh3zd+/WYH/2YcB/69/6AJ96688ODWgfhObm5wfpLWAN9t6CcFK8jCWQFKQG9ZmXJ5N5DuqZ9iZS7n69vYAqpRiZRr0ARBZm/ET+R1ezKqBpQUNCWRfU39PaYrDrALyNx3vy55x+cHA/3t/dpFe9G/FF3p4FUDGZ0Og+UNBmYy1fGizZxjzJj3nU6rAcqDRtzOXdvfTYCjdp7gtb2YuZKCi/wUOI8+aOSKJak95wF6yEBUn2f/51I8+oh94zmEe8V0+2vt333x/9rHeiWrLFcr4+tpx7LoaE4S0L966M3ZUTr1NgZFuiGxlouFQ05a/FRhegPgHHdBshjqCnYb2W30JzxKMOiwZ7TskE/ikZqCnPWVBP/nca+kQtAT/V/2bDvyPTgHL6znr0eXiXMsTx9dT2KglBSlDtrxVGVaXrBX77Gu7TSYFcd2+BOC6U5YNUXMs1RKWA/KeTwSadROuyaxZxqocdkrJHuh50wr8z7t29cDPvmkF/jc/sP5wz9BozuYUB33GZ0sAXU8DnCYgkQySy1lN1QDFiYs/Je2g6jyWmzFVqmW7mmAuz55KluWV4iTChgFvdmitIFgyEu3tLgAaRHIgP+26NfiXf/dNK/D/zAP0gdUn+5YB4TLdTsLyDfmbfNasmTmAXwHnjhvtx5oEVrzAJGiYNRp8/YhaTEDTcdR5m49k63JVjKRY0eCWTfZA0zrJqCCETtDvzsjd8EurGf/HvuSaVQWwb7q/K/dH8K/iGYLzS/QQ6HO+A1hzlh1nUsb8FVMs/6KVQHAyQeQlFlshyJ4xKR27JzOLnFm4ZENiKRQGYIIPyUCdZuAb1cg+yFgCDIdL8H/KR+//Kb8l+L/6TQ/QB+8/KUJbxzolAQ/0zV9swsJEsMqw/E+/IhyNw5/ew+BmpWrTDFC30JZ/GiyZWd8jc2bO9L3OYi4HG7Rb2EzhGX88J2lnxxdGukP98IqbrqLP+ri9/sL7SN9+98P0n/7/izTGpBIUztxzQO8CvnhDZiVh2RhFAhOV/vIQquUEPHBnVgChhNFIG38YiFHPNoOeyqsfKbc5qxaCA2Pd5Gz8ZXKWnb09ATgQ6ovu4KV/4wr62mdeQYegb/+lh+itf/iYmnHxNe0f8527EVi5HqtDz3bNvpDB51DK1aoGZNcV8wb6JnsCAdr814EbPk5sXcC1HSAHlY2ZYuAB0CubAVvcmpB2RPLjwMsYXtKB/yWfdZgHfb73nofpDb//mF2ZwNl86jlUrTXP5BaoQNLw7Msm1OAm/BZZSyeLpZm4qRnS8WaDOxh5JSPnjRZQceZN2r6XcbkO6NYP2+ycEhUD/2ufdfnBwP+qdz5Cr/v3j47HoX5hIZL9np/7W4YVoFjP23uTjBVbGR8BRePQGgNsqvqQYUPHoi2MwZl7APWdvDrgc3EjZbvJqU8YTHY1ULxJbtbXFxU8i36ASiAf+P/zJ15G33XzVXQIetWvP0I//M7z7aCXlzY30G+woqTPtbLdWBqZMWUyEQBHx2/LB3+85GTpNY01pyJIhljjHkDyfXNVrJTPhauzfRkHO75Cg6VvYGhDgP8AwM9CWdGn/IUj+v4vPAz4f7gD/4/8+nnz24ZGMvoTjQ0GSmqWl28Mn+PbxmUhjA/IsHlA9bFRqWQCKvGBl2wFy0QgATig57CoEUhqm105UOqDxIAqDDZtiECsQdeUODegzs/TnrqgH33uNQd5yu+uex/tEsD5MRYT9D0/a/aTutJjKlQgsMtrU002Qs2yr+PDWb/0h68FR3wrJXJpl8vNYzT7qQAaShZEOKPV1+O5/KSSCJqDwAfyTLGPBTsl5j7vBDz9KQv6iS+/lp72lP2D/w2/9xj947c9vHoP+2H5TwvoifwHq7zZfDUGuND1/AKTvn0VI/ZVmJkxuxeJb6C5ODIb43TMEe8zBrwbbPTHDdRMnaA5NCMX4I/OGFZcBwD+QD/xFYcB/+//yUV6+S8+hGftGWW6rBKkngWe6KZsNaEIG0W7MWszFNbnAkQMAxSrCGo2ctaGY3LzLwWVneKR9/towqY+OQB+b3BkI7G6NswqiwjwedW2n2xwKPB/zesf0LvuLcAPgH71NjCbm6AKJhuyYvbsELWV88BAeMJgBxM7HmbzEgD7WRBTqmdHsrKamJld4NPY89UfAhWVRWQ2422k3UuYPnD/CX3NTz4wfqy3VrLXvrMwmlCjoG/5SHGLDRUDigPYi+AA2hZ+ahTBzhzyEwDDt03jn6VCDbxKObn+GclbGZ2Q/9QAfJqWCU/CHLAE/ws78D/4SLKBbJTseVKFoLfkafJjzapVwKJkU/ONDhzAN/8AbUVei7Cvn7O2OPaO3WSylbW/uDph4BPVfjVVX5SWZ/zXB3IgmSWltUx4ktAK/P9q/eGeFVklvbMMgNWAu+cSB+1oLz9Ojm6mb1YCmYwZo2cL2BwPUmCcMFAX/iLENWayhbb2wyD6TkEyD80MnMmykzLlBR4OrLsVeDClwl9hF5aLoiR+EtES/Lf8ywn8fj/QlAxqPGvGT4YPoSP9uMsK5K9mf2g3xiD2pYUjXw4CNVNAbdPxlsRfKi7D/ARgl0S2QXhisJTC9ZW9pk9TptNq6gB9OKUYMNVKgGhuv11qtPxY7xL8H/hID34L9ETzlwWGPauvw49jO7FIPrRPpR+GBko5E488E+CwIWNtqxIw5Nu+FDT34GzUQV3ZsBXgZ8xahZGAD3DR8P3n5CeXJyitwP8T3cx/7qQAney/fEaHs++MMt+dsVv2ESqxqHhWNljriwYreYx8I4lAu5Z9oLuk8NjiiIgvdNw0kFOskXEkUJyRnRDwex1vJu9FlA/GFxjPaAnLPAnoH/7cw/SuP15/pr91zQ/7rzLb54lE2rP0mJzjWmLIkZ/8cWkBHsXo2svkUUUQHz9cX242VAcWbbAHUAEGu+KCrTcKrXNXu/HSHmOTBfhDSQMkJNIhP5Hp8z/xMvqldz8WA74HtjmzfQ30EX6aWiLJJOfLZCRU1YnUJ6OY/CBs6RUUqSrmUGZsRgLoN8Nqxr1sKmy1AT/TI3DREmjvDcNZS/hfH4plwpMA7Iie91cupwe7ZcD/9daHVf+oaqilzOfAbO+t/ZE/NaEwTjYG6FsAj8ZJIRKQtZJSQU0VQWZq02yQxVtJABWwI2YI+EThn+1WCQXEpAAsAuL6AJ4OSyPVgfgEp6969hV0f3ff/9VvPz+2FTO+d/7RZUMQ2HD9Pl6jbOZEPpHf4U0F9FHAaz9s2iyaKhMIVxsEBSekyFA93viRVrDWy/5oGnq7kv10mQdmfRf4ROO3vlZKyEmvskxgelKU/pK+4XPXXzBy5z3n68BPMRDJBGvN9i7oV7qMk8zIL1jiDfmbgk5iKH0wlpO+RDyGmNGQ+4uLmjScH3sivL3PAoxvaxVFEoMDmRPAVrN+FfhrZnzW7xsCg3/QebItC5ZJYHleqyQwkJhdIfAbZvQYj+F1tb7/QVUYQKa0b/jP36T1GzhEnQRU2DEbSr0wuNmMyLVfw/fszwKMb0P6PYBZNSGTWk8KuSVdqpSSSC/lfwp7bOk8CenFfRJ49T3n8Xkb1z062+MlA4884UIlIOjP8lmRYSBoJo/8jTX2YEMMH6N3b4B5fjeg8GcBiqZw0hDA9zo3P+g3+hiZY08vuYNPio8nYw1aT+dJSi9aLgfSuhJAiVeByOB51cP4eftW0GdvIvf7/bsL7AOeQZtz2dFjz0p/FDT4jcOKzYM4+d8KnBrtitoIXchCnLU/pSvtgoG2btNXG3Vq8TXm+QDk0mQx+Ar/6Um5BMjpRZ+33hN4zT3gm4BkAk5+/2keh/t91SaBmPPBZFC/ezBC35YZ5QAxfGvM0KyNRDAFzqtKoYpa0+Y/DALAEVIxMqb3A49Ns75bbYClhTcbJaHTdGWemLRMAh86d5He/B8eWzeAhOpVADlvGmN9sesl9Bo/B4dRISBgskAulpGBgLce0Jir8lBPMlJAroWchLLxHgCcfT21bMCUPHEV3HW+7df8BNrqTTIvtp9E8JeE7oM+cO6EPu76/f/u35Ju/zvXrP4uk0B0zW9v9HH9uwXI4DMGFFd1OWZfxDH+cScRGjvCA7vnA/JbEwbigqrDosWKab0sd8tZN3u5NvoBUnRSzhtsmHwRT6YnY2XSusWn+aTN8Xx0vNOx2FQE+rukF772wVUSOBQtk8D/8umXw+vIWV+MPNE+lNySx9k1W72SwwfXlF3dNYdr9kUyGeSQ7HTuPP23vEWJZEVfMel4VR9Zr7H3uPRd/Gfbr738qUWANAp4EhcIy2S2gAy6SEXCkL6A/qSXoE15EUrwpwn80m6ivdEHP3xCt/z4g6uHdQ5Ft3VJ4Nk3XAYBZAE/H646GZMJbMSPgZ6ogAuwrewTuYCf5Aaw24C37IZAngpP5X8J26rZMwEvXxLc6KXAa1Ad9JSBOFMEJ0aKD2IxfI22exAjmwj4XPgSF1bacPphq5TWy4BDJ4Hv/7Jr6C//xaOi323gkw3sBEBBmc3cFuBhQE9gqYIe+U824FcPASUvOZCfSIROFi0EOjWAN7cdfUmatQSwslDN1nLNXqzbE7ZVgCxlCaOwpX0WHW3M+pQw+AfgF7M+kid9QXdNy/N/14cu0K0//sDBksB1VzLd+dXX0Sd3SUAO1DFOouxalHvtCniUAUkOfo9X+DNmZSpjguDKfYwya8CzJ2fZE/Gpoj3lSYVckFugJhmHiGdWRUAeJTJBWgV9EbCzdCDC2WkEfqoCn5IEfiqBO8SRjEEodYoYtA15fruk/Pzf9aGL9A//9UN0KFolga/JkgANMZIAcH81EuIRscPL7UEe5WAlDHqkb8oMoGeQYBxbCYF90FnbVMkkCPIaqD085okm8vIrgNQAeAEKRgAWshaYSW4MZjYtOzmIXSAXOlQAn4V8DnZ4/vugVILm7t97/OBJ4PtecC19THdnAoOUNbjJ7tv2SiADax5Y8vVzG4UdovgML+UoHxPlPoEHdCIf5FVwk97+MzcEK6+Fl2mqgJdAKECfZgM/HywIjOMFJVK+JJAJ6HLvS836rnzG32MGmBLVFOebfuuxgyaBJfhf3VUCqyRAhMFNZeLyePFkwSaglV2hXyYG9qsNMY5QYqAckKuZtA3oEOCFvgQ2qziq9gKvagUQmvEK4NPWgI/AWLYnZV/KcNJxUnb3ASaLQj733+9heH2xbcqAkcf0M7/5GL36lx6hQ9ES/P90mQSeulCJV15nBAioQwQT+QgI47oysgtsDxWKAg6VMeZxIptotpWxoUkLJYiJJ8tzjRUIYsNelNqeMCmCce4UAILA740i4BeDnkh0gnbEwi7WLcHLlr/M12gP3BLcF6mZsqc7f/n8wZPAj7zwOvrY4UGlxBj4CYCptyEHOuax4tV0NT/bMCSqgpcEwEbYJ2fHPvedv6C83hgkAGoJcDZsz30t5ExsvZpuDRodqoCPQJWmE1UJIQd+IgjU4cKrZJULJCNhiLjzOKXs3IzbSvnAyduG9td0SeDOAyeBH37huhJAs3kx+Ils4Js8hjwMUovPdnUirrcGmHGnIQFQIt8C8JT8tbo8B3Zw1AT2ws/036IEecwxJBCYBnb/pgJ8COCUfD9EGtg58KUOkTkgRgV0+9Hrg11QHlPSoFn+vfOXztNrDp0EbumTQAG8NVkJoc5jzEsR0NMIMxOYIj4J2GIXn2x5CMbsDNByoYY1H8CUTUAc+w8sL1YVgAlyb6AbsnayGIBvyyDgq7sBwlceX2l3/YaRTmaLQQwD8EkNRuvcdksI/OMAy44vhSTwqluupWuvYDiT54Bb8UgP9rKvWSVsC0SUJDCMUp2IZCWAwceurAJoLkflUsECO7KhwU2gEtFgpsZXkQCqCif9K2AMgz7RHOCPACbsjzIeAj6DOHNbLGJVdxPyi5DboZK3D5IDfUWiL5Z/X/PW8/Tm33qMDkWrJHBrnwTENV5RIgjagWBSMNplUph4TDgpYCBOdvK52gErScBP4LTu+xOIB503F+cw2aRsjwAmFGp75RTfBDQCKEA7vE6SBqwA/tDJBGzgpKCBPwF5Mgz1kM7Yhp8yRImiqCj2ROzFJWW6122vf+igSeCT/vsj+qFlEriSfUATwaQ+le5k6pu87ItDy6SgAZPLoafzKGnAE0kZDXqStgPxUAF0roJa+UjzX6HbgKVSIrxRSAVB4KsLRsXMTSRAlusMhgs7ve+sc6UOE+Ekku175ABjJCvbqeTtgyAQko5rlQR+sksCv3kJJIErWINbjgOSPMbJgsrBrhMHTjgSxKUNsVQgDTQMnKlW0MnEiCG/VlnEaENwRcnyrfHDG7wWaIdf7/gLoFuDPznAzzoqn+3HJcIJ1tMgHoCblN/cF0ok4wM88gEgIpg8lG3qbSSrA7ZPxYBy2uUM8wP/5mF69wcv0qHoE7sk8LIvvXr1XgGfSAFMAxq0JwBQWgPSA72yMYI4swH8aZ/Zv0hO+M9p0IzsD5gAJ3IqAp713wKCFb0koQAdHZ1MSA0GBdjieAC+lmfhT8eRPcAjBlotefDgm/TtwL3QuK+RyuRntfcBPvjwCb3oR+8/aBL43GdcRt/+/Kv1tU5GAiMwi2f25HVZX0M8E3tAHv9NBuhJAMx4OAcmm0EvZYmmtj9ANriLV2avthnIwdesPYAo6Cn5DwqhWVpd+LxKMGLIY2QAfHnRoPwQ0yibA0rapb0mgSJ+0C6T4tD+4PlELz5wEviiZ11O395VAi7wEwDjYMDh1aqEUabww749ZZOVrAJ8kngogQl9mP7ka508CNzCK16EYzN99q+2R4ER6CQVDw4RBkqyEwcCvhz4Si+LLW9QCYMseRETJQ2ojNzz3zLlfagqk5zAQFu2PfBwom993QP0oQ8f7luFvrBLAt/2/KvhbJ7P5NO/pMZaAeoCaARnf5ncp+Lds5f5FfUCGjsSC4MPCEAw5iWAcw20P0DIrrCPXh6e658GJCOzjDKJ0MNElJAsCCqTcZcI6gKRuCClrvShbBR+M32rYpDHeyZUBeR9qRJW1ncf+rMTevGd9x82Cfy1y+mFz7kSx0yVWVkChkqgIV09w+rd+iIJFMcMAZTbJiJVmntlPpp9Jxu4nOcUAzZb5x14LXRjKl6Uai9S2XokEGQBehqSBl5fS9CSAXx3QxAdC/18U48NX8X5yfPcJYFBRKIvGcQoZ8I/6sD/DQdOAl/z+VeuXoxiluDK28XgRmPK0qUenBL0jGwMslnMCrBKx7+TgM6VM18waWT+LHvWpIx8VL4PAAM68kLBWnKFgLOuz09Etk8Xf0oc0q9MMjKJrI+xPkNfIv58AOyBuBIPO20yif1RVwn8vVcfPgl89edfCQFTA3UB0pruqM+TXCIFksLG8C+ylfXlYLew7fiACYPYBnpyYgCvxRLI/QttDrq6YcDLIIcGR2eSS4QSjAQrEWnwj51S2kD+EVAnO3lFk8mCWBjZRD72RBagudKGKoNlJfCNl0IS+IIr8UxMfkKgDDiuLhG1bPiRIVvI9wBWywnR58oHsU4YKQ708otF9H+k/MVf1bsAMivVkwVaPpACKqoaCh89g8HzB2pWTzohcB8LXNdD2d52TY4mm/ugPOEgQLOKD7eNttJ6T+Blpx+gBw/4JaNf3VcC8td//YTAKjlLgOZVAkl90uN4kJWgXVEiMHsjgOtrw31SQd8xiHQX/UuDNIN9ZUaXOIq8FjUlBXDKeke81sCHrCJDIvUJhP2bpB/RJdIxaXvl7Tupg5IHtE2TvSGprePKY90TZT5NsIg22TcsrsF7PnCR/v4/vX91q/BQ9FVfsK4E1Pjr+bFZHvWDUyUUNrJ/k5ZlJUtwMpR4kTv4ecwx8GYlPIlrHni1yC5YPFhSfRmbfypZCLISA+fgogQSQk/AR2lzAOokT+CiUwUgYzKTy43c3j5JDEQZBz4HClUL7/lglwRefegkcAU9/29eEQC1DWhXN2EQhkp+T9aSJ9YJLWHA5zp5ymDhX+kFXx6Mh0RTLgFS/KWcSLLkcpANishuZgf5UncoiJpm9xIMGVP4guBH57sj8mZ22EblQCEhK6uFP+gqgR9608N0SPr6L7mS/sdnXV70vQY144RAJMYImDWTBA8u+THQjOWBkgclurQvXtbDPRIL0mZOrF6x/wZLTb8NyOYBkTnrF4jr3yZsnIE9LowlqA9/D5AnO6WNQT8pOemPZTtP9nhfSSAlGNM4LIs2ISfaUZ8s237+Nx5dHb/sK66hQ9E3f9lVqxje+luP+edDZd+P14WyPtFDLvvNQi6uqy2nZeWQn+QZ8tnEBAMbmBQrYa5jwiUzAeQdCynZjVDX6sQClIKV9z7SFyBFbQX4czCRThxsxAOTyZ5oFYeIibODqY3d2E1Q9W0//85HV82HTAIvHZLAbz42XothpuwPR9I/QirAkJ/3yobQFwZLOQFQZI96OSORYD84UUTGFdckQHwRWkgbw2sIzH4lkvsGNV04a+ZlT9aY37KzkofWI1AW9wcp6ZkD2U5kyu0b/CMlAX7YVp7jeC2MfmdwTr/QJYHTv3CeDkn/+9+5kj7hY49W79kYO8U1Ee1jZZONq6l0ZjVGsVzAnnGXIT+e/JSlPokxqsZ18WKYkNQL2Eb4k6+F/bFf8VIWcSciMSsxrPWyhuxxYukGdRwJmzwkJpBAFHAM2/k6n8U5DIlPfrvwTimVg1CeD0p4SC4/n1GXSJ33XV0CuOuASeCaK5n+z6+7hj7hY/okQDVQE6HHZ7WulpEgWsGtsuEnE4mSE0kCfuw4t5UI7AEweR/+ocp5WC9Esz8NaAJfkE4MPchzBWFT+kUJQdrM7Ul5NdATto2rgDI57rsKKGbxFG1bM+QAc3Vpajv984dPAt/bJYG/9DFHFVCTDXwwRgtdkmBiJYeByhj0pJNE7gfplO1oiy4I6EQmNssXU/NPg3mGEeAnOVBVDAAlwy44IZkQxqohf8hH2hPykJcQgPI4e8ArGcLnvSsSfcDJaSPZVn4dupRjy173uuvQSeCqdRL4ix+1GGOSs58H6hKYrJNhNuaKe/yEwLkGDxErAOpKwKgiSFwfmnyP/hORNdv7wBYAB+kCtzY8ClyeQAkS/YnAhIGSMCAt4E/tud3SaHW2F51e8voEkj/bAGzK2IqYd0x533CqtCWrbfrcQ60CyHVf1yWB1x04CXzP1/dJAIzD9bkIsJFMCKyBn8sYt+HkbI6SizqWiYR03056usSXY86d9WmCtawcWhLJQnLYeEU+MFSAdiDhUJ2kspM/dSf8AZuWrRH8hex0jmv7fjxWMpF+d0rCv4qv0sZFWyK1Geqc3/LvMgn84jsP9/2Cf6ED/z/6+qtXf61ZfCDN5/L8oQzBGT2f+dkY36WesXcg2wht6wmgQzu6fEd+oq9hvCxqmaL2UtkJySDApGlA5mU3k+1D2SxskQJBUTn0AcgkxMiG8GfJ7IsU0InsmTzrGxQ3Dw2qjcy27/sXDx4+CbwoSwI0jImydC4SIJGafQvgE1FtaUAESn4lm4FRyOZxjJaSDUjVnkWJqgE3iQRfs38cFIHSBC71gmiZkLEZ+LMSAmXt6ws6JJDcD+HENJwDspm3C/8s+mAfxPLTi0T+rC2OJSimtqG/SJ2fAkVH398lgX/3Hw+bBL57mQSuXxhgJpEUZywNiv6LbPax8q3kRSxybKkEQxPkGX34yXlF5fJXPQHkBJxNrx50EIgJA1h0mkoyIJapo9d2YTmvZEklAxPkhv9p5sR7ETujRFMFI+7zT/yszTg3uy2pGc7qh+//Fw/Rf/7A4b5fcJUEXgwqATHwh/aRT+SDnUjM8CA5KF/27UIa7ZblfgF4qTf6NaqEwq7/kpLef85twGnQUeRZgaIDyQSkO6NnvDIh9ElF+FMAT1TEYSUDKDe6ms5XJzM6SBWwjovGSgfdlmTn3Ly2aAWwbHvo4UTf8qr7D5oE/rsO/LevksAR2bN7Dez9zJ3s5OElELX+zuIzZYSf0ocu83Pf6JxQ8rC+DISMV18BJMI7+cJpjZAz0TFWUtCBZQc58JJtz5rdpWwuN1YSxcxOxTmpWInUue2SGPku+i4RW31AftvUTyCRyBj6tofOJ/rWLgn81z873BeKLJPAt9xy1eouAU5WojSnHDyMAT68r9w1IGI102qQswnkUsffzMNAz23lMzw1v5a0IBBkWUb0lMjNJDBJZHw7KSQq7+kn5U9WCNJXkURcWdsXo4RBGHhF+x4IJTBUIZEJcAoAPBUDVvnr25ayy0rg2171wEGTwKmPXdArukpgTAI9MRhz3myuk4cnD9bkQnaMJnlAFqW+ODcLi+XegD/Dc/C1qJUJ5gsEaCeGrFHe00+kLp70IdtyX/Zsr28nsuELzZJVmTyWXRLoCxTj0M+RTcMC4EUbfvBJJo3l3z/+04v07T90+CTwXcskcGW2yUZsArgKdndjsKwq8oQ6Vhbo0V3lx7+zIOOUlQIEd2bP/mYh/FrUQI6IqQQa+twA+pIPOehGMvzChKDkJpCXX2wifGbiaJDL5GLJ7HPmH32TBiEE5ng89bslY9tO0J8E0pL+ePnVYpdCEviGq1WMGsBExdIgSVl7aWB+IUia7OpKYNAlMfNrAEu9PNXIhAHBLc7ZTBTgtSAvA4jbduZvBQpiZC7roKFjZKAkOk3aVo8AZ3cXqvogFjfhyDYiuxrZJYlBQh4wM511W99PQIaTY9t4arCcLWl1Hf74Tw+fBG7oksCLv+JKHePwPuHzlbMyASCxYXM8BlVDAb7MA0ow5WRKxM6HgFyAE4EkUnrCdwGEUcuBO+AT7jwpA2d0ZafcgbeeG4B+xEVWfgmDyJMZ3pQ7715nbJdUwiSCszHlbURidk8BGdzmVQAD70+6JPDyOx5YbRAeiv7WZ1xGL/rKq8qElQDISfCB7Fo+A2/SOus+9Df7hgQBdVXbEowMQczkAXzwkycPhokEYRzeBpQORkrkJgtLXieREtzl0kH7kklCDnxGsiAuDfKkEo7+4U2C4NsbSSCCPmFLpjj3FJDJ2xJZFQDS/5OuAviOHzp0Ejimr//KK1fvUXLnBJJflhh0UmDCFUOvl5DOBEYi/9beYvTP5cSUasmiBLz69mGKvxbsOKy+xMkNM7hcOhRKsmwHAxACDgxCaQPLgjjQ8sWJhQ2Z/dD0HAIu18s2lYgLmQT7XdkhGisHVAGUstPG4X3vv3hJJIGvfu4VU6y0jrSclansh0J2AjiSX7/nAmiTDo3ekB6yU/CJ3Fk/t45u/Y2UULLAr2wJkEjOxrUXfDAoIzSbR4A86uc6BACeMgNoE9IAOZr1cvtWUpEzxT5IVU5ZP5tVQbIA3ScBQ08dC1soLil79n0X6R//6IN0SPrCmy6jL/3Cy1fvJfBWbVQmhvz8rWohVjEQFbv1RBDQuR2ZmOQkPNjMS3oSMaKZXxIbrwVZ01qyX5wwYHM9NJvngXjJACWEYUbSjwAnG9RJHJMNYkaxSj0U755Ig7XvB7G+h4BW52B/PFgfp9G2myCy9t95zwV61T9/iA5Jz/+iy/skIGZKMY7H8dzr1Wf/EnBEOKEgQOdgRnZyW5xZs8CrdJL9srB8vLKQKDSqoUgy5FjLMRSUNlL5Lam5nmgf2hi0jSq5XMK+83gZ2GHpC5zzziiLj8XxJJPWwwTIoL4pEsTyrzh36c+UGdt7/5nuL79j/cWe3/hVh/uS0ed90boKeOPPP15+iaj6Nx8bXIy3Emhc2kiaJ8dqOeZZYcAaTwzQpltKJntMg6ZvBU5BVTcKMOCGdsRAgzkXMdqZbVm29B1Qh+1Yce2Qim5DiXG88Gk9s1SSZAn6CbilM6m7rDZY+NNyMrZlErj6qgV97f96FR2KhiTwpi4JLKlMXFS0qfdJtHNF3tBd80qHaAixsuIPNXgdDC3LzjEc+B4l3Cgzn3KedCPKCUVCkFUDg8yLZCXIkdwAACmTbH/FbwikPZUBifTMnsVSJrLUy7ADemGL1w7g7I90QZ96uj/7y4/QtVcyveBLrqRD0TIJLGOakgCrsWV9v38+56uEIDXY1i2Ok+QjadJcA5xMVdSadFw8ex8ldg4T4KGkEEgIUpcdcFIum/pZS7StDo2EYQLd4++JLABPB6Rn9vy79MH5jDT0FXMlYYhlxqhLfVufSMS1W/79yZ9bf63YIZPAc/tK4Gfe8niZpAYBmRCyN2yAk+W/CtisdEgkiXWTHlAwCaSaBNCp8PEPg9S0UkWMBd9cDmRtCMhSt2hP2pc5wLM2YI9rQDf4+6BioIpzkW16Zu8ZpgxVQJ/xZV+BNtNm93r9zz2y+vtlB04Cf/qnRP/unRdoiGv8y8bsL36UhAsmg4Sg3xfHxbBlU35oZGzF16tQrnMMJQIDvAAV0GclnL0Fs3+hjMp5obdZ6W8kjIZEsDdKidRIAAAelgpaJo3D1CrnrY08mXyorxTytlAi6WVf/7OPrN4eMgl87d9dLwdkEiiSHU1vVBuBsSh5IDlIOcRXMqls9Ybd3CHp/zYgV5oMXTXD94PHTApehVBLBgYwTLlk2wqX/knHvEviPClyeR+6FygBSRLkyzsrArji/JkEA1VKuSwCfb6USBhIP9UlgeVHeL/486+gQ9GtQxL49QtFbEsq3icNPAvgSA/xpKb/u4BstNcpmhCObVbC6/mKJ5kdx3aYFBrALe0WA1zIA333Vh7XEwEh/h6IVUxTgzvrimSoKglUJa1s9Wt5E/RirW9dI7bP4XU/dZ6uuZrpps+6nA5Ft3RJ4E//LNG737P8diMB5vzcCbzPAK71dNIojwXfqCQsO3ljbBjiWAcyvxFovdNN48U3neVy2XtPToGfNG9oUw8ESfn8VKVtwyblMxZl5yyOcz7LJwz3Tdm1WMU+xqhlpF4xQxfHhm1DznsQqEV2+ffO1z1Mb3vH4b5kdEkv/t/6pwWzNhmnPLfiISGi8j34ko7ymN0Hf4YW+ZSgkhU+cj+tHwYyKwA1sBxBmBwkaGWlkBw7aHbJO05VC2L0JUuO4O0zlj6sGT/TeeChE/rgn+CPwFYzcyx1T4MRnEc5s5Mu8fuDApDODO7qKblE6ML7G4l6GfKaux7ulgMLuuFp0+8AbpO42kDqbkkJRCrilSbK2Z9h+3SctSYkg+Z/dIBOgyt8m/jUF//XFFLkpuaRafHhnYDxn2Gg2vIwGQBZNmLhiJ6QQXy25CXPkC+eIIN8O2atw9Avw/Ngx84gx8WxtsWGDzZsMo6ZUB9xLB7Yf6WctEce0IV2ec1zLRLv2WifHOY8xQd20bH2WCdP7jhqBFUBrN6UwmiWH/+ksp2RH1YmYTtbtpE+12WsOwdeRTDKD3EA+3AXPu+klAdIMGYFoERl5yUm67zKc0/l6Ib9Uc70ZgxebPn5ynYh7+rkPpB/adeS6e2s35fJY/ojPvBDWXzAdiFPJODAarxDvopBk/fAj83xqbsLwOe66K73EV4hr5wXcgWgBvEK6NmSB7IIcCrBiAGtfCTSSQbwIQjl8sOKFSQZ7hvW9hjbl/rKRlbiA5CW564f7rH0TBCjdnn9UR8AXjWhZGpuopAywg6Uz4AOK0gBP/OpwEJXQl2+F3wXgsAW6k8obdK5bg/gpEsAdD1kJ/IdGF6smR/aBTxle8bsz0ZyYHGMZGAckdlf+pDJCADN9i8cAvsKIMY6X/aPpSdjsZ4PKARBxcE1UBOFqwLZXuhIm0IX2Yc+CnnGsz4jWflvHg+GLguDRXcC+T4iTIlsXoV678sE0FUAyU09dnOigBDpDRQ0WPp2RjqOfC5LHuhRG0gWHJn9Mx1GiUHwKJo0iECiSNkxBxKHMERUqZh6ORCL1a8QxEWCKBPQZLdv9+wQVZcOkIdkRr9AVj7hx0KveI8/B7BqZ6OdSipsVp4TyP3mDUiuZseWZTrhZQI4ufhe4sUzlUSSCtAKbkq6ESUOljacmR7JDw+5eICuJQJCekn4QgOyACKXywJZmVSSRiRRTIJsJw5lM5UbfskAlfe04EoPLBXEeUbBq0G5riJ0O5UznNxlNxMIA796nV3I9PZUm5FkyNEr3jNOJmTYQ1w1Zh3duvWSFqlbAqRuDyCcWaRgislx0oLoxGq3/Qp5ry0y+w8+KnbYsLv6Mw72ZOr3AjZfJTQBYkZg7Y0YiUnPzOvG6RjYpRS7lSj9UfbBI+UXyVM4SeRkJ5DSF7QrZE07xb9T8sjbJh3Rjmyo5GDplG/EqSsduw1JORxOZ5fPAZzVU7ahhMXWsozl0MVEMz0b7YO8tGNt8OVyXEkE+XF0GTDGKc9XATWXT0Kf7WpA2neqAZkITJ0+BrTrz1Km6CxS1QcL+8WlLZIGKPct4DLBsQZ1KOuznqkAlYQOkins6POB8r1ti796z7h97AvII7UsgDJQgDEvQoneu/wswNmQAa6wLFBLHlFopvfW+u6sjdp2OvvP0U/imKv27WMBNJFIaqW8Sl4idgkWmLBZJ4I81rI9KYa7tndnbIqt+T37418OLQNGWTLak9EO7EzH2B46LvwngsQUoxNe3HtMj1+8ly8/qkt7zsCFZiUEbBnt0qa5RiYHgLk9B6QF3/BVDKyKjUj1oI9Tf8w4MVWPs0YQbwkMULIX5+DtBySC63X0+YEhNqLqEmAgHG88GXgypX1x/lKGMmAm0EYEkgObtvK4NM/ZMGQsj+3UScoe0YXlXYDHz1I6imshVqrII8D27WzpGYBm0DbI5QCtgaiwA3yxAzwJZOWjZt8p69fHXA5wOUvDamDa8FPxKJ89EyWj3CE4VzOmQj9LNjmILHmi2TO/BqKWgfalf5reqDbjvQXqMiYLuj5P22dTzrMxMpJu/p4fuezM4uyZG88lWi8DICX84mTLFx88EHGQwRvtigZGX1MuP6yTtXnH6DcKchssv9o8iYEmz1vEzOCc5ICTfYEH5BC/9iXta38JxguB49hl4/rYuvZPjFfbrVgreire5IA3ef4zICZSY3jqCzbsg/aVHpc2sve5vIy1bAt8OIiMBDK8EpLle5f/9h8GOnlbd1PgFEEaZoNUGB5ZqhGoG3z3/jRoZ0uWRcez40PagTEk7SefIhLZfOAvP/Yqi/x4SATWU4EK0IW/VOgQ1Kl8RwBNXzJaAnUSlDFo2fygbGchL88fkuxLAn+VbbZliOCmHdRLhpyIJfp+XEpZfCoT09hm9Q3Z3YZl0yoBrH4aLNHijP+x4FR3IjOddJhlQEsX6iDZWpucqZCtZPuSg6SUXwcLf/FIzr6E/amZqBJbbjsLwdQZgVockyZ5e9aymwCARB+zoS8/Woz94V8gUn6rfJH08jFJ2lZxfuKvJa/awI91kIxF2dA8fcyKz+C88hcln1/IUnrb8t91BfA4nfG+GmQVRPKYoC05fIPn7fzDaqBvzwd4ZFOwmI09X2jmRHHkMbAAKgef6Qe29HHqj7mwZ9ufBKBNZGOQ698UO84sAhd97tokwncuinYhb8WM+EAf+s77A9kjMZ5G26zkke7alyc7OUd2hKQi1Ga3W9LdBuBJN+nnEjd+wQfv6w5OIRu2GSUq3oBDhiKwtGEkz74uG/a4Ysfjc0DeOtb6HNb1j/HHeRnFXvHJWSfnetwLlrYM/327/HivbaOUK+xBO1yc69CmznMyp9qUjBkfOAevTY0/eW619vxYGVMyVpv2ZNLZ21+9uHH5Zvx1YD45eRMyhUoLVE4WDvMyRAoa+tI2W/JI32rLYxN8buBb9tjRVzPIeJwI/jSX0JW29WZkgvZH30kYdGyOSxfZ9ytWeWKm/8mMJu965/q5HW+M5SWvQbKkZ2mDsoQgZJE8k2Oj113rl98KZG34MbCjyn4ZUyJY7qNvACLn1cmdGfyMCeDkKL2RjOAgicDci48uNuhspSPlgUzRialiR8YZONbAq9iX/t3jzIA8nxTV1/4ZHicMuDwxkQGYRPYanirJKtqOQJePryz4sH4+GyZy1/cWqAeAId92UhH8wYbES5EgWOkRsEXZuU33B7C89erorlx2pL/0+R/4MFsfDVbSZtPIsHjwARBLj0EHM9BlcUHY4nMRA1t+BD9e4uvjQT5mi5Wt5iUB4CtQ1Gxk58C5JrIF2nUsLPyJY2gLlO8sjsk4RudTsenZJSLcJq9d4Qv7lTKSp/nab9GOhG06e9ud6/J/SYuClU7uclUTeBnEhgwLO4x8IJ+gjWt60E7+xZ7ZC/y0+PRFoLZ9DvhX+gkcj7aSKq8j56bu/0vfUKeUgcsK93qIe/9kXE+rerDGjzmjD3E6fCCXkyU7yVv3+o22YRZPZFYZHvhjdwQGCyzaNJ7QK186LGgq/5dUJIBFojdSA0HniDx+ZXDkIPBKfDTQ2bBT86N89ILqoSTgXw0sYUsNUtNvn4TycyGyAZeEkaTByGMCzHTg+aI4QXIgEJMH3KI9lUClpEHmjKlaMihkRyCwjsuKNQeQkq8nCRbgg+8Li+QkAi4BD4idV04nF6byn5C9T3jOB+/uIryZyPFEdiAFj412yw6DQRuU3WSXv8bnyvGkz1XZecdOeS/beIzC1qnK4PNAy5NVK4xJgo1FjHmrZYvtfpijT2K2VTECGQIy6g6GlsvtRdvxsWyZBA2OZ+/sd71mKv+XtJAKKem7AaUA6V1GR9ab+dmSR+2Carv4hPje7I+qB8pidOxPx0NlkAKy8WO5FOFqVaP9FwM4ASdJH+C7AqVa8atFJGKyxobsa8GDm4VEbaU/4JdxE6wglAzhcSo38qQNH/z4vT5mGNPqlfnPqwv5KjDIJ7dLeyoBnNDjp7s/58ggmHUkmJBe8vUK3cDAg2010FPjMbIHZIsBOsrmPU/klf+WbX3+SRxn8alBn4rjal9RBPBJxe7aG2RTpgv8ST3tF/jy+IZMLXHUkgeuEAwbEoSFLW9DUKcNJp0gJK9GXdFy9rvuPD4t21UCWH04KJ3cgR4LLj58g165vMen2C/atAIaAilry8HAFT6h90R4H8KKZ7SbnT/VbfugLZOACZqVy+TaZ/mBo1FvMuYBHu5LWMA02qv7BgYgQ3witTmHgE2GDgHwYvBztc3eByjtIfCjOBHw2XmlxHB/b4EaT+jCK0lUAQUAQQeNMgMBfsnzE4TXxmrHnsDgBz6Dx2rQA1kO2tI8EVwwrnLWHJIxuXEPlYgXq1XCs3POXmXChix7NkoTmrwkQQLkZMvltjCwjdldJpFUSwi6LfdRtIukQP3zArKEh2U92clA0smC7kDtMAGsPyKc7kAnAQkBLiN2EwHwkYIDJAlD7sd9aTaQucYjwrMhGTNVonBcvu9U+JL86dj4sI2nQ4QrEuvJQNI+o9dcAY0w300Shg0VK9mJQ8uym7DUPgDVwO+/H47ZOc7bVKUiEsWUMNIdt93JZwkQTABLWlUByd4LIBCUzK6KrIuDdMBA8ZJAkVEB30sSro/suKX8r1IB4lQv/zMqk0IS9vq/TfYS1qEEKgYyr2F01i/GiuCNtuYmicxGpCqQM7Gng9tYxVYkB0MW2ZWbfrXkkLch3orfrf0vHi1eSQaZCWBVBXC6A2WZEAUSwRhk3o5kM2IrWVSOWdoo+CgpZI6Sbcv1ncCxqTv41eSBbnjDyp62z6gvydOxfCcAwhS43qm0i2KCej4vAu7auLUSTelflO9kgC6HPEoK8D0XNnVykD6wb8lPJ/bsTxUbK/qkm95/XxffKU8m9CUFDNr6A3RySp61Lldk0KcEc3+Rx3k1T98jz23ltqVP6FfqjW3+MwUM9Vl8yq8uU8bKto7RVsZXfxQXPR8w9ROXcVMmy+KYwDFX+IU9EBuVINTxsx4Xyodum9OOjlUbV+S72f87frS87y9pQRXqqoBbPf7KKciW2hBRuPwnqs/qhgy36DRUDpxyobxKmPpADihSuqUfXw9UH46ttX6qVAr9gZxVK/3Elp0sHuSTkeFk6zCogIr+B31V/C1s+8nAG6+WD3UOyZbb5L11bMWhNgf718lFfilVqJoA/uDM08+kbhPBBjcon4vbhkA8Izbah7YIoF0ZM+6gflU2P3eKxxGSnex6MbIDcItwkkiG3coz/6l8I0EGgWTFiOxLfg24jowlKx8TlnKFTt4mgUcWsDmcCLzjvM3qo2X7gvn0d/4zrj7aX00AS7q4uHAb88lZeZ+fa728EgOpKRlXyAD4QJHZCh1zzYYHqBYgZ+cY8ROJgQcmOAd24nDvSiB7VAO3aEPxVECdk1X95BUl5BGa7TGFqgbSCWutwzpekuBkzXc+9ktBG8N7C/iIiqTQlf6PPk63U4BCCWC9Ici3Fo05pmtkDSyQHPS3ABMEEhs+Bqrt2HPNZhIDw+ApoIvZ29tRRnYioEb8un7A3qpZVAGjHnqSTxuwy3vc3pIUEVkgV3YitvK/Ka8O1q3erG21Fe8TNWwKlsdsxIuSwsXEt9522t74yymUAJa0WgoQ4WcDrAxfkXHbC4FE1efrUdumxw2yZkKQsUsgNMWU6olMKs455wQGcOU6WeOBAw7tJJlUf5lA964HCVBTJWEgykEJ/Fhtre9NWyApIEqUbv/OHys/8ksR+1H6xJved3fn5WauWDU7hsWxOOCavJDDO/3yU1/6vanPYnCA4xZZVn7ZjQMdq519ZtdvZNe/iAX5742y0TbFI9sYxMUiPta+xhi8OwH2p/uKYxZ65BxzhU8kWrQMOn9Lt2y35GPHktflhH//8n8GfunboXAFMNAxX7iVOZ31ZNjLlDMrAVM/WcYSZu6hKpADZeDxKJTELFmS0ld+kus3fk7JvS72E3L63KY25zsMhLyy68xsnj31NyoX8EmGropLDDkb8Pn7zcGfJcuzfJGfR43UnAB+/8yNZ4kXzycKPCXogd0acAEAcniALztnKMGzx4JrH5f1KOHBb8kWNkU5jxMEkiU3CbArn2AsnJSgAnIuN7ap8zU2PIH5nNwNvEoipQBgw3KZfG3TMCfEG6sGWarn76Eetm0dD21Z+zm6yM95WXDdn1NzAljSe8487d6TlG4NdbIFdqL4oEltMhziZ1cG2G4CY6PslBBSVVbpBBXKARr7WjP3mjh6sh3Jm2AGxDUeiIE9OQA8V88bs1SJy2jL4zE3/CiWDGRbd3VvnQP+Jc1KAEv6w3s+vrvH2D8k5JzA2BYFe65Tk2sAvWljYBif0otcdA7ISrtlQzJlPcAMnwy0+DUwT32WMM+qHrBKFhO1lf1SNtNpBaoFII70BYrNTARcBX3ET8HLk0EiuLSQlDi99OWB+/0WzU4AS3rPPR9/usPN7WODE+jIN9pbAb+keYBzeCMYdK9Xlx1VuzVZDDZv9kLEAfuRZY6yGUnAhr5s54Adawb37FYpYsvQk8uDnMKzf4NMaK8hpdtf/mNH5gd9IrRRAljSH7z96bcVSWBJM5OA1VZ0VMMsb5VgiG/HFBw1LcnJHPCpGZxDjN5Mq5SBDZRc8MBOBU9VIY7f6uxn8QjHKCuS+ZuE7MoXlEpfKk6HOPAeHeO2dPvLfvzoNtqQNk4AS1olgRN+aWgWIGp6YiyUsSWgaknC481YJuRkrlHDMQx+LD4Z52uV8QQTqZKhik+rzbJlJBU3UdaSaONYqMoFZd0lSiURtFYHMfCf3LoN8C9pKwlgSX/wq0/rSpEL3d2BdG7s3eTMaC1JYI5Mg34cnPmMl6qyiMyEoI6T0in0yfFRAxIiE/Bi9k4N/sxr7I2LFIvXo0RxGzPGkpkInH7nupUI+M91E+3zX/bjx6dpS7S1BLCkd99z4xsXRxef1fXE2bERfj+gT6HMn+YduwN5+BseFGlL1QUmbrGVpvLcj6UHNOxTAXZqAFKQmvYvkIxR5isb0eVAL+svHxo2/NQwt8+qZcnQ0dmjE37Oy0/P3/BDtNUEsKTlcwKLo5PndD1679ioBttUIYRnUmdsb2WQOgkBg22QWZ/DtoEiHTfb33Bmc2dxkChqFV1TOe9diwjfkXNpBG8baM2E2duzngXw7JZ2+Ax14P/W03wvbZl2M257+uTPfe9tzPwK6U2dLIOgpn8meQadLdvYeG+1seaxY4urx1zaDPrIj7Vu65eDMLY9trHtb9WGf5ADtU16DH9yPLdZxhJ4bFfxuB6DtFHzUWgJO2z4ndmG/I/tYKyuKKU7Xvbao5fQjmjrFUBO7377DbdxuviccUnQkpGLtXaiZv0tyjNtwUiQ3aTrHDM6NhU3J+lvIzumvcBGJbBVWw6Q0V69M9HYZl2D8VzL4X52OevvEvxL2mkCWNLvv/3GM9wtCbpS+a7lMQRTqKPLb/jlgK5HIVAn4z06LnhtMVoDsuasVR7qB0TRx34tcJoxWcnIWiKgONAxsFuTa6LkX59oW5TWsaY7Hj3hZ73sdPxTfRv52xd98ufd97wFL36wc3uKUBCsj1UGLWSmUlHKsHDADl//tp4h6/AY2inLUKnHyL9xPFiqfeef5RvFbS8VuP4JxFWT92m87BjYLHgy3qieOkfLRj22Sa5yzFgG68l/SbxXm4tnOa0e6z1DeyKmA9Bf/rz3voQX9E3d5sapIggxEFfvJbj7N6UMlzK8QQIgMhOCZ4dNPRYDB+g6/pGtmDwH4mSs34NODmSrrTgG8Q7vbCCT2CPgMhbHJlnnTM7+AGsf07/SDjoejSgftbby/RjTueXX7n3H6e3c22+hnS8BEL3rnhteSbxaFtxB26BKyc1zyz/lp3K8Y+Imhw2yqRygGxNcc6f47v0GPufKsvHXs7Fp7LwG/u2PJb7xEODvYzgsPePm+07xyeIlXSTPXVYE6o5Adoxm4rGdRcZlzc9tzNvht+34MzNvVgH0bXjWpWrFUPgiPGOi2Rl9sUgJkJayfuqHwgfgwZmcgQ9pP5uVzZ398fxBlRE4RudO0B+Jsyj0z52kkzsu0vErbzvN4R/f2QUxXUL0jJv/yy2LlF7RhXVqaEOgW70vOp+KQa4vDm01AaA4uGqHw3sN+XEJKGCn4JENljzOUYZh7HhvIJ4AkP2Ry0BW8MxSnvMj3361jGfDR+VYtTG2n8uN/y7v51N60wVanD408AdiugSpqwpuZlrc0pXuN3Ude4qKQda/dxMAwX2B3IZMAOrCsZa9NBKAHLwUTgCeTC0BlODVIChsjW1tAFV7E/Ac8usateHH0pIAlHfDX6Z7rlsu3EV08sbvPH3ZGbrEiOkSp0/rkkHqkkH3dp0MeqomgEyIs0Y29D174QTg6ZEArglIAoCUfHbld5YApB8vAcjzFTaK6mPgOgkAJ5W5CYDtfgodl20yrpSWX86R3rSgdEmCPiemJxA9s9sveIyObj6idHMX+F9NzKsvQLRAHUkAtu4TOAEUxznotD8M9l4zmAA462Am43wpkADGuDRYLV7MBu02ARCf7XbTz5wQvY3o6MxtM7+d5xDE9ASnZYVwTHT9yWLxzER8wyLRqS77Xt/dZry+O73VKxufACD42JRlenImgGjbhgkAATS3RewkAGUzagPbnPpluqKKv/7uy3Ndy/J1llZ/L76XVu/pXqLLzl4q6/k59N8AMacGJFA0zucAAAAASUVORK5CYII=";

// ../../node_modules/.pnpm/@cosmos-kit+keplr-extension@2.15.1_@cosmjs+amino@0.34.0_@cosmjs+proto-signing@0.34.0_starknet@7.6.4/node_modules/@cosmos-kit/keplr-extension/esm/extension/registry.js
var keplrExtensionInfo = {
  name: "keplr-extension",
  prettyName: "Keplr",
  logo: ICON,
  mode: "extension",
  // In the Keplr Mobile in-app browser, Keplr is available in window.keplr,
  // similar to the extension on a desktop browser. For this reason, we must
  // check what mode the window.keplr client is in once it's available.
  mobileDisabled: () => !(typeof document !== "undefined" && document.readyState === "complete" && window.keplr && window.keplr.mode === "mobile-web"),
  rejectMessage: {
    source: "Request rejected"
  },
  connectEventNamesOnWindow: ["keplr_keystorechange"],
  supportedChains: [
    "agoric",
    "akash",
    "archway",
    "axelar",
    "bostrom",
    "celestia",
    "certik",
    "comdex",
    "cosmoshub",
    "cryptoorgchain",
    "dymension",
    "emoney",
    "evmos",
    "gravitybridge",
    "injective",
    "irisnet",
    "ixo",
    "juno",
    "kava",
    "kujira",
    "noble",
    "nois",
    "osmosis",
    "persistence",
    "quicksilver",
    "regen",
    "secretnetwork",
    "sentinel",
    "sifchain",
    "sommelier",
    "stargaze",
    "starname",
    "stride",
    "terra2",
    "tgrade",
    "umee"
  ],
  downloads: [
    {
      device: "desktop",
      browser: "chrome",
      link: "https://chrome.google.com/webstore/detail/keplr/dmkamcknogkgcdfhhbddcghachkejeap?hl=en"
    },
    {
      device: "desktop",
      browser: "firefox",
      link: "https://addons.mozilla.org/en-US/firefox/addon/keplr/"
    },
    {
      link: "https://www.keplr.app/download"
    }
  ]
};

// ../../node_modules/.pnpm/@cosmos-kit+keplr-extension@2.15.1_@cosmjs+amino@0.34.0_@cosmjs+proto-signing@0.34.0_starknet@7.6.4/node_modules/@cosmos-kit/keplr-extension/esm/keplr.js
var keplrExtension = new KeplrExtensionWallet(keplrExtensionInfo, preferredEndpoints);
var wallets = [keplrExtension];

// ../../node_modules/.pnpm/@cosmos-kit+keplr-mobile@2.15.1_@cosmjs+amino@0.34.0_@cosmjs+proto-signing@0.34.0_@wall_4d80990aea15eba7d005a9e6df60de3d/node_modules/@cosmos-kit/keplr-mobile/esm/config.js
var preferredEndpoints2 = {
  osmosis: {
    rpc: ["https://rpc-osmosis.keplr.app/"],
    rest: ["https://lcd-osmosis.keplr.app/"]
  },
  osmosistestnet: {
    rpc: ["https://rpc-test.osmosis.zone/"],
    rest: ["https://lcd-test.osmosis.zone/"]
  },
  cosmoshub: {
    rpc: ["https://rpc-cosmoshub.keplr.app"],
    rest: ["https://lcd-cosmoshub.keplr.app"]
  },
  terra: {
    rpc: ["https://rpc-columbus.keplr.app"],
    rest: ["https://lcd-columbus.keplr.app"]
  },
  secretnetwork: {
    rpc: ["https://rpc-secret.keplr.app"],
    rest: ["https://lcd-secret.keplr.app"]
  },
  akash: {
    rpc: ["https://rpc-akash.keplr.app"],
    rest: ["https://lcd-akash.keplr.app"]
  },
  regen: {
    rpc: ["https://rpc-regen.keplr.app"],
    rest: ["https://lcd-regen.keplr.app"]
  },
  sentinel: {
    rpc: ["https://rpc-sentinel.keplr.app"],
    rest: ["https://lcd-sentinel.keplr.app"]
  },
  persistence: {
    rpc: ["https://rpc-persistence.keplr.app"],
    rest: ["https://lcd-persistence.keplr.app"]
  },
  irisnet: {
    rpc: ["https://rpc-iris.keplr.app"],
    rest: ["https://lcd-iris.keplr.app"]
  },
  cryptoorgchain: {
    rpc: ["https://rpc-crypto-org.keplr.app/"],
    rest: ["https://lcd-crypto-org.keplr.app/"]
  },
  starname: {
    rpc: ["https://rpc-iov.keplr.app"],
    rest: ["https://lcd-iov.keplr.app"]
  },
  emoney: {
    rpc: ["https://rpc-emoney.keplr.app"],
    rest: ["https://lcd-emoney.keplr.app"]
  },
  juno: {
    rpc: ["https://rpc-juno.itastakers.com"],
    rest: ["https://lcd-juno.itastakers.com"]
  },
  microtick: {
    rpc: ["https://rpc-microtick.keplr.app"],
    rest: ["https://lcd-microtick.keplr.app"]
  },
  likecoin: {
    rpc: ["https://mainnet-node.like.co/rpc"],
    rest: ["https://mainnet-node.like.co"]
  },
  impacthub: {
    rpc: ["https://rpc-impacthub.keplr.app"],
    rest: ["https://lcd-impacthub.keplr.app"]
  },
  bitcanna: {
    rpc: ["https://rpc.bitcanna.io"],
    rest: ["https://lcd.bitcanna.io"]
  },
  bitsong: {
    rpc: ["https://rpc.explorebitsong.com"],
    rest: ["https://lcd.explorebitsong.com"]
  },
  kichain: {
    rpc: ["https://rpc-mainnet.blockchain.ki"],
    rest: ["https://api-mainnet.blockchain.ki"]
  },
  panacea: {
    rpc: ["https://rpc.gopanacea.org"],
    rest: ["https://api.gopanacea.org"]
  },
  bostrom: {
    rpc: ["https://rpc.bostrom.cybernode.ai"],
    rest: ["https://lcd.bostrom.cybernode.ai"]
  },
  comdex: {
    rpc: ["https://rpc.comdex.one"],
    rest: ["https://rest.comdex.one"]
  },
  cheqd: {
    rpc: ["https://rpc.cheqd.net"],
    rest: ["https://api.cheqd.net"]
  },
  stargaze: {
    rpc: ["https://rpc.stargaze-apis.com"],
    rest: ["https://rest.stargaze-apis.com"]
  },
  chihuahua: {
    rpc: ["https://rpc.chihuahua.wtf"],
    rest: ["https://api.chihuahua.wtf"]
  },
  lumnetwork: {
    rpc: ["https://node0.mainnet.lum.network/rpc"],
    rest: ["https://node0.mainnet.lum.network/rest"]
  },
  vidulum: {
    rpc: ["https://mainnet-rpc.vidulum.app"],
    rest: ["https://mainnet-lcd.vidulum.app"]
  },
  desmos: {
    rpc: ["https://rpc.mainnet.desmos.network"],
    rest: ["https://api.mainnet.desmos.network"]
  },
  dig: {
    rpc: ["https://rpc-1-dig.notional.ventures"],
    rest: ["https://api-1-dig.notional.ventures"]
  },
  sommelier: {
    rpc: ["https://rpc-sommelier.keplr.app"],
    rest: ["https://lcd-sommelier.keplr.app"]
  },
  sifchain: {
    rpc: ["https://rpc.sifchain.finance"],
    rest: ["https://api-int.sifchain.finance"]
  },
  bandchain: {
    rpc: ["https://rpc.laozi3.bandchain.org"],
    rest: ["https://laozi1.bandchain.org/api"]
  },
  konstellation: {
    rpc: ["https://node1.konstellation.tech:26657"],
    rest: ["https://node1.konstellation.tech:1318"]
  },
  umee: {
    rpc: ["https://rpc.aphrodite.main.network.umee.cc"],
    rest: ["https://api.aphrodite.main.network.umee.cc"]
  },
  gravitybridge: {
    rpc: ["https://gravitychain.io:26657"],
    rest: ["https://gravitychain.io:1317"]
  },
  decentr: {
    rpc: ["https://poseidon.mainnet.decentr.xyz"],
    rest: ["https://rest.mainnet.decentr.xyz"]
  },
  shentu: {
    rpc: ["https://shenturpc.certikpowered.info"],
    rest: ["https://azuredragon.noopsbycertik.com"]
  },
  carbon: {
    rpc: ["https://tm-api.carbon.network"],
    rest: ["https://api.carbon.network"]
  },
  injective: {
    rpc: ["https://public.api.injective.network"],
    rest: ["https://public.lcd.injective.network"]
  },
  cerberus: {
    rpc: ["https://rpc.cerberus.zone:26657"],
    rest: ["https://api.cerberus.zone:1317"]
  },
  fetchhub: {
    rpc: ["https://rpc-fetchhub.fetch.ai:443"],
    rest: ["https://rest-fetchhub.fetch.ai"]
  },
  assetmantle: {
    rpc: ["https://rpc.assetmantle.one/"],
    rest: ["https://rest.assetmantle.one/"]
  },
  provenance: {
    rpc: ["https://rpc.provenance.io/"],
    rest: ["https://api.provenance.io"]
  },
  galaxy: {
    rpc: ["https://rpc.galaxychain.zone"],
    rest: ["https://rest.galaxychain.zone"]
  },
  meme: {
    rpc: ["https://rpc-meme-1.meme.sx:443"],
    rest: ["https://api-meme-1.meme.sx:443"]
  },
  evmos: {
    rpc: ["https://rpc-evmos.keplr.app/"],
    rest: ["https://lcd-evmos.keplr.app/"]
  },
  terra2: {
    rpc: ["https://rpc.terrav2.ccvalidators.com/"],
    rest: ["https://phoenix-lcd.terra.dev/"]
  },
  rizon: {
    rpc: ["https://rpcapi.rizon.world/"],
    rest: ["https://restapi.rizon.world/"]
  },
  kava: {
    rpc: ["https://rpc-kava.keplr.app"],
    rest: ["https://lcd-kava.keplr.app"]
  },
  genesisl1: {
    rpc: ["https://26657.genesisl1.org"],
    rest: ["https://api.genesisl1.org"]
  }
};

// ../../node_modules/.pnpm/@cosmos-kit+walletconnect@2.13.1_@cosmjs+amino@0.34.0_@walletconnect+types@2.21.5/node_modules/@cosmos-kit/walletconnect/esm/chain-wallet.js
var ChainWC = class extends ChainWalletBase {
  constructor(walletInfo, chainInfo, WCClient2) {
    super(walletInfo, chainInfo);
    __publicField(this, "WCClient");
    __publicField(this, "clientMutable", { state: State.Init });
    __publicField(this, "options");
    this.WCClient = WCClient2;
  }
  setClientNotExist() {
    this.setState(State.Error);
    this.setMessage(this.clientMutable.message);
  }
};

// ../../node_modules/.pnpm/@walletconnect+core@2.21.5/node_modules/@walletconnect/core/dist/index.es.js
var import_events7 = __toESM(require_events());

// ../../node_modules/.pnpm/@walletconnect+heartbeat@1.2.2/node_modules/@walletconnect/heartbeat/dist/index.es.js
var import_events = __toESM(require_events());
var import_time = __toESM(require_cjs2());

// ../../node_modules/.pnpm/@walletconnect+events@1.0.1/node_modules/@walletconnect/events/dist/esm/events.js
var IEvents = class {
};

// ../../node_modules/.pnpm/@walletconnect+heartbeat@1.2.2/node_modules/@walletconnect/heartbeat/dist/index.es.js
var n = class extends IEvents {
  constructor(e2) {
    super();
  }
};
var s = import_time.FIVE_SECONDS;
var r = { pulse: "heartbeat_pulse" };
var i = class _i2 extends n {
  constructor(e2) {
    super(e2), this.events = new import_events.EventEmitter(), this.interval = s, this.interval = (e2 == null ? void 0 : e2.interval) || s;
  }
  static async init(e2) {
    const t = new _i2(e2);
    return await t.init(), t;
  }
  async init() {
    await this.initialize();
  }
  stop() {
    clearInterval(this.intervalRef);
  }
  on(e2, t) {
    this.events.on(e2, t);
  }
  once(e2, t) {
    this.events.once(e2, t);
  }
  off(e2, t) {
    this.events.off(e2, t);
  }
  removeListener(e2, t) {
    this.events.removeListener(e2, t);
  }
  async initialize() {
    this.intervalRef = setInterval(() => this.pulse(), (0, import_time.toMiliseconds)(this.interval));
  }
  pulse() {
    this.events.emit(r.pulse);
  }
};

// ../../node_modules/.pnpm/destr@2.0.5/node_modules/destr/dist/index.mjs
var suspectProtoRx = /"(?:_|\\u0{2}5[Ff]){2}(?:p|\\u0{2}70)(?:r|\\u0{2}72)(?:o|\\u0{2}6[Ff])(?:t|\\u0{2}74)(?:o|\\u0{2}6[Ff])(?:_|\\u0{2}5[Ff]){2}"\s*:/;
var suspectConstructorRx = /"(?:c|\\u0063)(?:o|\\u006[Ff])(?:n|\\u006[Ee])(?:s|\\u0073)(?:t|\\u0074)(?:r|\\u0072)(?:u|\\u0075)(?:c|\\u0063)(?:t|\\u0074)(?:o|\\u006[Ff])(?:r|\\u0072)"\s*:/;
var JsonSigRx = /^\s*["[{]|^\s*-?\d{1,16}(\.\d{1,17})?([Ee][+-]?\d+)?\s*$/;
function jsonParseTransform(key, value) {
  if (key === "__proto__" || key === "constructor" && value && typeof value === "object" && "prototype" in value) {
    warnKeyDropped(key);
    return;
  }
  return value;
}
function warnKeyDropped(key) {
  console.warn(`[destr] Dropping "${key}" key to prevent prototype pollution.`);
}
function destr(value, options = {}) {
  if (typeof value !== "string") {
    return value;
  }
  if (value[0] === '"' && value[value.length - 1] === '"' && value.indexOf("\\") === -1) {
    return value.slice(1, -1);
  }
  const _value = value.trim();
  if (_value.length <= 9) {
    switch (_value.toLowerCase()) {
      case "true": {
        return true;
      }
      case "false": {
        return false;
      }
      case "undefined": {
        return void 0;
      }
      case "null": {
        return null;
      }
      case "nan": {
        return Number.NaN;
      }
      case "infinity": {
        return Number.POSITIVE_INFINITY;
      }
      case "-infinity": {
        return Number.NEGATIVE_INFINITY;
      }
    }
  }
  if (!JsonSigRx.test(value)) {
    if (options.strict) {
      throw new SyntaxError("[destr] Invalid JSON");
    }
    return value;
  }
  try {
    if (suspectProtoRx.test(value) || suspectConstructorRx.test(value)) {
      if (options.strict) {
        throw new Error("[destr] Possible prototype pollution");
      }
      return JSON.parse(value, jsonParseTransform);
    }
    return JSON.parse(value);
  } catch (error) {
    if (options.strict) {
      throw error;
    }
    return value;
  }
}

// ../../node_modules/.pnpm/unstorage@1.16.1_idb-keyval@6.2.2/node_modules/unstorage/dist/shared/unstorage.CoCt7NXC.mjs
function wrapToPromise(value) {
  if (!value || typeof value.then !== "function") {
    return Promise.resolve(value);
  }
  return value;
}
function asyncCall(function_, ...arguments_) {
  try {
    return wrapToPromise(function_(...arguments_));
  } catch (error) {
    return Promise.reject(error);
  }
}
function isPrimitive(value) {
  const type = typeof value;
  return value === null || type !== "object" && type !== "function";
}
function isPureObject(value) {
  const proto = Object.getPrototypeOf(value);
  return !proto || proto.isPrototypeOf(Object);
}
function stringify(value) {
  if (isPrimitive(value)) {
    return String(value);
  }
  if (isPureObject(value) || Array.isArray(value)) {
    return JSON.stringify(value);
  }
  if (typeof value.toJSON === "function") {
    return stringify(value.toJSON());
  }
  throw new Error("[unstorage] Cannot stringify value!");
}
var BASE64_PREFIX = "base64:";
function serializeRaw(value) {
  if (typeof value === "string") {
    return value;
  }
  return BASE64_PREFIX + base64Encode(value);
}
function deserializeRaw(value) {
  if (typeof value !== "string") {
    return value;
  }
  if (!value.startsWith(BASE64_PREFIX)) {
    return value;
  }
  return base64Decode(value.slice(BASE64_PREFIX.length));
}
function base64Decode(input) {
  if (globalThis.Buffer) {
    return Buffer.from(input, "base64");
  }
  return Uint8Array.from(
    globalThis.atob(input),
    (c6) => c6.codePointAt(0)
  );
}
function base64Encode(input) {
  if (globalThis.Buffer) {
    return Buffer.from(input).toString("base64");
  }
  return globalThis.btoa(String.fromCodePoint(...input));
}
function normalizeKey(key) {
  var _a2;
  if (!key) {
    return "";
  }
  return ((_a2 = key.split("?")[0]) == null ? void 0 : _a2.replace(/[/\\]/g, ":").replace(/:+/g, ":").replace(/^:|:$/g, "")) || "";
}
function joinKeys(...keys3) {
  return normalizeKey(keys3.join(":"));
}
function normalizeBaseKey(base) {
  base = normalizeKey(base);
  return base ? base + ":" : "";
}
function filterKeyByDepth(key, depth) {
  if (depth === void 0) {
    return true;
  }
  let substrCount = 0;
  let index = key.indexOf(":");
  while (index > -1) {
    substrCount++;
    index = key.indexOf(":", index + 1);
  }
  return substrCount <= depth;
}
function filterKeyByBase(key, base) {
  if (base) {
    return key.startsWith(base) && key[key.length - 1] !== "$";
  }
  return key[key.length - 1] !== "$";
}

// ../../node_modules/.pnpm/unstorage@1.16.1_idb-keyval@6.2.2/node_modules/unstorage/dist/index.mjs
function defineDriver(factory) {
  return factory;
}
var DRIVER_NAME = "memory";
var memory = defineDriver(() => {
  const data = /* @__PURE__ */ new Map();
  return {
    name: DRIVER_NAME,
    getInstance: () => data,
    hasItem(key) {
      return data.has(key);
    },
    getItem(key) {
      return data.get(key) ?? null;
    },
    getItemRaw(key) {
      return data.get(key) ?? null;
    },
    setItem(key, value) {
      data.set(key, value);
    },
    setItemRaw(key, value) {
      data.set(key, value);
    },
    removeItem(key) {
      data.delete(key);
    },
    getKeys() {
      return [...data.keys()];
    },
    clear() {
      data.clear();
    },
    dispose() {
      data.clear();
    }
  };
});
function createStorage(options = {}) {
  const context = {
    mounts: { "": options.driver || memory() },
    mountpoints: [""],
    watching: false,
    watchListeners: [],
    unwatch: {}
  };
  const getMount = (key) => {
    for (const base of context.mountpoints) {
      if (key.startsWith(base)) {
        return {
          base,
          relativeKey: key.slice(base.length),
          driver: context.mounts[base]
        };
      }
    }
    return {
      base: "",
      relativeKey: key,
      driver: context.mounts[""]
    };
  };
  const getMounts = (base, includeParent) => {
    return context.mountpoints.filter(
      (mountpoint) => mountpoint.startsWith(base) || includeParent && base.startsWith(mountpoint)
    ).map((mountpoint) => ({
      relativeBase: base.length > mountpoint.length ? base.slice(mountpoint.length) : void 0,
      mountpoint,
      driver: context.mounts[mountpoint]
    }));
  };
  const onChange = (event, key) => {
    if (!context.watching) {
      return;
    }
    key = normalizeKey(key);
    for (const listener of context.watchListeners) {
      listener(event, key);
    }
  };
  const startWatch = async () => {
    if (context.watching) {
      return;
    }
    context.watching = true;
    for (const mountpoint in context.mounts) {
      context.unwatch[mountpoint] = await watch(
        context.mounts[mountpoint],
        onChange,
        mountpoint
      );
    }
  };
  const stopWatch = async () => {
    if (!context.watching) {
      return;
    }
    for (const mountpoint in context.unwatch) {
      await context.unwatch[mountpoint]();
    }
    context.unwatch = {};
    context.watching = false;
  };
  const runBatch = (items, commonOptions, cb) => {
    const batches = /* @__PURE__ */ new Map();
    const getBatch = (mount) => {
      let batch = batches.get(mount.base);
      if (!batch) {
        batch = {
          driver: mount.driver,
          base: mount.base,
          items: []
        };
        batches.set(mount.base, batch);
      }
      return batch;
    };
    for (const item of items) {
      const isStringItem = typeof item === "string";
      const key = normalizeKey(isStringItem ? item : item.key);
      const value = isStringItem ? void 0 : item.value;
      const options2 = isStringItem || !item.options ? commonOptions : { ...commonOptions, ...item.options };
      const mount = getMount(key);
      getBatch(mount).items.push({
        key,
        value,
        relativeKey: mount.relativeKey,
        options: options2
      });
    }
    return Promise.all([...batches.values()].map((batch) => cb(batch))).then(
      (r3) => r3.flat()
    );
  };
  const storage = {
    // Item
    hasItem(key, opts = {}) {
      key = normalizeKey(key);
      const { relativeKey, driver } = getMount(key);
      return asyncCall(driver.hasItem, relativeKey, opts);
    },
    getItem(key, opts = {}) {
      key = normalizeKey(key);
      const { relativeKey, driver } = getMount(key);
      return asyncCall(driver.getItem, relativeKey, opts).then(
        (value) => destr(value)
      );
    },
    getItems(items, commonOptions = {}) {
      return runBatch(items, commonOptions, (batch) => {
        if (batch.driver.getItems) {
          return asyncCall(
            batch.driver.getItems,
            batch.items.map((item) => ({
              key: item.relativeKey,
              options: item.options
            })),
            commonOptions
          ).then(
            (r3) => r3.map((item) => ({
              key: joinKeys(batch.base, item.key),
              value: destr(item.value)
            }))
          );
        }
        return Promise.all(
          batch.items.map((item) => {
            return asyncCall(
              batch.driver.getItem,
              item.relativeKey,
              item.options
            ).then((value) => ({
              key: item.key,
              value: destr(value)
            }));
          })
        );
      });
    },
    getItemRaw(key, opts = {}) {
      key = normalizeKey(key);
      const { relativeKey, driver } = getMount(key);
      if (driver.getItemRaw) {
        return asyncCall(driver.getItemRaw, relativeKey, opts);
      }
      return asyncCall(driver.getItem, relativeKey, opts).then(
        (value) => deserializeRaw(value)
      );
    },
    async setItem(key, value, opts = {}) {
      if (value === void 0) {
        return storage.removeItem(key);
      }
      key = normalizeKey(key);
      const { relativeKey, driver } = getMount(key);
      if (!driver.setItem) {
        return;
      }
      await asyncCall(driver.setItem, relativeKey, stringify(value), opts);
      if (!driver.watch) {
        onChange("update", key);
      }
    },
    async setItems(items, commonOptions) {
      await runBatch(items, commonOptions, async (batch) => {
        if (batch.driver.setItems) {
          return asyncCall(
            batch.driver.setItems,
            batch.items.map((item) => ({
              key: item.relativeKey,
              value: stringify(item.value),
              options: item.options
            })),
            commonOptions
          );
        }
        if (!batch.driver.setItem) {
          return;
        }
        await Promise.all(
          batch.items.map((item) => {
            return asyncCall(
              batch.driver.setItem,
              item.relativeKey,
              stringify(item.value),
              item.options
            );
          })
        );
      });
    },
    async setItemRaw(key, value, opts = {}) {
      if (value === void 0) {
        return storage.removeItem(key, opts);
      }
      key = normalizeKey(key);
      const { relativeKey, driver } = getMount(key);
      if (driver.setItemRaw) {
        await asyncCall(driver.setItemRaw, relativeKey, value, opts);
      } else if (driver.setItem) {
        await asyncCall(driver.setItem, relativeKey, serializeRaw(value), opts);
      } else {
        return;
      }
      if (!driver.watch) {
        onChange("update", key);
      }
    },
    async removeItem(key, opts = {}) {
      if (typeof opts === "boolean") {
        opts = { removeMeta: opts };
      }
      key = normalizeKey(key);
      const { relativeKey, driver } = getMount(key);
      if (!driver.removeItem) {
        return;
      }
      await asyncCall(driver.removeItem, relativeKey, opts);
      if (opts.removeMeta || opts.removeMata) {
        await asyncCall(driver.removeItem, relativeKey + "$", opts);
      }
      if (!driver.watch) {
        onChange("remove", key);
      }
    },
    // Meta
    async getMeta(key, opts = {}) {
      if (typeof opts === "boolean") {
        opts = { nativeOnly: opts };
      }
      key = normalizeKey(key);
      const { relativeKey, driver } = getMount(key);
      const meta = /* @__PURE__ */ Object.create(null);
      if (driver.getMeta) {
        Object.assign(meta, await asyncCall(driver.getMeta, relativeKey, opts));
      }
      if (!opts.nativeOnly) {
        const value = await asyncCall(
          driver.getItem,
          relativeKey + "$",
          opts
        ).then((value_) => destr(value_));
        if (value && typeof value === "object") {
          if (typeof value.atime === "string") {
            value.atime = new Date(value.atime);
          }
          if (typeof value.mtime === "string") {
            value.mtime = new Date(value.mtime);
          }
          Object.assign(meta, value);
        }
      }
      return meta;
    },
    setMeta(key, value, opts = {}) {
      return this.setItem(key + "$", value, opts);
    },
    removeMeta(key, opts = {}) {
      return this.removeItem(key + "$", opts);
    },
    // Keys
    async getKeys(base, opts = {}) {
      var _a2;
      base = normalizeBaseKey(base);
      const mounts = getMounts(base, true);
      let maskedMounts = [];
      const allKeys = [];
      let allMountsSupportMaxDepth = true;
      for (const mount of mounts) {
        if (!((_a2 = mount.driver.flags) == null ? void 0 : _a2.maxDepth)) {
          allMountsSupportMaxDepth = false;
        }
        const rawKeys = await asyncCall(
          mount.driver.getKeys,
          mount.relativeBase,
          opts
        );
        for (const key of rawKeys) {
          const fullKey = mount.mountpoint + normalizeKey(key);
          if (!maskedMounts.some((p4) => fullKey.startsWith(p4))) {
            allKeys.push(fullKey);
          }
        }
        maskedMounts = [
          mount.mountpoint,
          ...maskedMounts.filter((p4) => !p4.startsWith(mount.mountpoint))
        ];
      }
      const shouldFilterByDepth = opts.maxDepth !== void 0 && !allMountsSupportMaxDepth;
      return allKeys.filter(
        (key) => (!shouldFilterByDepth || filterKeyByDepth(key, opts.maxDepth)) && filterKeyByBase(key, base)
      );
    },
    // Utils
    async clear(base, opts = {}) {
      base = normalizeBaseKey(base);
      await Promise.all(
        getMounts(base, false).map(async (m3) => {
          if (m3.driver.clear) {
            return asyncCall(m3.driver.clear, m3.relativeBase, opts);
          }
          if (m3.driver.removeItem) {
            const keys3 = await m3.driver.getKeys(m3.relativeBase || "", opts);
            return Promise.all(
              keys3.map((key) => m3.driver.removeItem(key, opts))
            );
          }
        })
      );
    },
    async dispose() {
      await Promise.all(
        Object.values(context.mounts).map((driver) => dispose(driver))
      );
    },
    async watch(callback) {
      await startWatch();
      context.watchListeners.push(callback);
      return async () => {
        context.watchListeners = context.watchListeners.filter(
          (listener) => listener !== callback
        );
        if (context.watchListeners.length === 0) {
          await stopWatch();
        }
      };
    },
    async unwatch() {
      context.watchListeners = [];
      await stopWatch();
    },
    // Mount
    mount(base, driver) {
      base = normalizeBaseKey(base);
      if (base && context.mounts[base]) {
        throw new Error(`already mounted at ${base}`);
      }
      if (base) {
        context.mountpoints.push(base);
        context.mountpoints.sort((a3, b4) => b4.length - a3.length);
      }
      context.mounts[base] = driver;
      if (context.watching) {
        Promise.resolve(watch(driver, onChange, base)).then((unwatcher) => {
          context.unwatch[base] = unwatcher;
        }).catch(console.error);
      }
      return storage;
    },
    async unmount(base, _dispose = true) {
      var _a2, _b;
      base = normalizeBaseKey(base);
      if (!base || !context.mounts[base]) {
        return;
      }
      if (context.watching && base in context.unwatch) {
        (_b = (_a2 = context.unwatch)[base]) == null ? void 0 : _b.call(_a2);
        delete context.unwatch[base];
      }
      if (_dispose) {
        await dispose(context.mounts[base]);
      }
      context.mountpoints = context.mountpoints.filter((key) => key !== base);
      delete context.mounts[base];
    },
    getMount(key = "") {
      key = normalizeKey(key) + ":";
      const m3 = getMount(key);
      return {
        driver: m3.driver,
        base: m3.base
      };
    },
    getMounts(base = "", opts = {}) {
      base = normalizeKey(base);
      const mounts = getMounts(base, opts.parents);
      return mounts.map((m3) => ({
        driver: m3.driver,
        base: m3.mountpoint
      }));
    },
    // Aliases
    keys: (base, opts = {}) => storage.getKeys(base, opts),
    get: (key, opts = {}) => storage.getItem(key, opts),
    set: (key, value, opts = {}) => storage.setItem(key, value, opts),
    has: (key, opts = {}) => storage.hasItem(key, opts),
    del: (key, opts = {}) => storage.removeItem(key, opts),
    remove: (key, opts = {}) => storage.removeItem(key, opts)
  };
  return storage;
}
function watch(driver, onChange, base) {
  return driver.watch ? driver.watch((event, key) => onChange(event, base + key)) : () => {
  };
}
async function dispose(driver) {
  if (typeof driver.dispose === "function") {
    await asyncCall(driver.dispose);
  }
}

// ../../node_modules/.pnpm/idb-keyval@6.2.2/node_modules/idb-keyval/dist/index.js
function promisifyRequest(request) {
  return new Promise((resolve, reject) => {
    request.oncomplete = request.onsuccess = () => resolve(request.result);
    request.onabort = request.onerror = () => reject(request.error);
  });
}
function createStore(dbName, storeName) {
  let dbp;
  const getDB = () => {
    if (dbp)
      return dbp;
    const request = indexedDB.open(dbName);
    request.onupgradeneeded = () => request.result.createObjectStore(storeName);
    dbp = promisifyRequest(request);
    dbp.then((db) => {
      db.onclose = () => dbp = void 0;
    }, () => {
    });
    return dbp;
  };
  return (txMode, callback) => getDB().then((db) => callback(db.transaction(storeName, txMode).objectStore(storeName)));
}
var defaultGetStoreFunc;
function defaultGetStore() {
  if (!defaultGetStoreFunc) {
    defaultGetStoreFunc = createStore("keyval-store", "keyval");
  }
  return defaultGetStoreFunc;
}
function get4(key, customStore = defaultGetStore()) {
  return customStore("readonly", (store) => promisifyRequest(store.get(key)));
}
function set5(key, value, customStore = defaultGetStore()) {
  return customStore("readwrite", (store) => {
    store.put(value, key);
    return promisifyRequest(store.transaction);
  });
}
function del(key, customStore = defaultGetStore()) {
  return customStore("readwrite", (store) => {
    store.delete(key);
    return promisifyRequest(store.transaction);
  });
}
function clear2(customStore = defaultGetStore()) {
  return customStore("readwrite", (store) => {
    store.clear();
    return promisifyRequest(store.transaction);
  });
}
function eachCursor(store, callback) {
  store.openCursor().onsuccess = function() {
    if (!this.result)
      return;
    callback(this.result);
    this.result.continue();
  };
  return promisifyRequest(store.transaction);
}
function keys2(customStore = defaultGetStore()) {
  return customStore("readonly", (store) => {
    if (store.getAllKeys) {
      return promisifyRequest(store.getAllKeys());
    }
    const items = [];
    return eachCursor(store, (cursor) => items.push(cursor.key)).then(() => items);
  });
}

// ../../node_modules/.pnpm/@walletconnect+keyvaluestorage@1.1.1/node_modules/@walletconnect/keyvaluestorage/dist/index.es.js
var x = "idb-keyval";
var z = (i4 = {}) => {
  const t = i4.base && i4.base.length > 0 ? `${i4.base}:` : "", e2 = (s3) => t + s3;
  let n5;
  return i4.dbName && i4.storeName && (n5 = createStore(i4.dbName, i4.storeName)), { name: x, options: i4, async hasItem(s3) {
    return !(typeof await get4(e2(s3), n5) > "u");
  }, async getItem(s3) {
    return await get4(e2(s3), n5) ?? null;
  }, setItem(s3, a3) {
    return set5(e2(s3), a3, n5);
  }, removeItem(s3) {
    return del(e2(s3), n5);
  }, getKeys() {
    return keys2(n5);
  }, clear() {
    return clear2(n5);
  } };
};
var D = "WALLET_CONNECT_V2_INDEXED_DB";
var E = "keyvaluestorage";
var _14 = class {
  constructor() {
    this.indexedDb = createStorage({ driver: z({ dbName: D, storeName: E }) });
  }
  async getKeys() {
    return this.indexedDb.getKeys();
  }
  async getEntries() {
    return (await this.indexedDb.getItems(await this.indexedDb.getKeys())).map((t) => [t.key, t.value]);
  }
  async getItem(t) {
    const e2 = await this.indexedDb.getItem(t);
    if (e2 !== null)
      return e2;
  }
  async setItem(t, e2) {
    await this.indexedDb.setItem(t, safeJsonStringify(e2));
  }
  async removeItem(t) {
    await this.indexedDb.removeItem(t);
  }
};
var l2 = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
var c = { exports: {} };
(function() {
  let i4;
  function t() {
  }
  i4 = t, i4.prototype.getItem = function(e2) {
    return this.hasOwnProperty(e2) ? String(this[e2]) : null;
  }, i4.prototype.setItem = function(e2, n5) {
    this[e2] = String(n5);
  }, i4.prototype.removeItem = function(e2) {
    delete this[e2];
  }, i4.prototype.clear = function() {
    const e2 = this;
    Object.keys(e2).forEach(function(n5) {
      e2[n5] = void 0, delete e2[n5];
    });
  }, i4.prototype.key = function(e2) {
    return e2 = e2 || 0, Object.keys(this)[e2];
  }, i4.prototype.__defineGetter__("length", function() {
    return Object.keys(this).length;
  }), typeof l2 < "u" && l2.localStorage ? c.exports = l2.localStorage : typeof window < "u" && window.localStorage ? c.exports = window.localStorage : c.exports = new t();
})();
function k(i4) {
  var t;
  return [i4[0], safeJsonParse((t = i4[1]) != null ? t : "")];
}
var K = class {
  constructor() {
    this.localStorage = c.exports;
  }
  async getKeys() {
    return Object.keys(this.localStorage);
  }
  async getEntries() {
    return Object.entries(this.localStorage).map(k);
  }
  async getItem(t) {
    const e2 = this.localStorage.getItem(t);
    if (e2 !== null)
      return safeJsonParse(e2);
  }
  async setItem(t, e2) {
    this.localStorage.setItem(t, safeJsonStringify(e2));
  }
  async removeItem(t) {
    this.localStorage.removeItem(t);
  }
};
var N = "wc_storage_version";
var y = 1;
var O = async (i4, t, e2) => {
  const n5 = N, s3 = await t.getItem(n5);
  if (s3 && s3 >= y) {
    e2(t);
    return;
  }
  const a3 = await i4.getKeys();
  if (!a3.length) {
    e2(t);
    return;
  }
  const m3 = [];
  for (; a3.length; ) {
    const r3 = a3.shift();
    if (!r3)
      continue;
    const o4 = r3.toLowerCase();
    if (o4.includes("wc@") || o4.includes("walletconnect") || o4.includes("wc_") || o4.includes("wallet_connect")) {
      const f6 = await i4.getItem(r3);
      await t.setItem(r3, f6), m3.push(r3);
    }
  }
  await t.setItem(n5, y), e2(t), j(i4, m3);
};
var j = async (i4, t) => {
  t.length && t.forEach(async (e2) => {
    await i4.removeItem(e2);
  });
};
var h = class {
  constructor() {
    this.initialized = false, this.setInitialized = (e2) => {
      this.storage = e2, this.initialized = true;
    };
    const t = new K();
    this.storage = t;
    try {
      const e2 = new _14();
      O(t, e2, this.setInitialized);
    } catch {
      this.initialized = true;
    }
  }
  async getKeys() {
    return await this.initialize(), this.storage.getKeys();
  }
  async getEntries() {
    return await this.initialize(), this.storage.getEntries();
  }
  async getItem(t) {
    return await this.initialize(), this.storage.getItem(t);
  }
  async setItem(t, e2) {
    return await this.initialize(), this.storage.setItem(t, e2);
  }
  async removeItem(t) {
    return await this.initialize(), this.storage.removeItem(t);
  }
  async initialize() {
    this.initialized || await new Promise((t) => {
      const e2 = setInterval(() => {
        this.initialized && (clearInterval(e2), t());
      }, 20);
    });
  }
};

// ../../node_modules/.pnpm/@walletconnect+logger@2.1.2/node_modules/@walletconnect/logger/dist/index.es.js
var import_pino = __toESM(require_browser4());
var import_pino2 = __toESM(require_browser4());
var c2 = { level: "info" };
var n2 = "custom_context";
var l3 = 1e3 * 1024;
var O2 = class {
  constructor(e2) {
    this.nodeValue = e2, this.sizeInBytes = new TextEncoder().encode(this.nodeValue).length, this.next = null;
  }
  get value() {
    return this.nodeValue;
  }
  get size() {
    return this.sizeInBytes;
  }
};
var d = class {
  constructor(e2) {
    this.head = null, this.tail = null, this.lengthInNodes = 0, this.maxSizeInBytes = e2, this.sizeInBytes = 0;
  }
  append(e2) {
    const t = new O2(e2);
    if (t.size > this.maxSizeInBytes)
      throw new Error(`[LinkedList] Value too big to insert into list: ${e2} with size ${t.size}`);
    for (; this.size + t.size > this.maxSizeInBytes; )
      this.shift();
    this.head ? (this.tail && (this.tail.next = t), this.tail = t) : (this.head = t, this.tail = t), this.lengthInNodes++, this.sizeInBytes += t.size;
  }
  shift() {
    if (!this.head)
      return;
    const e2 = this.head;
    this.head = this.head.next, this.head || (this.tail = null), this.lengthInNodes--, this.sizeInBytes -= e2.size;
  }
  toArray() {
    const e2 = [];
    let t = this.head;
    for (; t !== null; )
      e2.push(t.value), t = t.next;
    return e2;
  }
  get length() {
    return this.lengthInNodes;
  }
  get size() {
    return this.sizeInBytes;
  }
  toOrderedArray() {
    return Array.from(this);
  }
  [Symbol.iterator]() {
    let e2 = this.head;
    return { next: () => {
      if (!e2)
        return { done: true, value: null };
      const t = e2.value;
      return e2 = e2.next, { done: false, value: t };
    } };
  }
};
var L = class {
  constructor(e2, t = l3) {
    this.level = e2 ?? "error", this.levelValue = import_pino.levels.values[this.level], this.MAX_LOG_SIZE_IN_BYTES = t, this.logs = new d(this.MAX_LOG_SIZE_IN_BYTES);
  }
  forwardToConsole(e2, t) {
    t === import_pino.levels.values.error ? console.error(e2) : t === import_pino.levels.values.warn ? console.warn(e2) : t === import_pino.levels.values.debug ? console.debug(e2) : t === import_pino.levels.values.trace ? console.trace(e2) : console.log(e2);
  }
  appendToLogs(e2) {
    this.logs.append(safeJsonStringify({ timestamp: (/* @__PURE__ */ new Date()).toISOString(), log: e2 }));
    const t = typeof e2 == "string" ? JSON.parse(e2).level : e2.level;
    t >= this.levelValue && this.forwardToConsole(e2, t);
  }
  getLogs() {
    return this.logs;
  }
  clearLogs() {
    this.logs = new d(this.MAX_LOG_SIZE_IN_BYTES);
  }
  getLogArray() {
    return Array.from(this.logs);
  }
  logsToBlob(e2) {
    const t = this.getLogArray();
    return t.push(safeJsonStringify({ extraMetadata: e2 })), new Blob(t, { type: "application/json" });
  }
};
var m = class {
  constructor(e2, t = l3) {
    this.baseChunkLogger = new L(e2, t);
  }
  write(e2) {
    this.baseChunkLogger.appendToLogs(e2);
  }
  getLogs() {
    return this.baseChunkLogger.getLogs();
  }
  clearLogs() {
    this.baseChunkLogger.clearLogs();
  }
  getLogArray() {
    return this.baseChunkLogger.getLogArray();
  }
  logsToBlob(e2) {
    return this.baseChunkLogger.logsToBlob(e2);
  }
  downloadLogsBlobInBrowser(e2) {
    const t = URL.createObjectURL(this.logsToBlob(e2)), o4 = document.createElement("a");
    o4.href = t, o4.download = `walletconnect-logs-${(/* @__PURE__ */ new Date()).toISOString()}.txt`, document.body.appendChild(o4), o4.click(), document.body.removeChild(o4), URL.revokeObjectURL(t);
  }
};
var B = class {
  constructor(e2, t = l3) {
    this.baseChunkLogger = new L(e2, t);
  }
  write(e2) {
    this.baseChunkLogger.appendToLogs(e2);
  }
  getLogs() {
    return this.baseChunkLogger.getLogs();
  }
  clearLogs() {
    this.baseChunkLogger.clearLogs();
  }
  getLogArray() {
    return this.baseChunkLogger.getLogArray();
  }
  logsToBlob(e2) {
    return this.baseChunkLogger.logsToBlob(e2);
  }
};
var x2 = Object.defineProperty;
var S = Object.defineProperties;
var _15 = Object.getOwnPropertyDescriptors;
var p = Object.getOwnPropertySymbols;
var T = Object.prototype.hasOwnProperty;
var z2 = Object.prototype.propertyIsEnumerable;
var f = (r3, e2, t) => e2 in r3 ? x2(r3, e2, { enumerable: true, configurable: true, writable: true, value: t }) : r3[e2] = t;
var i2 = (r3, e2) => {
  for (var t in e2 || (e2 = {}))
    T.call(e2, t) && f(r3, t, e2[t]);
  if (p)
    for (var t of p(e2))
      z2.call(e2, t) && f(r3, t, e2[t]);
  return r3;
};
var g = (r3, e2) => S(r3, _15(e2));
function k2(r3) {
  return g(i2({}, r3), { level: (r3 == null ? void 0 : r3.level) || c2.level });
}
function v(r3, e2 = n2) {
  return r3[e2] || "";
}
function b(r3, e2, t = n2) {
  return r3[t] = e2, r3;
}
function y2(r3, e2 = n2) {
  let t = "";
  return typeof r3.bindings > "u" ? t = v(r3, e2) : t = r3.bindings().context || "", t;
}
function w(r3, e2, t = n2) {
  const o4 = y2(r3, t);
  return o4.trim() ? `${o4}/${e2}` : e2;
}
function E2(r3, e2, t = n2) {
  const o4 = w(r3, e2, t), a3 = r3.child({ context: o4 });
  return b(a3, o4, t);
}
function C(r3) {
  var e2, t;
  const o4 = new m((e2 = r3.opts) == null ? void 0 : e2.level, r3.maxSizeInBytes);
  return { logger: (0, import_pino.default)(g(i2({}, r3.opts), { level: "trace", browser: g(i2({}, (t = r3.opts) == null ? void 0 : t.browser), { write: (a3) => o4.write(a3) }) })), chunkLoggerController: o4 };
}
function I(r3) {
  var e2;
  const t = new B((e2 = r3.opts) == null ? void 0 : e2.level, r3.maxSizeInBytes);
  return { logger: (0, import_pino.default)(g(i2({}, r3.opts), { level: "trace" }), t), chunkLoggerController: t };
}
function A(r3) {
  return typeof r3.loggerOverride < "u" && typeof r3.loggerOverride != "string" ? { logger: r3.loggerOverride, chunkLoggerController: null } : typeof window < "u" ? C(r3) : I(r3);
}

// ../../node_modules/.pnpm/@walletconnect+types@2.21.5/node_modules/@walletconnect/types/dist/index.es.js
var import_events4 = __toESM(require_events());
var a2 = Object.defineProperty;
var u = (e2, s3, r3) => s3 in e2 ? a2(e2, s3, { enumerable: true, configurable: true, writable: true, value: r3 }) : e2[s3] = r3;
var c3 = (e2, s3, r3) => u(e2, typeof s3 != "symbol" ? s3 + "" : s3, r3);
var h3 = class extends IEvents {
  constructor(s3) {
    super(), this.opts = s3, c3(this, "protocol", "wc"), c3(this, "version", 2);
  }
};
var p2 = Object.defineProperty;
var b2 = (e2, s3, r3) => s3 in e2 ? p2(e2, s3, { enumerable: true, configurable: true, writable: true, value: r3 }) : e2[s3] = r3;
var v2 = (e2, s3, r3) => b2(e2, typeof s3 != "symbol" ? s3 + "" : s3, r3);
var I2 = class extends IEvents {
  constructor(s3, r3) {
    super(), this.core = s3, this.logger = r3, v2(this, "records", /* @__PURE__ */ new Map());
  }
};
var y3 = class {
  constructor(s3, r3) {
    this.logger = s3, this.core = r3;
  }
};
var m2 = class extends IEvents {
  constructor(s3, r3) {
    super(), this.relayer = s3, this.logger = r3;
  }
};
var d2 = class extends IEvents {
  constructor(s3) {
    super();
  }
};
var f2 = class {
  constructor(s3, r3, t, q) {
    this.core = s3, this.logger = r3, this.name = t;
  }
};
var P = class extends IEvents {
  constructor(s3, r3) {
    super(), this.relayer = s3, this.logger = r3;
  }
};
var S2 = class extends IEvents {
  constructor(s3, r3) {
    super(), this.core = s3, this.logger = r3;
  }
};
var M = class {
  constructor(s3, r3, t) {
    this.core = s3, this.logger = r3, this.store = t;
  }
};
var O3 = class {
  constructor(s3, r3) {
    this.projectId = s3, this.logger = r3;
  }
};
var R = class {
  constructor(s3, r3, t) {
    this.core = s3, this.logger = r3, this.telemetryEnabled = t;
  }
};
var T2 = Object.defineProperty;
var k3 = (e2, s3, r3) => s3 in e2 ? T2(e2, s3, { enumerable: true, configurable: true, writable: true, value: r3 }) : e2[s3] = r3;
var i3 = (e2, s3, r3) => k3(e2, typeof s3 != "symbol" ? s3 + "" : s3, r3);
var J = class {
  constructor(s3) {
    this.opts = s3, i3(this, "protocol", "wc"), i3(this, "version", 2);
  }
};
var V = class {
  constructor(s3) {
    this.client = s3;
  }
};

// ../../node_modules/.pnpm/@walletconnect+core@2.21.5/node_modules/@walletconnect/core/dist/index.es.js
var import_time2 = __toESM(require_cjs2());

// ../../node_modules/.pnpm/@walletconnect+jsonrpc-provider@1.0.14/node_modules/@walletconnect/jsonrpc-provider/dist/index.es.js
var import_events5 = __toESM(require_events());

// ../../node_modules/.pnpm/@walletconnect+jsonrpc-utils@1.0.8/node_modules/@walletconnect/jsonrpc-utils/dist/esm/index.js
var esm_exports = {};
__export(esm_exports, {
  DEFAULT_ERROR: () => DEFAULT_ERROR,
  IBaseJsonRpcProvider: () => n4,
  IEvents: () => e,
  IJsonRpcConnection: () => o2,
  IJsonRpcProvider: () => r2,
  INTERNAL_ERROR: () => INTERNAL_ERROR,
  INVALID_PARAMS: () => INVALID_PARAMS,
  INVALID_REQUEST: () => INVALID_REQUEST,
  METHOD_NOT_FOUND: () => METHOD_NOT_FOUND,
  PARSE_ERROR: () => PARSE_ERROR,
  RESERVED_ERROR_CODES: () => RESERVED_ERROR_CODES,
  SERVER_ERROR: () => SERVER_ERROR,
  SERVER_ERROR_CODE_RANGE: () => SERVER_ERROR_CODE_RANGE,
  STANDARD_ERROR_MAP: () => STANDARD_ERROR_MAP,
  formatErrorMessage: () => formatErrorMessage,
  formatJsonRpcError: () => formatJsonRpcError,
  formatJsonRpcRequest: () => formatJsonRpcRequest,
  formatJsonRpcResult: () => formatJsonRpcResult,
  getBigIntRpcId: () => getBigIntRpcId,
  getError: () => getError,
  getErrorByCode: () => getErrorByCode,
  isHttpUrl: () => isHttpUrl,
  isJsonRpcError: () => isJsonRpcError,
  isJsonRpcPayload: () => isJsonRpcPayload,
  isJsonRpcRequest: () => isJsonRpcRequest,
  isJsonRpcResponse: () => isJsonRpcResponse,
  isJsonRpcResult: () => isJsonRpcResult,
  isJsonRpcValidationInvalid: () => isJsonRpcValidationInvalid,
  isLocalhostUrl: () => isLocalhostUrl,
  isNodeJs: () => isNodeJs,
  isReservedErrorCode: () => isReservedErrorCode,
  isServerErrorCode: () => isServerErrorCode,
  isValidDefaultRoute: () => isValidDefaultRoute,
  isValidErrorCode: () => isValidErrorCode,
  isValidLeadingWildcardRoute: () => isValidLeadingWildcardRoute,
  isValidRoute: () => isValidRoute,
  isValidTrailingWildcardRoute: () => isValidTrailingWildcardRoute,
  isValidWildcardRoute: () => isValidWildcardRoute,
  isWsUrl: () => isWsUrl,
  parseConnectionError: () => parseConnectionError,
  payloadId: () => payloadId,
  validateJsonRpcError: () => validateJsonRpcError
});

// ../../node_modules/.pnpm/@walletconnect+jsonrpc-utils@1.0.8/node_modules/@walletconnect/jsonrpc-utils/dist/esm/constants.js
var PARSE_ERROR = "PARSE_ERROR";
var INVALID_REQUEST = "INVALID_REQUEST";
var METHOD_NOT_FOUND = "METHOD_NOT_FOUND";
var INVALID_PARAMS = "INVALID_PARAMS";
var INTERNAL_ERROR = "INTERNAL_ERROR";
var SERVER_ERROR = "SERVER_ERROR";
var RESERVED_ERROR_CODES = [-32700, -32600, -32601, -32602, -32603];
var SERVER_ERROR_CODE_RANGE = [-32e3, -32099];
var STANDARD_ERROR_MAP = {
  [PARSE_ERROR]: { code: -32700, message: "Parse error" },
  [INVALID_REQUEST]: { code: -32600, message: "Invalid Request" },
  [METHOD_NOT_FOUND]: { code: -32601, message: "Method not found" },
  [INVALID_PARAMS]: { code: -32602, message: "Invalid params" },
  [INTERNAL_ERROR]: { code: -32603, message: "Internal error" },
  [SERVER_ERROR]: { code: -32e3, message: "Server error" }
};
var DEFAULT_ERROR = SERVER_ERROR;

// ../../node_modules/.pnpm/@walletconnect+jsonrpc-utils@1.0.8/node_modules/@walletconnect/jsonrpc-utils/dist/esm/error.js
function isServerErrorCode(code) {
  return code <= SERVER_ERROR_CODE_RANGE[0] && code >= SERVER_ERROR_CODE_RANGE[1];
}
function isReservedErrorCode(code) {
  return RESERVED_ERROR_CODES.includes(code);
}
function isValidErrorCode(code) {
  return typeof code === "number";
}
function getError(type) {
  if (!Object.keys(STANDARD_ERROR_MAP).includes(type)) {
    return STANDARD_ERROR_MAP[DEFAULT_ERROR];
  }
  return STANDARD_ERROR_MAP[type];
}
function getErrorByCode(code) {
  const match = Object.values(STANDARD_ERROR_MAP).find((e2) => e2.code === code);
  if (!match) {
    return STANDARD_ERROR_MAP[DEFAULT_ERROR];
  }
  return match;
}
function validateJsonRpcError(response) {
  if (typeof response.error.code === "undefined") {
    return { valid: false, error: "Missing code for JSON-RPC error" };
  }
  if (typeof response.error.message === "undefined") {
    return { valid: false, error: "Missing message for JSON-RPC error" };
  }
  if (!isValidErrorCode(response.error.code)) {
    return {
      valid: false,
      error: `Invalid error code type for JSON-RPC: ${response.error.code}`
    };
  }
  if (isReservedErrorCode(response.error.code)) {
    const error = getErrorByCode(response.error.code);
    if (error.message !== STANDARD_ERROR_MAP[DEFAULT_ERROR].message && response.error.message === error.message) {
      return {
        valid: false,
        error: `Invalid error code message for JSON-RPC: ${response.error.code}`
      };
    }
  }
  return { valid: true };
}
function parseConnectionError(e2, url, type) {
  return e2.message.includes("getaddrinfo ENOTFOUND") || e2.message.includes("connect ECONNREFUSED") ? new Error(`Unavailable ${type} RPC url at ${url}`) : e2;
}

// ../../node_modules/.pnpm/@walletconnect+jsonrpc-utils@1.0.8/node_modules/@walletconnect/jsonrpc-utils/dist/esm/env.js
var env_exports = {};
__export(env_exports, {
  isNodeJs: () => isNodeJs
});
var import_environment = __toESM(require_cjs4());
__reExport(env_exports, __toESM(require_cjs4()));
var isNodeJs = import_environment.isNode;

// ../../node_modules/.pnpm/@walletconnect+jsonrpc-utils@1.0.8/node_modules/@walletconnect/jsonrpc-utils/dist/esm/index.js
__reExport(esm_exports, env_exports);

// ../../node_modules/.pnpm/@walletconnect+jsonrpc-utils@1.0.8/node_modules/@walletconnect/jsonrpc-utils/dist/esm/format.js
function payloadId(entropy = 3) {
  const date = Date.now() * Math.pow(10, entropy);
  const extra = Math.floor(Math.random() * Math.pow(10, entropy));
  return date + extra;
}
function getBigIntRpcId(entropy = 6) {
  return BigInt(payloadId(entropy));
}
function formatJsonRpcRequest(method, params, id) {
  return {
    id: id || payloadId(),
    jsonrpc: "2.0",
    method,
    params
  };
}
function formatJsonRpcResult(id, result) {
  return {
    id,
    jsonrpc: "2.0",
    result
  };
}
function formatJsonRpcError(id, error, data) {
  return {
    id,
    jsonrpc: "2.0",
    error: formatErrorMessage(error, data)
  };
}
function formatErrorMessage(error, data) {
  if (typeof error === "undefined") {
    return getError(INTERNAL_ERROR);
  }
  if (typeof error === "string") {
    error = Object.assign(Object.assign({}, getError(SERVER_ERROR)), { message: error });
  }
  if (typeof data !== "undefined") {
    error.data = data;
  }
  if (isReservedErrorCode(error.code)) {
    error = getErrorByCode(error.code);
  }
  return error;
}

// ../../node_modules/.pnpm/@walletconnect+jsonrpc-utils@1.0.8/node_modules/@walletconnect/jsonrpc-utils/dist/esm/routing.js
function isValidRoute(route) {
  if (route.includes("*")) {
    return isValidWildcardRoute(route);
  }
  if (/\W/g.test(route)) {
    return false;
  }
  return true;
}
function isValidDefaultRoute(route) {
  return route === "*";
}
function isValidWildcardRoute(route) {
  if (isValidDefaultRoute(route)) {
    return true;
  }
  if (!route.includes("*")) {
    return false;
  }
  if (route.split("*").length !== 2) {
    return false;
  }
  if (route.split("*").filter((x4) => x4.trim() === "").length !== 1) {
    return false;
  }
  return true;
}
function isValidLeadingWildcardRoute(route) {
  return !isValidDefaultRoute(route) && isValidWildcardRoute(route) && !route.split("*")[0].trim();
}
function isValidTrailingWildcardRoute(route) {
  return !isValidDefaultRoute(route) && isValidWildcardRoute(route) && !route.split("*")[1].trim();
}

// ../../node_modules/.pnpm/@walletconnect+jsonrpc-types@1.0.4/node_modules/@walletconnect/jsonrpc-types/dist/index.es.js
var e = class {
};
var o2 = class extends e {
  constructor(c6) {
    super();
  }
};
var n4 = class extends e {
  constructor() {
    super();
  }
};
var r2 = class extends n4 {
  constructor(c6) {
    super();
  }
};

// ../../node_modules/.pnpm/@walletconnect+jsonrpc-utils@1.0.8/node_modules/@walletconnect/jsonrpc-utils/dist/esm/url.js
var HTTP_REGEX = "^https?:";
var WS_REGEX = "^wss?:";
function getUrlProtocol(url) {
  const matches = url.match(new RegExp(/^\w+:/, "gi"));
  if (!matches || !matches.length)
    return;
  return matches[0];
}
function matchRegexProtocol(url, regex) {
  const protocol = getUrlProtocol(url);
  if (typeof protocol === "undefined")
    return false;
  return new RegExp(regex).test(protocol);
}
function isHttpUrl(url) {
  return matchRegexProtocol(url, HTTP_REGEX);
}
function isWsUrl(url) {
  return matchRegexProtocol(url, WS_REGEX);
}
function isLocalhostUrl(url) {
  return new RegExp("wss?://localhost(:d{2,5})?").test(url);
}

// ../../node_modules/.pnpm/@walletconnect+jsonrpc-utils@1.0.8/node_modules/@walletconnect/jsonrpc-utils/dist/esm/validators.js
function isJsonRpcPayload(payload) {
  return typeof payload === "object" && "id" in payload && "jsonrpc" in payload && payload.jsonrpc === "2.0";
}
function isJsonRpcRequest(payload) {
  return isJsonRpcPayload(payload) && "method" in payload;
}
function isJsonRpcResponse(payload) {
  return isJsonRpcPayload(payload) && (isJsonRpcResult(payload) || isJsonRpcError(payload));
}
function isJsonRpcResult(payload) {
  return "result" in payload;
}
function isJsonRpcError(payload) {
  return "error" in payload;
}
function isJsonRpcValidationInvalid(validation) {
  return "error" in validation && validation.valid === false;
}

// ../../node_modules/.pnpm/@walletconnect+jsonrpc-provider@1.0.14/node_modules/@walletconnect/jsonrpc-provider/dist/index.es.js
var o3 = class extends r2 {
  constructor(t) {
    super(t), this.events = new import_events5.EventEmitter(), this.hasRegisteredEventListeners = false, this.connection = this.setConnection(t), this.connection.connected && this.registerEventListeners();
  }
  async connect(t = this.connection) {
    await this.open(t);
  }
  async disconnect() {
    await this.close();
  }
  on(t, e2) {
    this.events.on(t, e2);
  }
  once(t, e2) {
    this.events.once(t, e2);
  }
  off(t, e2) {
    this.events.off(t, e2);
  }
  removeListener(t, e2) {
    this.events.removeListener(t, e2);
  }
  async request(t, e2) {
    return this.requestStrict(formatJsonRpcRequest(t.method, t.params || [], t.id || getBigIntRpcId().toString()), e2);
  }
  async requestStrict(t, e2) {
    return new Promise(async (i4, s3) => {
      if (!this.connection.connected)
        try {
          await this.open();
        } catch (n5) {
          s3(n5);
        }
      this.events.on(`${t.id}`, (n5) => {
        isJsonRpcError(n5) ? s3(n5.error) : i4(n5.result);
      });
      try {
        await this.connection.send(t, e2);
      } catch (n5) {
        s3(n5);
      }
    });
  }
  setConnection(t = this.connection) {
    return t;
  }
  onPayload(t) {
    this.events.emit("payload", t), isJsonRpcResponse(t) ? this.events.emit(`${t.id}`, t) : this.events.emit("message", { type: t.method, data: t.params });
  }
  onClose(t) {
    t && t.code === 3e3 && this.events.emit("error", new Error(`WebSocket connection closed abnormally with code: ${t.code} ${t.reason ? `(${t.reason})` : ""}`)), this.events.emit("disconnect");
  }
  async open(t = this.connection) {
    this.connection === t && this.connection.connected || (this.connection.connected && this.close(), typeof t == "string" && (await this.connection.open(t), t = this.connection), this.connection = this.setConnection(t), await this.connection.open(), this.registerEventListeners(), this.events.emit("connect"));
  }
  async close() {
    await this.connection.close();
  }
  registerEventListeners() {
    this.hasRegisteredEventListeners || (this.connection.on("payload", (t) => this.onPayload(t)), this.connection.on("close", (t) => this.onClose(t)), this.connection.on("error", (t) => this.events.emit("error", t)), this.connection.on("register_error", (t) => this.onClose()), this.hasRegisteredEventListeners = true);
  }
};

// ../../node_modules/.pnpm/@walletconnect+jsonrpc-ws-connection@1.0.16/node_modules/@walletconnect/jsonrpc-ws-connection/dist/index.es.js
var import_events6 = __toESM(require_events());
var v3 = () => typeof WebSocket < "u" ? WebSocket : typeof global < "u" && typeof global.WebSocket < "u" ? global.WebSocket : typeof window < "u" && typeof window.WebSocket < "u" ? window.WebSocket : typeof self < "u" && typeof self.WebSocket < "u" ? self.WebSocket : require_browser5();
var w2 = () => typeof WebSocket < "u" || typeof global < "u" && typeof global.WebSocket < "u" || typeof window < "u" && typeof window.WebSocket < "u" || typeof self < "u" && typeof self.WebSocket < "u";
var d3 = (r3) => r3.split("?")[0];
var h4 = 10;
var b3 = v3();
var f3 = class {
  constructor(e2) {
    if (this.url = e2, this.events = new import_events6.EventEmitter(), this.registering = false, !isWsUrl(e2))
      throw new Error(`Provided URL is not compatible with WebSocket connection: ${e2}`);
    this.url = e2;
  }
  get connected() {
    return typeof this.socket < "u";
  }
  get connecting() {
    return this.registering;
  }
  on(e2, t) {
    this.events.on(e2, t);
  }
  once(e2, t) {
    this.events.once(e2, t);
  }
  off(e2, t) {
    this.events.off(e2, t);
  }
  removeListener(e2, t) {
    this.events.removeListener(e2, t);
  }
  async open(e2 = this.url) {
    await this.register(e2);
  }
  async close() {
    return new Promise((e2, t) => {
      if (typeof this.socket > "u") {
        t(new Error("Connection already closed"));
        return;
      }
      this.socket.onclose = (n5) => {
        this.onClose(n5), e2();
      }, this.socket.close();
    });
  }
  async send(e2) {
    typeof this.socket > "u" && (this.socket = await this.register());
    try {
      this.socket.send(safeJsonStringify(e2));
    } catch (t) {
      this.onError(e2.id, t);
    }
  }
  register(e2 = this.url) {
    if (!isWsUrl(e2))
      throw new Error(`Provided URL is not compatible with WebSocket connection: ${e2}`);
    if (this.registering) {
      const t = this.events.getMaxListeners();
      return (this.events.listenerCount("register_error") >= t || this.events.listenerCount("open") >= t) && this.events.setMaxListeners(t + 1), new Promise((n5, s3) => {
        this.events.once("register_error", (o4) => {
          this.resetMaxListeners(), s3(o4);
        }), this.events.once("open", () => {
          if (this.resetMaxListeners(), typeof this.socket > "u")
            return s3(new Error("WebSocket connection is missing or invalid"));
          n5(this.socket);
        });
      });
    }
    return this.url = e2, this.registering = true, new Promise((t, n5) => {
      const s3 = (0, esm_exports.isReactNative)() ? void 0 : { rejectUnauthorized: !isLocalhostUrl(e2) }, o4 = new b3(e2, [], s3);
      w2() ? o4.onerror = (i4) => {
        const a3 = i4;
        n5(this.emitError(a3.error));
      } : o4.on("error", (i4) => {
        n5(this.emitError(i4));
      }), o4.onopen = () => {
        this.onOpen(o4), t(o4);
      };
    });
  }
  onOpen(e2) {
    e2.onmessage = (t) => this.onPayload(t), e2.onclose = (t) => this.onClose(t), this.socket = e2, this.registering = false, this.events.emit("open");
  }
  onClose(e2) {
    this.socket = void 0, this.registering = false, this.events.emit("close", e2);
  }
  onPayload(e2) {
    if (typeof e2.data > "u")
      return;
    const t = typeof e2.data == "string" ? safeJsonParse(e2.data) : e2.data;
    this.events.emit("payload", t);
  }
  onError(e2, t) {
    const n5 = this.parseError(t), s3 = n5.message || n5.toString(), o4 = formatJsonRpcError(e2, s3);
    this.events.emit("payload", o4);
  }
  parseError(e2, t = this.url) {
    return parseConnectionError(e2, d3(t), "WS");
  }
  resetMaxListeners() {
    this.events.getMaxListeners() > h4 && this.events.setMaxListeners(h4);
  }
  emitError(e2) {
    const t = this.parseError(new Error((e2 == null ? void 0 : e2.message) || `WebSocket connection failed for host: ${d3(this.url)}`));
    return this.events.emit("register_error", t), t;
  }
};

// ../../node_modules/.pnpm/@walletconnect+core@2.21.5/node_modules/@walletconnect/core/dist/index.es.js
var import_window_getters = __toESM(require_cjs3());
var ze = "wc";
var Le = 2;
var he = "core";
var B2 = `${ze}@2:${he}:`;
var Et2 = { name: he, logger: "error" };
var It = { database: ":memory:" };
var Tt = "crypto";
var ke = "client_ed25519_seed";
var Ct = import_time2.ONE_DAY;
var Pt = "keychain";
var St = "0.3";
var Ot = "messages";
var Rt = "0.3";
var je = import_time2.SIX_HOURS;
var At = "publisher";
var xt = "irn";
var Nt = "error";
var Ue = "wss://relay.walletconnect.org";
var $t = "relayer";
var C2 = { message: "relayer_message", message_ack: "relayer_message_ack", connect: "relayer_connect", disconnect: "relayer_disconnect", error: "relayer_error", connection_stalled: "relayer_connection_stalled", transport_closed: "relayer_transport_closed", publish: "relayer_publish" };
var zt2 = "_subscription";
var L2 = { payload: "payload", connect: "connect", disconnect: "disconnect", error: "error" };
var Lt = 0.1;
var _e = "2.21.5";
var Q = { link_mode: "link_mode", relay: "relay" };
var le = { inbound: "inbound", outbound: "outbound" };
var kt2 = "0.3";
var jt = "WALLETCONNECT_CLIENT_ID";
var Fe2 = "WALLETCONNECT_LINK_MODE_APPS";
var $ = { created: "subscription_created", deleted: "subscription_deleted", expired: "subscription_expired", disabled: "subscription_disabled", sync: "subscription_sync", resubscribed: "subscription_resubscribed" };
var Ut = "subscription";
var Ft = "0.3";
var Js = import_time2.FIVE_SECONDS * 1e3;
var Mt = "pairing";
var Kt2 = "0.3";
var se = { wc_pairingDelete: { req: { ttl: import_time2.ONE_DAY, prompt: false, tag: 1e3 }, res: { ttl: import_time2.ONE_DAY, prompt: false, tag: 1001 } }, wc_pairingPing: { req: { ttl: import_time2.THIRTY_SECONDS, prompt: false, tag: 1002 }, res: { ttl: import_time2.THIRTY_SECONDS, prompt: false, tag: 1003 } }, unregistered_method: { req: { ttl: import_time2.ONE_DAY, prompt: false, tag: 0 }, res: { ttl: import_time2.ONE_DAY, prompt: false, tag: 0 } } };
var re = { create: "pairing_create", expire: "pairing_expire", delete: "pairing_delete", ping: "pairing_ping" };
var F = { created: "history_created", updated: "history_updated", deleted: "history_deleted", sync: "history_sync" };
var Bt2 = "history";
var Vt2 = "0.3";
var qt = "expirer";
var M2 = { created: "expirer_created", deleted: "expirer_deleted", expired: "expirer_expired", sync: "expirer_sync" };
var Gt = "0.3";
var Wt = "verify-api";
var Qs = "https://verify.walletconnect.com";
var Ht = "https://verify.walletconnect.org";
var ue = Ht;
var Yt = `${ue}/v3`;
var Jt = [Qs, Ht];
var Xt = "echo";
var Zt = "https://echo.walletconnect.com";
var G = { pairing_started: "pairing_started", pairing_uri_validation_success: "pairing_uri_validation_success", pairing_uri_not_expired: "pairing_uri_not_expired", store_new_pairing: "store_new_pairing", subscribing_pairing_topic: "subscribing_pairing_topic", subscribe_pairing_topic_success: "subscribe_pairing_topic_success", existing_pairing: "existing_pairing", pairing_not_expired: "pairing_not_expired", emit_inactive_pairing: "emit_inactive_pairing", emit_session_proposal: "emit_session_proposal", subscribing_to_pairing_topic: "subscribing_to_pairing_topic" };
var Y = { no_wss_connection: "no_wss_connection", no_internet_connection: "no_internet_connection", malformed_pairing_uri: "malformed_pairing_uri", active_pairing_already_exists: "active_pairing_already_exists", subscribe_pairing_topic_failure: "subscribe_pairing_topic_failure", pairing_expired: "pairing_expired", proposal_expired: "proposal_expired", proposal_listener_not_found: "proposal_listener_not_found" };
var tr = { session_approve_started: "session_approve_started", proposal_not_expired: "proposal_not_expired", session_namespaces_validation_success: "session_namespaces_validation_success", create_session_topic: "create_session_topic", subscribing_session_topic: "subscribing_session_topic", subscribe_session_topic_success: "subscribe_session_topic_success", publishing_session_approve: "publishing_session_approve", session_approve_publish_success: "session_approve_publish_success", store_session: "store_session", publishing_session_settle: "publishing_session_settle", session_settle_publish_success: "session_settle_publish_success" };
var ir = { no_internet_connection: "no_internet_connection", no_wss_connection: "no_wss_connection", proposal_expired: "proposal_expired", subscribe_session_topic_failure: "subscribe_session_topic_failure", session_approve_publish_failure: "session_approve_publish_failure", session_settle_publish_failure: "session_settle_publish_failure", session_approve_namespace_validation_failure: "session_approve_namespace_validation_failure", proposal_not_found: "proposal_not_found" };
var sr2 = { authenticated_session_approve_started: "authenticated_session_approve_started", authenticated_session_not_expired: "authenticated_session_not_expired", chains_caip2_compliant: "chains_caip2_compliant", chains_evm_compliant: "chains_evm_compliant", create_authenticated_session_topic: "create_authenticated_session_topic", cacaos_verified: "cacaos_verified", store_authenticated_session: "store_authenticated_session", subscribing_authenticated_session_topic: "subscribing_authenticated_session_topic", subscribe_authenticated_session_topic_success: "subscribe_authenticated_session_topic_success", publishing_authenticated_session_approve: "publishing_authenticated_session_approve", authenticated_session_approve_publish_success: "authenticated_session_approve_publish_success" };
var rr = { no_internet_connection: "no_internet_connection", no_wss_connection: "no_wss_connection", missing_session_authenticate_request: "missing_session_authenticate_request", session_authenticate_request_expired: "session_authenticate_request_expired", chains_caip2_compliant_failure: "chains_caip2_compliant_failure", chains_evm_compliant_failure: "chains_evm_compliant_failure", invalid_cacao: "invalid_cacao", subscribe_authenticated_session_topic_failure: "subscribe_authenticated_session_topic_failure", authenticated_session_approve_publish_failure: "authenticated_session_approve_publish_failure", authenticated_session_pending_request_not_found: "authenticated_session_pending_request_not_found" };
var Qt2 = 0.1;
var ei2 = "event-client";
var ti = 86400;
var ii2 = "https://pulse.walletconnect.org/batch";
function nr(r3, e2) {
  if (r3.length >= 255)
    throw new TypeError("Alphabet too long");
  for (var t = new Uint8Array(256), i4 = 0; i4 < t.length; i4++)
    t[i4] = 255;
  for (var s3 = 0; s3 < r3.length; s3++) {
    var n5 = r3.charAt(s3), o4 = n5.charCodeAt(0);
    if (t[o4] !== 255)
      throw new TypeError(n5 + " is ambiguous");
    t[o4] = s3;
  }
  var a3 = r3.length, c6 = r3.charAt(0), h5 = Math.log(a3) / Math.log(256), l6 = Math.log(256) / Math.log(a3);
  function d4(u2) {
    if (u2 instanceof Uint8Array || (ArrayBuffer.isView(u2) ? u2 = new Uint8Array(u2.buffer, u2.byteOffset, u2.byteLength) : Array.isArray(u2) && (u2 = Uint8Array.from(u2))), !(u2 instanceof Uint8Array))
      throw new TypeError("Expected Uint8Array");
    if (u2.length === 0)
      return "";
    for (var b4 = 0, x4 = 0, I4 = 0, D2 = u2.length; I4 !== D2 && u2[I4] === 0; )
      I4++, b4++;
    for (var j2 = (D2 - I4) * l6 + 1 >>> 0, T3 = new Uint8Array(j2); I4 !== D2; ) {
      for (var q = u2[I4], J2 = 0, K2 = j2 - 1; (q !== 0 || J2 < x4) && K2 !== -1; K2--, J2++)
        q += 256 * T3[K2] >>> 0, T3[K2] = q % a3 >>> 0, q = q / a3 >>> 0;
      if (q !== 0)
        throw new Error("Non-zero carry");
      x4 = J2, I4++;
    }
    for (var H = j2 - x4; H !== j2 && T3[H] === 0; )
      H++;
    for (var me3 = c6.repeat(b4); H < j2; ++H)
      me3 += r3.charAt(T3[H]);
    return me3;
  }
  function g3(u2) {
    if (typeof u2 != "string")
      throw new TypeError("Expected String");
    if (u2.length === 0)
      return new Uint8Array();
    var b4 = 0;
    if (u2[b4] !== " ") {
      for (var x4 = 0, I4 = 0; u2[b4] === c6; )
        x4++, b4++;
      for (var D2 = (u2.length - b4) * h5 + 1 >>> 0, j2 = new Uint8Array(D2); u2[b4]; ) {
        var T3 = t[u2.charCodeAt(b4)];
        if (T3 === 255)
          return;
        for (var q = 0, J2 = D2 - 1; (T3 !== 0 || q < I4) && J2 !== -1; J2--, q++)
          T3 += a3 * j2[J2] >>> 0, j2[J2] = T3 % 256 >>> 0, T3 = T3 / 256 >>> 0;
        if (T3 !== 0)
          throw new Error("Non-zero carry");
        I4 = q, b4++;
      }
      if (u2[b4] !== " ") {
        for (var K2 = D2 - I4; K2 !== D2 && j2[K2] === 0; )
          K2++;
        for (var H = new Uint8Array(x4 + (D2 - K2)), me3 = x4; K2 !== D2; )
          H[me3++] = j2[K2++];
        return H;
      }
    }
  }
  function _16(u2) {
    var b4 = g3(u2);
    if (b4)
      return b4;
    throw new Error(`Non-${e2} character`);
  }
  return { encode: d4, decodeUnsafe: g3, decode: _16 };
}
var or = nr;
var ar = or;
var si2 = (r3) => {
  if (r3 instanceof Uint8Array && r3.constructor.name === "Uint8Array")
    return r3;
  if (r3 instanceof ArrayBuffer)
    return new Uint8Array(r3);
  if (ArrayBuffer.isView(r3))
    return new Uint8Array(r3.buffer, r3.byteOffset, r3.byteLength);
  throw new Error("Unknown type, must be binary type");
};
var cr2 = (r3) => new TextEncoder().encode(r3);
var hr = (r3) => new TextDecoder().decode(r3);
var lr = class {
  constructor(e2, t, i4) {
    this.name = e2, this.prefix = t, this.baseEncode = i4;
  }
  encode(e2) {
    if (e2 instanceof Uint8Array)
      return `${this.prefix}${this.baseEncode(e2)}`;
    throw Error("Unknown type, must be binary type");
  }
};
var ur = class {
  constructor(e2, t, i4) {
    if (this.name = e2, this.prefix = t, t.codePointAt(0) === void 0)
      throw new Error("Invalid prefix character");
    this.prefixCodePoint = t.codePointAt(0), this.baseDecode = i4;
  }
  decode(e2) {
    if (typeof e2 == "string") {
      if (e2.codePointAt(0) !== this.prefixCodePoint)
        throw Error(`Unable to decode multibase string ${JSON.stringify(e2)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      return this.baseDecode(e2.slice(this.prefix.length));
    } else
      throw Error("Can only multibase decode strings");
  }
  or(e2) {
    return ri2(this, e2);
  }
};
var dr = class {
  constructor(e2) {
    this.decoders = e2;
  }
  or(e2) {
    return ri2(this, e2);
  }
  decode(e2) {
    const t = e2[0], i4 = this.decoders[t];
    if (i4)
      return i4.decode(e2);
    throw RangeError(`Unable to decode multibase string ${JSON.stringify(e2)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
  }
};
var ri2 = (r3, e2) => new dr({ ...r3.decoders || { [r3.prefix]: r3 }, ...e2.decoders || { [e2.prefix]: e2 } });
var gr = class {
  constructor(e2, t, i4, s3) {
    this.name = e2, this.prefix = t, this.baseEncode = i4, this.baseDecode = s3, this.encoder = new lr(e2, t, i4), this.decoder = new ur(e2, t, s3);
  }
  encode(e2) {
    return this.encoder.encode(e2);
  }
  decode(e2) {
    return this.decoder.decode(e2);
  }
};
var Ee = ({ name: r3, prefix: e2, encode: t, decode: i4 }) => new gr(r3, e2, t, i4);
var de = ({ prefix: r3, name: e2, alphabet: t }) => {
  const { encode: i4, decode: s3 } = ar(t, e2);
  return Ee({ prefix: r3, name: e2, encode: i4, decode: (n5) => si2(s3(n5)) });
};
var pr = (r3, e2, t, i4) => {
  const s3 = {};
  for (let l6 = 0; l6 < e2.length; ++l6)
    s3[e2[l6]] = l6;
  let n5 = r3.length;
  for (; r3[n5 - 1] === "="; )
    --n5;
  const o4 = new Uint8Array(n5 * t / 8 | 0);
  let a3 = 0, c6 = 0, h5 = 0;
  for (let l6 = 0; l6 < n5; ++l6) {
    const d4 = s3[r3[l6]];
    if (d4 === void 0)
      throw new SyntaxError(`Non-${i4} character`);
    c6 = c6 << t | d4, a3 += t, a3 >= 8 && (a3 -= 8, o4[h5++] = 255 & c6 >> a3);
  }
  if (a3 >= t || 255 & c6 << 8 - a3)
    throw new SyntaxError("Unexpected end of data");
  return o4;
};
var yr = (r3, e2, t) => {
  const i4 = e2[e2.length - 1] === "=", s3 = (1 << t) - 1;
  let n5 = "", o4 = 0, a3 = 0;
  for (let c6 = 0; c6 < r3.length; ++c6)
    for (a3 = a3 << 8 | r3[c6], o4 += 8; o4 > t; )
      o4 -= t, n5 += e2[s3 & a3 >> o4];
  if (o4 && (n5 += e2[s3 & a3 << t - o4]), i4)
    for (; n5.length * t & 7; )
      n5 += "=";
  return n5;
};
var P2 = ({ name: r3, prefix: e2, bitsPerChar: t, alphabet: i4 }) => Ee({ prefix: e2, name: r3, encode(s3) {
  return yr(s3, i4, t);
}, decode(s3) {
  return pr(s3, i4, t, r3);
} });
var br = Ee({ prefix: "\0", name: "identity", encode: (r3) => hr(r3), decode: (r3) => cr2(r3) });
var mr = Object.freeze({ __proto__: null, identity: br });
var fr = P2({ prefix: "0", name: "base2", alphabet: "01", bitsPerChar: 1 });
var Dr = Object.freeze({ __proto__: null, base2: fr });
var vr = P2({ prefix: "7", name: "base8", alphabet: "01234567", bitsPerChar: 3 });
var wr = Object.freeze({ __proto__: null, base8: vr });
var _r = de({ prefix: "9", name: "base10", alphabet: "0123456789" });
var Er = Object.freeze({ __proto__: null, base10: _r });
var Ir = P2({ prefix: "f", name: "base16", alphabet: "0123456789abcdef", bitsPerChar: 4 });
var Tr = P2({ prefix: "F", name: "base16upper", alphabet: "0123456789ABCDEF", bitsPerChar: 4 });
var Cr = Object.freeze({ __proto__: null, base16: Ir, base16upper: Tr });
var Pr = P2({ prefix: "b", name: "base32", alphabet: "abcdefghijklmnopqrstuvwxyz234567", bitsPerChar: 5 });
var Sr = P2({ prefix: "B", name: "base32upper", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567", bitsPerChar: 5 });
var Or = P2({ prefix: "c", name: "base32pad", alphabet: "abcdefghijklmnopqrstuvwxyz234567=", bitsPerChar: 5 });
var Rr = P2({ prefix: "C", name: "base32padupper", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=", bitsPerChar: 5 });
var Ar = P2({ prefix: "v", name: "base32hex", alphabet: "0123456789abcdefghijklmnopqrstuv", bitsPerChar: 5 });
var xr = P2({ prefix: "V", name: "base32hexupper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV", bitsPerChar: 5 });
var Nr = P2({ prefix: "t", name: "base32hexpad", alphabet: "0123456789abcdefghijklmnopqrstuv=", bitsPerChar: 5 });
var $r = P2({ prefix: "T", name: "base32hexpadupper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=", bitsPerChar: 5 });
var zr = P2({ prefix: "h", name: "base32z", alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769", bitsPerChar: 5 });
var Lr = Object.freeze({ __proto__: null, base32: Pr, base32upper: Sr, base32pad: Or, base32padupper: Rr, base32hex: Ar, base32hexupper: xr, base32hexpad: Nr, base32hexpadupper: $r, base32z: zr });
var kr = de({ prefix: "k", name: "base36", alphabet: "0123456789abcdefghijklmnopqrstuvwxyz" });
var jr = de({ prefix: "K", name: "base36upper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ" });
var Ur = Object.freeze({ __proto__: null, base36: kr, base36upper: jr });
var Fr = de({ name: "base58btc", prefix: "z", alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz" });
var Mr = de({ name: "base58flickr", prefix: "Z", alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ" });
var Kr = Object.freeze({ __proto__: null, base58btc: Fr, base58flickr: Mr });
var Br = P2({ prefix: "m", name: "base64", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", bitsPerChar: 6 });
var Vr2 = P2({ prefix: "M", name: "base64pad", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=", bitsPerChar: 6 });
var qr2 = P2({ prefix: "u", name: "base64url", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_", bitsPerChar: 6 });
var Gr = P2({ prefix: "U", name: "base64urlpad", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=", bitsPerChar: 6 });
var Wr = Object.freeze({ __proto__: null, base64: Br, base64pad: Vr2, base64url: qr2, base64urlpad: Gr });
var ni2 = Array.from("");
var Hr = ni2.reduce((r3, e2, t) => (r3[t] = e2, r3), []);
var Yr = ni2.reduce((r3, e2, t) => (r3[e2.codePointAt(0)] = t, r3), []);
function Jr(r3) {
  return r3.reduce((e2, t) => (e2 += Hr[t], e2), "");
}
function Xr(r3) {
  const e2 = [];
  for (const t of r3) {
    const i4 = Yr[t.codePointAt(0)];
    if (i4 === void 0)
      throw new Error(`Non-base256emoji character: ${t}`);
    e2.push(i4);
  }
  return new Uint8Array(e2);
}
var Zr = Ee({ prefix: "", name: "base256emoji", encode: Jr, decode: Xr });
var Qr = Object.freeze({ __proto__: null, base256emoji: Zr });
var en = ai2;
var oi2 = 128;
var tn = 127;
var sn2 = ~tn;
var rn = Math.pow(2, 31);
function ai2(r3, e2, t) {
  e2 = e2 || [], t = t || 0;
  for (var i4 = t; r3 >= rn; )
    e2[t++] = r3 & 255 | oi2, r3 /= 128;
  for (; r3 & sn2; )
    e2[t++] = r3 & 255 | oi2, r3 >>>= 7;
  return e2[t] = r3 | 0, ai2.bytes = t - i4 + 1, e2;
}
var nn = Me2;
var on = 128;
var ci2 = 127;
function Me2(r3, i4) {
  var t = 0, i4 = i4 || 0, s3 = 0, n5 = i4, o4, a3 = r3.length;
  do {
    if (n5 >= a3)
      throw Me2.bytes = 0, new RangeError("Could not decode varint");
    o4 = r3[n5++], t += s3 < 28 ? (o4 & ci2) << s3 : (o4 & ci2) * Math.pow(2, s3), s3 += 7;
  } while (o4 >= on);
  return Me2.bytes = n5 - i4, t;
}
var an = Math.pow(2, 7);
var cn = Math.pow(2, 14);
var hn = Math.pow(2, 21);
var ln = Math.pow(2, 28);
var un = Math.pow(2, 35);
var dn2 = Math.pow(2, 42);
var gn = Math.pow(2, 49);
var pn = Math.pow(2, 56);
var yn = Math.pow(2, 63);
var bn = function(r3) {
  return r3 < an ? 1 : r3 < cn ? 2 : r3 < hn ? 3 : r3 < ln ? 4 : r3 < un ? 5 : r3 < dn2 ? 6 : r3 < gn ? 7 : r3 < pn ? 8 : r3 < yn ? 9 : 10;
};
var mn = { encode: en, decode: nn, encodingLength: bn };
var hi2 = mn;
var li2 = (r3, e2, t = 0) => (hi2.encode(r3, e2, t), e2);
var ui2 = (r3) => hi2.encodingLength(r3);
var Ke = (r3, e2) => {
  const t = e2.byteLength, i4 = ui2(r3), s3 = i4 + ui2(t), n5 = new Uint8Array(s3 + t);
  return li2(r3, n5, 0), li2(t, n5, i4), n5.set(e2, s3), new fn(r3, t, e2, n5);
};
var fn = class {
  constructor(e2, t, i4, s3) {
    this.code = e2, this.size = t, this.digest = i4, this.bytes = s3;
  }
};
var di2 = ({ name: r3, code: e2, encode: t }) => new Dn(r3, e2, t);
var Dn = class {
  constructor(e2, t, i4) {
    this.name = e2, this.code = t, this.encode = i4;
  }
  digest(e2) {
    if (e2 instanceof Uint8Array) {
      const t = this.encode(e2);
      return t instanceof Uint8Array ? Ke(this.code, t) : t.then((i4) => Ke(this.code, i4));
    } else
      throw Error("Unknown type, must be binary type");
  }
};
var gi2 = (r3) => async (e2) => new Uint8Array(await crypto.subtle.digest(r3, e2));
var vn = di2({ name: "sha2-256", code: 18, encode: gi2("SHA-256") });
var wn = di2({ name: "sha2-512", code: 19, encode: gi2("SHA-512") });
var _n = Object.freeze({ __proto__: null, sha256: vn, sha512: wn });
var pi2 = 0;
var En = "identity";
var yi = si2;
var In = (r3) => Ke(pi2, yi(r3));
var Tn = { code: pi2, name: En, encode: yi, digest: In };
var Cn = Object.freeze({ __proto__: null, identity: Tn });
new TextEncoder(), new TextDecoder();
var bi = { ...mr, ...Dr, ...wr, ...Er, ...Cr, ...Lr, ...Ur, ...Kr, ...Wr, ...Qr };
({ ..._n, ...Cn });
function mi(r3) {
  return globalThis.Buffer != null ? new Uint8Array(r3.buffer, r3.byteOffset, r3.byteLength) : r3;
}
function Pn(r3 = 0) {
  return globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null ? mi(globalThis.Buffer.allocUnsafe(r3)) : new Uint8Array(r3);
}
function fi2(r3, e2, t, i4) {
  return { name: r3, prefix: e2, encoder: { name: r3, prefix: e2, encode: t }, decoder: { decode: i4 } };
}
var Di = fi2("utf8", "u", (r3) => "u" + new TextDecoder("utf8").decode(r3), (r3) => new TextEncoder().encode(r3.substring(1)));
var Be = fi2("ascii", "a", (r3) => {
  let e2 = "a";
  for (let t = 0; t < r3.length; t++)
    e2 += String.fromCharCode(r3[t]);
  return e2;
}, (r3) => {
  r3 = r3.substring(1);
  const e2 = Pn(r3.length);
  for (let t = 0; t < r3.length; t++)
    e2[t] = r3.charCodeAt(t);
  return e2;
});
var Sn = { utf8: Di, "utf-8": Di, hex: bi.base16, latin1: Be, ascii: Be, binary: Be, ...bi };
function On(r3, e2 = "utf8") {
  const t = Sn[e2];
  if (!t)
    throw new Error(`Unsupported encoding "${e2}"`);
  return (e2 === "utf8" || e2 === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null ? mi(globalThis.Buffer.from(r3, "utf-8")) : t.decoder.decode(`${t.prefix}${r3}`);
}
var Rn = Object.defineProperty;
var An = (r3, e2, t) => e2 in r3 ? Rn(r3, e2, { enumerable: true, configurable: true, writable: true, value: t }) : r3[e2] = t;
var W = (r3, e2, t) => An(r3, typeof e2 != "symbol" ? e2 + "" : e2, t);
var vi = class {
  constructor(e2, t) {
    this.core = e2, this.logger = t, W(this, "keychain", /* @__PURE__ */ new Map()), W(this, "name", Pt), W(this, "version", St), W(this, "initialized", false), W(this, "storagePrefix", B2), W(this, "init", async () => {
      if (!this.initialized) {
        const i4 = await this.getKeyChain();
        typeof i4 < "u" && (this.keychain = i4), this.initialized = true;
      }
    }), W(this, "has", (i4) => (this.isInitialized(), this.keychain.has(i4))), W(this, "set", async (i4, s3) => {
      this.isInitialized(), this.keychain.set(i4, s3), await this.persist();
    }), W(this, "get", (i4) => {
      this.isInitialized();
      const s3 = this.keychain.get(i4);
      if (typeof s3 > "u") {
        const { message: n5 } = Et("NO_MATCHING_KEY", `${this.name}: ${i4}`);
        throw new Error(n5);
      }
      return s3;
    }), W(this, "del", async (i4) => {
      this.isInitialized(), this.keychain.delete(i4), await this.persist();
    }), this.core = e2, this.logger = E2(t, this.name);
  }
  get context() {
    return y2(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  async setKeyChain(e2) {
    await this.core.storage.setItem(this.storageKey, Ys(e2));
  }
  async getKeyChain() {
    const e2 = await this.core.storage.getItem(this.storageKey);
    return typeof e2 < "u" ? Xs(e2) : void 0;
  }
  async persist() {
    await this.setKeyChain(this.keychain);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e2 } = Et("NOT_INITIALIZED", this.name);
      throw new Error(e2);
    }
  }
};
var xn = Object.defineProperty;
var Nn = (r3, e2, t) => e2 in r3 ? xn(r3, e2, { enumerable: true, configurable: true, writable: true, value: t }) : r3[e2] = t;
var S3 = (r3, e2, t) => Nn(r3, typeof e2 != "symbol" ? e2 + "" : e2, t);
var wi = class {
  constructor(e2, t, i4) {
    this.core = e2, this.logger = t, S3(this, "name", Tt), S3(this, "keychain"), S3(this, "randomSessionIdentifier", qc()), S3(this, "initialized", false), S3(this, "init", async () => {
      this.initialized || (await this.keychain.init(), this.initialized = true);
    }), S3(this, "hasKeys", (s3) => (this.isInitialized(), this.keychain.has(s3))), S3(this, "getClientId", async () => {
      this.isInitialized();
      const s3 = await this.getClientSeed(), n5 = Po(s3);
      return Qe(n5.publicKey);
    }), S3(this, "generateKeyPair", () => {
      this.isInitialized();
      const s3 = Vc();
      return this.setPrivateKey(s3.publicKey, s3.privateKey);
    }), S3(this, "signJWT", async (s3) => {
      this.isInitialized();
      const n5 = await this.getClientSeed(), o4 = Po(n5), a3 = this.randomSessionIdentifier, c6 = Ct;
      return await Qo(a3, s3, c6, o4);
    }), S3(this, "generateSharedKey", (s3, n5, o4) => {
      this.isInitialized();
      const a3 = this.getPrivateKey(s3), c6 = Kc(a3, n5);
      return this.setSymKey(c6, o4);
    }), S3(this, "setSymKey", async (s3, n5) => {
      this.isInitialized();
      const o4 = n5 || Fc(s3);
      return await this.keychain.set(o4, s3), o4;
    }), S3(this, "deleteKeyPair", async (s3) => {
      this.isInitialized(), await this.keychain.del(s3);
    }), S3(this, "deleteSymKey", async (s3) => {
      this.isInitialized(), await this.keychain.del(s3);
    }), S3(this, "encode", async (s3, n5, o4) => {
      this.isInitialized();
      const a3 = Ho(o4), c6 = safeJsonStringify(n5);
      if (Qc(a3))
        return Wc(c6, o4 == null ? void 0 : o4.encoding);
      if (Jc(a3)) {
        const g3 = a3.senderPublicKey, _16 = a3.receiverPublicKey;
        s3 = await this.generateSharedKey(g3, _16);
      }
      const h5 = this.getSymKey(s3), { type: l6, senderPublicKey: d4 } = a3;
      return Gc({ type: l6, symKey: h5, message: c6, senderPublicKey: d4, encoding: o4 == null ? void 0 : o4.encoding });
    }), S3(this, "decode", async (s3, n5, o4) => {
      this.isInitialized();
      const a3 = Xc(n5, o4);
      if (Qc(a3)) {
        const c6 = Yc(n5, o4 == null ? void 0 : o4.encoding);
        return safeJsonParse(c6);
      }
      if (Jc(a3)) {
        const c6 = a3.receiverPublicKey, h5 = a3.senderPublicKey;
        s3 = await this.generateSharedKey(c6, h5);
      }
      try {
        const c6 = this.getSymKey(s3), h5 = Zc({ symKey: c6, encoded: n5, encoding: o4 == null ? void 0 : o4.encoding });
        return safeJsonParse(h5);
      } catch (c6) {
        this.logger.error(`Failed to decode message from topic: '${s3}', clientId: '${await this.getClientId()}'`), this.logger.error(c6);
      }
    }), S3(this, "getPayloadType", (s3, n5 = Qt) => {
      const o4 = Me({ encoded: s3, encoding: n5 });
      return Vt(o4.type);
    }), S3(this, "getPayloadSenderPublicKey", (s3, n5 = Qt) => {
      const o4 = Me({ encoded: s3, encoding: n5 });
      return o4.senderPublicKey ? toString(o4.senderPublicKey, tt) : void 0;
    }), this.core = e2, this.logger = E2(t, this.name), this.keychain = i4 || new vi(this.core, this.logger);
  }
  get context() {
    return y2(this.logger);
  }
  async setPrivateKey(e2, t) {
    return await this.keychain.set(e2, t), e2;
  }
  getPrivateKey(e2) {
    return this.keychain.get(e2);
  }
  async getClientSeed() {
    let e2 = "";
    try {
      e2 = this.keychain.get(ke);
    } catch {
      e2 = qc(), await this.keychain.set(ke, e2);
    }
    return On(e2, "base16");
  }
  getSymKey(e2) {
    return this.keychain.get(e2);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e2 } = Et("NOT_INITIALIZED", this.name);
      throw new Error(e2);
    }
  }
};
var $n = Object.defineProperty;
var zn = Object.defineProperties;
var Ln = Object.getOwnPropertyDescriptors;
var _i = Object.getOwnPropertySymbols;
var kn = Object.prototype.hasOwnProperty;
var jn = Object.prototype.propertyIsEnumerable;
var Ve2 = (r3, e2, t) => e2 in r3 ? $n(r3, e2, { enumerable: true, configurable: true, writable: true, value: t }) : r3[e2] = t;
var Un = (r3, e2) => {
  for (var t in e2 || (e2 = {}))
    kn.call(e2, t) && Ve2(r3, t, e2[t]);
  if (_i)
    for (var t of _i(e2))
      jn.call(e2, t) && Ve2(r3, t, e2[t]);
  return r3;
};
var Fn = (r3, e2) => zn(r3, Ln(e2));
var k4 = (r3, e2, t) => Ve2(r3, typeof e2 != "symbol" ? e2 + "" : e2, t);
var Ei = class extends y3 {
  constructor(e2, t) {
    super(e2, t), this.logger = e2, this.core = t, k4(this, "messages", /* @__PURE__ */ new Map()), k4(this, "messagesWithoutClientAck", /* @__PURE__ */ new Map()), k4(this, "name", Ot), k4(this, "version", Rt), k4(this, "initialized", false), k4(this, "storagePrefix", B2), k4(this, "init", async () => {
      if (!this.initialized) {
        this.logger.trace("Initialized");
        try {
          const i4 = await this.getRelayerMessages();
          typeof i4 < "u" && (this.messages = i4);
          const s3 = await this.getRelayerMessagesWithoutClientAck();
          typeof s3 < "u" && (this.messagesWithoutClientAck = s3), this.logger.debug(`Successfully Restored records for ${this.name}`), this.logger.trace({ type: "method", method: "restore", size: this.messages.size });
        } catch (i4) {
          this.logger.debug(`Failed to Restore records for ${this.name}`), this.logger.error(i4);
        } finally {
          this.initialized = true;
        }
      }
    }), k4(this, "set", async (i4, s3, n5) => {
      this.isInitialized();
      const o4 = zc(s3);
      let a3 = this.messages.get(i4);
      if (typeof a3 > "u" && (a3 = {}), typeof a3[o4] < "u")
        return o4;
      if (a3[o4] = s3, this.messages.set(i4, a3), n5 === le.inbound) {
        const c6 = this.messagesWithoutClientAck.get(i4) || {};
        this.messagesWithoutClientAck.set(i4, Fn(Un({}, c6), { [o4]: s3 }));
      }
      return await this.persist(), o4;
    }), k4(this, "get", (i4) => {
      this.isInitialized();
      let s3 = this.messages.get(i4);
      return typeof s3 > "u" && (s3 = {}), s3;
    }), k4(this, "getWithoutAck", (i4) => {
      this.isInitialized();
      const s3 = {};
      for (const n5 of i4) {
        const o4 = this.messagesWithoutClientAck.get(n5) || {};
        s3[n5] = Object.values(o4);
      }
      return s3;
    }), k4(this, "has", (i4, s3) => {
      this.isInitialized();
      const n5 = this.get(i4), o4 = zc(s3);
      return typeof n5[o4] < "u";
    }), k4(this, "ack", async (i4, s3) => {
      this.isInitialized();
      const n5 = this.messagesWithoutClientAck.get(i4);
      if (typeof n5 > "u")
        return;
      const o4 = zc(s3);
      delete n5[o4], Object.keys(n5).length === 0 ? this.messagesWithoutClientAck.delete(i4) : this.messagesWithoutClientAck.set(i4, n5), await this.persist();
    }), k4(this, "del", async (i4) => {
      this.isInitialized(), this.messages.delete(i4), this.messagesWithoutClientAck.delete(i4), await this.persist();
    }), this.logger = E2(e2, this.name), this.core = t;
  }
  get context() {
    return y2(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  get storageKeyWithoutClientAck() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name + "_withoutClientAck";
  }
  async setRelayerMessages(e2) {
    await this.core.storage.setItem(this.storageKey, Ys(e2));
  }
  async setRelayerMessagesWithoutClientAck(e2) {
    await this.core.storage.setItem(this.storageKeyWithoutClientAck, Ys(e2));
  }
  async getRelayerMessages() {
    const e2 = await this.core.storage.getItem(this.storageKey);
    return typeof e2 < "u" ? Xs(e2) : void 0;
  }
  async getRelayerMessagesWithoutClientAck() {
    const e2 = await this.core.storage.getItem(this.storageKeyWithoutClientAck);
    return typeof e2 < "u" ? Xs(e2) : void 0;
  }
  async persist() {
    await this.setRelayerMessages(this.messages), await this.setRelayerMessagesWithoutClientAck(this.messagesWithoutClientAck);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e2 } = Et("NOT_INITIALIZED", this.name);
      throw new Error(e2);
    }
  }
};
var Mn = Object.defineProperty;
var Kn = Object.defineProperties;
var Bn = Object.getOwnPropertyDescriptors;
var Ii = Object.getOwnPropertySymbols;
var Vn = Object.prototype.hasOwnProperty;
var qn = Object.prototype.propertyIsEnumerable;
var qe = (r3, e2, t) => e2 in r3 ? Mn(r3, e2, { enumerable: true, configurable: true, writable: true, value: t }) : r3[e2] = t;
var Ie = (r3, e2) => {
  for (var t in e2 || (e2 = {}))
    Vn.call(e2, t) && qe(r3, t, e2[t]);
  if (Ii)
    for (var t of Ii(e2))
      qn.call(e2, t) && qe(r3, t, e2[t]);
  return r3;
};
var Ge = (r3, e2) => Kn(r3, Bn(e2));
var V2 = (r3, e2, t) => qe(r3, typeof e2 != "symbol" ? e2 + "" : e2, t);
var Gn = class extends m2 {
  constructor(e2, t) {
    super(e2, t), this.relayer = e2, this.logger = t, V2(this, "events", new import_events7.EventEmitter()), V2(this, "name", At), V2(this, "queue", /* @__PURE__ */ new Map()), V2(this, "publishTimeout", (0, import_time2.toMiliseconds)(import_time2.ONE_MINUTE)), V2(this, "initialPublishTimeout", (0, import_time2.toMiliseconds)(import_time2.ONE_SECOND * 15)), V2(this, "needsTransportRestart", false), V2(this, "publish", async (i4, s3, n5) => {
      var o4;
      this.logger.debug("Publishing Payload"), this.logger.trace({ type: "method", method: "publish", params: { topic: i4, message: s3, opts: n5 } });
      const a3 = (n5 == null ? void 0 : n5.ttl) || je, c6 = ea(n5), h5 = (n5 == null ? void 0 : n5.prompt) || false, l6 = (n5 == null ? void 0 : n5.tag) || 0, d4 = (n5 == null ? void 0 : n5.id) || getBigIntRpcId().toString(), g3 = { topic: i4, message: s3, opts: { ttl: a3, relay: c6, prompt: h5, tag: l6, id: d4, attestation: n5 == null ? void 0 : n5.attestation, tvf: n5 == null ? void 0 : n5.tvf } }, _16 = `Failed to publish payload, please try again. id:${d4} tag:${l6}`;
      try {
        const u2 = new Promise(async (b4) => {
          const x4 = ({ id: D2 }) => {
            g3.opts.id === D2 && (this.removeRequestFromQueue(D2), this.relayer.events.removeListener(C2.publish, x4), b4(g3));
          };
          this.relayer.events.on(C2.publish, x4);
          const I4 = ni(new Promise((D2, j2) => {
            this.rpcPublish({ topic: i4, message: s3, ttl: a3, prompt: h5, tag: l6, id: d4, attestation: n5 == null ? void 0 : n5.attestation, tvf: n5 == null ? void 0 : n5.tvf }).then(D2).catch((T3) => {
              this.logger.warn(T3, T3 == null ? void 0 : T3.message), j2(T3);
            });
          }), this.initialPublishTimeout, `Failed initial publish, retrying.... id:${d4} tag:${l6}`);
          try {
            await I4, this.events.removeListener(C2.publish, x4);
          } catch (D2) {
            this.queue.set(d4, Ge(Ie({}, g3), { attempt: 1 })), this.logger.warn(D2, D2 == null ? void 0 : D2.message);
          }
        });
        this.logger.trace({ type: "method", method: "publish", params: { id: d4, topic: i4, message: s3, opts: n5 } }), await ni(u2, this.publishTimeout, _16);
      } catch (u2) {
        if (this.logger.debug("Failed to Publish Payload"), this.logger.error(u2), (o4 = n5 == null ? void 0 : n5.internal) != null && o4.throwOnFailedPublish)
          throw u2;
      } finally {
        this.queue.delete(d4);
      }
    }), V2(this, "on", (i4, s3) => {
      this.events.on(i4, s3);
    }), V2(this, "once", (i4, s3) => {
      this.events.once(i4, s3);
    }), V2(this, "off", (i4, s3) => {
      this.events.off(i4, s3);
    }), V2(this, "removeListener", (i4, s3) => {
      this.events.removeListener(i4, s3);
    }), this.relayer = e2, this.logger = E2(t, this.name), this.registerEventListeners();
  }
  get context() {
    return y2(this.logger);
  }
  async rpcPublish(e2) {
    var t, i4, s3, n5;
    const { topic: o4, message: a3, ttl: c6 = je, prompt: h5, tag: l6, id: d4, attestation: g3, tvf: _16 } = e2, u2 = { method: na(ea().protocol).publish, params: Ie({ topic: o4, message: a3, ttl: c6, prompt: h5, tag: l6, attestation: g3 }, _16), id: d4 };
    kt((t = u2.params) == null ? void 0 : t.prompt) && ((i4 = u2.params) == null || delete i4.prompt), kt((s3 = u2.params) == null ? void 0 : s3.tag) && ((n5 = u2.params) == null || delete n5.tag), this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "message", direction: "outgoing", request: u2 });
    const b4 = await this.relayer.request(u2);
    return this.relayer.events.emit(C2.publish, e2), this.logger.debug("Successfully Published Payload"), b4;
  }
  removeRequestFromQueue(e2) {
    this.queue.delete(e2);
  }
  checkQueue() {
    this.queue.forEach(async (e2, t) => {
      const i4 = e2.attempt + 1;
      this.queue.set(t, Ge(Ie({}, e2), { attempt: i4 }));
      const { topic: s3, message: n5, opts: o4, attestation: a3 } = e2;
      this.logger.warn({}, `Publisher: queue->publishing: ${e2.opts.id}, tag: ${e2.opts.tag}, attempt: ${i4}`), await this.rpcPublish(Ge(Ie({}, e2), { topic: s3, message: n5, ttl: o4.ttl, prompt: o4.prompt, tag: o4.tag, id: o4.id, attestation: a3, tvf: o4.tvf })), this.logger.warn({}, `Publisher: queue->published: ${e2.opts.id}`);
    });
  }
  registerEventListeners() {
    this.relayer.core.heartbeat.on(r.pulse, () => {
      if (this.needsTransportRestart) {
        this.needsTransportRestart = false, this.relayer.events.emit(C2.connection_stalled);
        return;
      }
      this.checkQueue();
    }), this.relayer.on(C2.message_ack, (e2) => {
      this.removeRequestFromQueue(e2.id.toString());
    });
  }
};
var Wn = Object.defineProperty;
var Hn = (r3, e2, t) => e2 in r3 ? Wn(r3, e2, { enumerable: true, configurable: true, writable: true, value: t }) : r3[e2] = t;
var ne = (r3, e2, t) => Hn(r3, typeof e2 != "symbol" ? e2 + "" : e2, t);
var Yn = class {
  constructor() {
    ne(this, "map", /* @__PURE__ */ new Map()), ne(this, "set", (e2, t) => {
      const i4 = this.get(e2);
      this.exists(e2, t) || this.map.set(e2, [...i4, t]);
    }), ne(this, "get", (e2) => this.map.get(e2) || []), ne(this, "exists", (e2, t) => this.get(e2).includes(t)), ne(this, "delete", (e2, t) => {
      if (typeof t > "u") {
        this.map.delete(e2);
        return;
      }
      if (!this.map.has(e2))
        return;
      const i4 = this.get(e2);
      if (!this.exists(e2, t))
        return;
      const s3 = i4.filter((n5) => n5 !== t);
      if (!s3.length) {
        this.map.delete(e2);
        return;
      }
      this.map.set(e2, s3);
    }), ne(this, "clear", () => {
      this.map.clear();
    });
  }
  get topics() {
    return Array.from(this.map.keys());
  }
};
var Jn = Object.defineProperty;
var Xn = Object.defineProperties;
var Zn = Object.getOwnPropertyDescriptors;
var Ti = Object.getOwnPropertySymbols;
var Qn = Object.prototype.hasOwnProperty;
var eo = Object.prototype.propertyIsEnumerable;
var We = (r3, e2, t) => e2 in r3 ? Jn(r3, e2, { enumerable: true, configurable: true, writable: true, value: t }) : r3[e2] = t;
var ge2 = (r3, e2) => {
  for (var t in e2 || (e2 = {}))
    Qn.call(e2, t) && We(r3, t, e2[t]);
  if (Ti)
    for (var t of Ti(e2))
      eo.call(e2, t) && We(r3, t, e2[t]);
  return r3;
};
var He = (r3, e2) => Xn(r3, Zn(e2));
var f4 = (r3, e2, t) => We(r3, typeof e2 != "symbol" ? e2 + "" : e2, t);
var Ci = class extends P {
  constructor(e2, t) {
    super(e2, t), this.relayer = e2, this.logger = t, f4(this, "subscriptions", /* @__PURE__ */ new Map()), f4(this, "topicMap", new Yn()), f4(this, "events", new import_events7.EventEmitter()), f4(this, "name", Ut), f4(this, "version", Ft), f4(this, "pending", /* @__PURE__ */ new Map()), f4(this, "cached", []), f4(this, "initialized", false), f4(this, "storagePrefix", B2), f4(this, "subscribeTimeout", (0, import_time2.toMiliseconds)(import_time2.ONE_MINUTE)), f4(this, "initialSubscribeTimeout", (0, import_time2.toMiliseconds)(import_time2.ONE_SECOND * 15)), f4(this, "clientId"), f4(this, "batchSubscribeTopicsLimit", 500), f4(this, "init", async () => {
      this.initialized || (this.logger.trace("Initialized"), this.registerEventListeners(), await this.restore()), this.initialized = true;
    }), f4(this, "subscribe", async (i4, s3) => {
      this.isInitialized(), this.logger.debug("Subscribing Topic"), this.logger.trace({ type: "method", method: "subscribe", params: { topic: i4, opts: s3 } });
      try {
        const n5 = ea(s3), o4 = { topic: i4, relay: n5, transportType: s3 == null ? void 0 : s3.transportType };
        this.pending.set(i4, o4);
        const a3 = await this.rpcSubscribe(i4, n5, s3);
        return typeof a3 == "string" && (this.onSubscribe(a3, o4), this.logger.debug("Successfully Subscribed Topic"), this.logger.trace({ type: "method", method: "subscribe", params: { topic: i4, opts: s3 } })), a3;
      } catch (n5) {
        throw this.logger.debug("Failed to Subscribe Topic"), this.logger.error(n5), n5;
      }
    }), f4(this, "unsubscribe", async (i4, s3) => {
      this.isInitialized(), typeof (s3 == null ? void 0 : s3.id) < "u" ? await this.unsubscribeById(i4, s3.id, s3) : await this.unsubscribeByTopic(i4, s3);
    }), f4(this, "isSubscribed", (i4) => new Promise((s3) => {
      s3(this.topicMap.topics.includes(i4));
    })), f4(this, "isKnownTopic", (i4) => new Promise((s3) => {
      s3(this.topicMap.topics.includes(i4) || this.pending.has(i4) || this.cached.some((n5) => n5.topic === i4));
    })), f4(this, "on", (i4, s3) => {
      this.events.on(i4, s3);
    }), f4(this, "once", (i4, s3) => {
      this.events.once(i4, s3);
    }), f4(this, "off", (i4, s3) => {
      this.events.off(i4, s3);
    }), f4(this, "removeListener", (i4, s3) => {
      this.events.removeListener(i4, s3);
    }), f4(this, "start", async () => {
      await this.onConnect();
    }), f4(this, "stop", async () => {
      await this.onDisconnect();
    }), f4(this, "restart", async () => {
      await this.restore(), await this.onRestart();
    }), f4(this, "checkPending", async () => {
      if (this.pending.size === 0 && (!this.initialized || !this.relayer.connected))
        return;
      const i4 = [];
      this.pending.forEach((s3) => {
        i4.push(s3);
      }), await this.batchSubscribe(i4);
    }), f4(this, "registerEventListeners", () => {
      this.relayer.core.heartbeat.on(r.pulse, async () => {
        await this.checkPending();
      }), this.events.on($.created, async (i4) => {
        const s3 = $.created;
        this.logger.info(`Emitting ${s3}`), this.logger.debug({ type: "event", event: s3, data: i4 }), await this.persist();
      }), this.events.on($.deleted, async (i4) => {
        const s3 = $.deleted;
        this.logger.info(`Emitting ${s3}`), this.logger.debug({ type: "event", event: s3, data: i4 }), await this.persist();
      });
    }), this.relayer = e2, this.logger = E2(t, this.name), this.clientId = "";
  }
  get context() {
    return y2(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.relayer.core.customStoragePrefix + "//" + this.name;
  }
  get length() {
    return this.subscriptions.size;
  }
  get ids() {
    return Array.from(this.subscriptions.keys());
  }
  get values() {
    return Array.from(this.subscriptions.values());
  }
  get topics() {
    return this.topicMap.topics;
  }
  get hasAnyTopics() {
    return this.topicMap.topics.length > 0 || this.pending.size > 0 || this.cached.length > 0 || this.subscriptions.size > 0;
  }
  hasSubscription(e2, t) {
    let i4 = false;
    try {
      i4 = this.getSubscription(e2).topic === t;
    } catch {
    }
    return i4;
  }
  reset() {
    this.cached = [], this.initialized = true;
  }
  onDisable() {
    this.values.length > 0 && (this.cached = this.values), this.subscriptions.clear(), this.topicMap.clear();
  }
  async unsubscribeByTopic(e2, t) {
    const i4 = this.topicMap.get(e2);
    await Promise.all(i4.map(async (s3) => await this.unsubscribeById(e2, s3, t)));
  }
  async unsubscribeById(e2, t, i4) {
    this.logger.debug("Unsubscribing Topic"), this.logger.trace({ type: "method", method: "unsubscribe", params: { topic: e2, id: t, opts: i4 } });
    try {
      const s3 = ea(i4);
      await this.restartToComplete({ topic: e2, id: t, relay: s3 }), await this.rpcUnsubscribe(e2, t, s3);
      const n5 = Kt("USER_DISCONNECTED", `${this.name}, ${e2}`);
      await this.onUnsubscribe(e2, t, n5), this.logger.debug("Successfully Unsubscribed Topic"), this.logger.trace({ type: "method", method: "unsubscribe", params: { topic: e2, id: t, opts: i4 } });
    } catch (s3) {
      throw this.logger.debug("Failed to Unsubscribe Topic"), this.logger.error(s3), s3;
    }
  }
  async rpcSubscribe(e2, t, i4) {
    var s3;
    (!i4 || (i4 == null ? void 0 : i4.transportType) === Q.relay) && await this.restartToComplete({ topic: e2, id: e2, relay: t });
    const n5 = { method: na(t.protocol).subscribe, params: { topic: e2 } };
    this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "payload", direction: "outgoing", request: n5 });
    const o4 = (s3 = i4 == null ? void 0 : i4.internal) == null ? void 0 : s3.throwOnFailedPublish;
    try {
      const a3 = await this.getSubscriptionId(e2);
      if ((i4 == null ? void 0 : i4.transportType) === Q.link_mode)
        return setTimeout(() => {
          (this.relayer.connected || this.relayer.connecting) && this.relayer.request(n5).catch((l6) => this.logger.warn(l6));
        }, (0, import_time2.toMiliseconds)(import_time2.ONE_SECOND)), a3;
      const c6 = new Promise(async (l6) => {
        const d4 = (g3) => {
          g3.topic === e2 && (this.events.removeListener($.created, d4), l6(g3.id));
        };
        this.events.on($.created, d4);
        try {
          const g3 = await ni(new Promise((_16, u2) => {
            this.relayer.request(n5).catch((b4) => {
              this.logger.warn(b4, b4 == null ? void 0 : b4.message), u2(b4);
            }).then(_16);
          }), this.initialSubscribeTimeout, `Subscribing to ${e2} failed, please try again`);
          this.events.removeListener($.created, d4), l6(g3);
        } catch {
        }
      }), h5 = await ni(c6, this.subscribeTimeout, `Subscribing to ${e2} failed, please try again`);
      if (!h5 && o4)
        throw new Error(`Subscribing to ${e2} failed, please try again`);
      return h5 ? a3 : null;
    } catch (a3) {
      if (this.logger.debug("Outgoing Relay Subscribe Payload stalled"), this.relayer.events.emit(C2.connection_stalled), o4)
        throw a3;
    }
    return null;
  }
  async rpcBatchSubscribe(e2) {
    if (!e2.length)
      return;
    const t = e2[0].relay, i4 = { method: na(t.protocol).batchSubscribe, params: { topics: e2.map((s3) => s3.topic) } };
    this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "payload", direction: "outgoing", request: i4 });
    try {
      await await ni(new Promise((s3) => {
        this.relayer.request(i4).catch((n5) => this.logger.warn(n5)).then(s3);
      }), this.subscribeTimeout, "rpcBatchSubscribe failed, please try again");
    } catch {
      this.relayer.events.emit(C2.connection_stalled);
    }
  }
  async rpcBatchFetchMessages(e2) {
    if (!e2.length)
      return;
    const t = e2[0].relay, i4 = { method: na(t.protocol).batchFetchMessages, params: { topics: e2.map((n5) => n5.topic) } };
    this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "payload", direction: "outgoing", request: i4 });
    let s3;
    try {
      s3 = await await ni(new Promise((n5, o4) => {
        this.relayer.request(i4).catch((a3) => {
          this.logger.warn(a3), o4(a3);
        }).then(n5);
      }), this.subscribeTimeout, "rpcBatchFetchMessages failed, please try again");
    } catch {
      this.relayer.events.emit(C2.connection_stalled);
    }
    return s3;
  }
  rpcUnsubscribe(e2, t, i4) {
    const s3 = { method: na(i4.protocol).unsubscribe, params: { topic: e2, id: t } };
    return this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "payload", direction: "outgoing", request: s3 }), this.relayer.request(s3);
  }
  onSubscribe(e2, t) {
    this.setSubscription(e2, He(ge2({}, t), { id: e2 })), this.pending.delete(t.topic);
  }
  onBatchSubscribe(e2) {
    e2.length && e2.forEach((t) => {
      this.setSubscription(t.id, ge2({}, t)), this.pending.delete(t.topic);
    });
  }
  async onUnsubscribe(e2, t, i4) {
    this.events.removeAllListeners(t), this.hasSubscription(t, e2) && this.deleteSubscription(t, i4), await this.relayer.messages.del(e2);
  }
  async setRelayerSubscriptions(e2) {
    await this.relayer.core.storage.setItem(this.storageKey, e2);
  }
  async getRelayerSubscriptions() {
    return await this.relayer.core.storage.getItem(this.storageKey);
  }
  setSubscription(e2, t) {
    this.logger.debug("Setting subscription"), this.logger.trace({ type: "method", method: "setSubscription", id: e2, subscription: t }), this.addSubscription(e2, t);
  }
  addSubscription(e2, t) {
    this.subscriptions.set(e2, ge2({}, t)), this.topicMap.set(t.topic, e2), this.events.emit($.created, t);
  }
  getSubscription(e2) {
    this.logger.debug("Getting subscription"), this.logger.trace({ type: "method", method: "getSubscription", id: e2 });
    const t = this.subscriptions.get(e2);
    if (!t) {
      const { message: i4 } = Et("NO_MATCHING_KEY", `${this.name}: ${e2}`);
      throw new Error(i4);
    }
    return t;
  }
  deleteSubscription(e2, t) {
    this.logger.debug("Deleting subscription"), this.logger.trace({ type: "method", method: "deleteSubscription", id: e2, reason: t });
    const i4 = this.getSubscription(e2);
    this.subscriptions.delete(e2), this.topicMap.delete(i4.topic, e2), this.events.emit($.deleted, He(ge2({}, i4), { reason: t }));
  }
  async persist() {
    await this.setRelayerSubscriptions(this.values), this.events.emit($.sync);
  }
  async onRestart() {
    if (this.cached.length) {
      const e2 = [...this.cached], t = Math.ceil(this.cached.length / this.batchSubscribeTopicsLimit);
      for (let i4 = 0; i4 < t; i4++) {
        const s3 = e2.splice(0, this.batchSubscribeTopicsLimit);
        await this.batchSubscribe(s3);
      }
    }
    this.events.emit($.resubscribed);
  }
  async restore() {
    try {
      const e2 = await this.getRelayerSubscriptions();
      if (typeof e2 > "u" || !e2.length)
        return;
      if (this.subscriptions.size) {
        const { message: t } = Et("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(t), this.logger.error(`${this.name}: ${JSON.stringify(this.values)}`), new Error(t);
      }
      this.cached = e2, this.logger.debug(`Successfully Restored subscriptions for ${this.name}`), this.logger.trace({ type: "method", method: "restore", subscriptions: this.values });
    } catch (e2) {
      this.logger.debug(`Failed to Restore subscriptions for ${this.name}`), this.logger.error(e2);
    }
  }
  async batchSubscribe(e2) {
    e2.length && (await this.rpcBatchSubscribe(e2), this.onBatchSubscribe(await Promise.all(e2.map(async (t) => He(ge2({}, t), { id: await this.getSubscriptionId(t.topic) })))));
  }
  async batchFetchMessages(e2) {
    if (!e2.length)
      return;
    this.logger.trace(`Fetching batch messages for ${e2.length} subscriptions`);
    const t = await this.rpcBatchFetchMessages(e2);
    t && t.messages && (await pi((0, import_time2.toMiliseconds)(import_time2.ONE_SECOND)), await this.relayer.handleBatchMessageEvents(t.messages));
  }
  async onConnect() {
    await this.restart(), this.reset();
  }
  onDisconnect() {
    this.onDisable();
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e2 } = Et("NOT_INITIALIZED", this.name);
      throw new Error(e2);
    }
  }
  async restartToComplete(e2) {
    !this.relayer.connected && !this.relayer.connecting && (this.cached.push(e2), await this.relayer.transportOpen());
  }
  async getClientId() {
    return this.clientId || (this.clientId = await this.relayer.core.crypto.getClientId()), this.clientId;
  }
  async getSubscriptionId(e2) {
    return zc(e2 + await this.getClientId());
  }
};
var to = Object.defineProperty;
var Pi = Object.getOwnPropertySymbols;
var io = Object.prototype.hasOwnProperty;
var so = Object.prototype.propertyIsEnumerable;
var Ye2 = (r3, e2, t) => e2 in r3 ? to(r3, e2, { enumerable: true, configurable: true, writable: true, value: t }) : r3[e2] = t;
var Si = (r3, e2) => {
  for (var t in e2 || (e2 = {}))
    io.call(e2, t) && Ye2(r3, t, e2[t]);
  if (Pi)
    for (var t of Pi(e2))
      so.call(e2, t) && Ye2(r3, t, e2[t]);
  return r3;
};
var y4 = (r3, e2, t) => Ye2(r3, typeof e2 != "symbol" ? e2 + "" : e2, t);
var Oi = class extends d2 {
  constructor(e2) {
    super(e2), y4(this, "protocol", "wc"), y4(this, "version", 2), y4(this, "core"), y4(this, "logger"), y4(this, "events", new import_events7.EventEmitter()), y4(this, "provider"), y4(this, "messages"), y4(this, "subscriber"), y4(this, "publisher"), y4(this, "name", $t), y4(this, "transportExplicitlyClosed", false), y4(this, "initialized", false), y4(this, "connectionAttemptInProgress", false), y4(this, "relayUrl"), y4(this, "projectId"), y4(this, "packageName"), y4(this, "bundleId"), y4(this, "hasExperiencedNetworkDisruption", false), y4(this, "pingTimeout"), y4(this, "heartBeatTimeout", (0, import_time2.toMiliseconds)(import_time2.THIRTY_SECONDS + import_time2.FIVE_SECONDS)), y4(this, "reconnectTimeout"), y4(this, "connectPromise"), y4(this, "reconnectInProgress", false), y4(this, "requestsInFlight", []), y4(this, "connectTimeout", (0, import_time2.toMiliseconds)(import_time2.ONE_SECOND * 15)), y4(this, "request", async (t) => {
      var i4, s3;
      this.logger.debug("Publishing Request Payload");
      const n5 = t.id || getBigIntRpcId().toString();
      await this.toEstablishConnection();
      try {
        this.logger.trace({ id: n5, method: t.method, topic: (i4 = t.params) == null ? void 0 : i4.topic }, "relayer.request - publishing...");
        const o4 = `${n5}:${((s3 = t.params) == null ? void 0 : s3.tag) || ""}`;
        this.requestsInFlight.push(o4);
        const a3 = await this.provider.request(t);
        return this.requestsInFlight = this.requestsInFlight.filter((c6) => c6 !== o4), a3;
      } catch (o4) {
        throw this.logger.debug(`Failed to Publish Request: ${n5}`), o4;
      }
    }), y4(this, "resetPingTimeout", () => {
      Ye() && (clearTimeout(this.pingTimeout), this.pingTimeout = setTimeout(() => {
        var t, i4, s3, n5;
        try {
          this.logger.debug({}, "pingTimeout: Connection stalled, terminating..."), (n5 = (s3 = (i4 = (t = this.provider) == null ? void 0 : t.connection) == null ? void 0 : i4.socket) == null ? void 0 : s3.terminate) == null || n5.call(s3);
        } catch (o4) {
          this.logger.warn(o4, o4 == null ? void 0 : o4.message);
        }
      }, this.heartBeatTimeout));
    }), y4(this, "onPayloadHandler", (t) => {
      this.onProviderPayload(t), this.resetPingTimeout();
    }), y4(this, "onConnectHandler", () => {
      this.logger.warn({}, "Relayer connected "), this.startPingTimeout(), this.events.emit(C2.connect);
    }), y4(this, "onDisconnectHandler", () => {
      this.logger.warn({}, "Relayer disconnected "), this.requestsInFlight = [], this.onProviderDisconnect();
    }), y4(this, "onProviderErrorHandler", (t) => {
      this.logger.fatal(`Fatal socket error: ${t.message}`), this.events.emit(C2.error, t), this.logger.fatal("Fatal socket error received, closing transport"), this.transportClose();
    }), y4(this, "registerProviderListeners", () => {
      this.provider.on(L2.payload, this.onPayloadHandler), this.provider.on(L2.connect, this.onConnectHandler), this.provider.on(L2.disconnect, this.onDisconnectHandler), this.provider.on(L2.error, this.onProviderErrorHandler);
    }), this.core = e2.core, this.logger = typeof e2.logger < "u" && typeof e2.logger != "string" ? E2(e2.logger, this.name) : (0, import_pino2.default)(k2({ level: e2.logger || Nt })), this.messages = new Ei(this.logger, e2.core), this.subscriber = new Ci(this, this.logger), this.publisher = new Gn(this, this.logger), this.relayUrl = (e2 == null ? void 0 : e2.relayUrl) || Ue, this.projectId = e2.projectId, Ms() ? this.packageName = qs() : Vs() && (this.bundleId = qs()), this.provider = {};
  }
  async init() {
    this.logger.trace("Initialized"), this.registerEventListeners(), await Promise.all([this.messages.init(), this.subscriber.init()]), this.initialized = true, this.transportOpen().catch((e2) => this.logger.warn(e2, e2 == null ? void 0 : e2.message));
  }
  get context() {
    return y2(this.logger);
  }
  get connected() {
    var e2, t, i4;
    return ((i4 = (t = (e2 = this.provider) == null ? void 0 : e2.connection) == null ? void 0 : t.socket) == null ? void 0 : i4.readyState) === 1 || false;
  }
  get connecting() {
    var e2, t, i4;
    return ((i4 = (t = (e2 = this.provider) == null ? void 0 : e2.connection) == null ? void 0 : t.socket) == null ? void 0 : i4.readyState) === 0 || this.connectPromise !== void 0 || false;
  }
  async publish(e2, t, i4) {
    this.isInitialized(), await this.publisher.publish(e2, t, i4), await this.recordMessageEvent({ topic: e2, message: t, publishedAt: Date.now(), transportType: Q.relay }, le.outbound);
  }
  async subscribe(e2, t) {
    var i4, s3, n5;
    this.isInitialized(), (!(t != null && t.transportType) || (t == null ? void 0 : t.transportType) === "relay") && await this.toEstablishConnection();
    const o4 = typeof ((i4 = t == null ? void 0 : t.internal) == null ? void 0 : i4.throwOnFailedPublish) > "u" ? true : (s3 = t == null ? void 0 : t.internal) == null ? void 0 : s3.throwOnFailedPublish;
    let a3 = ((n5 = this.subscriber.topicMap.get(e2)) == null ? void 0 : n5[0]) || "", c6;
    const h5 = (l6) => {
      l6.topic === e2 && (this.subscriber.off($.created, h5), c6());
    };
    return await Promise.all([new Promise((l6) => {
      c6 = l6, this.subscriber.on($.created, h5);
    }), new Promise(async (l6, d4) => {
      a3 = await this.subscriber.subscribe(e2, Si({ internal: { throwOnFailedPublish: o4 } }, t)).catch((g3) => {
        o4 && d4(g3);
      }) || a3, l6();
    })]), a3;
  }
  async unsubscribe(e2, t) {
    this.isInitialized(), await this.subscriber.unsubscribe(e2, t);
  }
  on(e2, t) {
    this.events.on(e2, t);
  }
  once(e2, t) {
    this.events.once(e2, t);
  }
  off(e2, t) {
    this.events.off(e2, t);
  }
  removeListener(e2, t) {
    this.events.removeListener(e2, t);
  }
  async transportDisconnect() {
    this.provider.disconnect && (this.hasExperiencedNetworkDisruption || this.connected) ? await ni(this.provider.disconnect(), 2e3, "provider.disconnect()").catch(() => this.onProviderDisconnect()) : this.onProviderDisconnect();
  }
  async transportClose() {
    this.transportExplicitlyClosed = true, await this.transportDisconnect();
  }
  async transportOpen(e2) {
    if (!this.subscriber.hasAnyTopics) {
      this.logger.info("Starting WS connection skipped because the client has no topics to work with.");
      return;
    }
    if (this.connectPromise ? (this.logger.debug({}, "Waiting for existing connection attempt to resolve..."), await this.connectPromise, this.logger.debug({}, "Existing connection attempt resolved")) : (this.connectPromise = new Promise(async (t, i4) => {
      await this.connect(e2).then(t).catch(i4).finally(() => {
        this.connectPromise = void 0;
      });
    }), await this.connectPromise), !this.connected)
      throw new Error(`Couldn't establish socket connection to the relay server: ${this.relayUrl}`);
  }
  async restartTransport(e2) {
    this.logger.debug({}, "Restarting transport..."), !this.connectionAttemptInProgress && (this.relayUrl = e2 || this.relayUrl, await this.confirmOnlineStateOrThrow(), await this.transportClose(), await this.transportOpen());
  }
  async confirmOnlineStateOrThrow() {
    if (!await ja())
      throw new Error("No internet connection detected. Please restart your network and try again.");
  }
  async handleBatchMessageEvents(e2) {
    if ((e2 == null ? void 0 : e2.length) === 0) {
      this.logger.trace("Batch message events is empty. Ignoring...");
      return;
    }
    const t = e2.sort((i4, s3) => i4.publishedAt - s3.publishedAt);
    this.logger.debug(`Batch of ${t.length} message events sorted`);
    for (const i4 of t)
      try {
        await this.onMessageEvent(i4);
      } catch (s3) {
        this.logger.warn(s3, "Error while processing batch message event: " + (s3 == null ? void 0 : s3.message));
      }
    this.logger.trace(`Batch of ${t.length} message events processed`);
  }
  async onLinkMessageEvent(e2, t) {
    const { topic: i4 } = e2;
    if (!t.sessionExists) {
      const s3 = ii(import_time2.FIVE_MINUTES), n5 = { topic: i4, expiry: s3, relay: { protocol: "irn" }, active: false };
      await this.core.pairing.pairings.set(i4, n5);
    }
    this.events.emit(C2.message, e2), await this.recordMessageEvent(e2, le.inbound);
  }
  async connect(e2) {
    await this.confirmOnlineStateOrThrow(), e2 && e2 !== this.relayUrl && (this.relayUrl = e2, await this.transportDisconnect()), this.connectionAttemptInProgress = true, this.transportExplicitlyClosed = false;
    let t = 1;
    for (; t < 6; ) {
      try {
        if (this.transportExplicitlyClosed)
          break;
        this.logger.debug({}, `Connecting to ${this.relayUrl}, attempt: ${t}...`), await this.createProvider(), await new Promise(async (i4, s3) => {
          const n5 = () => {
            s3(new Error("Connection interrupted while trying to connect"));
          };
          this.provider.once(L2.disconnect, n5), await ni(new Promise((o4, a3) => {
            this.provider.connect().then(o4).catch(a3);
          }), this.connectTimeout, `Socket stalled when trying to connect to ${this.relayUrl}`).catch((o4) => {
            s3(o4);
          }).finally(() => {
            this.provider.off(L2.disconnect, n5), clearTimeout(this.reconnectTimeout);
          }), await new Promise(async (o4, a3) => {
            const c6 = () => {
              s3(new Error("Connection interrupted while trying to subscribe"));
            };
            this.provider.once(L2.disconnect, c6), await this.subscriber.start().then(o4).catch(a3).finally(() => {
              this.provider.off(L2.disconnect, c6);
            });
          }), this.hasExperiencedNetworkDisruption = false, i4();
        });
      } catch (i4) {
        await this.subscriber.stop();
        const s3 = i4;
        this.logger.warn({}, s3.message), this.hasExperiencedNetworkDisruption = true;
      } finally {
        this.connectionAttemptInProgress = false;
      }
      if (this.connected) {
        this.logger.debug({}, `Connected to ${this.relayUrl} successfully on attempt: ${t}`);
        break;
      }
      await new Promise((i4) => setTimeout(i4, (0, import_time2.toMiliseconds)(t * 1))), t++;
    }
  }
  startPingTimeout() {
    var e2, t, i4, s3, n5;
    if (Ye())
      try {
        (t = (e2 = this.provider) == null ? void 0 : e2.connection) != null && t.socket && ((n5 = (s3 = (i4 = this.provider) == null ? void 0 : i4.connection) == null ? void 0 : s3.socket) == null || n5.on("ping", () => {
          this.resetPingTimeout();
        })), this.resetPingTimeout();
      } catch (o4) {
        this.logger.warn(o4, o4 == null ? void 0 : o4.message);
      }
  }
  async createProvider() {
    this.provider.connection && this.unregisterProviderListeners();
    const e2 = await this.core.crypto.signJWT(this.relayUrl);
    this.provider = new o3(new f3(zs({ sdkVersion: _e, protocol: this.protocol, version: this.version, relayUrl: this.relayUrl, projectId: this.projectId, auth: e2, useOnCloseEvent: true, bundleId: this.bundleId, packageName: this.packageName }))), this.registerProviderListeners();
  }
  async recordMessageEvent(e2, t) {
    const { topic: i4, message: s3 } = e2;
    await this.messages.set(i4, s3, t);
  }
  async shouldIgnoreMessageEvent(e2) {
    const { topic: t, message: i4 } = e2;
    if (!i4 || i4.length === 0)
      return this.logger.warn(`Ignoring invalid/empty message: ${i4}`), true;
    if (!await this.subscriber.isKnownTopic(t))
      return this.logger.warn(`Ignoring message for unknown topic ${t}`), true;
    const s3 = this.messages.has(t, i4);
    return s3 && this.logger.warn(`Ignoring duplicate message: ${i4}`), s3;
  }
  async onProviderPayload(e2) {
    if (this.logger.debug("Incoming Relay Payload"), this.logger.trace({ type: "payload", direction: "incoming", payload: e2 }), isJsonRpcRequest(e2)) {
      if (!e2.method.endsWith(zt2))
        return;
      const t = e2.params, { topic: i4, message: s3, publishedAt: n5, attestation: o4 } = t.data, a3 = { topic: i4, message: s3, publishedAt: n5, transportType: Q.relay, attestation: o4 };
      this.logger.debug("Emitting Relayer Payload"), this.logger.trace(Si({ type: "event", event: t.id }, a3)), this.events.emit(t.id, a3), await this.acknowledgePayload(e2), await this.onMessageEvent(a3);
    } else
      isJsonRpcResponse(e2) && this.events.emit(C2.message_ack, e2);
  }
  async onMessageEvent(e2) {
    await this.shouldIgnoreMessageEvent(e2) || (await this.recordMessageEvent(e2, le.inbound), this.events.emit(C2.message, e2));
  }
  async acknowledgePayload(e2) {
    const t = formatJsonRpcResult(e2.id, true);
    await this.provider.connection.send(t);
  }
  unregisterProviderListeners() {
    this.provider.off(L2.payload, this.onPayloadHandler), this.provider.off(L2.connect, this.onConnectHandler), this.provider.off(L2.disconnect, this.onDisconnectHandler), this.provider.off(L2.error, this.onProviderErrorHandler), clearTimeout(this.pingTimeout);
  }
  async registerEventListeners() {
    let e2 = await ja();
    ka(async (t) => {
      e2 !== t && (e2 = t, t ? await this.transportOpen().catch((i4) => this.logger.error(i4, i4 == null ? void 0 : i4.message)) : (this.hasExperiencedNetworkDisruption = true, await this.transportDisconnect(), this.transportExplicitlyClosed = false));
    }), this.core.heartbeat.on(r.pulse, async () => {
      if (!this.transportExplicitlyClosed && !this.connected && Pa())
        try {
          await this.confirmOnlineStateOrThrow(), await this.transportOpen();
        } catch (t) {
          this.logger.warn(t, t == null ? void 0 : t.message);
        }
    });
  }
  async onProviderDisconnect() {
    clearTimeout(this.pingTimeout), this.events.emit(C2.disconnect), this.connectionAttemptInProgress = false, !this.reconnectInProgress && (this.reconnectInProgress = true, await this.subscriber.stop(), this.subscriber.hasAnyTopics && (this.transportExplicitlyClosed || (this.reconnectTimeout = setTimeout(async () => {
      await this.transportOpen().catch((e2) => this.logger.error(e2, e2 == null ? void 0 : e2.message)), this.reconnectTimeout = void 0, this.reconnectInProgress = false;
    }, (0, import_time2.toMiliseconds)(Lt)))));
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e2 } = Et("NOT_INITIALIZED", this.name);
      throw new Error(e2);
    }
  }
  async toEstablishConnection() {
    if (await this.confirmOnlineStateOrThrow(), !this.connected) {
      if (this.connectPromise) {
        await this.connectPromise;
        return;
      }
      await this.connect();
    }
  }
};
function ro(r3, e2) {
  return r3 === e2 || Number.isNaN(r3) && Number.isNaN(e2);
}
function Ri(r3) {
  return Object.getOwnPropertySymbols(r3).filter((e2) => Object.prototype.propertyIsEnumerable.call(r3, e2));
}
function Ai(r3) {
  return r3 == null ? r3 === void 0 ? "[object Undefined]" : "[object Null]" : Object.prototype.toString.call(r3);
}
var no = "[object RegExp]";
var oo = "[object String]";
var ao = "[object Number]";
var co = "[object Boolean]";
var xi = "[object Arguments]";
var ho = "[object Symbol]";
var lo = "[object Date]";
var uo = "[object Map]";
var go = "[object Set]";
var po = "[object Array]";
var yo = "[object Function]";
var bo = "[object ArrayBuffer]";
var Je = "[object Object]";
var mo = "[object Error]";
var fo = "[object DataView]";
var Do = "[object Uint8Array]";
var vo = "[object Uint8ClampedArray]";
var wo = "[object Uint16Array]";
var _o = "[object Uint32Array]";
var Eo = "[object BigUint64Array]";
var Io = "[object Int8Array]";
var To = "[object Int16Array]";
var Co = "[object Int32Array]";
var Po2 = "[object BigInt64Array]";
var So = "[object Float32Array]";
var Oo = "[object Float64Array]";
function Ro() {
}
function Ni(r3) {
  if (!r3 || typeof r3 != "object")
    return false;
  const e2 = Object.getPrototypeOf(r3);
  return e2 === null || e2 === Object.prototype || Object.getPrototypeOf(e2) === null ? Object.prototype.toString.call(r3) === "[object Object]" : false;
}
function Ao(r3, e2, t) {
  return pe(r3, e2, void 0, void 0, void 0, void 0, t);
}
function pe(r3, e2, t, i4, s3, n5, o4) {
  const a3 = o4(r3, e2, t, i4, s3, n5);
  if (a3 !== void 0)
    return a3;
  if (typeof r3 == typeof e2)
    switch (typeof r3) {
      case "bigint":
      case "string":
      case "boolean":
      case "symbol":
      case "undefined":
        return r3 === e2;
      case "number":
        return r3 === e2 || Object.is(r3, e2);
      case "function":
        return r3 === e2;
      case "object":
        return ye(r3, e2, n5, o4);
    }
  return ye(r3, e2, n5, o4);
}
function ye(r3, e2, t, i4) {
  if (Object.is(r3, e2))
    return true;
  let s3 = Ai(r3), n5 = Ai(e2);
  if (s3 === xi && (s3 = Je), n5 === xi && (n5 = Je), s3 !== n5)
    return false;
  switch (s3) {
    case oo:
      return r3.toString() === e2.toString();
    case ao: {
      const c6 = r3.valueOf(), h5 = e2.valueOf();
      return ro(c6, h5);
    }
    case co:
    case lo:
    case ho:
      return Object.is(r3.valueOf(), e2.valueOf());
    case no:
      return r3.source === e2.source && r3.flags === e2.flags;
    case yo:
      return r3 === e2;
  }
  t = t ?? /* @__PURE__ */ new Map();
  const o4 = t.get(r3), a3 = t.get(e2);
  if (o4 != null && a3 != null)
    return o4 === e2;
  t.set(r3, e2), t.set(e2, r3);
  try {
    switch (s3) {
      case uo: {
        if (r3.size !== e2.size)
          return false;
        for (const [c6, h5] of r3.entries())
          if (!e2.has(c6) || !pe(h5, e2.get(c6), c6, r3, e2, t, i4))
            return false;
        return true;
      }
      case go: {
        if (r3.size !== e2.size)
          return false;
        const c6 = Array.from(r3.values()), h5 = Array.from(e2.values());
        for (let l6 = 0; l6 < c6.length; l6++) {
          const d4 = c6[l6], g3 = h5.findIndex((_16) => pe(d4, _16, void 0, r3, e2, t, i4));
          if (g3 === -1)
            return false;
          h5.splice(g3, 1);
        }
        return true;
      }
      case po:
      case Do:
      case vo:
      case wo:
      case _o:
      case Eo:
      case Io:
      case To:
      case Co:
      case Po2:
      case So:
      case Oo: {
        if (typeof Buffer < "u" && Buffer.isBuffer(r3) !== Buffer.isBuffer(e2) || r3.length !== e2.length)
          return false;
        for (let c6 = 0; c6 < r3.length; c6++)
          if (!pe(r3[c6], e2[c6], c6, r3, e2, t, i4))
            return false;
        return true;
      }
      case bo:
        return r3.byteLength !== e2.byteLength ? false : ye(new Uint8Array(r3), new Uint8Array(e2), t, i4);
      case fo:
        return r3.byteLength !== e2.byteLength || r3.byteOffset !== e2.byteOffset ? false : ye(new Uint8Array(r3), new Uint8Array(e2), t, i4);
      case mo:
        return r3.name === e2.name && r3.message === e2.message;
      case Je: {
        if (!(ye(r3.constructor, e2.constructor, t, i4) || Ni(r3) && Ni(e2)))
          return false;
        const h5 = [...Object.keys(r3), ...Ri(r3)], l6 = [...Object.keys(e2), ...Ri(e2)];
        if (h5.length !== l6.length)
          return false;
        for (let d4 = 0; d4 < h5.length; d4++) {
          const g3 = h5[d4], _16 = r3[g3];
          if (!Object.hasOwn(e2, g3))
            return false;
          const u2 = e2[g3];
          if (!pe(_16, u2, g3, r3, e2, t, i4))
            return false;
        }
        return true;
      }
      default:
        return false;
    }
  } finally {
    t.delete(r3), t.delete(e2);
  }
}
function xo(r3, e2) {
  return Ao(r3, e2, Ro);
}
var No = Object.defineProperty;
var $i = Object.getOwnPropertySymbols;
var $o = Object.prototype.hasOwnProperty;
var zo = Object.prototype.propertyIsEnumerable;
var Xe = (r3, e2, t) => e2 in r3 ? No(r3, e2, { enumerable: true, configurable: true, writable: true, value: t }) : r3[e2] = t;
var zi = (r3, e2) => {
  for (var t in e2 || (e2 = {}))
    $o.call(e2, t) && Xe(r3, t, e2[t]);
  if ($i)
    for (var t of $i(e2))
      zo.call(e2, t) && Xe(r3, t, e2[t]);
  return r3;
};
var z3 = (r3, e2, t) => Xe(r3, typeof e2 != "symbol" ? e2 + "" : e2, t);
var Li = class extends f2 {
  constructor(e2, t, i4, s3 = B2, n5 = void 0) {
    super(e2, t, i4, s3), this.core = e2, this.logger = t, this.name = i4, z3(this, "map", /* @__PURE__ */ new Map()), z3(this, "version", kt2), z3(this, "cached", []), z3(this, "initialized", false), z3(this, "getKey"), z3(this, "storagePrefix", B2), z3(this, "recentlyDeleted", []), z3(this, "recentlyDeletedLimit", 200), z3(this, "init", async () => {
      this.initialized || (this.logger.trace("Initialized"), await this.restore(), this.cached.forEach((o4) => {
        this.getKey && o4 !== null && !kt(o4) ? this.map.set(this.getKey(o4), o4) : wa(o4) ? this.map.set(o4.id, o4) : xa(o4) && this.map.set(o4.topic, o4);
      }), this.cached = [], this.initialized = true);
    }), z3(this, "set", async (o4, a3) => {
      this.isInitialized(), this.map.has(o4) ? await this.update(o4, a3) : (this.logger.debug("Setting value"), this.logger.trace({ type: "method", method: "set", key: o4, value: a3 }), this.map.set(o4, a3), await this.persist());
    }), z3(this, "get", (o4) => (this.isInitialized(), this.logger.debug("Getting value"), this.logger.trace({ type: "method", method: "get", key: o4 }), this.getData(o4))), z3(this, "getAll", (o4) => (this.isInitialized(), o4 ? this.values.filter((a3) => Object.keys(o4).every((c6) => xo(a3[c6], o4[c6]))) : this.values)), z3(this, "update", async (o4, a3) => {
      this.isInitialized(), this.logger.debug("Updating value"), this.logger.trace({ type: "method", method: "update", key: o4, update: a3 });
      const c6 = zi(zi({}, this.getData(o4)), a3);
      this.map.set(o4, c6), await this.persist();
    }), z3(this, "delete", async (o4, a3) => {
      this.isInitialized(), this.map.has(o4) && (this.logger.debug("Deleting value"), this.logger.trace({ type: "method", method: "delete", key: o4, reason: a3 }), this.map.delete(o4), this.addToRecentlyDeleted(o4), await this.persist());
    }), this.logger = E2(t, this.name), this.storagePrefix = s3, this.getKey = n5;
  }
  get context() {
    return y2(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  get length() {
    return this.map.size;
  }
  get keys() {
    return Array.from(this.map.keys());
  }
  get values() {
    return Array.from(this.map.values());
  }
  addToRecentlyDeleted(e2) {
    this.recentlyDeleted.push(e2), this.recentlyDeleted.length >= this.recentlyDeletedLimit && this.recentlyDeleted.splice(0, this.recentlyDeletedLimit / 2);
  }
  async setDataStore(e2) {
    await this.core.storage.setItem(this.storageKey, e2);
  }
  async getDataStore() {
    return await this.core.storage.getItem(this.storageKey);
  }
  getData(e2) {
    const t = this.map.get(e2);
    if (!t) {
      if (this.recentlyDeleted.includes(e2)) {
        const { message: s3 } = Et("MISSING_OR_INVALID", `Record was recently deleted - ${this.name}: ${e2}`);
        throw this.logger.error(s3), new Error(s3);
      }
      const { message: i4 } = Et("NO_MATCHING_KEY", `${this.name}: ${e2}`);
      throw this.logger.error(i4), new Error(i4);
    }
    return t;
  }
  async persist() {
    await this.setDataStore(this.values);
  }
  async restore() {
    try {
      const e2 = await this.getDataStore();
      if (typeof e2 > "u" || !e2.length)
        return;
      if (this.map.size) {
        const { message: t } = Et("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(t), new Error(t);
      }
      this.cached = e2, this.logger.debug(`Successfully Restored value for ${this.name}`), this.logger.trace({ type: "method", method: "restore", value: this.values });
    } catch (e2) {
      this.logger.debug(`Failed to Restore value for ${this.name}`), this.logger.error(e2);
    }
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e2 } = Et("NOT_INITIALIZED", this.name);
      throw new Error(e2);
    }
  }
};
var Lo = Object.defineProperty;
var ko = (r3, e2, t) => e2 in r3 ? Lo(r3, e2, { enumerable: true, configurable: true, writable: true, value: t }) : r3[e2] = t;
var p3 = (r3, e2, t) => ko(r3, typeof e2 != "symbol" ? e2 + "" : e2, t);
var ki = class {
  constructor(e2, t) {
    this.core = e2, this.logger = t, p3(this, "name", Mt), p3(this, "version", Kt2), p3(this, "events", new import_events7.default()), p3(this, "pairings"), p3(this, "initialized", false), p3(this, "storagePrefix", B2), p3(this, "ignoredPayloadTypes", [ee]), p3(this, "registeredMethods", []), p3(this, "init", async () => {
      this.initialized || (await this.pairings.init(), await this.cleanup(), this.registerRelayerEvents(), this.registerExpirerEvents(), this.initialized = true, this.logger.trace("Initialized"));
    }), p3(this, "register", ({ methods: i4 }) => {
      this.isInitialized(), this.registeredMethods = [.../* @__PURE__ */ new Set([...this.registeredMethods, ...i4])];
    }), p3(this, "create", async (i4) => {
      this.isInitialized();
      const s3 = qc(), n5 = await this.core.crypto.setSymKey(s3), o4 = ii(import_time2.FIVE_MINUTES), a3 = { protocol: xt }, c6 = { topic: n5, expiry: o4, relay: a3, active: false, methods: i4 == null ? void 0 : i4.methods }, h5 = oa({ protocol: this.core.protocol, version: this.core.version, topic: n5, symKey: s3, relay: a3, expiryTimestamp: o4, methods: i4 == null ? void 0 : i4.methods });
      return this.events.emit(re.create, c6), this.core.expirer.set(n5, o4), await this.pairings.set(n5, c6), await this.core.relayer.subscribe(n5, { transportType: i4 == null ? void 0 : i4.transportType }), { topic: n5, uri: h5 };
    }), p3(this, "pair", async (i4) => {
      this.isInitialized();
      const s3 = this.core.eventClient.createEvent({ properties: { topic: i4 == null ? void 0 : i4.uri, trace: [G.pairing_started] } });
      this.isValidPair(i4, s3);
      const { topic: n5, symKey: o4, relay: a3, expiryTimestamp: c6, methods: h5 } = ra(i4.uri);
      s3.props.properties.topic = n5, s3.addTrace(G.pairing_uri_validation_success), s3.addTrace(G.pairing_uri_not_expired);
      let l6;
      if (this.pairings.keys.includes(n5)) {
        if (l6 = this.pairings.get(n5), s3.addTrace(G.existing_pairing), l6.active)
          throw s3.setError(Y.active_pairing_already_exists), new Error(`Pairing already exists: ${n5}. Please try again with a new connection URI.`);
        s3.addTrace(G.pairing_not_expired);
      }
      const d4 = c6 || ii(import_time2.FIVE_MINUTES), g3 = { topic: n5, relay: a3, expiry: d4, active: false, methods: h5 };
      this.core.expirer.set(n5, d4), await this.pairings.set(n5, g3), s3.addTrace(G.store_new_pairing), i4.activatePairing && await this.activate({ topic: n5 }), this.events.emit(re.create, g3), s3.addTrace(G.emit_inactive_pairing), this.core.crypto.keychain.has(n5) || await this.core.crypto.setSymKey(o4, n5), s3.addTrace(G.subscribing_pairing_topic);
      try {
        await this.core.relayer.confirmOnlineStateOrThrow();
      } catch {
        s3.setError(Y.no_internet_connection);
      }
      try {
        await this.core.relayer.subscribe(n5, { relay: a3 });
      } catch (_16) {
        throw s3.setError(Y.subscribe_pairing_topic_failure), _16;
      }
      return s3.addTrace(G.subscribe_pairing_topic_success), g3;
    }), p3(this, "activate", async ({ topic: i4 }) => {
      this.isInitialized();
      const s3 = ii(import_time2.FIVE_MINUTES);
      this.core.expirer.set(i4, s3), await this.pairings.update(i4, { active: true, expiry: s3 });
    }), p3(this, "ping", async (i4) => {
      this.isInitialized(), await this.isValidPing(i4), this.logger.warn("ping() is deprecated and will be removed in the next major release.");
      const { topic: s3 } = i4;
      if (this.pairings.keys.includes(s3)) {
        const n5 = await this.sendRequest(s3, "wc_pairingPing", {}), { done: o4, resolve: a3, reject: c6 } = ei();
        this.events.once(ci("pairing_ping", n5), ({ error: h5 }) => {
          h5 ? c6(h5) : a3();
        }), await o4();
      }
    }), p3(this, "updateExpiry", async ({ topic: i4, expiry: s3 }) => {
      this.isInitialized(), await this.pairings.update(i4, { expiry: s3 });
    }), p3(this, "updateMetadata", async ({ topic: i4, metadata: s3 }) => {
      this.isInitialized(), await this.pairings.update(i4, { peerMetadata: s3 });
    }), p3(this, "getPairings", () => (this.isInitialized(), this.pairings.values)), p3(this, "disconnect", async (i4) => {
      this.isInitialized(), await this.isValidDisconnect(i4);
      const { topic: s3 } = i4;
      this.pairings.keys.includes(s3) && (await this.sendRequest(s3, "wc_pairingDelete", Kt("USER_DISCONNECTED")), await this.deletePairing(s3));
    }), p3(this, "formatUriFromPairing", (i4) => {
      this.isInitialized();
      const { topic: s3, relay: n5, expiry: o4, methods: a3 } = i4, c6 = this.core.crypto.keychain.get(s3);
      return oa({ protocol: this.core.protocol, version: this.core.version, topic: s3, symKey: c6, relay: n5, expiryTimestamp: o4, methods: a3 });
    }), p3(this, "sendRequest", async (i4, s3, n5) => {
      const o4 = formatJsonRpcRequest(s3, n5), a3 = await this.core.crypto.encode(i4, o4), c6 = se[s3].req;
      return this.core.history.set(i4, o4), this.core.relayer.publish(i4, a3, c6), o4.id;
    }), p3(this, "sendResult", async (i4, s3, n5) => {
      const o4 = formatJsonRpcResult(i4, n5), a3 = await this.core.crypto.encode(s3, o4), c6 = (await this.core.history.get(s3, i4)).request.method, h5 = se[c6].res;
      await this.core.relayer.publish(s3, a3, h5), await this.core.history.resolve(o4);
    }), p3(this, "sendError", async (i4, s3, n5) => {
      const o4 = formatJsonRpcError(i4, n5), a3 = await this.core.crypto.encode(s3, o4), c6 = (await this.core.history.get(s3, i4)).request.method, h5 = se[c6] ? se[c6].res : se.unregistered_method.res;
      await this.core.relayer.publish(s3, a3, h5), await this.core.history.resolve(o4);
    }), p3(this, "deletePairing", async (i4, s3) => {
      await this.core.relayer.unsubscribe(i4), await Promise.all([this.pairings.delete(i4, Kt("USER_DISCONNECTED")), this.core.crypto.deleteSymKey(i4), s3 ? Promise.resolve() : this.core.expirer.del(i4)]);
    }), p3(this, "cleanup", async () => {
      const i4 = this.pairings.getAll().filter((s3) => fi(s3.expiry));
      await Promise.all(i4.map((s3) => this.deletePairing(s3.topic)));
    }), p3(this, "onRelayEventRequest", async (i4) => {
      const { topic: s3, payload: n5 } = i4;
      switch (n5.method) {
        case "wc_pairingPing":
          return await this.onPairingPingRequest(s3, n5);
        case "wc_pairingDelete":
          return await this.onPairingDeleteRequest(s3, n5);
        default:
          return await this.onUnknownRpcMethodRequest(s3, n5);
      }
    }), p3(this, "onRelayEventResponse", async (i4) => {
      const { topic: s3, payload: n5 } = i4, o4 = (await this.core.history.get(s3, n5.id)).request.method;
      switch (o4) {
        case "wc_pairingPing":
          return this.onPairingPingResponse(s3, n5);
        default:
          return this.onUnknownRpcMethodResponse(o4);
      }
    }), p3(this, "onPairingPingRequest", async (i4, s3) => {
      const { id: n5 } = s3;
      try {
        this.isValidPing({ topic: i4 }), await this.sendResult(n5, i4, true), this.events.emit(re.ping, { id: n5, topic: i4 });
      } catch (o4) {
        await this.sendError(n5, i4, o4), this.logger.error(o4);
      }
    }), p3(this, "onPairingPingResponse", (i4, s3) => {
      const { id: n5 } = s3;
      setTimeout(() => {
        isJsonRpcResult(s3) ? this.events.emit(ci("pairing_ping", n5), {}) : isJsonRpcError(s3) && this.events.emit(ci("pairing_ping", n5), { error: s3.error });
      }, 500);
    }), p3(this, "onPairingDeleteRequest", async (i4, s3) => {
      const { id: n5 } = s3;
      try {
        this.isValidDisconnect({ topic: i4 }), await this.deletePairing(i4), this.events.emit(re.delete, { id: n5, topic: i4 });
      } catch (o4) {
        await this.sendError(n5, i4, o4), this.logger.error(o4);
      }
    }), p3(this, "onUnknownRpcMethodRequest", async (i4, s3) => {
      const { id: n5, method: o4 } = s3;
      try {
        if (this.registeredMethods.includes(o4))
          return;
        const a3 = Kt("WC_METHOD_UNSUPPORTED", o4);
        await this.sendError(n5, i4, a3), this.logger.error(a3);
      } catch (a3) {
        await this.sendError(n5, i4, a3), this.logger.error(a3);
      }
    }), p3(this, "onUnknownRpcMethodResponse", (i4) => {
      this.registeredMethods.includes(i4) || this.logger.error(Kt("WC_METHOD_UNSUPPORTED", i4));
    }), p3(this, "isValidPair", (i4, s3) => {
      var n5;
      if (!Aa(i4)) {
        const { message: a3 } = Et("MISSING_OR_INVALID", `pair() params: ${i4}`);
        throw s3.setError(Y.malformed_pairing_uri), new Error(a3);
      }
      if (!ma(i4.uri)) {
        const { message: a3 } = Et("MISSING_OR_INVALID", `pair() uri: ${i4.uri}`);
        throw s3.setError(Y.malformed_pairing_uri), new Error(a3);
      }
      const o4 = ra(i4 == null ? void 0 : i4.uri);
      if (!((n5 = o4 == null ? void 0 : o4.relay) != null && n5.protocol)) {
        const { message: a3 } = Et("MISSING_OR_INVALID", "pair() uri#relay-protocol");
        throw s3.setError(Y.malformed_pairing_uri), new Error(a3);
      }
      if (!(o4 != null && o4.symKey)) {
        const { message: a3 } = Et("MISSING_OR_INVALID", "pair() uri#symKey");
        throw s3.setError(Y.malformed_pairing_uri), new Error(a3);
      }
      if (o4 != null && o4.expiryTimestamp && (0, import_time2.toMiliseconds)(o4 == null ? void 0 : o4.expiryTimestamp) < Date.now()) {
        s3.setError(Y.pairing_expired);
        const { message: a3 } = Et("EXPIRED", "pair() URI has expired. Please try again with a new connection URI.");
        throw new Error(a3);
      }
    }), p3(this, "isValidPing", async (i4) => {
      if (!Aa(i4)) {
        const { message: n5 } = Et("MISSING_OR_INVALID", `ping() params: ${i4}`);
        throw new Error(n5);
      }
      const { topic: s3 } = i4;
      await this.isValidPairingTopic(s3);
    }), p3(this, "isValidDisconnect", async (i4) => {
      if (!Aa(i4)) {
        const { message: n5 } = Et("MISSING_OR_INVALID", `disconnect() params: ${i4}`);
        throw new Error(n5);
      }
      const { topic: s3 } = i4;
      await this.isValidPairingTopic(s3);
    }), p3(this, "isValidPairingTopic", async (i4) => {
      if (!it(i4, false)) {
        const { message: s3 } = Et("MISSING_OR_INVALID", `pairing topic should be a string: ${i4}`);
        throw new Error(s3);
      }
      if (!this.pairings.keys.includes(i4)) {
        const { message: s3 } = Et("NO_MATCHING_KEY", `pairing topic doesn't exist: ${i4}`);
        throw new Error(s3);
      }
      if (fi(this.pairings.get(i4).expiry)) {
        await this.deletePairing(i4);
        const { message: s3 } = Et("EXPIRED", `pairing topic: ${i4}`);
        throw new Error(s3);
      }
    }), this.core = e2, this.logger = E2(t, this.name), this.pairings = new Li(this.core, this.logger, this.name, this.storagePrefix);
  }
  get context() {
    return y2(this.logger);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e2 } = Et("NOT_INITIALIZED", this.name);
      throw new Error(e2);
    }
  }
  registerRelayerEvents() {
    this.core.relayer.on(C2.message, async (e2) => {
      const { topic: t, message: i4, transportType: s3 } = e2;
      if (this.pairings.keys.includes(t) && s3 !== Q.link_mode && !this.ignoredPayloadTypes.includes(this.core.crypto.getPayloadType(i4)))
        try {
          const n5 = await this.core.crypto.decode(t, i4);
          isJsonRpcRequest(n5) ? (this.core.history.set(t, n5), await this.onRelayEventRequest({ topic: t, payload: n5 })) : isJsonRpcResponse(n5) && (await this.core.history.resolve(n5), await this.onRelayEventResponse({ topic: t, payload: n5 }), this.core.history.delete(t, n5.id)), await this.core.relayer.messages.ack(t, i4);
        } catch (n5) {
          this.logger.error(n5);
        }
    });
  }
  registerExpirerEvents() {
    this.core.expirer.on(M2.expired, async (e2) => {
      const { topic: t } = si(e2.target);
      t && this.pairings.keys.includes(t) && (await this.deletePairing(t, true), this.events.emit(re.expire, { topic: t }));
    });
  }
};
var jo = Object.defineProperty;
var Uo = (r3, e2, t) => e2 in r3 ? jo(r3, e2, { enumerable: true, configurable: true, writable: true, value: t }) : r3[e2] = t;
var O4 = (r3, e2, t) => Uo(r3, typeof e2 != "symbol" ? e2 + "" : e2, t);
var ji = class extends I2 {
  constructor(e2, t) {
    super(e2, t), this.core = e2, this.logger = t, O4(this, "records", /* @__PURE__ */ new Map()), O4(this, "events", new import_events7.EventEmitter()), O4(this, "name", Bt2), O4(this, "version", Vt2), O4(this, "cached", []), O4(this, "initialized", false), O4(this, "storagePrefix", B2), O4(this, "init", async () => {
      this.initialized || (this.logger.trace("Initialized"), await this.restore(), this.cached.forEach((i4) => this.records.set(i4.id, i4)), this.cached = [], this.registerEventListeners(), this.initialized = true);
    }), O4(this, "set", (i4, s3, n5) => {
      if (this.isInitialized(), this.logger.debug("Setting JSON-RPC request history record"), this.logger.trace({ type: "method", method: "set", topic: i4, request: s3, chainId: n5 }), this.records.has(s3.id))
        return;
      const o4 = { id: s3.id, topic: i4, request: { method: s3.method, params: s3.params || null }, chainId: n5, expiry: ii(import_time2.THIRTY_DAYS) };
      this.records.set(o4.id, o4), this.persist(), this.events.emit(F.created, o4);
    }), O4(this, "resolve", async (i4) => {
      if (this.isInitialized(), this.logger.debug("Updating JSON-RPC response history record"), this.logger.trace({ type: "method", method: "update", response: i4 }), !this.records.has(i4.id))
        return;
      const s3 = await this.getRecord(i4.id);
      typeof s3.response > "u" && (s3.response = isJsonRpcError(i4) ? { error: i4.error } : { result: i4.result }, this.records.set(s3.id, s3), this.persist(), this.events.emit(F.updated, s3));
    }), O4(this, "get", async (i4, s3) => (this.isInitialized(), this.logger.debug("Getting record"), this.logger.trace({ type: "method", method: "get", topic: i4, id: s3 }), await this.getRecord(s3))), O4(this, "delete", (i4, s3) => {
      this.isInitialized(), this.logger.debug("Deleting record"), this.logger.trace({ type: "method", method: "delete", id: s3 }), this.values.forEach((n5) => {
        if (n5.topic === i4) {
          if (typeof s3 < "u" && n5.id !== s3)
            return;
          this.records.delete(n5.id), this.events.emit(F.deleted, n5);
        }
      }), this.persist();
    }), O4(this, "exists", async (i4, s3) => (this.isInitialized(), this.records.has(s3) ? (await this.getRecord(s3)).topic === i4 : false)), O4(this, "on", (i4, s3) => {
      this.events.on(i4, s3);
    }), O4(this, "once", (i4, s3) => {
      this.events.once(i4, s3);
    }), O4(this, "off", (i4, s3) => {
      this.events.off(i4, s3);
    }), O4(this, "removeListener", (i4, s3) => {
      this.events.removeListener(i4, s3);
    }), this.logger = E2(t, this.name);
  }
  get context() {
    return y2(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  get size() {
    return this.records.size;
  }
  get keys() {
    return Array.from(this.records.keys());
  }
  get values() {
    return Array.from(this.records.values());
  }
  get pending() {
    const e2 = [];
    return this.values.forEach((t) => {
      if (typeof t.response < "u")
        return;
      const i4 = { topic: t.topic, request: formatJsonRpcRequest(t.request.method, t.request.params, t.id), chainId: t.chainId };
      return e2.push(i4);
    }), e2;
  }
  async setJsonRpcRecords(e2) {
    await this.core.storage.setItem(this.storageKey, e2);
  }
  async getJsonRpcRecords() {
    return await this.core.storage.getItem(this.storageKey);
  }
  getRecord(e2) {
    this.isInitialized();
    const t = this.records.get(e2);
    if (!t) {
      const { message: i4 } = Et("NO_MATCHING_KEY", `${this.name}: ${e2}`);
      throw new Error(i4);
    }
    return t;
  }
  async persist() {
    await this.setJsonRpcRecords(this.values), this.events.emit(F.sync);
  }
  async restore() {
    try {
      const e2 = await this.getJsonRpcRecords();
      if (typeof e2 > "u" || !e2.length)
        return;
      if (this.records.size) {
        const { message: t } = Et("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(t), new Error(t);
      }
      this.cached = e2, this.logger.debug(`Successfully Restored records for ${this.name}`), this.logger.trace({ type: "method", method: "restore", records: this.values });
    } catch (e2) {
      this.logger.debug(`Failed to Restore records for ${this.name}`), this.logger.error(e2);
    }
  }
  registerEventListeners() {
    this.events.on(F.created, (e2) => {
      const t = F.created;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, record: e2 });
    }), this.events.on(F.updated, (e2) => {
      const t = F.updated;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, record: e2 });
    }), this.events.on(F.deleted, (e2) => {
      const t = F.deleted;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, record: e2 });
    }), this.core.heartbeat.on(r.pulse, () => {
      this.cleanup();
    });
  }
  cleanup() {
    try {
      this.isInitialized();
      let e2 = false;
      this.records.forEach((t) => {
        (0, import_time2.toMiliseconds)(t.expiry || 0) - Date.now() <= 0 && (this.logger.info(`Deleting expired history log: ${t.id}`), this.records.delete(t.id), this.events.emit(F.deleted, t, false), e2 = true);
      }), e2 && this.persist();
    } catch (e2) {
      this.logger.warn(e2);
    }
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e2 } = Et("NOT_INITIALIZED", this.name);
      throw new Error(e2);
    }
  }
};
var Fo = Object.defineProperty;
var Mo = (r3, e2, t) => e2 in r3 ? Fo(r3, e2, { enumerable: true, configurable: true, writable: true, value: t }) : r3[e2] = t;
var A2 = (r3, e2, t) => Mo(r3, typeof e2 != "symbol" ? e2 + "" : e2, t);
var Ui = class extends S2 {
  constructor(e2, t) {
    super(e2, t), this.core = e2, this.logger = t, A2(this, "expirations", /* @__PURE__ */ new Map()), A2(this, "events", new import_events7.EventEmitter()), A2(this, "name", qt), A2(this, "version", Gt), A2(this, "cached", []), A2(this, "initialized", false), A2(this, "storagePrefix", B2), A2(this, "init", async () => {
      this.initialized || (this.logger.trace("Initialized"), await this.restore(), this.cached.forEach((i4) => this.expirations.set(i4.target, i4)), this.cached = [], this.registerEventListeners(), this.initialized = true);
    }), A2(this, "has", (i4) => {
      try {
        const s3 = this.formatTarget(i4);
        return typeof this.getExpiration(s3) < "u";
      } catch {
        return false;
      }
    }), A2(this, "set", (i4, s3) => {
      this.isInitialized();
      const n5 = this.formatTarget(i4), o4 = { target: n5, expiry: s3 };
      this.expirations.set(n5, o4), this.checkExpiry(n5, o4), this.events.emit(M2.created, { target: n5, expiration: o4 });
    }), A2(this, "get", (i4) => {
      this.isInitialized();
      const s3 = this.formatTarget(i4);
      return this.getExpiration(s3);
    }), A2(this, "del", (i4) => {
      if (this.isInitialized(), this.has(i4)) {
        const s3 = this.formatTarget(i4), n5 = this.getExpiration(s3);
        this.expirations.delete(s3), this.events.emit(M2.deleted, { target: s3, expiration: n5 });
      }
    }), A2(this, "on", (i4, s3) => {
      this.events.on(i4, s3);
    }), A2(this, "once", (i4, s3) => {
      this.events.once(i4, s3);
    }), A2(this, "off", (i4, s3) => {
      this.events.off(i4, s3);
    }), A2(this, "removeListener", (i4, s3) => {
      this.events.removeListener(i4, s3);
    }), this.logger = E2(t, this.name);
  }
  get context() {
    return y2(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  get length() {
    return this.expirations.size;
  }
  get keys() {
    return Array.from(this.expirations.keys());
  }
  get values() {
    return Array.from(this.expirations.values());
  }
  formatTarget(e2) {
    if (typeof e2 == "string")
      return ri(e2);
    if (typeof e2 == "number")
      return oi(e2);
    const { message: t } = Et("UNKNOWN_TYPE", `Target type: ${typeof e2}`);
    throw new Error(t);
  }
  async setExpirations(e2) {
    await this.core.storage.setItem(this.storageKey, e2);
  }
  async getExpirations() {
    return await this.core.storage.getItem(this.storageKey);
  }
  async persist() {
    await this.setExpirations(this.values), this.events.emit(M2.sync);
  }
  async restore() {
    try {
      const e2 = await this.getExpirations();
      if (typeof e2 > "u" || !e2.length)
        return;
      if (this.expirations.size) {
        const { message: t } = Et("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(t), new Error(t);
      }
      this.cached = e2, this.logger.debug(`Successfully Restored expirations for ${this.name}`), this.logger.trace({ type: "method", method: "restore", expirations: this.values });
    } catch (e2) {
      this.logger.debug(`Failed to Restore expirations for ${this.name}`), this.logger.error(e2);
    }
  }
  getExpiration(e2) {
    const t = this.expirations.get(e2);
    if (!t) {
      const { message: i4 } = Et("NO_MATCHING_KEY", `${this.name}: ${e2}`);
      throw this.logger.warn(i4), new Error(i4);
    }
    return t;
  }
  checkExpiry(e2, t) {
    const { expiry: i4 } = t;
    (0, import_time2.toMiliseconds)(i4) - Date.now() <= 0 && this.expire(e2, t);
  }
  expire(e2, t) {
    this.expirations.delete(e2), this.events.emit(M2.expired, { target: e2, expiration: t });
  }
  checkExpirations() {
    this.core.relayer.connected && this.expirations.forEach((e2, t) => this.checkExpiry(t, e2));
  }
  registerEventListeners() {
    this.core.heartbeat.on(r.pulse, () => this.checkExpirations()), this.events.on(M2.created, (e2) => {
      const t = M2.created;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, data: e2 }), this.persist();
    }), this.events.on(M2.expired, (e2) => {
      const t = M2.expired;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, data: e2 }), this.persist();
    }), this.events.on(M2.deleted, (e2) => {
      const t = M2.deleted;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, data: e2 }), this.persist();
    });
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e2 } = Et("NOT_INITIALIZED", this.name);
      throw new Error(e2);
    }
  }
};
var Ko = Object.defineProperty;
var Bo = (r3, e2, t) => e2 in r3 ? Ko(r3, e2, { enumerable: true, configurable: true, writable: true, value: t }) : r3[e2] = t;
var w3 = (r3, e2, t) => Bo(r3, typeof e2 != "symbol" ? e2 + "" : e2, t);
var Fi = class extends M {
  constructor(e2, t, i4) {
    super(e2, t, i4), this.core = e2, this.logger = t, this.store = i4, w3(this, "name", Wt), w3(this, "abortController"), w3(this, "isDevEnv"), w3(this, "verifyUrlV3", Yt), w3(this, "storagePrefix", B2), w3(this, "version", Le), w3(this, "publicKey"), w3(this, "fetchPromise"), w3(this, "init", async () => {
      var s3;
      this.isDevEnv || (this.publicKey = await this.store.getItem(this.storeKey), this.publicKey && (0, import_time2.toMiliseconds)((s3 = this.publicKey) == null ? void 0 : s3.expiresAt) < Date.now() && (this.logger.debug("verify v2 public key expired"), await this.removePublicKey()));
    }), w3(this, "register", async (s3) => {
      if (!zt() || this.isDevEnv)
        return;
      const n5 = window.location.origin, { id: o4, decryptedId: a3 } = s3, c6 = `${this.verifyUrlV3}/attestation?projectId=${this.core.projectId}&origin=${n5}&id=${o4}&decryptedId=${a3}`;
      try {
        const h5 = (0, import_window_getters.getDocument)(), l6 = this.startAbortTimer(import_time2.ONE_SECOND * 5), d4 = await new Promise((g3, _16) => {
          const u2 = () => {
            window.removeEventListener("message", x4), h5.body.removeChild(b4), _16("attestation aborted");
          };
          this.abortController.signal.addEventListener("abort", u2);
          const b4 = h5.createElement("iframe");
          b4.src = c6, b4.style.display = "none", b4.addEventListener("error", u2, { signal: this.abortController.signal });
          const x4 = (I4) => {
            if (I4.data && typeof I4.data == "string")
              try {
                const D2 = JSON.parse(I4.data);
                if (D2.type === "verify_attestation") {
                  if (sn(D2.attestation).payload.id !== o4)
                    return;
                  clearInterval(l6), h5.body.removeChild(b4), this.abortController.signal.removeEventListener("abort", u2), window.removeEventListener("message", x4), g3(D2.attestation === null ? "" : D2.attestation);
                }
              } catch (D2) {
                this.logger.warn(D2);
              }
          };
          h5.body.appendChild(b4), window.addEventListener("message", x4, { signal: this.abortController.signal });
        });
        return this.logger.debug("jwt attestation", d4), d4;
      } catch (h5) {
        this.logger.warn(h5);
      }
      return "";
    }), w3(this, "resolve", async (s3) => {
      if (this.isDevEnv)
        return "";
      const { attestationId: n5, hash: o4, encryptedId: a3 } = s3;
      if (n5 === "") {
        this.logger.debug("resolve: attestationId is empty, skipping");
        return;
      }
      if (n5) {
        if (sn(n5).payload.id !== a3)
          return;
        const h5 = await this.isValidJwtAttestation(n5);
        if (h5) {
          if (!h5.isVerified) {
            this.logger.warn("resolve: jwt attestation: origin url not verified");
            return;
          }
          return h5;
        }
      }
      if (!o4)
        return;
      const c6 = this.getVerifyUrl(s3 == null ? void 0 : s3.verifyUrl);
      return this.fetchAttestation(o4, c6);
    }), w3(this, "fetchAttestation", async (s3, n5) => {
      this.logger.debug(`resolving attestation: ${s3} from url: ${n5}`);
      const o4 = this.startAbortTimer(import_time2.ONE_SECOND * 5), a3 = await fetch(`${n5}/attestation/${s3}?v2Supported=true`, { signal: this.abortController.signal });
      return clearTimeout(o4), a3.status === 200 ? await a3.json() : void 0;
    }), w3(this, "getVerifyUrl", (s3) => {
      let n5 = s3 || ue;
      return Jt.includes(n5) || (this.logger.info(`verify url: ${n5}, not included in trusted list, assigning default: ${ue}`), n5 = ue), n5;
    }), w3(this, "fetchPublicKey", async () => {
      try {
        this.logger.debug(`fetching public key from: ${this.verifyUrlV3}`);
        const s3 = this.startAbortTimer(import_time2.FIVE_SECONDS), n5 = await fetch(`${this.verifyUrlV3}/public-key`, { signal: this.abortController.signal });
        return clearTimeout(s3), await n5.json();
      } catch (s3) {
        this.logger.warn(s3);
      }
    }), w3(this, "persistPublicKey", async (s3) => {
      this.logger.debug("persisting public key to local storage", s3), await this.store.setItem(this.storeKey, s3), this.publicKey = s3;
    }), w3(this, "removePublicKey", async () => {
      this.logger.debug("removing verify v2 public key from storage"), await this.store.removeItem(this.storeKey), this.publicKey = void 0;
    }), w3(this, "isValidJwtAttestation", async (s3) => {
      const n5 = await this.getPublicKey();
      try {
        if (n5)
          return this.validateAttestation(s3, n5);
      } catch (a3) {
        this.logger.error(a3), this.logger.warn("error validating attestation");
      }
      const o4 = await this.fetchAndPersistPublicKey();
      try {
        if (o4)
          return this.validateAttestation(s3, o4);
      } catch (a3) {
        this.logger.error(a3), this.logger.warn("error validating attestation");
      }
    }), w3(this, "getPublicKey", async () => this.publicKey ? this.publicKey : await this.fetchAndPersistPublicKey()), w3(this, "fetchAndPersistPublicKey", async () => {
      if (this.fetchPromise)
        return await this.fetchPromise, this.publicKey;
      this.fetchPromise = new Promise(async (n5) => {
        const o4 = await this.fetchPublicKey();
        o4 && (await this.persistPublicKey(o4), n5(o4));
      });
      const s3 = await this.fetchPromise;
      return this.fetchPromise = void 0, s3;
    }), w3(this, "validateAttestation", (s3, n5) => {
      const o4 = ta(s3, n5.publicKey), a3 = { hasExpired: (0, import_time2.toMiliseconds)(o4.exp) < Date.now(), payload: o4 };
      if (a3.hasExpired)
        throw this.logger.warn("resolve: jwt attestation expired"), new Error("JWT attestation expired");
      return { origin: a3.payload.origin, isScam: a3.payload.isScam, isVerified: a3.payload.isVerified };
    }), this.logger = E2(t, this.name), this.abortController = new AbortController(), this.isDevEnv = hi(), this.init();
  }
  get storeKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//verify:public:key";
  }
  get context() {
    return y2(this.logger);
  }
  startAbortTimer(e2) {
    return this.abortController = new AbortController(), setTimeout(() => this.abortController.abort(), (0, import_time2.toMiliseconds)(e2));
  }
};
var Vo = Object.defineProperty;
var qo = (r3, e2, t) => e2 in r3 ? Vo(r3, e2, { enumerable: true, configurable: true, writable: true, value: t }) : r3[e2] = t;
var Mi = (r3, e2, t) => qo(r3, typeof e2 != "symbol" ? e2 + "" : e2, t);
var Ki = class extends O3 {
  constructor(e2, t) {
    super(e2, t), this.projectId = e2, this.logger = t, Mi(this, "context", Xt), Mi(this, "registerDeviceToken", async (i4) => {
      const { clientId: s3, token: n5, notificationType: o4, enableEncrypted: a3 = false } = i4, c6 = `${Zt}/${this.projectId}/clients`;
      await fetch(c6, { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify({ client_id: s3, type: o4, token: n5, always_raw: a3 }) });
    }), this.logger = E2(t, this.context);
  }
};
var Go = Object.defineProperty;
var Bi = Object.getOwnPropertySymbols;
var Wo = Object.prototype.hasOwnProperty;
var Ho2 = Object.prototype.propertyIsEnumerable;
var Ze = (r3, e2, t) => e2 in r3 ? Go(r3, e2, { enumerable: true, configurable: true, writable: true, value: t }) : r3[e2] = t;
var be = (r3, e2) => {
  for (var t in e2 || (e2 = {}))
    Wo.call(e2, t) && Ze(r3, t, e2[t]);
  if (Bi)
    for (var t of Bi(e2))
      Ho2.call(e2, t) && Ze(r3, t, e2[t]);
  return r3;
};
var E3 = (r3, e2, t) => Ze(r3, typeof e2 != "symbol" ? e2 + "" : e2, t);
var Vi = class extends R {
  constructor(e2, t, i4 = true) {
    super(e2, t, i4), this.core = e2, this.logger = t, E3(this, "context", ei2), E3(this, "storagePrefix", B2), E3(this, "storageVersion", Qt2), E3(this, "events", /* @__PURE__ */ new Map()), E3(this, "shouldPersist", false), E3(this, "init", async () => {
      if (!hi())
        try {
          const s3 = { eventId: di(), timestamp: Date.now(), domain: this.getAppDomain(), props: { event: "INIT", type: "", properties: { client_id: await this.core.crypto.getClientId(), user_agent: cr(this.core.relayer.protocol, this.core.relayer.version, _e) } } };
          await this.sendEvent([s3]);
        } catch (s3) {
          this.logger.warn(s3);
        }
    }), E3(this, "createEvent", (s3) => {
      const { event: n5 = "ERROR", type: o4 = "", properties: { topic: a3, trace: c6 } } = s3, h5 = di(), l6 = this.core.projectId || "", d4 = Date.now(), g3 = be({ eventId: h5, timestamp: d4, props: { event: n5, type: o4, properties: { topic: a3, trace: c6 } }, bundleId: l6, domain: this.getAppDomain() }, this.setMethods(h5));
      return this.telemetryEnabled && (this.events.set(h5, g3), this.shouldPersist = true), g3;
    }), E3(this, "getEvent", (s3) => {
      const { eventId: n5, topic: o4 } = s3;
      if (n5)
        return this.events.get(n5);
      const a3 = Array.from(this.events.values()).find((c6) => c6.props.properties.topic === o4);
      if (a3)
        return be(be({}, a3), this.setMethods(a3.eventId));
    }), E3(this, "deleteEvent", (s3) => {
      const { eventId: n5 } = s3;
      this.events.delete(n5), this.shouldPersist = true;
    }), E3(this, "setEventListeners", () => {
      this.core.heartbeat.on(r.pulse, async () => {
        this.shouldPersist && await this.persist(), this.events.forEach((s3) => {
          (0, import_time2.fromMiliseconds)(Date.now()) - (0, import_time2.fromMiliseconds)(s3.timestamp) > ti && (this.events.delete(s3.eventId), this.shouldPersist = true);
        });
      });
    }), E3(this, "setMethods", (s3) => ({ addTrace: (n5) => this.addTrace(s3, n5), setError: (n5) => this.setError(s3, n5) })), E3(this, "addTrace", (s3, n5) => {
      const o4 = this.events.get(s3);
      o4 && (o4.props.properties.trace.push(n5), this.events.set(s3, o4), this.shouldPersist = true);
    }), E3(this, "setError", (s3, n5) => {
      const o4 = this.events.get(s3);
      o4 && (o4.props.type = n5, o4.timestamp = Date.now(), this.events.set(s3, o4), this.shouldPersist = true);
    }), E3(this, "persist", async () => {
      await this.core.storage.setItem(this.storageKey, Array.from(this.events.values())), this.shouldPersist = false;
    }), E3(this, "restore", async () => {
      try {
        const s3 = await this.core.storage.getItem(this.storageKey) || [];
        if (!s3.length)
          return;
        s3.forEach((n5) => {
          this.events.set(n5.eventId, be(be({}, n5), this.setMethods(n5.eventId)));
        });
      } catch (s3) {
        this.logger.warn(s3);
      }
    }), E3(this, "submit", async () => {
      if (!this.telemetryEnabled || this.events.size === 0)
        return;
      const s3 = [];
      for (const [n5, o4] of this.events)
        o4.props.type && s3.push(o4);
      if (s3.length !== 0)
        try {
          if ((await this.sendEvent(s3)).ok)
            for (const n5 of s3)
              this.events.delete(n5.eventId), this.shouldPersist = true;
        } catch (n5) {
          this.logger.warn(n5);
        }
    }), E3(this, "sendEvent", async (s3) => {
      const n5 = this.getAppDomain() ? "" : "&sp=desktop";
      return await fetch(`${ii2}?projectId=${this.core.projectId}&st=events_sdk&sv=js-${_e}${n5}`, { method: "POST", body: JSON.stringify(s3) });
    }), E3(this, "getAppDomain", () => sr().url), this.logger = E2(t, this.context), this.telemetryEnabled = i4, i4 ? this.restore().then(async () => {
      await this.submit(), this.setEventListeners();
    }) : this.persist();
  }
  get storageKey() {
    return this.storagePrefix + this.storageVersion + this.core.customStoragePrefix + "//" + this.context;
  }
};
var Yo = Object.defineProperty;
var qi = Object.getOwnPropertySymbols;
var Jo = Object.prototype.hasOwnProperty;
var Xo = Object.prototype.propertyIsEnumerable;
var Qe2 = (r3, e2, t) => e2 in r3 ? Yo(r3, e2, { enumerable: true, configurable: true, writable: true, value: t }) : r3[e2] = t;
var Gi = (r3, e2) => {
  for (var t in e2 || (e2 = {}))
    Jo.call(e2, t) && Qe2(r3, t, e2[t]);
  if (qi)
    for (var t of qi(e2))
      Xo.call(e2, t) && Qe2(r3, t, e2[t]);
  return r3;
};
var v4 = (r3, e2, t) => Qe2(r3, typeof e2 != "symbol" ? e2 + "" : e2, t);
var Te = class _Te extends h3 {
  constructor(e2) {
    var t;
    super(e2), v4(this, "protocol", ze), v4(this, "version", Le), v4(this, "name", he), v4(this, "relayUrl"), v4(this, "projectId"), v4(this, "customStoragePrefix"), v4(this, "events", new import_events7.EventEmitter()), v4(this, "logger"), v4(this, "heartbeat"), v4(this, "relayer"), v4(this, "crypto"), v4(this, "storage"), v4(this, "history"), v4(this, "expirer"), v4(this, "pairing"), v4(this, "verify"), v4(this, "echoClient"), v4(this, "linkModeSupportedApps"), v4(this, "eventClient"), v4(this, "initialized", false), v4(this, "logChunkController"), v4(this, "on", (a3, c6) => this.events.on(a3, c6)), v4(this, "once", (a3, c6) => this.events.once(a3, c6)), v4(this, "off", (a3, c6) => this.events.off(a3, c6)), v4(this, "removeListener", (a3, c6) => this.events.removeListener(a3, c6)), v4(this, "dispatchEnvelope", ({ topic: a3, message: c6, sessionExists: h5 }) => {
      if (!a3 || !c6)
        return;
      const l6 = { topic: a3, message: c6, publishedAt: Date.now(), transportType: Q.link_mode };
      this.relayer.onLinkMessageEvent(l6, { sessionExists: h5 });
    });
    const i4 = this.getGlobalCore(e2 == null ? void 0 : e2.customStoragePrefix);
    if (i4)
      try {
        return this.customStoragePrefix = i4.customStoragePrefix, this.logger = i4.logger, this.heartbeat = i4.heartbeat, this.crypto = i4.crypto, this.history = i4.history, this.expirer = i4.expirer, this.storage = i4.storage, this.relayer = i4.relayer, this.pairing = i4.pairing, this.verify = i4.verify, this.echoClient = i4.echoClient, this.linkModeSupportedApps = i4.linkModeSupportedApps, this.eventClient = i4.eventClient, this.initialized = i4.initialized, this.logChunkController = i4.logChunkController, i4;
      } catch (a3) {
        console.warn("Failed to copy global core", a3);
      }
    this.projectId = e2 == null ? void 0 : e2.projectId, this.relayUrl = (e2 == null ? void 0 : e2.relayUrl) || Ue, this.customStoragePrefix = e2 != null && e2.customStoragePrefix ? `:${e2.customStoragePrefix}` : "";
    const s3 = k2({ level: typeof (e2 == null ? void 0 : e2.logger) == "string" && e2.logger ? e2.logger : Et2.logger, name: he }), { logger: n5, chunkLoggerController: o4 } = A({ opts: s3, maxSizeInBytes: e2 == null ? void 0 : e2.maxLogBlobSizeInBytes, loggerOverride: e2 == null ? void 0 : e2.logger });
    this.logChunkController = o4, (t = this.logChunkController) != null && t.downloadLogsBlobInBrowser && (window.downloadLogsBlobInBrowser = async () => {
      var a3, c6;
      (a3 = this.logChunkController) != null && a3.downloadLogsBlobInBrowser && ((c6 = this.logChunkController) == null || c6.downloadLogsBlobInBrowser({ clientId: await this.crypto.getClientId() }));
    }), this.logger = E2(n5, this.name), this.heartbeat = new i(), this.crypto = new wi(this, this.logger, e2 == null ? void 0 : e2.keychain), this.history = new ji(this, this.logger), this.expirer = new Ui(this, this.logger), this.storage = e2 != null && e2.storage ? e2.storage : new h(Gi(Gi({}, It), e2 == null ? void 0 : e2.storageOptions)), this.relayer = new Oi({ core: this, logger: this.logger, relayUrl: this.relayUrl, projectId: this.projectId }), this.pairing = new ki(this, this.logger), this.verify = new Fi(this, this.logger, this.storage), this.echoClient = new Ki(this.projectId || "", this.logger), this.linkModeSupportedApps = [], this.eventClient = new Vi(this, this.logger, e2 == null ? void 0 : e2.telemetryEnabled), this.setGlobalCore(this);
  }
  static async init(e2) {
    const t = new _Te(e2);
    await t.initialize();
    const i4 = await t.crypto.getClientId();
    return await t.storage.setItem(jt, i4), t;
  }
  get context() {
    return y2(this.logger);
  }
  async start() {
    this.initialized || await this.initialize();
  }
  async getLogsBlob() {
    var e2;
    return (e2 = this.logChunkController) == null ? void 0 : e2.logsToBlob({ clientId: await this.crypto.getClientId() });
  }
  async addLinkModeSupportedApp(e2) {
    this.linkModeSupportedApps.includes(e2) || (this.linkModeSupportedApps.push(e2), await this.storage.setItem(Fe2, this.linkModeSupportedApps));
  }
  async initialize() {
    this.logger.trace("Initialized");
    try {
      await this.crypto.init(), await this.history.init(), await this.expirer.init(), await this.relayer.init(), await this.heartbeat.init(), await this.pairing.init(), this.linkModeSupportedApps = await this.storage.getItem(Fe2) || [], this.initialized = true, this.logger.info("Core Initialization Success");
    } catch (e2) {
      throw this.logger.warn(`Core Initialization Failure at epoch ${Date.now()}`, e2), this.logger.error(e2.message), e2;
    }
  }
  getGlobalCore(e2 = "") {
    try {
      if (this.isGlobalCoreDisabled())
        return;
      const t = `_walletConnectCore_${e2}`, i4 = `${t}_count`;
      return globalThis[i4] = (globalThis[i4] || 0) + 1, globalThis[i4] > 1 && console.warn(`WalletConnect Core is already initialized. This is probably a mistake and can lead to unexpected behavior. Init() was called ${globalThis[i4]} times.`), globalThis[t];
    } catch (t) {
      console.warn("Failed to get global WalletConnect core", t);
      return;
    }
  }
  setGlobalCore(e2) {
    var t;
    try {
      if (this.isGlobalCoreDisabled())
        return;
      const i4 = `_walletConnectCore_${((t = e2.opts) == null ? void 0 : t.customStoragePrefix) || ""}`;
      globalThis[i4] = e2;
    } catch (i4) {
      console.warn("Failed to set global WalletConnect core", i4);
    }
  }
  isGlobalCoreDisabled() {
    try {
      return typeof process < "u" && process.env.DISABLE_GLOBAL_CORE === "true";
    } catch {
      return true;
    }
  }
};
var Zo = Te;

// ../../node_modules/.pnpm/@walletconnect+sign-client@2.21.5/node_modules/@walletconnect/sign-client/dist/index.es.js
var import_events8 = __toESM(require_events());
var import_time3 = __toESM(require_cjs2());
var Ce2 = "wc";
var ke2 = 2;
var De2 = "client";
var me2 = `${Ce2}@${ke2}:${De2}:`;
var we = { name: De2, logger: "error", controller: false, relayUrl: "wss://relay.walletconnect.org" };
var Le2 = "WALLETCONNECT_DEEPLINK_CHOICE";
var ht = "proposal";
var Me3 = "Proposal expired";
var dt = "session";
var X = import_time3.SEVEN_DAYS;
var ut = "engine";
var N2 = { wc_sessionPropose: { req: { ttl: import_time3.FIVE_MINUTES, prompt: true, tag: 1100 }, res: { ttl: import_time3.FIVE_MINUTES, prompt: false, tag: 1101 }, reject: { ttl: import_time3.FIVE_MINUTES, prompt: false, tag: 1120 }, autoReject: { ttl: import_time3.FIVE_MINUTES, prompt: false, tag: 1121 } }, wc_sessionSettle: { req: { ttl: import_time3.FIVE_MINUTES, prompt: false, tag: 1102 }, res: { ttl: import_time3.FIVE_MINUTES, prompt: false, tag: 1103 } }, wc_sessionUpdate: { req: { ttl: import_time3.ONE_DAY, prompt: false, tag: 1104 }, res: { ttl: import_time3.ONE_DAY, prompt: false, tag: 1105 } }, wc_sessionExtend: { req: { ttl: import_time3.ONE_DAY, prompt: false, tag: 1106 }, res: { ttl: import_time3.ONE_DAY, prompt: false, tag: 1107 } }, wc_sessionRequest: { req: { ttl: import_time3.FIVE_MINUTES, prompt: true, tag: 1108 }, res: { ttl: import_time3.FIVE_MINUTES, prompt: false, tag: 1109 } }, wc_sessionEvent: { req: { ttl: import_time3.FIVE_MINUTES, prompt: true, tag: 1110 }, res: { ttl: import_time3.FIVE_MINUTES, prompt: false, tag: 1111 } }, wc_sessionDelete: { req: { ttl: import_time3.ONE_DAY, prompt: false, tag: 1112 }, res: { ttl: import_time3.ONE_DAY, prompt: false, tag: 1113 } }, wc_sessionPing: { req: { ttl: import_time3.ONE_DAY, prompt: false, tag: 1114 }, res: { ttl: import_time3.ONE_DAY, prompt: false, tag: 1115 } }, wc_sessionAuthenticate: { req: { ttl: import_time3.ONE_HOUR, prompt: true, tag: 1116 }, res: { ttl: import_time3.ONE_HOUR, prompt: false, tag: 1117 }, reject: { ttl: import_time3.FIVE_MINUTES, prompt: false, tag: 1118 }, autoReject: { ttl: import_time3.FIVE_MINUTES, prompt: false, tag: 1119 } } };
var _e2 = { min: import_time3.FIVE_MINUTES, max: import_time3.SEVEN_DAYS };
var $2 = { idle: "IDLE", active: "ACTIVE" };
var gt = { eth_sendTransaction: { key: "" }, eth_sendRawTransaction: { key: "" }, wallet_sendCalls: { key: "" }, solana_signTransaction: { key: "signature" }, solana_signAllTransactions: { key: "transactions" }, solana_signAndSendTransaction: { key: "signature" }, sui_signAndExecuteTransaction: { key: "digest" }, sui_signTransaction: { key: "" }, hedera_signAndExecuteTransaction: { key: "transactionId" }, hedera_executeTransaction: { key: "transactionId" }, near_signTransaction: { key: "" }, near_signTransactions: { key: "" }, tron_signTransaction: { key: "txID" }, xrpl_signTransaction: { key: "" }, xrpl_signTransactionFor: { key: "" }, algo_signTxn: { key: "" }, sendTransfer: { key: "txid" }, stacks_stxTransfer: { key: "txId" }, polkadot_signTransaction: { key: "" }, cosmos_signDirect: { key: "" } };
var yt = "request";
var mt = ["wc_sessionPropose", "wc_sessionRequest", "wc_authRequest", "wc_sessionAuthenticate"];
var wt = "wc";
var _t = "auth";
var Et3 = "authKeys";
var ft = "pairingTopics";
var St2 = "requests";
var ae = `${wt}@${1.5}:${_t}:`;
var ce = `${ae}:PUB_KEY`;
var Os = Object.defineProperty;
var bs = Object.defineProperties;
var As = Object.getOwnPropertyDescriptors;
var Rt2 = Object.getOwnPropertySymbols;
var xs = Object.prototype.hasOwnProperty;
var Vs2 = Object.prototype.propertyIsEnumerable;
var $e = (S4, o4, t) => o4 in S4 ? Os(S4, o4, { enumerable: true, configurable: true, writable: true, value: t }) : S4[o4] = t;
var I3 = (S4, o4) => {
  for (var t in o4 || (o4 = {}))
    xs.call(o4, t) && $e(S4, t, o4[t]);
  if (Rt2)
    for (var t of Rt2(o4))
      Vs2.call(o4, t) && $e(S4, t, o4[t]);
  return S4;
};
var x3 = (S4, o4) => bs(S4, As(o4));
var c5 = (S4, o4, t) => $e(S4, typeof o4 != "symbol" ? o4 + "" : o4, t);
var Cs = class extends V {
  constructor(o4) {
    super(o4), c5(this, "name", ut), c5(this, "events", new import_events8.default()), c5(this, "initialized", false), c5(this, "requestQueue", { state: $2.idle, queue: [] }), c5(this, "sessionRequestQueue", { state: $2.idle, queue: [] }), c5(this, "emittedSessionRequests", new gi({ limit: 500 })), c5(this, "requestQueueDelay", import_time3.ONE_SECOND), c5(this, "expectedPairingMethodMap", /* @__PURE__ */ new Map()), c5(this, "recentlyDeletedMap", /* @__PURE__ */ new Map()), c5(this, "recentlyDeletedLimit", 200), c5(this, "relayMessageCache", []), c5(this, "pendingSessions", /* @__PURE__ */ new Map()), c5(this, "init", async () => {
      this.initialized || (await this.cleanup(), this.registerRelayerEvents(), this.registerExpirerEvents(), this.registerPairingEvents(), await this.registerLinkModeListeners(), this.client.core.pairing.register({ methods: Object.keys(N2) }), this.initialized = true, setTimeout(async () => {
        await this.processPendingMessageEvents(), this.sessionRequestQueue.queue = this.getPendingSessionRequests(), this.processSessionRequestQueue();
      }, (0, import_time3.toMiliseconds)(this.requestQueueDelay)));
    }), c5(this, "connect", async (t) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow();
      const e2 = x3(I3({}, t), { requiredNamespaces: t.requiredNamespaces || {}, optionalNamespaces: t.optionalNamespaces || {} });
      await this.isValidConnect(e2), e2.optionalNamespaces = ba(e2.requiredNamespaces, e2.optionalNamespaces), e2.requiredNamespaces = {};
      const { pairingTopic: s3, requiredNamespaces: i4, optionalNamespaces: r3, sessionProperties: n5, scopedProperties: a3, relays: l6 } = e2;
      let p4 = s3, h5, u2 = false;
      try {
        if (p4) {
          const T3 = this.client.core.pairing.pairings.get(p4);
          this.client.logger.warn("connect() with existing pairing topic is deprecated and will be removed in the next major release."), u2 = T3.active;
        }
      } catch (T3) {
        throw this.client.logger.error(`connect() -> pairing.get(${p4}) failed`), T3;
      }
      if (!p4 || !u2) {
        const { topic: T3, uri: K2 } = await this.client.core.pairing.create();
        p4 = T3, h5 = K2;
      }
      if (!p4) {
        const { message: T3 } = Et("NO_MATCHING_KEY", `connect() pairing topic: ${p4}`);
        throw new Error(T3);
      }
      const d4 = await this.client.core.crypto.generateKeyPair(), w4 = N2.wc_sessionPropose.req.ttl || import_time3.FIVE_MINUTES, m3 = ii(w4), y5 = x3(I3(I3({ requiredNamespaces: i4, optionalNamespaces: r3, relays: l6 ?? [{ protocol: xt }], proposer: { publicKey: d4, metadata: this.client.metadata }, expiryTimestamp: m3, pairingTopic: p4 }, n5 && { sessionProperties: n5 }), a3 && { scopedProperties: a3 }), { id: payloadId() }), E4 = ci("session_connect", y5.id), { reject: _16, resolve: V3, done: C3 } = ei(w4, Me3), v5 = ({ id: T3 }) => {
        T3 === y5.id && (this.client.events.off("proposal_expire", v5), this.pendingSessions.delete(y5.id), this.events.emit(E4, { error: { message: Me3, code: 0 } }));
      };
      return this.client.events.on("proposal_expire", v5), this.events.once(E4, ({ error: T3, session: K2 }) => {
        this.client.events.off("proposal_expire", v5), T3 ? _16(T3) : K2 && V3(K2);
      }), await this.sendRequest({ topic: p4, method: "wc_sessionPropose", params: y5, throwOnFailedPublish: true, clientRpcId: y5.id }), await this.setProposal(y5.id, y5), { uri: h5, approval: C3 };
    }), c5(this, "pair", async (t) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow();
      try {
        return await this.client.core.pairing.pair(t);
      } catch (e2) {
        throw this.client.logger.error("pair() failed"), e2;
      }
    }), c5(this, "approve", async (t) => {
      var e2, s3, i4;
      const r3 = this.client.core.eventClient.createEvent({ properties: { topic: (e2 = t == null ? void 0 : t.id) == null ? void 0 : e2.toString(), trace: [tr.session_approve_started] } });
      try {
        this.isInitialized(), await this.confirmOnlineStateOrThrow();
      } catch (q) {
        throw r3.setError(ir.no_internet_connection), q;
      }
      try {
        await this.isValidProposalId(t == null ? void 0 : t.id);
      } catch (q) {
        throw this.client.logger.error(`approve() -> proposal.get(${t == null ? void 0 : t.id}) failed`), r3.setError(ir.proposal_not_found), q;
      }
      try {
        await this.isValidApprove(t);
      } catch (q) {
        throw this.client.logger.error("approve() -> isValidApprove() failed"), r3.setError(ir.session_approve_namespace_validation_failure), q;
      }
      const { id: n5, relayProtocol: a3, namespaces: l6, sessionProperties: p4, scopedProperties: h5, sessionConfig: u2 } = t, d4 = this.client.proposal.get(n5);
      this.client.core.eventClient.deleteEvent({ eventId: r3.eventId });
      const { pairingTopic: w4, proposer: m3, requiredNamespaces: y5, optionalNamespaces: E4 } = d4;
      let _16 = (s3 = this.client.core.eventClient) == null ? void 0 : s3.getEvent({ topic: w4 });
      _16 || (_16 = (i4 = this.client.core.eventClient) == null ? void 0 : i4.createEvent({ type: tr.session_approve_started, properties: { topic: w4, trace: [tr.session_approve_started, tr.session_namespaces_validation_success] } }));
      const V3 = await this.client.core.crypto.generateKeyPair(), C3 = m3.publicKey, v5 = await this.client.core.crypto.generateSharedKey(V3, C3), T3 = I3(I3(I3({ relay: { protocol: a3 ?? "irn" }, namespaces: l6, controller: { publicKey: V3, metadata: this.client.metadata }, expiry: ii(X) }, p4 && { sessionProperties: p4 }), h5 && { scopedProperties: h5 }), u2 && { sessionConfig: u2 }), K2 = Q.relay;
      _16.addTrace(tr.subscribing_session_topic);
      try {
        await this.client.core.relayer.subscribe(v5, { transportType: K2 });
      } catch (q) {
        throw _16.setError(ir.subscribe_session_topic_failure), q;
      }
      _16.addTrace(tr.subscribe_session_topic_success);
      const fe2 = x3(I3({}, T3), { topic: v5, requiredNamespaces: y5, optionalNamespaces: E4, pairingTopic: w4, acknowledged: false, self: T3.controller, peer: { publicKey: m3.publicKey, metadata: m3.metadata }, controller: V3, transportType: Q.relay });
      await this.client.session.set(v5, fe2), _16.addTrace(tr.store_session);
      try {
        _16.addTrace(tr.publishing_session_settle), await this.sendRequest({ topic: v5, method: "wc_sessionSettle", params: T3, throwOnFailedPublish: true }).catch((q) => {
          throw _16 == null ? void 0 : _16.setError(ir.session_settle_publish_failure), q;
        }), _16.addTrace(tr.session_settle_publish_success), _16.addTrace(tr.publishing_session_approve), await this.sendResult({ id: n5, topic: w4, result: { relay: { protocol: a3 ?? "irn" }, responderPublicKey: V3 }, throwOnFailedPublish: true }).catch((q) => {
          throw _16 == null ? void 0 : _16.setError(ir.session_approve_publish_failure), q;
        }), _16.addTrace(tr.session_approve_publish_success);
      } catch (q) {
        throw this.client.logger.error(q), this.client.session.delete(v5, Kt("USER_DISCONNECTED")), await this.client.core.relayer.unsubscribe(v5), q;
      }
      return this.client.core.eventClient.deleteEvent({ eventId: _16.eventId }), await this.client.core.pairing.updateMetadata({ topic: w4, metadata: m3.metadata }), await this.deleteProposal(n5), await this.client.core.pairing.activate({ topic: w4 }), await this.setExpiry(v5, ii(X)), { topic: v5, acknowledged: () => Promise.resolve(this.client.session.get(v5)) };
    }), c5(this, "reject", async (t) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow();
      try {
        await this.isValidReject(t);
      } catch (r3) {
        throw this.client.logger.error("reject() -> isValidReject() failed"), r3;
      }
      const { id: e2, reason: s3 } = t;
      let i4;
      try {
        i4 = this.client.proposal.get(e2).pairingTopic;
      } catch (r3) {
        throw this.client.logger.error(`reject() -> proposal.get(${e2}) failed`), r3;
      }
      i4 && await this.sendError({ id: e2, topic: i4, error: s3, rpcOpts: N2.wc_sessionPropose.reject }), await this.deleteProposal(e2);
    }), c5(this, "update", async (t) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow();
      try {
        await this.isValidUpdate(t);
      } catch (h5) {
        throw this.client.logger.error("update() -> isValidUpdate() failed"), h5;
      }
      const { topic: e2, namespaces: s3 } = t, { done: i4, resolve: r3, reject: n5 } = ei(), a3 = payloadId(), l6 = getBigIntRpcId().toString(), p4 = this.client.session.get(e2).namespaces;
      return this.events.once(ci("session_update", a3), ({ error: h5 }) => {
        h5 ? n5(h5) : r3();
      }), await this.client.session.update(e2, { namespaces: s3 }), await this.sendRequest({ topic: e2, method: "wc_sessionUpdate", params: { namespaces: s3 }, throwOnFailedPublish: true, clientRpcId: a3, relayRpcId: l6 }).catch((h5) => {
        this.client.logger.error(h5), this.client.session.update(e2, { namespaces: p4 }), n5(h5);
      }), { acknowledged: i4 };
    }), c5(this, "extend", async (t) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow();
      try {
        await this.isValidExtend(t);
      } catch (a3) {
        throw this.client.logger.error("extend() -> isValidExtend() failed"), a3;
      }
      const { topic: e2 } = t, s3 = payloadId(), { done: i4, resolve: r3, reject: n5 } = ei();
      return this.events.once(ci("session_extend", s3), ({ error: a3 }) => {
        a3 ? n5(a3) : r3();
      }), await this.setExpiry(e2, ii(X)), this.sendRequest({ topic: e2, method: "wc_sessionExtend", params: {}, clientRpcId: s3, throwOnFailedPublish: true }).catch((a3) => {
        n5(a3);
      }), { acknowledged: i4 };
    }), c5(this, "request", async (t) => {
      this.isInitialized();
      try {
        await this.isValidRequest(t);
      } catch (y5) {
        throw this.client.logger.error("request() -> isValidRequest() failed"), y5;
      }
      const { chainId: e2, request: s3, topic: i4, expiry: r3 = N2.wc_sessionRequest.req.ttl } = t, n5 = this.client.session.get(i4);
      (n5 == null ? void 0 : n5.transportType) === Q.relay && await this.confirmOnlineStateOrThrow();
      const a3 = payloadId(), l6 = getBigIntRpcId().toString(), { done: p4, resolve: h5, reject: u2 } = ei(r3, "Request expired. Please try again.");
      this.events.once(ci("session_request", a3), ({ error: y5, result: E4 }) => {
        y5 ? u2(y5) : h5(E4);
      });
      const d4 = "wc_sessionRequest", w4 = this.getAppLinkIfEnabled(n5.peer.metadata, n5.transportType);
      if (w4)
        return await this.sendRequest({ clientRpcId: a3, relayRpcId: l6, topic: i4, method: d4, params: { request: x3(I3({}, s3), { expiryTimestamp: ii(r3) }), chainId: e2 }, expiry: r3, throwOnFailedPublish: true, appLink: w4 }).catch((y5) => u2(y5)), this.client.events.emit("session_request_sent", { topic: i4, request: s3, chainId: e2, id: a3 }), await p4();
      const m3 = { request: x3(I3({}, s3), { expiryTimestamp: ii(r3) }), chainId: e2 };
      return await Promise.all([new Promise(async (y5) => {
        await this.sendRequest({ clientRpcId: a3, relayRpcId: l6, topic: i4, method: d4, params: m3, expiry: r3, throwOnFailedPublish: true, tvf: this.getTVFParams(a3, m3) }).catch((E4) => u2(E4)), this.client.events.emit("session_request_sent", { topic: i4, request: s3, chainId: e2, id: a3 }), y5();
      }), new Promise(async (y5) => {
        var E4;
        if (!((E4 = n5.sessionConfig) != null && E4.disableDeepLink)) {
          const _16 = await ui(this.client.core.storage, Le2);
          await ai({ id: a3, topic: i4, wcDeepLink: _16 });
        }
        y5();
      }), p4()]).then((y5) => y5[2]);
    }), c5(this, "respond", async (t) => {
      this.isInitialized(), await this.isValidRespond(t);
      const { topic: e2, response: s3 } = t, { id: i4 } = s3, r3 = this.client.session.get(e2);
      r3.transportType === Q.relay && await this.confirmOnlineStateOrThrow();
      const n5 = this.getAppLinkIfEnabled(r3.peer.metadata, r3.transportType);
      isJsonRpcResult(s3) ? await this.sendResult({ id: i4, topic: e2, result: s3.result, throwOnFailedPublish: true, appLink: n5 }) : isJsonRpcError(s3) && await this.sendError({ id: i4, topic: e2, error: s3.error, appLink: n5 }), this.cleanupAfterResponse(t);
    }), c5(this, "ping", async (t) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow();
      try {
        await this.isValidPing(t);
      } catch (s3) {
        throw this.client.logger.error("ping() -> isValidPing() failed"), s3;
      }
      const { topic: e2 } = t;
      if (this.client.session.keys.includes(e2)) {
        const s3 = payloadId(), i4 = getBigIntRpcId().toString(), { done: r3, resolve: n5, reject: a3 } = ei();
        this.events.once(ci("session_ping", s3), ({ error: l6 }) => {
          l6 ? a3(l6) : n5();
        }), await Promise.all([this.sendRequest({ topic: e2, method: "wc_sessionPing", params: {}, throwOnFailedPublish: true, clientRpcId: s3, relayRpcId: i4 }), r3()]);
      } else
        this.client.core.pairing.pairings.keys.includes(e2) && (this.client.logger.warn("ping() on pairing topic is deprecated and will be removed in the next major release."), await this.client.core.pairing.ping({ topic: e2 }));
    }), c5(this, "emit", async (t) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow(), await this.isValidEmit(t);
      const { topic: e2, event: s3, chainId: i4 } = t, r3 = getBigIntRpcId().toString(), n5 = payloadId();
      await this.sendRequest({ topic: e2, method: "wc_sessionEvent", params: { event: s3, chainId: i4 }, throwOnFailedPublish: true, relayRpcId: r3, clientRpcId: n5 });
    }), c5(this, "disconnect", async (t) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow(), await this.isValidDisconnect(t);
      const { topic: e2 } = t;
      if (this.client.session.keys.includes(e2))
        await this.sendRequest({ topic: e2, method: "wc_sessionDelete", params: Kt("USER_DISCONNECTED"), throwOnFailedPublish: true }), await this.deleteSession({ topic: e2, emitEvent: false });
      else if (this.client.core.pairing.pairings.keys.includes(e2))
        await this.client.core.pairing.disconnect({ topic: e2 });
      else {
        const { message: s3 } = Et("MISMATCHED_TOPIC", `Session or pairing topic not found: ${e2}`);
        throw new Error(s3);
      }
    }), c5(this, "find", (t) => (this.isInitialized(), this.client.session.getAll().filter((e2) => ya(e2, t)))), c5(this, "getPendingSessionRequests", () => this.client.pendingRequest.getAll()), c5(this, "authenticate", async (t, e2) => {
      var s3;
      this.isInitialized(), this.isValidAuthenticate(t);
      const i4 = e2 && this.client.core.linkModeSupportedApps.includes(e2) && ((s3 = this.client.metadata.redirect) == null ? void 0 : s3.linkMode), r3 = i4 ? Q.link_mode : Q.relay;
      r3 === Q.relay && await this.confirmOnlineStateOrThrow();
      const { chains: n5, statement: a3 = "", uri: l6, domain: p4, nonce: h5, type: u2, exp: d4, nbf: w4, methods: m3 = [], expiry: y5 } = t, E4 = [...t.resources || []], { topic: _16, uri: V3 } = await this.client.core.pairing.create({ methods: ["wc_sessionAuthenticate"], transportType: r3 });
      this.client.logger.info({ message: "Generated new pairing", pairing: { topic: _16, uri: V3 } });
      const C3 = await this.client.core.crypto.generateKeyPair(), v5 = Fc(C3);
      if (await Promise.all([this.client.auth.authKeys.set(ce, { responseTopic: v5, publicKey: C3 }), this.client.auth.pairingTopics.set(v5, { topic: v5, pairingTopic: _16 })]), await this.client.core.relayer.subscribe(v5, { transportType: r3 }), this.client.logger.info(`sending request to new pairing topic: ${_16}`), m3.length > 0) {
        const { namespace: O5 } = Fe(n5[0]);
        let k5 = Ef(O5, "request", m3);
        Oe(E4) && (k5 = Bf(k5, E4.pop())), E4.push(k5);
      }
      const T3 = y5 && y5 > N2.wc_sessionAuthenticate.req.ttl ? y5 : N2.wc_sessionAuthenticate.req.ttl, K2 = { authPayload: { type: u2 ?? "caip122", chains: n5, statement: a3, aud: l6, domain: p4, version: "1", nonce: h5, iat: (/* @__PURE__ */ new Date()).toISOString(), exp: d4, nbf: w4, resources: E4 }, requester: { publicKey: C3, metadata: this.client.metadata }, expiryTimestamp: ii(T3) }, fe2 = { eip155: { chains: n5, methods: [.../* @__PURE__ */ new Set(["personal_sign", ...m3])], events: ["chainChanged", "accountsChanged"] } }, q = { requiredNamespaces: {}, optionalNamespaces: fe2, relays: [{ protocol: "irn" }], pairingTopic: _16, proposer: { publicKey: C3, metadata: this.client.metadata }, expiryTimestamp: ii(N2.wc_sessionPropose.req.ttl), id: payloadId() }, { done: It2, resolve: Ue2, reject: Se2 } = ei(T3, "Request expired"), te = payloadId(), le2 = ci("session_connect", q.id), Re = ci("session_request", te), pe2 = async ({ error: O5, session: k5 }) => {
        this.events.off(Re, ve), O5 ? Se2(O5) : k5 && Ue2({ session: k5 });
      }, ve = async (O5) => {
        var k5, Ge2, je2;
        if (await this.deletePendingAuthRequest(te, { message: "fulfilled", code: 0 }), O5.error) {
          const ie2 = Kt("WC_METHOD_UNSUPPORTED", "wc_sessionAuthenticate");
          return O5.error.code === ie2.code ? void 0 : (this.events.off(le2, pe2), Se2(O5.error.message));
        }
        await this.deleteProposal(q.id), this.events.off(le2, pe2);
        const { cacaos: Fe3, responder: Q2 } = O5.result, Te2 = [], Qe3 = [];
        for (const ie2 of Fe3) {
          await yf({ cacao: ie2, projectId: this.client.core.projectId }) || (this.client.logger.error(ie2, "Signature verification failed"), Se2(Kt("SESSION_SETTLEMENT_FAILED", "Signature verification failed")));
          const { p: qe2 } = ie2, Pe2 = Oe(qe2.resources), He2 = [Vr(qe2.iss)], Tt2 = dn(qe2.iss);
          if (Pe2) {
            const Ne = If(Pe2), qt2 = Af(Pe2);
            Te2.push(...Ne), He2.push(...qt2);
          }
          for (const Ne of He2)
            Qe3.push(`${Ne}:${Tt2}`);
        }
        const se2 = await this.client.core.crypto.generateSharedKey(C3, Q2.publicKey);
        let he2;
        Te2.length > 0 && (he2 = { topic: se2, acknowledged: true, self: { publicKey: C3, metadata: this.client.metadata }, peer: Q2, controller: Q2.publicKey, expiry: ii(X), requiredNamespaces: {}, optionalNamespaces: {}, relay: { protocol: "irn" }, pairingTopic: _16, namespaces: ga([...new Set(Te2)], [...new Set(Qe3)]), transportType: r3 }, await this.client.core.relayer.subscribe(se2, { transportType: r3 }), await this.client.session.set(se2, he2), _16 && await this.client.core.pairing.updateMetadata({ topic: _16, metadata: Q2.metadata }), he2 = this.client.session.get(se2)), (k5 = this.client.metadata.redirect) != null && k5.linkMode && (Ge2 = Q2.metadata.redirect) != null && Ge2.linkMode && (je2 = Q2.metadata.redirect) != null && je2.universal && e2 && (this.client.core.addLinkModeSupportedApp(Q2.metadata.redirect.universal), this.client.session.update(se2, { transportType: Q.link_mode })), Ue2({ auths: Fe3, session: he2 });
      };
      this.events.once(le2, pe2), this.events.once(Re, ve);
      let Ie2;
      try {
        if (i4) {
          const O5 = formatJsonRpcRequest("wc_sessionAuthenticate", K2, te);
          this.client.core.history.set(_16, O5);
          const k5 = await this.client.core.crypto.encode("", O5, { type: ge, encoding: De });
          Ie2 = sa(e2, _16, k5);
        } else
          await Promise.all([this.sendRequest({ topic: _16, method: "wc_sessionAuthenticate", params: K2, expiry: t.expiry, throwOnFailedPublish: true, clientRpcId: te }), this.sendRequest({ topic: _16, method: "wc_sessionPropose", params: q, expiry: N2.wc_sessionPropose.req.ttl, throwOnFailedPublish: true, clientRpcId: q.id })]);
      } catch (O5) {
        throw this.events.off(le2, pe2), this.events.off(Re, ve), O5;
      }
      return await this.setProposal(q.id, q), await this.setAuthRequest(te, { request: x3(I3({}, K2), { verifyContext: {} }), pairingTopic: _16, transportType: r3 }), { uri: Ie2 ?? V3, response: It2 };
    }), c5(this, "approveSessionAuthenticate", async (t) => {
      const { id: e2, auths: s3 } = t, i4 = this.client.core.eventClient.createEvent({ properties: { topic: e2.toString(), trace: [sr2.authenticated_session_approve_started] } });
      try {
        this.isInitialized();
      } catch (y5) {
        throw i4.setError(rr.no_internet_connection), y5;
      }
      const r3 = this.getPendingAuthRequest(e2);
      if (!r3)
        throw i4.setError(rr.authenticated_session_pending_request_not_found), new Error(`Could not find pending auth request with id ${e2}`);
      const n5 = r3.transportType || Q.relay;
      n5 === Q.relay && await this.confirmOnlineStateOrThrow();
      const a3 = r3.requester.publicKey, l6 = await this.client.core.crypto.generateKeyPair(), p4 = Fc(a3), h5 = { type: ee, receiverPublicKey: a3, senderPublicKey: l6 }, u2 = [], d4 = [];
      for (const y5 of s3) {
        if (!await yf({ cacao: y5, projectId: this.client.core.projectId })) {
          i4.setError(rr.invalid_cacao);
          const v5 = Kt("SESSION_SETTLEMENT_FAILED", "Signature verification failed");
          throw await this.sendError({ id: e2, topic: p4, error: v5, encodeOpts: h5 }), new Error(v5.message);
        }
        i4.addTrace(sr2.cacaos_verified);
        const { p: E4 } = y5, _16 = Oe(E4.resources), V3 = [Vr(E4.iss)], C3 = dn(E4.iss);
        if (_16) {
          const v5 = If(_16), T3 = Af(_16);
          u2.push(...v5), V3.push(...T3);
        }
        for (const v5 of V3)
          d4.push(`${v5}:${C3}`);
      }
      const w4 = await this.client.core.crypto.generateSharedKey(l6, a3);
      i4.addTrace(sr2.create_authenticated_session_topic);
      let m3;
      if ((u2 == null ? void 0 : u2.length) > 0) {
        m3 = { topic: w4, acknowledged: true, self: { publicKey: l6, metadata: this.client.metadata }, peer: { publicKey: a3, metadata: r3.requester.metadata }, controller: a3, expiry: ii(X), authentication: s3, requiredNamespaces: {}, optionalNamespaces: {}, relay: { protocol: "irn" }, pairingTopic: r3.pairingTopic, namespaces: ga([...new Set(u2)], [...new Set(d4)]), transportType: n5 }, i4.addTrace(sr2.subscribing_authenticated_session_topic);
        try {
          await this.client.core.relayer.subscribe(w4, { transportType: n5 });
        } catch (y5) {
          throw i4.setError(rr.subscribe_authenticated_session_topic_failure), y5;
        }
        i4.addTrace(sr2.subscribe_authenticated_session_topic_success), await this.client.session.set(w4, m3), i4.addTrace(sr2.store_authenticated_session), await this.client.core.pairing.updateMetadata({ topic: r3.pairingTopic, metadata: r3.requester.metadata });
      }
      i4.addTrace(sr2.publishing_authenticated_session_approve);
      try {
        await this.sendResult({ topic: p4, id: e2, result: { cacaos: s3, responder: { publicKey: l6, metadata: this.client.metadata } }, encodeOpts: h5, throwOnFailedPublish: true, appLink: this.getAppLinkIfEnabled(r3.requester.metadata, n5) });
      } catch (y5) {
        throw i4.setError(rr.authenticated_session_approve_publish_failure), y5;
      }
      return await this.client.auth.requests.delete(e2, { message: "fulfilled", code: 0 }), await this.client.core.pairing.activate({ topic: r3.pairingTopic }), this.client.core.eventClient.deleteEvent({ eventId: i4.eventId }), { session: m3 };
    }), c5(this, "rejectSessionAuthenticate", async (t) => {
      this.isInitialized();
      const { id: e2, reason: s3 } = t, i4 = this.getPendingAuthRequest(e2);
      if (!i4)
        throw new Error(`Could not find pending auth request with id ${e2}`);
      i4.transportType === Q.relay && await this.confirmOnlineStateOrThrow();
      const r3 = i4.requester.publicKey, n5 = await this.client.core.crypto.generateKeyPair(), a3 = Fc(r3), l6 = { type: ee, receiverPublicKey: r3, senderPublicKey: n5 };
      await this.sendError({ id: e2, topic: a3, error: s3, encodeOpts: l6, rpcOpts: N2.wc_sessionAuthenticate.reject, appLink: this.getAppLinkIfEnabled(i4.requester.metadata, i4.transportType) }), await this.client.auth.requests.delete(e2, { message: "rejected", code: 0 }), await this.deleteProposal(e2);
    }), c5(this, "formatAuthMessage", (t) => {
      this.isInitialized();
      const { request: e2, iss: s3 } = t;
      return qr(e2, s3);
    }), c5(this, "processRelayMessageCache", () => {
      setTimeout(async () => {
        if (this.relayMessageCache.length !== 0)
          for (; this.relayMessageCache.length > 0; )
            try {
              const t = this.relayMessageCache.shift();
              t && await this.onRelayMessage(t);
            } catch (t) {
              this.client.logger.error(t);
            }
      }, 50);
    }), c5(this, "cleanupDuplicatePairings", async (t) => {
      if (t.pairingTopic)
        try {
          const e2 = this.client.core.pairing.pairings.get(t.pairingTopic), s3 = this.client.core.pairing.pairings.getAll().filter((i4) => {
            var r3, n5;
            return ((r3 = i4.peerMetadata) == null ? void 0 : r3.url) && ((n5 = i4.peerMetadata) == null ? void 0 : n5.url) === t.peer.metadata.url && i4.topic && i4.topic !== e2.topic;
          });
          if (s3.length === 0)
            return;
          this.client.logger.info(`Cleaning up ${s3.length} duplicate pairing(s)`), await Promise.all(s3.map((i4) => this.client.core.pairing.disconnect({ topic: i4.topic }))), this.client.logger.info("Duplicate pairings clean up finished");
        } catch (e2) {
          this.client.logger.error(e2);
        }
    }), c5(this, "deleteSession", async (t) => {
      var e2;
      const { topic: s3, expirerHasDeleted: i4 = false, emitEvent: r3 = true, id: n5 = 0 } = t, { self: a3 } = this.client.session.get(s3);
      await this.client.core.relayer.unsubscribe(s3), await this.client.session.delete(s3, Kt("USER_DISCONNECTED")), this.addToRecentlyDeleted(s3, "session"), this.client.core.crypto.keychain.has(a3.publicKey) && await this.client.core.crypto.deleteKeyPair(a3.publicKey), this.client.core.crypto.keychain.has(s3) && await this.client.core.crypto.deleteSymKey(s3), i4 || this.client.core.expirer.del(s3), this.client.core.storage.removeItem(Le2).catch((l6) => this.client.logger.warn(l6)), this.getPendingSessionRequests().forEach((l6) => {
        l6.topic === s3 && this.deletePendingSessionRequest(l6.id, Kt("USER_DISCONNECTED"));
      }), s3 === ((e2 = this.sessionRequestQueue.queue[0]) == null ? void 0 : e2.topic) && (this.sessionRequestQueue.state = $2.idle), r3 && this.client.events.emit("session_delete", { id: n5, topic: s3 });
    }), c5(this, "deleteProposal", async (t, e2) => {
      if (e2)
        try {
          const s3 = this.client.proposal.get(t), i4 = this.client.core.eventClient.getEvent({ topic: s3.pairingTopic });
          i4 == null ? void 0 : i4.setError(ir.proposal_expired);
        } catch {
        }
      await Promise.all([this.client.proposal.delete(t, Kt("USER_DISCONNECTED")), e2 ? Promise.resolve() : this.client.core.expirer.del(t)]), this.addToRecentlyDeleted(t, "proposal");
    }), c5(this, "deletePendingSessionRequest", async (t, e2, s3 = false) => {
      await Promise.all([this.client.pendingRequest.delete(t, e2), s3 ? Promise.resolve() : this.client.core.expirer.del(t)]), this.addToRecentlyDeleted(t, "request"), this.sessionRequestQueue.queue = this.sessionRequestQueue.queue.filter((i4) => i4.id !== t), s3 && (this.sessionRequestQueue.state = $2.idle, this.client.events.emit("session_request_expire", { id: t }));
    }), c5(this, "deletePendingAuthRequest", async (t, e2, s3 = false) => {
      await Promise.all([this.client.auth.requests.delete(t, e2), s3 ? Promise.resolve() : this.client.core.expirer.del(t)]);
    }), c5(this, "setExpiry", async (t, e2) => {
      this.client.session.keys.includes(t) && (this.client.core.expirer.set(t, e2), await this.client.session.update(t, { expiry: e2 }));
    }), c5(this, "setProposal", async (t, e2) => {
      this.client.core.expirer.set(t, ii(N2.wc_sessionPropose.req.ttl)), await this.client.proposal.set(t, e2);
    }), c5(this, "setAuthRequest", async (t, e2) => {
      const { request: s3, pairingTopic: i4, transportType: r3 = Q.relay } = e2;
      this.client.core.expirer.set(t, s3.expiryTimestamp), await this.client.auth.requests.set(t, { authPayload: s3.authPayload, requester: s3.requester, expiryTimestamp: s3.expiryTimestamp, id: t, pairingTopic: i4, verifyContext: s3.verifyContext, transportType: r3 });
    }), c5(this, "setPendingSessionRequest", async (t) => {
      const { id: e2, topic: s3, params: i4, verifyContext: r3 } = t, n5 = i4.request.expiryTimestamp || ii(N2.wc_sessionRequest.req.ttl);
      this.client.core.expirer.set(e2, n5), await this.client.pendingRequest.set(e2, { id: e2, topic: s3, params: i4, verifyContext: r3 });
    }), c5(this, "sendRequest", async (t) => {
      const { topic: e2, method: s3, params: i4, expiry: r3, relayRpcId: n5, clientRpcId: a3, throwOnFailedPublish: l6, appLink: p4, tvf: h5 } = t, u2 = formatJsonRpcRequest(s3, i4, a3);
      let d4;
      const w4 = !!p4;
      try {
        const E4 = w4 ? De : Qt;
        d4 = await this.client.core.crypto.encode(e2, u2, { encoding: E4 });
      } catch (E4) {
        throw await this.cleanup(), this.client.logger.error(`sendRequest() -> core.crypto.encode() for topic ${e2} failed`), E4;
      }
      let m3;
      if (mt.includes(s3)) {
        const E4 = zc(JSON.stringify(u2)), _16 = zc(d4);
        m3 = await this.client.core.verify.register({ id: _16, decryptedId: E4 });
      }
      const y5 = N2[s3].req;
      if (y5.attestation = m3, r3 && (y5.ttl = r3), n5 && (y5.id = n5), this.client.core.history.set(e2, u2), w4) {
        const E4 = sa(p4, e2, d4);
        await global.Linking.openURL(E4, this.client.name);
      } else {
        const E4 = N2[s3].req;
        r3 && (E4.ttl = r3), n5 && (E4.id = n5), E4.tvf = x3(I3({}, h5), { correlationId: u2.id }), l6 ? (E4.internal = x3(I3({}, E4.internal), { throwOnFailedPublish: true }), await this.client.core.relayer.publish(e2, d4, E4)) : this.client.core.relayer.publish(e2, d4, E4).catch((_16) => this.client.logger.error(_16));
      }
      return u2.id;
    }), c5(this, "sendResult", async (t) => {
      const { id: e2, topic: s3, result: i4, throwOnFailedPublish: r3, encodeOpts: n5, appLink: a3 } = t, l6 = formatJsonRpcResult(e2, i4);
      let p4;
      const h5 = a3 && typeof (global == null ? void 0 : global.Linking) < "u";
      try {
        const w4 = h5 ? De : Qt;
        p4 = await this.client.core.crypto.encode(s3, l6, x3(I3({}, n5 || {}), { encoding: w4 }));
      } catch (w4) {
        throw await this.cleanup(), this.client.logger.error(`sendResult() -> core.crypto.encode() for topic ${s3} failed`), w4;
      }
      let u2, d4;
      try {
        u2 = await this.client.core.history.get(s3, e2);
        const w4 = u2.request;
        try {
          d4 = this.getTVFParams(e2, w4.params, i4);
        } catch (m3) {
          this.client.logger.warn(`sendResult() -> getTVFParams() failed: ${m3 == null ? void 0 : m3.message}`);
        }
      } catch (w4) {
        throw this.client.logger.error(`sendResult() -> history.get(${s3}, ${e2}) failed`), w4;
      }
      if (h5) {
        const w4 = sa(a3, s3, p4);
        await global.Linking.openURL(w4, this.client.name);
      } else {
        const w4 = u2.request.method, m3 = N2[w4].res;
        m3.tvf = x3(I3({}, d4), { correlationId: e2 }), r3 ? (m3.internal = x3(I3({}, m3.internal), { throwOnFailedPublish: true }), await this.client.core.relayer.publish(s3, p4, m3)) : this.client.core.relayer.publish(s3, p4, m3).catch((y5) => this.client.logger.error(y5));
      }
      await this.client.core.history.resolve(l6);
    }), c5(this, "sendError", async (t) => {
      const { id: e2, topic: s3, error: i4, encodeOpts: r3, rpcOpts: n5, appLink: a3 } = t, l6 = formatJsonRpcError(e2, i4);
      let p4;
      const h5 = a3 && typeof (global == null ? void 0 : global.Linking) < "u";
      try {
        const d4 = h5 ? De : Qt;
        p4 = await this.client.core.crypto.encode(s3, l6, x3(I3({}, r3 || {}), { encoding: d4 }));
      } catch (d4) {
        throw await this.cleanup(), this.client.logger.error(`sendError() -> core.crypto.encode() for topic ${s3} failed`), d4;
      }
      let u2;
      try {
        u2 = await this.client.core.history.get(s3, e2);
      } catch (d4) {
        throw this.client.logger.error(`sendError() -> history.get(${s3}, ${e2}) failed`), d4;
      }
      if (h5) {
        const d4 = sa(a3, s3, p4);
        await global.Linking.openURL(d4, this.client.name);
      } else {
        const d4 = u2.request.method, w4 = n5 || N2[d4].res;
        this.client.core.relayer.publish(s3, p4, w4);
      }
      await this.client.core.history.resolve(l6);
    }), c5(this, "cleanup", async () => {
      const t = [], e2 = [];
      this.client.session.getAll().forEach((s3) => {
        let i4 = false;
        fi(s3.expiry) && (i4 = true), this.client.core.crypto.keychain.has(s3.topic) || (i4 = true), i4 && t.push(s3.topic);
      }), this.client.proposal.getAll().forEach((s3) => {
        fi(s3.expiryTimestamp) && e2.push(s3.id);
      }), await Promise.all([...t.map((s3) => this.deleteSession({ topic: s3 })), ...e2.map((s3) => this.deleteProposal(s3))]);
    }), c5(this, "onProviderMessageEvent", async (t) => {
      !this.initialized || this.relayMessageCache.length > 0 ? this.relayMessageCache.push(t) : await this.onRelayMessage(t);
    }), c5(this, "onRelayEventRequest", async (t) => {
      this.requestQueue.queue.push(t), await this.processRequestsQueue();
    }), c5(this, "processRequestsQueue", async () => {
      if (this.requestQueue.state === $2.active) {
        this.client.logger.info("Request queue already active, skipping...");
        return;
      }
      for (this.client.logger.info(`Request queue starting with ${this.requestQueue.queue.length} requests`); this.requestQueue.queue.length > 0; ) {
        this.requestQueue.state = $2.active;
        const t = this.requestQueue.queue.shift();
        if (t)
          try {
            await this.processRequest(t);
          } catch (e2) {
            this.client.logger.warn(e2);
          }
      }
      this.requestQueue.state = $2.idle;
    }), c5(this, "processRequest", async (t) => {
      const { topic: e2, payload: s3, attestation: i4, transportType: r3, encryptedId: n5 } = t, a3 = s3.method;
      if (!this.shouldIgnorePairingRequest({ topic: e2, requestMethod: a3 }))
        switch (a3) {
          case "wc_sessionPropose":
            return await this.onSessionProposeRequest({ topic: e2, payload: s3, attestation: i4, encryptedId: n5 });
          case "wc_sessionSettle":
            return await this.onSessionSettleRequest(e2, s3);
          case "wc_sessionUpdate":
            return await this.onSessionUpdateRequest(e2, s3);
          case "wc_sessionExtend":
            return await this.onSessionExtendRequest(e2, s3);
          case "wc_sessionPing":
            return await this.onSessionPingRequest(e2, s3);
          case "wc_sessionDelete":
            return await this.onSessionDeleteRequest(e2, s3);
          case "wc_sessionRequest":
            return await this.onSessionRequest({ topic: e2, payload: s3, attestation: i4, encryptedId: n5, transportType: r3 });
          case "wc_sessionEvent":
            return await this.onSessionEventRequest(e2, s3);
          case "wc_sessionAuthenticate":
            return await this.onSessionAuthenticateRequest({ topic: e2, payload: s3, attestation: i4, encryptedId: n5, transportType: r3 });
          default:
            return this.client.logger.info(`Unsupported request method ${a3}`);
        }
    }), c5(this, "onRelayEventResponse", async (t) => {
      const { topic: e2, payload: s3, transportType: i4 } = t, r3 = (await this.client.core.history.get(e2, s3.id)).request.method;
      switch (r3) {
        case "wc_sessionPropose":
          return this.onSessionProposeResponse(e2, s3, i4);
        case "wc_sessionSettle":
          return this.onSessionSettleResponse(e2, s3);
        case "wc_sessionUpdate":
          return this.onSessionUpdateResponse(e2, s3);
        case "wc_sessionExtend":
          return this.onSessionExtendResponse(e2, s3);
        case "wc_sessionPing":
          return this.onSessionPingResponse(e2, s3);
        case "wc_sessionRequest":
          return this.onSessionRequestResponse(e2, s3);
        case "wc_sessionAuthenticate":
          return this.onSessionAuthenticateResponse(e2, s3);
        default:
          return this.client.logger.info(`Unsupported response method ${r3}`);
      }
    }), c5(this, "onRelayEventUnknownPayload", (t) => {
      const { topic: e2 } = t, { message: s3 } = Et("MISSING_OR_INVALID", `Decoded payload on topic ${e2} is not identifiable as a JSON-RPC request or a response.`);
      throw new Error(s3);
    }), c5(this, "shouldIgnorePairingRequest", (t) => {
      const { topic: e2, requestMethod: s3 } = t, i4 = this.expectedPairingMethodMap.get(e2);
      return !i4 || i4.includes(s3) ? false : !!(i4.includes("wc_sessionAuthenticate") && this.client.events.listenerCount("session_authenticate") > 0);
    }), c5(this, "onSessionProposeRequest", async (t) => {
      const { topic: e2, payload: s3, attestation: i4, encryptedId: r3 } = t, { params: n5, id: a3 } = s3;
      try {
        const l6 = this.client.core.eventClient.getEvent({ topic: e2 });
        this.client.events.listenerCount("session_proposal") === 0 && (console.warn("No listener for session_proposal event"), l6 == null ? void 0 : l6.setError(Y.proposal_listener_not_found)), this.isValidConnect(I3({}, s3.params));
        const p4 = n5.expiryTimestamp || ii(N2.wc_sessionPropose.req.ttl), h5 = I3({ id: a3, pairingTopic: e2, expiryTimestamp: p4, attestation: i4, encryptedId: r3 }, n5);
        await this.setProposal(a3, h5);
        const u2 = await this.getVerifyContext({ attestationId: i4, hash: zc(JSON.stringify(s3)), encryptedId: r3, metadata: h5.proposer.metadata });
        l6 == null ? void 0 : l6.addTrace(G.emit_session_proposal), this.client.events.emit("session_proposal", { id: a3, params: h5, verifyContext: u2 });
      } catch (l6) {
        await this.sendError({ id: a3, topic: e2, error: l6, rpcOpts: N2.wc_sessionPropose.autoReject }), this.client.logger.error(l6);
      }
    }), c5(this, "onSessionProposeResponse", async (t, e2, s3) => {
      const { id: i4 } = e2;
      if (isJsonRpcResult(e2)) {
        const { result: r3 } = e2;
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", result: r3 });
        const n5 = this.client.proposal.get(i4);
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", proposal: n5 });
        const a3 = n5.proposer.publicKey;
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", selfPublicKey: a3 });
        const l6 = r3.responderPublicKey;
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", peerPublicKey: l6 });
        const p4 = await this.client.core.crypto.generateSharedKey(a3, l6);
        this.pendingSessions.set(i4, { sessionTopic: p4, pairingTopic: t, proposalId: i4, publicKey: a3 });
        const h5 = await this.client.core.relayer.subscribe(p4, { transportType: s3 });
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", subscriptionId: h5 }), await this.client.core.pairing.activate({ topic: t });
      } else if (isJsonRpcError(e2)) {
        await this.deleteProposal(i4);
        const r3 = ci("session_connect", i4);
        if (this.events.listenerCount(r3) === 0)
          throw new Error(`emitting ${r3} without any listeners, 954`);
        this.events.emit(r3, { error: e2.error });
      }
    }), c5(this, "onSessionSettleRequest", async (t, e2) => {
      const { id: s3, params: i4 } = e2;
      try {
        this.isValidSessionSettleRequest(i4);
        const { relay: r3, controller: n5, expiry: a3, namespaces: l6, sessionProperties: p4, scopedProperties: h5, sessionConfig: u2 } = e2.params, d4 = [...this.pendingSessions.values()].find((y5) => y5.sessionTopic === t);
        if (!d4)
          return this.client.logger.error(`Pending session not found for topic ${t}`);
        const w4 = this.client.proposal.get(d4.proposalId), m3 = x3(I3(I3(I3({ topic: t, relay: r3, expiry: a3, namespaces: l6, acknowledged: true, pairingTopic: d4.pairingTopic, requiredNamespaces: w4.requiredNamespaces, optionalNamespaces: w4.optionalNamespaces, controller: n5.publicKey, self: { publicKey: d4.publicKey, metadata: this.client.metadata }, peer: { publicKey: n5.publicKey, metadata: n5.metadata } }, p4 && { sessionProperties: p4 }), h5 && { scopedProperties: h5 }), u2 && { sessionConfig: u2 }), { transportType: Q.relay });
        await this.client.session.set(m3.topic, m3), await this.setExpiry(m3.topic, m3.expiry), await this.client.core.pairing.updateMetadata({ topic: d4.pairingTopic, metadata: m3.peer.metadata }), this.client.events.emit("session_connect", { session: m3 }), this.events.emit(ci("session_connect", d4.proposalId), { session: m3 }), this.pendingSessions.delete(d4.proposalId), this.deleteProposal(d4.proposalId, false), this.cleanupDuplicatePairings(m3), await this.sendResult({ id: e2.id, topic: t, result: true });
      } catch (r3) {
        await this.sendError({ id: s3, topic: t, error: r3 }), this.client.logger.error(r3);
      }
    }), c5(this, "onSessionSettleResponse", async (t, e2) => {
      const { id: s3 } = e2;
      isJsonRpcResult(e2) ? (await this.client.session.update(t, { acknowledged: true }), this.events.emit(ci("session_approve", s3), {})) : isJsonRpcError(e2) && (await this.client.session.delete(t, Kt("USER_DISCONNECTED")), this.events.emit(ci("session_approve", s3), { error: e2.error }));
    }), c5(this, "onSessionUpdateRequest", async (t, e2) => {
      const { params: s3, id: i4 } = e2;
      try {
        const r3 = `${t}_session_update`, n5 = Ha.get(r3);
        if (n5 && this.isRequestOutOfSync(n5, i4)) {
          this.client.logger.warn(`Discarding out of sync request - ${i4}`), this.sendError({ id: i4, topic: t, error: Kt("INVALID_UPDATE_REQUEST") });
          return;
        }
        this.isValidUpdate(I3({ topic: t }, s3));
        try {
          Ha.set(r3, i4), await this.client.session.update(t, { namespaces: s3.namespaces }), await this.sendResult({ id: i4, topic: t, result: true });
        } catch (a3) {
          throw Ha.delete(r3), a3;
        }
        this.client.events.emit("session_update", { id: i4, topic: t, params: s3 });
      } catch (r3) {
        await this.sendError({ id: i4, topic: t, error: r3 }), this.client.logger.error(r3);
      }
    }), c5(this, "isRequestOutOfSync", (t, e2) => e2.toString().slice(0, -3) < t.toString().slice(0, -3)), c5(this, "onSessionUpdateResponse", (t, e2) => {
      const { id: s3 } = e2, i4 = ci("session_update", s3);
      if (this.events.listenerCount(i4) === 0)
        throw new Error(`emitting ${i4} without any listeners`);
      isJsonRpcResult(e2) ? this.events.emit(ci("session_update", s3), {}) : isJsonRpcError(e2) && this.events.emit(ci("session_update", s3), { error: e2.error });
    }), c5(this, "onSessionExtendRequest", async (t, e2) => {
      const { id: s3 } = e2;
      try {
        this.isValidExtend({ topic: t }), await this.setExpiry(t, ii(X)), await this.sendResult({ id: s3, topic: t, result: true }), this.client.events.emit("session_extend", { id: s3, topic: t });
      } catch (i4) {
        await this.sendError({ id: s3, topic: t, error: i4 }), this.client.logger.error(i4);
      }
    }), c5(this, "onSessionExtendResponse", (t, e2) => {
      const { id: s3 } = e2, i4 = ci("session_extend", s3);
      if (this.events.listenerCount(i4) === 0)
        throw new Error(`emitting ${i4} without any listeners`);
      isJsonRpcResult(e2) ? this.events.emit(ci("session_extend", s3), {}) : isJsonRpcError(e2) && this.events.emit(ci("session_extend", s3), { error: e2.error });
    }), c5(this, "onSessionPingRequest", async (t, e2) => {
      const { id: s3 } = e2;
      try {
        this.isValidPing({ topic: t }), await this.sendResult({ id: s3, topic: t, result: true, throwOnFailedPublish: true }), this.client.events.emit("session_ping", { id: s3, topic: t });
      } catch (i4) {
        await this.sendError({ id: s3, topic: t, error: i4 }), this.client.logger.error(i4);
      }
    }), c5(this, "onSessionPingResponse", (t, e2) => {
      const { id: s3 } = e2, i4 = ci("session_ping", s3);
      setTimeout(() => {
        if (this.events.listenerCount(i4) === 0)
          throw new Error(`emitting ${i4} without any listeners 2176`);
        isJsonRpcResult(e2) ? this.events.emit(ci("session_ping", s3), {}) : isJsonRpcError(e2) && this.events.emit(ci("session_ping", s3), { error: e2.error });
      }, 500);
    }), c5(this, "onSessionDeleteRequest", async (t, e2) => {
      const { id: s3 } = e2;
      try {
        this.isValidDisconnect({ topic: t, reason: e2.params }), Promise.all([new Promise((i4) => {
          this.client.core.relayer.once(C2.publish, async () => {
            i4(await this.deleteSession({ topic: t, id: s3 }));
          });
        }), this.sendResult({ id: s3, topic: t, result: true }), this.cleanupPendingSentRequestsForTopic({ topic: t, error: Kt("USER_DISCONNECTED") })]).catch((i4) => this.client.logger.error(i4));
      } catch (i4) {
        this.client.logger.error(i4);
      }
    }), c5(this, "onSessionRequest", async (t) => {
      var e2, s3, i4;
      const { topic: r3, payload: n5, attestation: a3, encryptedId: l6, transportType: p4 } = t, { id: h5, params: u2 } = n5;
      try {
        await this.isValidRequest(I3({ topic: r3 }, u2));
        const d4 = this.client.session.get(r3), w4 = await this.getVerifyContext({ attestationId: a3, hash: zc(JSON.stringify(formatJsonRpcRequest("wc_sessionRequest", u2, h5))), encryptedId: l6, metadata: d4.peer.metadata, transportType: p4 }), m3 = { id: h5, topic: r3, params: u2, verifyContext: w4 };
        await this.setPendingSessionRequest(m3), p4 === Q.link_mode && (e2 = d4.peer.metadata.redirect) != null && e2.universal && this.client.core.addLinkModeSupportedApp((s3 = d4.peer.metadata.redirect) == null ? void 0 : s3.universal), (i4 = this.client.signConfig) != null && i4.disableRequestQueue ? this.emitSessionRequest(m3) : (this.addSessionRequestToSessionRequestQueue(m3), this.processSessionRequestQueue());
      } catch (d4) {
        await this.sendError({ id: h5, topic: r3, error: d4 }), this.client.logger.error(d4);
      }
    }), c5(this, "onSessionRequestResponse", (t, e2) => {
      const { id: s3 } = e2, i4 = ci("session_request", s3);
      if (this.events.listenerCount(i4) === 0)
        throw new Error(`emitting ${i4} without any listeners`);
      isJsonRpcResult(e2) ? this.events.emit(ci("session_request", s3), { result: e2.result }) : isJsonRpcError(e2) && this.events.emit(ci("session_request", s3), { error: e2.error });
    }), c5(this, "onSessionEventRequest", async (t, e2) => {
      const { id: s3, params: i4 } = e2;
      try {
        const r3 = `${t}_session_event_${i4.event.name}`, n5 = Ha.get(r3);
        if (n5 && this.isRequestOutOfSync(n5, s3)) {
          this.client.logger.info(`Discarding out of sync request - ${s3}`);
          return;
        }
        this.isValidEmit(I3({ topic: t }, i4)), this.client.events.emit("session_event", { id: s3, topic: t, params: i4 }), Ha.set(r3, s3);
      } catch (r3) {
        await this.sendError({ id: s3, topic: t, error: r3 }), this.client.logger.error(r3);
      }
    }), c5(this, "onSessionAuthenticateResponse", (t, e2) => {
      const { id: s3 } = e2;
      this.client.logger.trace({ type: "method", method: "onSessionAuthenticateResponse", topic: t, payload: e2 }), isJsonRpcResult(e2) ? this.events.emit(ci("session_request", s3), { result: e2.result }) : isJsonRpcError(e2) && this.events.emit(ci("session_request", s3), { error: e2.error });
    }), c5(this, "onSessionAuthenticateRequest", async (t) => {
      var e2;
      const { topic: s3, payload: i4, attestation: r3, encryptedId: n5, transportType: a3 } = t;
      try {
        const { requester: l6, authPayload: p4, expiryTimestamp: h5 } = i4.params, u2 = await this.getVerifyContext({ attestationId: r3, hash: zc(JSON.stringify(i4)), encryptedId: n5, metadata: l6.metadata, transportType: a3 }), d4 = { requester: l6, pairingTopic: s3, id: i4.id, authPayload: p4, verifyContext: u2, expiryTimestamp: h5 };
        await this.setAuthRequest(i4.id, { request: d4, pairingTopic: s3, transportType: a3 }), a3 === Q.link_mode && (e2 = l6.metadata.redirect) != null && e2.universal && this.client.core.addLinkModeSupportedApp(l6.metadata.redirect.universal), this.client.events.emit("session_authenticate", { topic: s3, params: i4.params, id: i4.id, verifyContext: u2 });
      } catch (l6) {
        this.client.logger.error(l6);
        const p4 = i4.params.requester.publicKey, h5 = await this.client.core.crypto.generateKeyPair(), u2 = this.getAppLinkIfEnabled(i4.params.requester.metadata, a3), d4 = { type: ee, receiverPublicKey: p4, senderPublicKey: h5 };
        await this.sendError({ id: i4.id, topic: s3, error: l6, encodeOpts: d4, rpcOpts: N2.wc_sessionAuthenticate.autoReject, appLink: u2 });
      }
    }), c5(this, "addSessionRequestToSessionRequestQueue", (t) => {
      this.sessionRequestQueue.queue.push(t);
    }), c5(this, "cleanupAfterResponse", (t) => {
      this.deletePendingSessionRequest(t.response.id, { message: "fulfilled", code: 0 }), setTimeout(() => {
        this.sessionRequestQueue.state = $2.idle, this.processSessionRequestQueue();
      }, (0, import_time3.toMiliseconds)(this.requestQueueDelay));
    }), c5(this, "cleanupPendingSentRequestsForTopic", ({ topic: t, error: e2 }) => {
      const s3 = this.client.core.history.pending;
      s3.length > 0 && s3.filter((i4) => i4.topic === t && i4.request.method === "wc_sessionRequest").forEach((i4) => {
        const r3 = i4.request.id, n5 = ci("session_request", r3);
        if (this.events.listenerCount(n5) === 0)
          throw new Error(`emitting ${n5} without any listeners`);
        this.events.emit(ci("session_request", i4.request.id), { error: e2 });
      });
    }), c5(this, "processSessionRequestQueue", () => {
      if (this.sessionRequestQueue.state === $2.active) {
        this.client.logger.info("session request queue is already active.");
        return;
      }
      const t = this.sessionRequestQueue.queue[0];
      if (!t) {
        this.client.logger.info("session request queue is empty.");
        return;
      }
      try {
        this.emitSessionRequest(t);
      } catch (e2) {
        this.client.logger.error(e2);
      }
    }), c5(this, "emitSessionRequest", (t) => {
      if (this.emittedSessionRequests.has(t.id)) {
        this.client.logger.warn({ id: t.id }, `Skipping emitting \`session_request\` event for duplicate request. id: ${t.id}`);
        return;
      }
      this.sessionRequestQueue.state = $2.active, this.emittedSessionRequests.add(t.id), this.client.events.emit("session_request", t);
    }), c5(this, "onPairingCreated", (t) => {
      if (t.methods && this.expectedPairingMethodMap.set(t.topic, t.methods), t.active)
        return;
      const e2 = this.client.proposal.getAll().find((s3) => s3.pairingTopic === t.topic);
      e2 && this.onSessionProposeRequest({ topic: t.topic, payload: formatJsonRpcRequest("wc_sessionPropose", x3(I3({}, e2), { requiredNamespaces: e2.requiredNamespaces, optionalNamespaces: e2.optionalNamespaces, relays: e2.relays, proposer: e2.proposer, sessionProperties: e2.sessionProperties, scopedProperties: e2.scopedProperties }), e2.id), attestation: e2.attestation, encryptedId: e2.encryptedId });
    }), c5(this, "isValidConnect", async (t) => {
      if (!Aa(t)) {
        const { message: l6 } = Et("MISSING_OR_INVALID", `connect() params: ${JSON.stringify(t)}`);
        throw new Error(l6);
      }
      const { pairingTopic: e2, requiredNamespaces: s3, optionalNamespaces: i4, sessionProperties: r3, scopedProperties: n5, relays: a3 } = t;
      if (kt(e2) || await this.isValidPairingTopic(e2), !Ba(a3, true)) {
        const { message: l6 } = Et("MISSING_OR_INVALID", `connect() relays: ${a3}`);
        throw new Error(l6);
      }
      if (!kt(s3) && Ve(s3) !== 0) {
        const l6 = "requiredNamespaces are deprecated and are automatically assigned to optionalNamespaces";
        ["fatal", "error", "silent"].includes(this.client.logger.level) ? console.warn(l6) : this.client.logger.warn(l6), this.validateNamespaces(s3, "requiredNamespaces");
      }
      if (!kt(i4) && Ve(i4) !== 0 && this.validateNamespaces(i4, "optionalNamespaces"), kt(r3) || this.validateSessionProps(r3, "sessionProperties"), !kt(n5)) {
        this.validateSessionProps(n5, "scopedProperties");
        const l6 = Object.keys(s3 || {}).concat(Object.keys(i4 || {}));
        if (!Object.keys(n5).every((p4) => l6.includes(p4.split(":")[0])))
          throw new Error(`Scoped properties must be a subset of required/optional namespaces, received: ${JSON.stringify(n5)}, required/optional namespaces: ${JSON.stringify(l6)}`);
      }
    }), c5(this, "validateNamespaces", (t, e2) => {
      const s3 = Ea(t, "connect()", e2);
      if (s3)
        throw new Error(s3.message);
    }), c5(this, "isValidApprove", async (t) => {
      if (!Aa(t))
        throw new Error(Et("MISSING_OR_INVALID", `approve() params: ${t}`).message);
      const { id: e2, namespaces: s3, relayProtocol: i4, sessionProperties: r3, scopedProperties: n5 } = t;
      this.checkRecentlyDeleted(e2), await this.isValidProposalId(e2);
      const a3 = this.client.proposal.get(e2), l6 = is(s3, "approve()");
      if (l6)
        throw new Error(l6.message);
      const p4 = cs(a3.requiredNamespaces, s3, "approve()");
      if (p4)
        throw new Error(p4.message);
      if (!it(i4, true)) {
        const { message: h5 } = Et("MISSING_OR_INVALID", `approve() relayProtocol: ${i4}`);
        throw new Error(h5);
      }
      if (kt(r3) || this.validateSessionProps(r3, "sessionProperties"), !kt(n5)) {
        this.validateSessionProps(n5, "scopedProperties");
        const h5 = new Set(Object.keys(s3));
        if (!Object.keys(n5).every((u2) => h5.has(u2.split(":")[0])))
          throw new Error(`Scoped properties must be a subset of approved namespaces, received: ${JSON.stringify(n5)}, approved namespaces: ${Array.from(h5).join(", ")}`);
      }
    }), c5(this, "isValidReject", async (t) => {
      if (!Aa(t)) {
        const { message: i4 } = Et("MISSING_OR_INVALID", `reject() params: ${t}`);
        throw new Error(i4);
      }
      const { id: e2, reason: s3 } = t;
      if (this.checkRecentlyDeleted(e2), await this.isValidProposalId(e2), !Sa(s3)) {
        const { message: i4 } = Et("MISSING_OR_INVALID", `reject() reason: ${JSON.stringify(s3)}`);
        throw new Error(i4);
      }
    }), c5(this, "isValidSessionSettleRequest", (t) => {
      if (!Aa(t)) {
        const { message: l6 } = Et("MISSING_OR_INVALID", `onSessionSettleRequest() params: ${t}`);
        throw new Error(l6);
      }
      const { relay: e2, controller: s3, namespaces: i4, expiry: r3 } = t;
      if (!fs(e2)) {
        const { message: l6 } = Et("MISSING_OR_INVALID", "onSessionSettleRequest() relay protocol should be a string");
        throw new Error(l6);
      }
      const n5 = va(s3, "onSessionSettleRequest()");
      if (n5)
        throw new Error(n5.message);
      const a3 = is(i4, "onSessionSettleRequest()");
      if (a3)
        throw new Error(a3.message);
      if (fi(r3)) {
        const { message: l6 } = Et("EXPIRED", "onSessionSettleRequest()");
        throw new Error(l6);
      }
    }), c5(this, "isValidUpdate", async (t) => {
      if (!Aa(t)) {
        const { message: a3 } = Et("MISSING_OR_INVALID", `update() params: ${t}`);
        throw new Error(a3);
      }
      const { topic: e2, namespaces: s3 } = t;
      this.checkRecentlyDeleted(e2), await this.isValidSessionTopic(e2);
      const i4 = this.client.session.get(e2), r3 = is(s3, "update()");
      if (r3)
        throw new Error(r3.message);
      const n5 = cs(i4.requiredNamespaces, s3, "update()");
      if (n5)
        throw new Error(n5.message);
    }), c5(this, "isValidExtend", async (t) => {
      if (!Aa(t)) {
        const { message: s3 } = Et("MISSING_OR_INVALID", `extend() params: ${t}`);
        throw new Error(s3);
      }
      const { topic: e2 } = t;
      this.checkRecentlyDeleted(e2), await this.isValidSessionTopic(e2);
    }), c5(this, "isValidRequest", async (t) => {
      if (!Aa(t)) {
        const { message: a3 } = Et("MISSING_OR_INVALID", `request() params: ${t}`);
        throw new Error(a3);
      }
      const { topic: e2, request: s3, chainId: i4, expiry: r3 } = t;
      this.checkRecentlyDeleted(e2), await this.isValidSessionTopic(e2);
      const { namespaces: n5 } = this.client.session.get(e2);
      if (!_a(n5, i4)) {
        const { message: a3 } = Et("MISSING_OR_INVALID", `request() chainId: ${i4}`);
        throw new Error(a3);
      }
      if (!Na(s3)) {
        const { message: a3 } = Et("MISSING_OR_INVALID", `request() ${JSON.stringify(s3)}`);
        throw new Error(a3);
      }
      if (!Ta(n5, i4, s3.method)) {
        const { message: a3 } = Et("MISSING_OR_INVALID", `request() method: ${s3.method}`);
        throw new Error(a3);
      }
      if (r3 && !La(r3, _e2)) {
        const { message: a3 } = Et("MISSING_OR_INVALID", `request() expiry: ${r3}. Expiry must be a number (in seconds) between ${_e2.min} and ${_e2.max}`);
        throw new Error(a3);
      }
    }), c5(this, "isValidRespond", async (t) => {
      var e2;
      if (!Aa(t)) {
        const { message: r3 } = Et("MISSING_OR_INVALID", `respond() params: ${t}`);
        throw new Error(r3);
      }
      const { topic: s3, response: i4 } = t;
      try {
        await this.isValidSessionTopic(s3);
      } catch (r3) {
        throw (e2 = t == null ? void 0 : t.response) != null && e2.id && this.cleanupAfterResponse(t), r3;
      }
      if (!Oa(i4)) {
        const { message: r3 } = Et("MISSING_OR_INVALID", `respond() response: ${JSON.stringify(i4)}`);
        throw new Error(r3);
      }
    }), c5(this, "isValidPing", async (t) => {
      if (!Aa(t)) {
        const { message: s3 } = Et("MISSING_OR_INVALID", `ping() params: ${t}`);
        throw new Error(s3);
      }
      const { topic: e2 } = t;
      await this.isValidSessionOrPairingTopic(e2);
    }), c5(this, "isValidEmit", async (t) => {
      if (!Aa(t)) {
        const { message: n5 } = Et("MISSING_OR_INVALID", `emit() params: ${t}`);
        throw new Error(n5);
      }
      const { topic: e2, event: s3, chainId: i4 } = t;
      await this.isValidSessionTopic(e2);
      const { namespaces: r3 } = this.client.session.get(e2);
      if (!_a(r3, i4)) {
        const { message: n5 } = Et("MISSING_OR_INVALID", `emit() chainId: ${i4}`);
        throw new Error(n5);
      }
      if (!Ua(s3)) {
        const { message: n5 } = Et("MISSING_OR_INVALID", `emit() event: ${JSON.stringify(s3)}`);
        throw new Error(n5);
      }
      if (!Ra(r3, i4, s3.name)) {
        const { message: n5 } = Et("MISSING_OR_INVALID", `emit() event: ${JSON.stringify(s3)}`);
        throw new Error(n5);
      }
    }), c5(this, "isValidDisconnect", async (t) => {
      if (!Aa(t)) {
        const { message: s3 } = Et("MISSING_OR_INVALID", `disconnect() params: ${t}`);
        throw new Error(s3);
      }
      const { topic: e2 } = t;
      await this.isValidSessionOrPairingTopic(e2);
    }), c5(this, "isValidAuthenticate", (t) => {
      const { chains: e2, uri: s3, domain: i4, nonce: r3 } = t;
      if (!Array.isArray(e2) || e2.length === 0)
        throw new Error("chains is required and must be a non-empty array");
      if (!it(s3, false))
        throw new Error("uri is required parameter");
      if (!it(i4, false))
        throw new Error("domain is required parameter");
      if (!it(r3, false))
        throw new Error("nonce is required parameter");
      if ([...new Set(e2.map((a3) => Fe(a3).namespace))].length > 1)
        throw new Error("Multi-namespace requests are not supported. Please request single namespace only.");
      const { namespace: n5 } = Fe(e2[0]);
      if (n5 !== "eip155")
        throw new Error("Only eip155 namespace is supported for authenticated sessions. Please use .connect() for non-eip155 chains.");
    }), c5(this, "getVerifyContext", async (t) => {
      const { attestationId: e2, hash: s3, encryptedId: i4, metadata: r3, transportType: n5 } = t, a3 = { verified: { verifyUrl: r3.verifyUrl || ue, validation: "UNKNOWN", origin: r3.url || "" } };
      try {
        if (n5 === Q.link_mode) {
          const p4 = this.getAppLinkIfEnabled(r3, n5);
          return a3.verified.validation = p4 && new URL(p4).origin === new URL(r3.url).origin ? "VALID" : "INVALID", a3;
        }
        const l6 = await this.client.core.verify.resolve({ attestationId: e2, hash: s3, encryptedId: i4, verifyUrl: r3.verifyUrl });
        l6 && (a3.verified.origin = l6.origin, a3.verified.isScam = l6.isScam, a3.verified.validation = l6.origin === new URL(r3.url).origin ? "VALID" : "INVALID");
      } catch (l6) {
        this.client.logger.warn(l6);
      }
      return this.client.logger.debug(`Verify context: ${JSON.stringify(a3)}`), a3;
    }), c5(this, "validateSessionProps", (t, e2) => {
      Object.values(t).forEach((s3, i4) => {
        if (s3 == null) {
          const { message: r3 } = Et("MISSING_OR_INVALID", `${e2} must contain an existing value for each key. Received: ${s3} for key ${Object.keys(t)[i4]}`);
          throw new Error(r3);
        }
      });
    }), c5(this, "getPendingAuthRequest", (t) => {
      const e2 = this.client.auth.requests.get(t);
      return typeof e2 == "object" ? e2 : void 0;
    }), c5(this, "addToRecentlyDeleted", (t, e2) => {
      if (this.recentlyDeletedMap.set(t, e2), this.recentlyDeletedMap.size >= this.recentlyDeletedLimit) {
        let s3 = 0;
        const i4 = this.recentlyDeletedLimit / 2;
        for (const r3 of this.recentlyDeletedMap.keys()) {
          if (s3++ >= i4)
            break;
          this.recentlyDeletedMap.delete(r3);
        }
      }
    }), c5(this, "checkRecentlyDeleted", (t) => {
      const e2 = this.recentlyDeletedMap.get(t);
      if (e2) {
        const { message: s3 } = Et("MISSING_OR_INVALID", `Record was recently deleted - ${e2}: ${t}`);
        throw new Error(s3);
      }
    }), c5(this, "isLinkModeEnabled", (t, e2) => {
      var s3, i4, r3, n5, a3, l6, p4, h5, u2;
      return !t || e2 !== Q.link_mode ? false : ((i4 = (s3 = this.client.metadata) == null ? void 0 : s3.redirect) == null ? void 0 : i4.linkMode) === true && ((n5 = (r3 = this.client.metadata) == null ? void 0 : r3.redirect) == null ? void 0 : n5.universal) !== void 0 && ((l6 = (a3 = this.client.metadata) == null ? void 0 : a3.redirect) == null ? void 0 : l6.universal) !== "" && ((p4 = t == null ? void 0 : t.redirect) == null ? void 0 : p4.universal) !== void 0 && ((h5 = t == null ? void 0 : t.redirect) == null ? void 0 : h5.universal) !== "" && ((u2 = t == null ? void 0 : t.redirect) == null ? void 0 : u2.linkMode) === true && this.client.core.linkModeSupportedApps.includes(t.redirect.universal) && typeof (global == null ? void 0 : global.Linking) < "u";
    }), c5(this, "getAppLinkIfEnabled", (t, e2) => {
      var s3;
      return this.isLinkModeEnabled(t, e2) ? (s3 = t == null ? void 0 : t.redirect) == null ? void 0 : s3.universal : void 0;
    }), c5(this, "handleLinkModeMessage", ({ url: t }) => {
      if (!t || !t.includes("wc_ev") || !t.includes("topic"))
        return;
      const e2 = li(t, "topic") || "", s3 = decodeURIComponent(li(t, "wc_ev") || ""), i4 = this.client.session.keys.includes(e2);
      i4 && this.client.session.update(e2, { transportType: Q.link_mode }), this.client.core.dispatchEnvelope({ topic: e2, message: s3, sessionExists: i4 });
    }), c5(this, "registerLinkModeListeners", async () => {
      var t;
      if (hi() || Bt() && (t = this.client.metadata.redirect) != null && t.linkMode) {
        const e2 = global == null ? void 0 : global.Linking;
        if (typeof e2 < "u") {
          e2.addEventListener("url", this.handleLinkModeMessage, this.client.name);
          const s3 = await e2.getInitialURL();
          s3 && setTimeout(() => {
            this.handleLinkModeMessage({ url: s3 });
          }, 50);
        }
      }
    }), c5(this, "getTVFParams", (t, e2, s3) => {
      var i4, r3, n5;
      if (!((i4 = e2.request) != null && i4.method))
        return {};
      const a3 = { correlationId: t, rpcMethods: [e2.request.method], chainId: e2.chainId };
      try {
        const l6 = this.extractTxHashesFromResult(e2.request, s3);
        a3.txHashes = l6, a3.contractAddresses = this.isValidContractData(e2.request.params) ? [(n5 = (r3 = e2.request.params) == null ? void 0 : r3[0]) == null ? void 0 : n5.to] : [];
      } catch (l6) {
        this.client.logger.warn("Error getting TVF params", l6);
      }
      return a3;
    }), c5(this, "isValidContractData", (t) => {
      var e2;
      if (!t)
        return false;
      try {
        const s3 = (t == null ? void 0 : t.data) || ((e2 = t == null ? void 0 : t[0]) == null ? void 0 : e2.data);
        if (!s3.startsWith("0x"))
          return false;
        const i4 = s3.slice(2);
        return /^[0-9a-fA-F]*$/.test(i4) ? i4.length % 2 === 0 : false;
      } catch {
      }
      return false;
    }), c5(this, "extractTxHashesFromResult", (t, e2) => {
      var s3;
      try {
        if (!e2)
          return [];
        const i4 = t.method, r3 = gt[i4];
        if (i4 === "sui_signTransaction")
          return [ff(e2.transactionBytes)];
        if (i4 === "near_signTransaction")
          return [cf(e2)];
        if (i4 === "near_signTransactions")
          return e2.map((a3) => cf(a3));
        if (i4 === "xrpl_signTransactionFor" || i4 === "xrpl_signTransaction")
          return [(s3 = e2.tx_json) == null ? void 0 : s3.hash];
        if (i4 === "polkadot_signTransaction")
          return [Ka({ transaction: t.params.transactionPayload, signature: e2.signature })];
        if (i4 === "algo_signTxn")
          return me(e2) ? e2.map((a3) => af(a3)) : [af(e2)];
        if (i4 === "cosmos_signDirect")
          return [uf(e2)];
        if (typeof e2 == "string")
          return [e2];
        const n5 = e2[r3.key];
        if (me(n5))
          return i4 === "solana_signAllTransactions" ? n5.map((a3) => sf(a3)) : n5;
        if (typeof n5 == "string")
          return [n5];
      } catch (i4) {
        this.client.logger.warn("Error extracting tx hashes from result", i4);
      }
      return [];
    });
  }
  async processPendingMessageEvents() {
    try {
      const o4 = this.client.session.keys, t = this.client.core.relayer.messages.getWithoutAck(o4);
      for (const [e2, s3] of Object.entries(t))
        for (const i4 of s3)
          try {
            await this.onProviderMessageEvent({ topic: e2, message: i4, publishedAt: Date.now() });
          } catch {
            this.client.logger.warn(`Error processing pending message event for topic: ${e2}, message: ${i4}`);
          }
    } catch (o4) {
      this.client.logger.warn("processPendingMessageEvents failed", o4);
    }
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: o4 } = Et("NOT_INITIALIZED", this.name);
      throw new Error(o4);
    }
  }
  async confirmOnlineStateOrThrow() {
    await this.client.core.relayer.confirmOnlineStateOrThrow();
  }
  registerRelayerEvents() {
    this.client.core.relayer.on(C2.message, (o4) => {
      this.onProviderMessageEvent(o4);
    });
  }
  async onRelayMessage(o4) {
    const { topic: t, message: e2, attestation: s3, transportType: i4 } = o4, { publicKey: r3 } = this.client.auth.authKeys.keys.includes(ce) ? this.client.auth.authKeys.get(ce) : { responseTopic: void 0, publicKey: void 0 };
    try {
      const n5 = await this.client.core.crypto.decode(t, e2, { receiverPublicKey: r3, encoding: i4 === Q.link_mode ? De : Qt });
      isJsonRpcRequest(n5) ? (this.client.core.history.set(t, n5), await this.onRelayEventRequest({ topic: t, payload: n5, attestation: s3, transportType: i4, encryptedId: zc(e2) })) : isJsonRpcResponse(n5) ? (await this.client.core.history.resolve(n5), await this.onRelayEventResponse({ topic: t, payload: n5, transportType: i4 }), this.client.core.history.delete(t, n5.id)) : await this.onRelayEventUnknownPayload({ topic: t, payload: n5, transportType: i4 }), await this.client.core.relayer.messages.ack(t, e2);
    } catch (n5) {
      this.client.logger.error(n5);
    }
  }
  registerExpirerEvents() {
    this.client.core.expirer.on(M2.expired, async (o4) => {
      const { topic: t, id: e2 } = si(o4.target);
      if (e2 && this.client.pendingRequest.keys.includes(e2))
        return await this.deletePendingSessionRequest(e2, Et("EXPIRED"), true);
      if (e2 && this.client.auth.requests.keys.includes(e2))
        return await this.deletePendingAuthRequest(e2, Et("EXPIRED"), true);
      t ? this.client.session.keys.includes(t) && (await this.deleteSession({ topic: t, expirerHasDeleted: true }), this.client.events.emit("session_expire", { topic: t })) : e2 && (await this.deleteProposal(e2, true), this.client.events.emit("proposal_expire", { id: e2 }));
    });
  }
  registerPairingEvents() {
    this.client.core.pairing.events.on(re.create, (o4) => this.onPairingCreated(o4)), this.client.core.pairing.events.on(re.delete, (o4) => {
      this.addToRecentlyDeleted(o4.topic, "pairing");
    });
  }
  isValidPairingTopic(o4) {
    if (!it(o4, false)) {
      const { message: t } = Et("MISSING_OR_INVALID", `pairing topic should be a string: ${o4}`);
      throw new Error(t);
    }
    if (!this.client.core.pairing.pairings.keys.includes(o4)) {
      const { message: t } = Et("NO_MATCHING_KEY", `pairing topic doesn't exist: ${o4}`);
      throw new Error(t);
    }
    if (fi(this.client.core.pairing.pairings.get(o4).expiry)) {
      const { message: t } = Et("EXPIRED", `pairing topic: ${o4}`);
      throw new Error(t);
    }
  }
  async isValidSessionTopic(o4) {
    if (!it(o4, false)) {
      const { message: t } = Et("MISSING_OR_INVALID", `session topic should be a string: ${o4}`);
      throw new Error(t);
    }
    if (this.checkRecentlyDeleted(o4), !this.client.session.keys.includes(o4)) {
      const { message: t } = Et("NO_MATCHING_KEY", `session topic doesn't exist: ${o4}`);
      throw new Error(t);
    }
    if (fi(this.client.session.get(o4).expiry)) {
      await this.deleteSession({ topic: o4 });
      const { message: t } = Et("EXPIRED", `session topic: ${o4}`);
      throw new Error(t);
    }
    if (!this.client.core.crypto.keychain.has(o4)) {
      const { message: t } = Et("MISSING_OR_INVALID", `session topic does not exist in keychain: ${o4}`);
      throw await this.deleteSession({ topic: o4 }), new Error(t);
    }
  }
  async isValidSessionOrPairingTopic(o4) {
    if (this.checkRecentlyDeleted(o4), this.client.session.keys.includes(o4))
      await this.isValidSessionTopic(o4);
    else if (this.client.core.pairing.pairings.keys.includes(o4))
      this.isValidPairingTopic(o4);
    else if (it(o4, false)) {
      const { message: t } = Et("NO_MATCHING_KEY", `session or pairing topic doesn't exist: ${o4}`);
      throw new Error(t);
    } else {
      const { message: t } = Et("MISSING_OR_INVALID", `session or pairing topic should be a string: ${o4}`);
      throw new Error(t);
    }
  }
  async isValidProposalId(o4) {
    if (!Ia(o4)) {
      const { message: t } = Et("MISSING_OR_INVALID", `proposal id should be a number: ${o4}`);
      throw new Error(t);
    }
    if (!this.client.proposal.keys.includes(o4)) {
      const { message: t } = Et("NO_MATCHING_KEY", `proposal id doesn't exist: ${o4}`);
      throw new Error(t);
    }
    if (fi(this.client.proposal.get(o4).expiryTimestamp)) {
      await this.deleteProposal(o4);
      const { message: t } = Et("EXPIRED", `proposal id: ${o4}`);
      throw new Error(t);
    }
  }
};
var ks = class extends Li {
  constructor(o4, t) {
    super(o4, t, ht, me2), this.core = o4, this.logger = t;
  }
};
var vt = class extends Li {
  constructor(o4, t) {
    super(o4, t, dt, me2), this.core = o4, this.logger = t;
  }
};
var Ds = class extends Li {
  constructor(o4, t) {
    super(o4, t, yt, me2, (e2) => e2.id), this.core = o4, this.logger = t;
  }
};
var Ls = class extends Li {
  constructor(o4, t) {
    super(o4, t, Et3, ae, () => ce), this.core = o4, this.logger = t;
  }
};
var Ms2 = class extends Li {
  constructor(o4, t) {
    super(o4, t, ft, ae), this.core = o4, this.logger = t;
  }
};
var $s = class extends Li {
  constructor(o4, t) {
    super(o4, t, St2, ae, (e2) => e2.id), this.core = o4, this.logger = t;
  }
};
var Ks2 = Object.defineProperty;
var Us = (S4, o4, t) => o4 in S4 ? Ks2(S4, o4, { enumerable: true, configurable: true, writable: true, value: t }) : S4[o4] = t;
var Ke2 = (S4, o4, t) => Us(S4, typeof o4 != "symbol" ? o4 + "" : o4, t);
var Gs2 = class {
  constructor(o4, t) {
    this.core = o4, this.logger = t, Ke2(this, "authKeys"), Ke2(this, "pairingTopics"), Ke2(this, "requests"), this.authKeys = new Ls(this.core, this.logger), this.pairingTopics = new Ms2(this.core, this.logger), this.requests = new $s(this.core, this.logger);
  }
  async init() {
    await this.authKeys.init(), await this.pairingTopics.init(), await this.requests.init();
  }
};
var js = Object.defineProperty;
var Fs = (S4, o4, t) => o4 in S4 ? js(S4, o4, { enumerable: true, configurable: true, writable: true, value: t }) : S4[o4] = t;
var f5 = (S4, o4, t) => Fs(S4, typeof o4 != "symbol" ? o4 + "" : o4, t);
var Ee2 = class _Ee extends J {
  constructor(o4) {
    super(o4), f5(this, "protocol", Ce2), f5(this, "version", ke2), f5(this, "name", we.name), f5(this, "metadata"), f5(this, "core"), f5(this, "logger"), f5(this, "events", new import_events8.EventEmitter()), f5(this, "engine"), f5(this, "session"), f5(this, "proposal"), f5(this, "pendingRequest"), f5(this, "auth"), f5(this, "signConfig"), f5(this, "on", (e2, s3) => this.events.on(e2, s3)), f5(this, "once", (e2, s3) => this.events.once(e2, s3)), f5(this, "off", (e2, s3) => this.events.off(e2, s3)), f5(this, "removeListener", (e2, s3) => this.events.removeListener(e2, s3)), f5(this, "removeAllListeners", (e2) => this.events.removeAllListeners(e2)), f5(this, "connect", async (e2) => {
      try {
        return await this.engine.connect(e2);
      } catch (s3) {
        throw this.logger.error(s3.message), s3;
      }
    }), f5(this, "pair", async (e2) => {
      try {
        return await this.engine.pair(e2);
      } catch (s3) {
        throw this.logger.error(s3.message), s3;
      }
    }), f5(this, "approve", async (e2) => {
      try {
        return await this.engine.approve(e2);
      } catch (s3) {
        throw this.logger.error(s3.message), s3;
      }
    }), f5(this, "reject", async (e2) => {
      try {
        return await this.engine.reject(e2);
      } catch (s3) {
        throw this.logger.error(s3.message), s3;
      }
    }), f5(this, "update", async (e2) => {
      try {
        return await this.engine.update(e2);
      } catch (s3) {
        throw this.logger.error(s3.message), s3;
      }
    }), f5(this, "extend", async (e2) => {
      try {
        return await this.engine.extend(e2);
      } catch (s3) {
        throw this.logger.error(s3.message), s3;
      }
    }), f5(this, "request", async (e2) => {
      try {
        return await this.engine.request(e2);
      } catch (s3) {
        throw this.logger.error(s3.message), s3;
      }
    }), f5(this, "respond", async (e2) => {
      try {
        return await this.engine.respond(e2);
      } catch (s3) {
        throw this.logger.error(s3.message), s3;
      }
    }), f5(this, "ping", async (e2) => {
      try {
        return await this.engine.ping(e2);
      } catch (s3) {
        throw this.logger.error(s3.message), s3;
      }
    }), f5(this, "emit", async (e2) => {
      try {
        return await this.engine.emit(e2);
      } catch (s3) {
        throw this.logger.error(s3.message), s3;
      }
    }), f5(this, "disconnect", async (e2) => {
      try {
        return await this.engine.disconnect(e2);
      } catch (s3) {
        throw this.logger.error(s3.message), s3;
      }
    }), f5(this, "find", (e2) => {
      try {
        return this.engine.find(e2);
      } catch (s3) {
        throw this.logger.error(s3.message), s3;
      }
    }), f5(this, "getPendingSessionRequests", () => {
      try {
        return this.engine.getPendingSessionRequests();
      } catch (e2) {
        throw this.logger.error(e2.message), e2;
      }
    }), f5(this, "authenticate", async (e2, s3) => {
      try {
        return await this.engine.authenticate(e2, s3);
      } catch (i4) {
        throw this.logger.error(i4.message), i4;
      }
    }), f5(this, "formatAuthMessage", (e2) => {
      try {
        return this.engine.formatAuthMessage(e2);
      } catch (s3) {
        throw this.logger.error(s3.message), s3;
      }
    }), f5(this, "approveSessionAuthenticate", async (e2) => {
      try {
        return await this.engine.approveSessionAuthenticate(e2);
      } catch (s3) {
        throw this.logger.error(s3.message), s3;
      }
    }), f5(this, "rejectSessionAuthenticate", async (e2) => {
      try {
        return await this.engine.rejectSessionAuthenticate(e2);
      } catch (s3) {
        throw this.logger.error(s3.message), s3;
      }
    }), this.name = (o4 == null ? void 0 : o4.name) || we.name, this.metadata = Ks(o4 == null ? void 0 : o4.metadata), this.signConfig = o4 == null ? void 0 : o4.signConfig;
    const t = typeof (o4 == null ? void 0 : o4.logger) < "u" && typeof (o4 == null ? void 0 : o4.logger) != "string" ? o4.logger : (0, import_pino2.default)(k2({ level: (o4 == null ? void 0 : o4.logger) || we.logger }));
    this.core = (o4 == null ? void 0 : o4.core) || new Zo(o4), this.logger = E2(t, this.name), this.session = new vt(this.core, this.logger), this.proposal = new ks(this.core, this.logger), this.pendingRequest = new Ds(this.core, this.logger), this.engine = new Cs(this), this.auth = new Gs2(this.core, this.logger);
  }
  static async init(o4) {
    const t = new _Ee(o4);
    return await t.initialize(), t;
  }
  get context() {
    return y2(this.logger);
  }
  get pairing() {
    return this.core.pairing.pairings;
  }
  async initialize() {
    this.logger.trace("Initialized");
    try {
      await this.core.start(), await this.session.init(), await this.proposal.init(), await this.pendingRequest.init(), await this.auth.init(), await this.engine.init(), this.logger.info("SignClient Initialization Success");
    } catch (o4) {
      throw this.logger.info("SignClient Initialization Failure"), this.logger.error(o4.message), o4;
    }
  }
};

// ../../node_modules/.pnpm/@cosmos-kit+walletconnect@2.13.1_@cosmjs+amino@0.34.0_@walletconnect+types@2.21.5/node_modules/@cosmos-kit/walletconnect/esm/utils/core.js
var WALLETCONNECT_DEEPLINK_CHOICE = "WALLETCONNECT_DEEPLINK_CHOICE";
var CoreUtil = {
  isHttpUrl(url) {
    return url.startsWith("http://") || url.startsWith("https://");
  },
  formatNativeUrl(appUrl, wcUri, os, name) {
    if (CoreUtil.isHttpUrl(appUrl)) {
      return this.formatUniversalUrl(appUrl, wcUri, name);
    }
    const plainAppUrl = appUrl.replaceAll("/", "").replaceAll(":", "");
    CoreUtil.setWalletConnectDeepLink(plainAppUrl, name);
    const encodedWcUrl = encodeURIComponent(wcUri);
    return `${plainAppUrl}://wc?uri=${encodedWcUrl}`;
  },
  formatUniversalUrl(appUrl, wcUri, name) {
    if (!CoreUtil.isHttpUrl(appUrl)) {
      return this.formatNativeUrl(appUrl, wcUri, name);
    }
    let plainAppUrl = appUrl;
    if (appUrl.endsWith("/")) {
      plainAppUrl = appUrl.slice(0, -1);
    }
    CoreUtil.setWalletConnectDeepLink(plainAppUrl, name);
    const encodedWcUrl = encodeURIComponent(wcUri);
    return `${plainAppUrl}/wc?uri=${encodedWcUrl}`;
  },
  async wait(milliseconds) {
    return new Promise((resolve) => {
      setTimeout(resolve, milliseconds);
    });
  },
  openHref(href, target = "_self") {
    window.open(href, target, "noreferrer noopener");
  },
  setWalletConnectDeepLink(href, name) {
    localStorage.setItem(WALLETCONNECT_DEEPLINK_CHOICE, JSON.stringify({ href, name }));
  },
  removeWalletConnectDeepLink() {
    localStorage.removeItem(WALLETCONNECT_DEEPLINK_CHOICE);
  }
};

// ../../node_modules/.pnpm/@cosmos-kit+walletconnect@2.13.1_@cosmjs+amino@0.34.0_@walletconnect+types@2.21.5/node_modules/@cosmos-kit/walletconnect/esm/client.js
var EXPLORER_API = "https://explorer-api.walletconnect.com";
var WCClient = class {
  constructor(walletInfo) {
    __publicField(this, "walletInfo");
    __publicField(this, "signClient");
    __publicField(this, "wcCloudInfo");
    // info from WalletConnect Cloud Explorer
    __publicField(this, "actions");
    __publicField(this, "qrUrl");
    __publicField(this, "appUrl");
    __publicField(this, "pairings", []);
    __publicField(this, "sessions", []);
    __publicField(this, "emitter");
    __publicField(this, "logger");
    __publicField(this, "options");
    __publicField(this, "relayUrl");
    __publicField(this, "env");
    __publicField(this, "requiredNamespaces");
    __publicField(this, "_defaultSignOptions", {
      preferNoSetFee: false,
      preferNoSetMemo: true,
      disableBalanceCheck: true
    });
    if (!walletInfo.walletconnect) {
      throw new Error(`'walletconnect' info for wallet ${walletInfo.prettyName} is not provided in wallet registry.`);
    }
    this.walletInfo = walletInfo;
    this.qrUrl = { state: State.Init };
    this.appUrl = { state: State.Init };
    this.requiredNamespaces = walletInfo.walletconnect.requiredNamespaces;
  }
  get defaultSignOptions() {
    return this._defaultSignOptions;
  }
  setDefaultSignOptions(options) {
    this._defaultSignOptions = options;
  }
  get isMobile() {
    var _a2;
    return ((_a2 = this.env) == null ? void 0 : _a2.device) === "mobile";
  }
  // walletconnect wallet name
  get wcName() {
    return this.walletInfo.walletconnect.name;
  }
  // wallet defined bytes encoding
  get wcEncoding() {
    return this.walletInfo.walletconnect.encoding || "hex";
  }
  // walletconnect wallet project id
  get wcProjectId() {
    return this.walletInfo.walletconnect.projectId;
  }
  // walletconnect wallet mobile link
  get wcMobile() {
    return this.walletInfo.walletconnect.mobile;
  }
  get accounts() {
    const accounts = [];
    this.sessions.forEach((s3) => {
      Object.entries(s3.namespaces).forEach(([, nsValue]) => {
        nsValue.accounts.forEach((account) => {
          const [namespace, chainId, address] = account.split(":");
          accounts.push({
            namespace,
            chainId,
            address
          });
        });
      });
    });
    return accounts;
  }
  deleteSession(topic) {
    var _a2, _b;
    const chainIds = [];
    this.sessions = this.sessions.filter((s3) => {
      if (s3.topic === topic) {
        s3.namespaces.cosmos.accounts.forEach((account) => {
          const [, chainId] = account.split(":");
          chainIds.push(chainId);
        });
        return false;
      } else {
        return true;
      }
    });
    (_a2 = this.emitter) == null ? void 0 : _a2.emit("reset", chainIds);
    (_b = this.logger) == null ? void 0 : _b.debug("[WALLET EVENT] Emit `reset`");
  }
  subscribeToEvents() {
    if (typeof this.signClient === "undefined") {
      throw new Error("WalletConnect is not initialized");
    }
    this.signClient.on("session_ping", (args) => {
      var _a2;
      (_a2 = this.logger) == null ? void 0 : _a2.debug("EVENT", "session_ping", args);
    });
    this.signClient.on("session_event", async (args) => {
      var _a2;
      (_a2 = this.logger) == null ? void 0 : _a2.debug("EVENT", "session_event", args);
    });
    this.signClient.on("session_update", ({ topic, params }) => {
      var _a2;
      (_a2 = this.logger) == null ? void 0 : _a2.debug("EVENT", "session_update", { topic, params });
    });
    this.signClient.on("session_delete", (args) => {
      var _a2;
      (_a2 = this.logger) == null ? void 0 : _a2.debug("EVENT", "session_delete", args);
      this.deleteSession(args.topic);
    });
    this.signClient.on("session_expire", (args) => {
      var _a2;
      (_a2 = this.logger) == null ? void 0 : _a2.debug("EVENT", "session_expire", args);
      this.deleteSession(args.topic);
    });
    this.signClient.on("session_proposal", (args) => {
      var _a2;
      (_a2 = this.logger) == null ? void 0 : _a2.debug("EVENT", "session_proposal", args);
    });
    this.signClient.on("session_request", (args) => {
      var _a2;
      (_a2 = this.logger) == null ? void 0 : _a2.debug("EVENT", "session_request", args);
    });
    this.signClient.on("proposal_expire", (args) => {
      var _a2;
      (_a2 = this.logger) == null ? void 0 : _a2.debug("EVENT", "proposal_expire", args);
    });
  }
  async deleteInactivePairings() {
    var _a2;
    if (typeof this.signClient === "undefined") {
      throw new Error("WalletConnect is not initialized");
    }
    for (const pairing of this.signClient.pairing.getAll({ active: false })) {
      await this.signClient.pairing.delete(pairing.topic, {
        code: 7001,
        message: "Clear inactive pairings."
      });
      (_a2 = this.logger) == null ? void 0 : _a2.debug("Delete inactive pairing:", pairing.topic);
    }
  }
  async deleteAllPairings() {
    var _a2;
    if (typeof this.signClient === "undefined") {
      throw new Error("WalletConnect is not initialized");
    }
    for (const pairing of this.signClient.pairing.getAll()) {
      await this.signClient.pairing.delete(pairing.topic, {
        code: 7001,
        message: "Clear pairings."
      });
      (_a2 = this.logger) == null ? void 0 : _a2.debug("Delete pairing:", pairing.topic);
    }
  }
  restorePairings() {
    var _a2;
    if (typeof this.signClient === "undefined") {
      throw new Error("WalletConnect is not initialized");
    }
    this.pairings = this.signClient.pairing.getAll({ active: true }).filter((p4) => {
      var _a3;
      return ((_a3 = p4.peerMetadata) == null ? void 0 : _a3.name) === this.wcName && p4.expiry * 1e3 > Date.now() + 1e3;
    });
    (_a2 = this.logger) == null ? void 0 : _a2.debug("RESTORED PAIRINGS: ", this.pairings);
  }
  get pairing() {
    return this.pairings[0];
  }
  restoreSessions() {
    var _a2;
    if (typeof this.signClient === "undefined") {
      throw new Error("WalletConnect is not initialized");
    }
    this.sessions = this.signClient.session.getAll().filter((s3) => s3.peer.metadata.name === this.wcName && s3.expiry * 1e3 > Date.now() + 1e3);
    (_a2 = this.logger) == null ? void 0 : _a2.debug("RESTORED SESSIONS: ", this.sessions);
  }
  async getSession(namespace, chainId) {
    if (typeof this.signClient === "undefined") {
      await this.init();
    }
    return this.sessions.find((s3) => {
      var _a2, _b;
      return (_b = (_a2 = s3.namespaces[namespace]) == null ? void 0 : _a2.accounts) == null ? void 0 : _b.find((account) => account.startsWith(`${namespace}:${chainId}`));
    });
  }
  get walletName() {
    return this.walletInfo.name;
  }
  get dappProjectId() {
    var _a2;
    return (_a2 = this.options) == null ? void 0 : _a2.signClient.projectId;
  }
  setActions(actions) {
    this.actions = actions;
  }
  setQRState(state) {
    var _a2, _b;
    this.qrUrl.state = state;
    (_b = (_a2 = this.actions) == null ? void 0 : _a2.qrUrl) == null ? void 0 : _b.state(state);
  }
  setQRError(e2) {
    var _a2, _b, _c, _d;
    this.setQRState(State.Error);
    this.qrUrl.message = typeof e2 === "string" ? e2 : e2 == null ? void 0 : e2.message;
    (_c = (_b = (_a2 = this.actions) == null ? void 0 : _a2.qrUrl) == null ? void 0 : _b.message) == null ? void 0 : _c.call(_b, this.qrUrl.message);
    if (typeof e2 !== "string" && (e2 == null ? void 0 : e2.stack)) {
      (_d = this.logger) == null ? void 0 : _d.error(e2.stack);
    }
  }
  async init() {
    await this.initSignClient();
    if (this.isMobile) {
      await this.initAppUrl();
    }
  }
  async initSignClient() {
    var _a2, _b, _c, _d, _e3, _f;
    if (this.signClient && this.relayUrl === ((_a2 = this.options) == null ? void 0 : _a2.signClient.relayUrl)) {
      return;
    }
    this.signClient = await Ee2.init((_b = this.options) == null ? void 0 : _b.signClient);
    this.relayUrl = (_c = this.options) == null ? void 0 : _c.signClient.relayUrl;
    (_d = this.logger) == null ? void 0 : _d.debug("CREATED CLIENT: ", this.signClient);
    (_f = this.logger) == null ? void 0 : _f.debug("relayerRegion ", (_e3 = this.options) == null ? void 0 : _e3.signClient.relayUrl);
    this.subscribeToEvents();
    this.restorePairings();
    this.restoreSessions();
  }
  async initWCCloudInfo() {
    var _a2;
    const fetcUrl = `${EXPLORER_API}/v3/wallets?projectId=${this.dappProjectId}&sdks=sign_v2&search=${this.wcName}`;
    const fetched = await (await fetch(fetcUrl)).json();
    this.wcCloudInfo = fetched.listings[this.walletInfo.walletconnect.projectId];
    (_a2 = this.logger) == null ? void 0 : _a2.debug("WalletConnect Info:", this.wcCloudInfo);
  }
  async initAppUrl() {
    var _a2, _b;
    this.appUrl.state = State.Pending;
    if (!this.wcCloudInfo)
      await this.initWCCloudInfo();
    const native = this.wcCloudInfo.mobile.native || ((_a2 = this.wcMobile) == null ? void 0 : _a2.native);
    const universal = this.wcCloudInfo.mobile.universal || ((_b = this.wcMobile) == null ? void 0 : _b.universal);
    this.appUrl.data = { native, universal };
    this.appUrl.state = State.Done;
  }
  get nativeUrl() {
    var _a2, _b, _c;
    const native = (_a2 = this.appUrl.data) == null ? void 0 : _a2.native;
    if (typeof native === "string" || typeof native === "undefined") {
      return native;
    } else {
      const { android, ios, macos, windows } = native;
      switch ((_b = this.env) == null ? void 0 : _b.os) {
        case "android":
          return android;
        case "ios":
          return ios;
        case "macos":
          return macos;
        case "windows":
          return windows;
        default:
          throw new Error(`Unknown os: ${(_c = this.env) == null ? void 0 : _c.os}.`);
      }
    }
  }
  get universalUrl() {
    var _a2;
    return (_a2 = this.appUrl.data) == null ? void 0 : _a2.universal;
  }
  get redirectHref() {
    return this.nativeUrl || this.universalUrl;
  }
  get redirectHrefWithWCUri() {
    var _a2;
    let href;
    if (this.nativeUrl) {
      href = (this.walletInfo.walletconnect.formatNativeUrl || CoreUtil.formatNativeUrl)(this.nativeUrl, this.qrUrl.data, (_a2 = this.env) == null ? void 0 : _a2.os, this.walletName);
    } else if (this.universalUrl) {
      href = (this.walletInfo.walletconnect.formatUniversalUrl || CoreUtil.formatUniversalUrl)(this.universalUrl, this.qrUrl.data, this.walletName);
    }
    return href;
  }
  get displayQRCode() {
    if (this.pairing || this.redirect) {
      return false;
    } else {
      return true;
    }
  }
  get redirect() {
    return Boolean(this.isMobile && (this.nativeUrl || this.universalUrl));
  }
  openApp(withWCUri = true) {
    var _a2, _b;
    const href = withWCUri ? this.redirectHrefWithWCUri : this.redirectHref;
    if (href) {
      (_a2 = this.logger) == null ? void 0 : _a2.debug("Redirecting:", href);
      CoreUtil.openHref(href);
    } else {
      (_b = this.logger) == null ? void 0 : _b.error("No redirecting href.");
    }
  }
  async connect(chainIds, options) {
    var _a2, _b, _c, _d, _e3, _f, _g, _h;
    if (typeof this.signClient === "undefined") {
      await this.init();
    }
    if (this.qrUrl.state !== "Init") {
      this.setQRState(State.Init);
    }
    const chainIdsWithNS = typeof chainIds === "string" ? [`cosmos:${chainIds}`] : chainIds.map((chainId) => `cosmos:${chainId}`);
    this.restorePairings();
    const pairing = this.pairing;
    (_a2 = this.logger) == null ? void 0 : _a2.debug("Restored active pairing topic is:", pairing == null ? void 0 : pairing.topic);
    if (this.displayQRCode)
      this.setQRState(State.Pending);
    const requiredNamespaces = {
      cosmos: {
        methods: [
          "cosmos_getAccounts",
          "cosmos_signAmino",
          "cosmos_signDirect",
          ...((_b = this.requiredNamespaces) == null ? void 0 : _b.methods) ?? []
        ],
        chains: chainIdsWithNS,
        events: [
          "chainChanged",
          "accountsChanged",
          ...((_c = this.requiredNamespaces) == null ? void 0 : _c.events) ?? []
        ]
      }
    };
    let connectResp;
    try {
      (_d = this.logger) == null ? void 0 : _d.debug("Connecting chains:", chainIdsWithNS);
      connectResp = await this.signClient.connect({
        pairingTopic: pairing == null ? void 0 : pairing.topic,
        requiredNamespaces,
        ...options
      });
      this.qrUrl.data = connectResp.uri;
      (_e3 = this.logger) == null ? void 0 : _e3.debug("Using QR URI:", connectResp.uri);
      if (this.displayQRCode)
        this.setQRState(State.Done);
    } catch (error) {
      (_f = this.logger) == null ? void 0 : _f.error("Client connect error: ", error);
      if (this.displayQRCode)
        this.setQRError(error);
      return;
    }
    if (this.redirect)
      this.openApp();
    try {
      const session = await connectResp.approval();
      (_g = this.logger) == null ? void 0 : _g.debug("Established session:", session);
      this.sessions.push(session);
      this.restorePairings();
    } catch (error) {
      (_h = this.logger) == null ? void 0 : _h.error("Session approval error: ", error);
      await this.deleteInactivePairings();
      if (!error) {
        if (this.displayQRCode)
          this.setQRError(ExpiredError);
        throw new Error("Proposal Expired");
      } else if (error.code == 5001) {
        throw RejectedError;
      } else {
        throw error;
      }
    } finally {
      if (!pairing && this.qrUrl.message !== ExpiredError.message) {
        this.setQRState(State.Init);
      }
    }
  }
  async disconnect(options) {
    var _a2, _b, _c, _d, _e3;
    if (typeof this.signClient === "undefined") {
      await this.init();
    }
    if (((_a2 = options == null ? void 0 : options.walletconnect) == null ? void 0 : _a2.removeAllPairings) === true) {
      await this.deleteAllPairings();
    }
    if (this.sessions.length === 0) {
      return;
    }
    for (const session of this.sessions) {
      try {
        (_b = this.logger) == null ? void 0 : _b.debug("Delete session:", session);
        const { getSdkError } = await import("./index.es-DLQUG72I.js");
        await this.signClient.disconnect({
          topic: session.topic,
          reason: getSdkError("USER_DISCONNECTED")
        });
      } catch (error) {
        (_c = this.logger) == null ? void 0 : _c.error(`SignClient.disconnect session ${session.topic} failed:`, error);
      }
    }
    this.sessions = [];
    (_d = this.emitter) == null ? void 0 : _d.emit("sync_disconnect");
    (_e3 = this.logger) == null ? void 0 : _e3.debug("[WALLET EVENT] Emit `sync_disconnect`");
  }
  async getSimpleAccount(chainId) {
    const account = this.accounts.find(({ chainId: id }) => id === chainId);
    if (!account) {
      throw new Error(`Chain ${chainId} is not connected yet, please check the session approval namespaces`);
    }
    return account;
  }
  getOfflineSignerAmino(chainId) {
    return {
      getAccounts: async () => [await this.getAccount(chainId)],
      signAmino: (signerAddress, signDoc) => this.signAmino(chainId, signerAddress, signDoc)
    };
  }
  getOfflineSignerDirect(chainId) {
    return {
      getAccounts: async () => [await this.getAccount(chainId)],
      signDirect: (signerAddress, signDoc) => this.signDirect(chainId, signerAddress, signDoc)
    };
  }
  async getOfflineSigner(chainId, preferredSignType) {
    var _a2;
    if (preferredSignType === "amino" && this.getOfflineSignerAmino) {
      return this.getOfflineSignerAmino(chainId);
    }
    if (preferredSignType === "direct" && this.getOfflineSignerDirect) {
      return this.getOfflineSignerDirect(chainId);
    }
    return this.getOfflineSignerAmino ? (_a2 = this.getOfflineSignerAmino) == null ? void 0 : _a2.call(this, chainId) : this.getOfflineSignerDirect(chainId);
  }
  async _getAccount(chainId) {
    var _a2;
    const session = await this.getSession("cosmos", chainId);
    if (!session) {
      throw new Error(`Session for ${chainId} not established yet.`);
    }
    const resp = await this.signClient.request({
      topic: session.topic,
      chainId: `cosmos:${chainId}`,
      request: {
        method: "cosmos_getAccounts",
        params: {}
      }
    });
    (_a2 = this.logger) == null ? void 0 : _a2.debug(`Response of cosmos_getAccounts`, resp);
    return resp;
  }
  async getAccount(chainId) {
    const { address, algo, pubkey } = (await this._getAccount(chainId))[0];
    return {
      address,
      algo,
      pubkey: new Uint8Array(Buffer.from(pubkey, this.wcEncoding))
    };
  }
  async _signAmino(chainId, signer, signDoc, signOptions) {
    var _a2;
    const session = await this.getSession("cosmos", chainId);
    if (!session) {
      throw new Error(`Session for ${chainId} not established yet.`);
    }
    if (this.redirect)
      this.openApp();
    const resp = await this.signClient.request({
      topic: session.topic,
      chainId: `cosmos:${chainId}`,
      request: {
        method: "cosmos_signAmino",
        params: {
          signerAddress: signer,
          signDoc
        }
      }
    });
    (_a2 = this.logger) == null ? void 0 : _a2.debug(`Response of cosmos_signAmino`, resp);
    return resp;
  }
  async signAmino(chainId, signer, signDoc, signOptions) {
    const result = await this._signAmino(chainId, signer, signDoc, signOptions || this.defaultSignOptions);
    return result;
  }
  async _signDirect(chainId, signer, signDoc, signOptions) {
    var _a2;
    const session = await this.getSession("cosmos", chainId);
    if (!session) {
      throw new Error(`Session for ${chainId} not established yet.`);
    }
    const signDocValue = {
      signerAddress: signer,
      signDoc: {
        chainId: signDoc.chainId,
        bodyBytes: Buffer.from(signDoc.bodyBytes).toString(this.wcEncoding),
        authInfoBytes: Buffer.from(signDoc.authInfoBytes).toString(this.wcEncoding),
        accountNumber: signDoc.accountNumber.toString()
      }
    };
    if (this.redirect)
      this.openApp();
    const resp = await this.signClient.request({
      topic: session.topic,
      chainId: `cosmos:${chainId}`,
      request: {
        method: "cosmos_signDirect",
        params: signDocValue
      }
    });
    (_a2 = this.logger) == null ? void 0 : _a2.debug(`Response of cosmos_signDirect`, resp);
    return resp;
  }
  async signDirect(chainId, signer, signDoc, signOptions) {
    const { signed, signature } = await this._signDirect(chainId, signer, signDoc, signOptions || this.defaultSignOptions);
    return {
      signed: {
        chainId: signed.chainId,
        accountNumber: BigInt(signed.accountNumber),
        authInfoBytes: new Uint8Array(Buffer.from(signed.authInfoBytes, this.wcEncoding)),
        bodyBytes: new Uint8Array(Buffer.from(signed.bodyBytes, this.wcEncoding))
      },
      signature
    };
  }
};

// ../../node_modules/.pnpm/@cosmos-kit+walletconnect@2.13.1_@cosmjs+amino@0.34.0_@walletconnect+types@2.21.5/node_modules/@cosmos-kit/walletconnect/esm/main-wallet.js
var WCWallet = class extends MainWalletBase {
  constructor(walletInfo, ChainWC2, WCClient2) {
    if (!walletInfo.walletconnect) {
      throw new Error(`'walletconnect' info for wallet ${walletInfo.prettyName} is not provided in wallet registry.`);
    }
    super(walletInfo, ChainWC2);
    __publicField(this, "WCClient");
    __publicField(this, "clientMutable", { state: State.Init });
    this.WCClient = WCClient2;
  }
  async initClient(options) {
    if (!options) {
      this.initClientError(new Error("`walletconnectOptions` is not provided."));
      return;
    }
    if (!options.signClient.projectId) {
      this.initClientError(new Error("`projectId` is not provided in `walletconnectOptions`."));
      return;
    }
    this.initingClient();
    try {
      const client = new this.WCClient(this.walletInfo);
      client.logger = this.logger;
      client.emitter = this.emitter;
      client.env = this.env;
      client.options = options;
      this.initClientDone(client);
    } catch (error) {
      this.initClientError(error);
    }
  }
};

// ../../node_modules/.pnpm/@cosmos-kit+keplr-mobile@2.15.1_@cosmjs+amino@0.34.0_@cosmjs+proto-signing@0.34.0_@wall_4d80990aea15eba7d005a9e6df60de3d/node_modules/@cosmos-kit/keplr-mobile/esm/wallet-connect/client.js
var import_long2 = __toESM(require_long());
var import_wc_client = __toESM(require_build10());
var KeplrClient2 = class extends WCClient {
  constructor(walletInfo) {
    super(walletInfo);
    __publicField(this, "keplr");
  }
  initKeplrWCClient(signClient, options) {
    var _a2;
    this.keplr = new import_wc_client.KeplrWalletConnectV2(signClient, options);
    localStorage.setItem("wallet-connect-v2-mobile-link", JSON.stringify(((_a2 = this.env) == null ? void 0 : _a2.os) === "android" ? {
      name: "Keplr",
      href: "intent://wcV2#Intent;package=com.chainapsis.keplr;scheme=keplrwallet;end;"
    } : {
      name: "Keplr",
      href: `keplrwallet://wcV2`
    }));
  }
  async connect(chainIds, options) {
    var _a2, _b, _c, _d, _e3, _f, _g, _h, _i2;
    if (typeof this.signClient === "undefined") {
      await this.init();
    }
    if (this.qrUrl.state !== "Init") {
      this.setQRState(State.Init);
    }
    const chainIdsWithNS = typeof chainIds === "string" ? [`cosmos:${chainIds}`] : chainIds.map((chainId) => `cosmos:${chainId}`);
    this.restorePairings();
    const pairing = this.pairing;
    (_a2 = this.logger) == null ? void 0 : _a2.debug("Restored active pairing topic is:", pairing == null ? void 0 : pairing.topic);
    if (this.signClient && (pairing == null ? void 0 : pairing.topic)) {
      const allSessions = this.signClient.session.getAll();
      const currentSession = allSessions.find((session) => session.pairingTopic === pairing.topic);
      if (allSessions.length > 0 && currentSession) {
        this.initKeplrWCClient(this.signClient, {
          sessionProperties: currentSession.sessionProperties
        });
        return;
      }
    }
    if (this.displayQRCode)
      this.setQRState(State.Pending);
    const requiredNamespaces = {
      cosmos: {
        methods: [
          "cosmos_getAccounts",
          "cosmos_signAmino",
          "cosmos_signDirect",
          ...((_b = this.requiredNamespaces) == null ? void 0 : _b.methods) ?? []
        ],
        chains: chainIdsWithNS,
        events: [
          "chainChanged",
          "accountsChanged",
          ...((_c = this.requiredNamespaces) == null ? void 0 : _c.events) ?? []
        ]
      }
    };
    let connectResp;
    try {
      (_d = this.logger) == null ? void 0 : _d.debug("Connecting chains:", chainIdsWithNS);
      connectResp = await ((_e3 = this.signClient) == null ? void 0 : _e3.connect({
        pairingTopic: pairing == null ? void 0 : pairing.topic,
        requiredNamespaces,
        ...options
      }));
      this.qrUrl.data = connectResp.uri;
      (_f = this.logger) == null ? void 0 : _f.debug("Using QR URI:", connectResp.uri);
      if (this.displayQRCode)
        this.setQRState(State.Done);
    } catch (error) {
      (_g = this.logger) == null ? void 0 : _g.error("Client connect error: ", error);
      if (this.displayQRCode)
        this.setQRError(error);
      return;
    }
    if (this.redirect)
      this.openApp();
    try {
      const session = await connectResp.approval();
      (_h = this.logger) == null ? void 0 : _h.debug("Established session:", session);
      this.sessions.push(session);
      this.restorePairings();
      if (this.signClient) {
        this.initKeplrWCClient(this.signClient, {
          sessionProperties: session.sessionProperties
        });
      }
    } catch (error) {
      (_i2 = this.logger) == null ? void 0 : _i2.error("Session approval error: ", error);
      await this.deleteInactivePairings();
      if (!error) {
        if (this.displayQRCode)
          this.setQRError(ExpiredError);
        throw new Error("Proposal Expired");
      } else if (error.code == 5001) {
        throw RejectedError;
      } else {
        throw error;
      }
    } finally {
      if (!pairing && this.qrUrl.message !== ExpiredError.message) {
        this.setQRState(State.Init);
      }
    }
  }
  async enable(chainIds) {
    if (!this.keplr) {
      throw new Error("Keplr Wallet is not initialized");
    }
    await this.keplr.enable(chainIds);
  }
  async getSimpleAccount(chainId) {
    if (!this.keplr) {
      throw new Error("Keplr Wallet is not initialized");
    }
    await this.enable(chainId);
    const { address, username } = await this.getAccount(chainId);
    return {
      namespace: "cosmos",
      chainId,
      address,
      username
    };
  }
  async getAccount(chainId) {
    if (!this.keplr) {
      throw new Error("Keplr Wallet is not initialized");
    }
    const key = await this.keplr.getKey(chainId);
    return {
      username: key.name,
      address: key.bech32Address,
      algo: key.algo,
      pubkey: key.pubKey,
      isNanoLedger: key.isNanoLedger
    };
  }
  async getOfflineSigner(chainId, preferredSignType) {
    if (!this.keplr) {
      throw new Error("Keplr Wallet is not initialized");
    }
    switch (preferredSignType) {
      case "amino":
        return this.getOfflineSignerAmino(chainId);
      case "direct":
        return this.getOfflineSignerDirect(chainId);
      default:
        return this.getOfflineSignerAmino(chainId);
    }
  }
  getOfflineSignerAmino(chainId) {
    if (!this.keplr) {
      throw new Error("Keplr Wallet is not initialized");
    }
    return this.keplr.getOfflineSignerOnlyAmino(chainId);
  }
  getOfflineSignerDirect(chainId) {
    if (!this.keplr) {
      throw new Error("Keplr Wallet is not initialized");
    }
    return this.keplr.getOfflineSigner(chainId);
  }
  async signAmino(chainId, signer, signDoc, signOptions) {
    if (!this.keplr) {
      throw new Error("Keplr Wallet is not initialized");
    }
    return await this.keplr.signAmino(chainId, signer, signDoc, signOptions);
  }
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
  async signDirect(chainId, signer, signDoc, signOptions) {
    var _a2;
    if (!this.keplr) {
      throw new Error("Keplr Wallet is not initialized");
    }
    return await this.keplr.signDirect(chainId, signer, {
      ...signDoc,
      accountNumber: import_long2.default.fromString(((_a2 = signDoc.accountNumber) == null ? void 0 : _a2.toString()) ?? "0")
    }, signOptions);
  }
  async signArbitrary(chainId, signer, data) {
    if (!this.keplr) {
      throw new Error("Keplr Wallet is not initialized");
    }
    return await this.keplr.signArbitrary(chainId, signer, data);
  }
};

// ../../node_modules/.pnpm/@cosmos-kit+keplr-mobile@2.15.1_@cosmjs+amino@0.34.0_@cosmjs+proto-signing@0.34.0_@wall_4d80990aea15eba7d005a9e6df60de3d/node_modules/@cosmos-kit/keplr-mobile/esm/wallet-connect/chain-wallet.js
var ChainKeplrMobile = class extends ChainWC {
  constructor(walletInfo, chainInfo) {
    super(walletInfo, chainInfo, KeplrClient2);
  }
};

// ../../node_modules/.pnpm/@cosmos-kit+keplr-mobile@2.15.1_@cosmjs+amino@0.34.0_@cosmjs+proto-signing@0.34.0_@wall_4d80990aea15eba7d005a9e6df60de3d/node_modules/@cosmos-kit/keplr-mobile/esm/wallet-connect/main-wallet.js
var import_provider_extension2 = __toESM(require_build2());
var KeplrMobileWallet = class extends WCWallet {
  constructor(walletInfo, preferredEndpoints3) {
    super(walletInfo, ChainKeplrMobile, KeplrClient2);
    this.preferredEndpoints = preferredEndpoints3;
  }
  async initClient(options) {
    try {
      const keplr = await import_provider_extension2.Keplr.getKeplr();
      const userAgent = window.navigator.userAgent;
      if (keplr && userAgent.includes("KeplrWalletMobile")) {
        this.initClientDone(keplr ? new KeplrClient(keplr) : void 0);
      } else {
        await super.initClient(options);
      }
    } catch (error) {
      if (error instanceof Error) {
        if (error.message === "Client Not Exist!") {
          await super.initClient(options);
          return;
        }
        this.initClientError(error);
      }
    }
  }
};

// ../../node_modules/.pnpm/@cosmos-kit+keplr-mobile@2.15.1_@cosmjs+amino@0.34.0_@cosmjs+proto-signing@0.34.0_@wall_4d80990aea15eba7d005a9e6df60de3d/node_modules/@cosmos-kit/keplr-mobile/esm/constant.js
var ICON2 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQAAAAEACAYAAABccqhmAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAGAzSURBVHgB3b0L1G3HUR5Ydf5fb8kWCZMMYKOr8IgHCLETQ4BAJMPMQGBlbDMLAyuAJdYM2IQsbDI8bAKWCEwmAwMWhlhmCL7yygoJhtjGAQMx6BqZYMwASgIE2xBdxy8CA77W6+px79/Z55z96K76qrp6n9eVSjr3P7vruXv3V13de59zmJ7IdHe6nujxU0SPPZOITxEvbuj+dm0nH91xj9evdFy1k8Z/IoIrYmqlE4ratvg8SzdwXsrwiW+PHV5OCwr4Tk6EG8TBqiUQF4okXehivECJL3R6F7qGs3Tx4nu79/d24Z2jz77xDD2BqX0cH5LuPn+K6OLNdHR0E6V0c9dyauSZo6gCgBSUy2TmAXHJbgQq529TXK+Vx1G9GTrs8FZ8KwEEE40Vh5kA2hJHQWye47204GVCeFuXHM50SeEsPUHo0k8Ad5+/mRbpeV2oz6UV4MVFqOI2BVk7TgDVKsP3z7zDBLByMEMvohNIAFgCA7nOt/VGT802e2LvPAobZ7sK4Qw9nu661CuESzMBjKCnF65L+pwSfGvTdhMAV/jzfdg8lvw5YK3xLrkE0LduMQGsuR4/kHTcCiGzMdElnQwunQSwWs+fv4WOupk+0c224JYSQArKCZlQApi1HGlIAAVjSwlgckRbTQAruYo9Ht9pnvKzGS9tBPJZCWCiRZcMTtLt9Jk3nqZLhA6fAJbAP37km7qOeYme7RHVQGbIV5vrBnmjGb7GT4bPmm5glmzhtSaVSNIIJgDRSiGQQ76vl0weUR3ktWVAjb/6e7bbVHwjXTi549D7BYdLAM3AHyg1gL+XDzRV1+BIpjmJtAGSQ7pBkLTweM8JoLCjeRiwgQTg8NLcBLBxghC2iF7Z3Vs4WCI4TAK45/wr2oHfU2pCP9VBW2XgWXhGEmkBJM/V3db+QLSqiC4bNtnRJ5QEggnA0Uv72wcQfOXr7CoJfNaNr6Q9034TwGpzj1/bnfgpmkNp/KdVKaBWK8F7mdRuI8ZPwF+b7kita3mLF60qqv42LOWHIy+5zeFx675Dz98kAYwyQG6ZCC7SS+lv3PhG2hPtJwEsy/2jR1/Rne9L1g2tIM5VGnXDFYORALa2xvf5vMXqYTK6pwQwym6YAJQMTjapVS/AS4g/q0KgSr9T5BxP0+N0+z6WBbtPAOOsv7yHP1ADiJvX2VJ0fgLgra7xDR8b6NZ5M4AsebXyOqdZa30M8hovzdSDfM45XvLIdDfZJyj0zYR6tmPdSp+x21uHkYc159OvPPKDHfjvpgL8AUrZaw5totsTb6gf8kF7on31ZUQ2YiuYR1pyUzzfcWWCZqNdyGw+V5zq/r2bfuO+V9AOaTdjcPnI7lE365v381OoKazrsoKGU20NHrEV429lnb8JL7pmh3pzZnmgV42h4k/wUkQnZNOzq/nVzc1QJVAdo/d2m4TP38WSYPsJ4O4Hn0mL4zeQN+s37+QXyu5hVd5kpUBnbJAAUnCdXxtQ2+RlZU78roMfIwZMr6f8O7yRH+fFk0A8AYwt4T0GIFNNAgE8LJcEj9Nztp0EtrsEuPvR53Xgv5sk+JN4bUpbXiLAcnKuTeMVtl+xM4fYeqX+RY2UAr42LfVr/OT79pfoHLY52k7SU02PK3wRT2RJcEy/Tf/ffc+jLdL2EsDbH3th10tv6AK9fuuApy3YM/Q3An4gpq0kF8vntnzP6dvIpJXs5BO205gEcp57/slrx1o8t0CL8Id9A19uia030DvuewltibaTAN7W3eK7cHKatk2bgD4Ako1n5Qptf31lUCpn842STkt/R2QNmSLOHSYBmtMncxOL0mMYj02RDcaOjugHt7U5uPkYXYI/pduoidIs1jxdLO+ueVOTA8Wft8lX42te9RZidNPO4rVMd1Eke8iB4z8JH74uBXU3+1AQFedbWwG0zUBNJept3W3C22kD2iwBvO2Rb+rinfH4YnIPw7ohvVLIvt7bWbTu7i6Cl1wCII9NWZvpzb5L4IFc3Jn3dBXf5yXYLvTdJJCQBvDn9Em0f604eHELPfuGu2gmzU8Ayw2/5Zp/Dm16F2BmwvDHzmYJgEM25vHrtht5kYHZAiypF6kcavYcfgrr1mbTVL6z+P6OIuTrRFC59tH+Zdj2fHr2vMeH5yWA1Vdz8W/TclNiFs1MAGn8J0zjrbdNlhaOTHndtpcAzCXK3Jkc0ZxHhVuWFZvM1gXfjiW1xhnwmSx+8xIkl0gxtIWSs5Slc534c+gzb7yXGql9E3AN/rtpNviDlMCrQXfYFGvWDdiG9rfko7pZlWizvrFs7UKnJrcFvrnBh6d0YZNdm3ATTxEDu0iC432W263Jrl9LLL6Bfu2+U9RI7Qlg+UUG1N2T3BZtY0AL3XlljW8zt70V+xmZg7iFtpQMvFt36lWRL2zXfM/lZ+sB5buWXDxecs5lbuEU0S9kmkbE8jmB11IjtSWAu7sdf6a/SnNoG0C37PU0C0SBuLYCUEC7sLmi4lwY9tH6xRi0QK8ktv0RBuQ6WbAzY1f8NYJu8svkfp9q1S4X9kpe7q1ut/iUQVM1EKTlo/e/cd8PtqjEx9/yU31pVfpvgYJnluK6XDNSdZkCNgOpO/l8dp0E7De0s8dvnSbZ4SnbFZvs8HpfyeL1/DivtAs0KjERxXb7vf7Q2snlI/KuoaCLq0eGz1CAYglgue5PMz7VZ1JyD1t0a2MpbrxiN2mZmg1tay7AAR8EWE2CFq/eiSXVBjwAnOJBPii9Ml6CccR0bZ6w7PWFsaUw6UWTQAoXV45HT/csXUbPomfdeI4qFFsCXKTbaFPwJ+c1g8aSbIs2V3YT6c29sD3GMRr8jShla/C0oeXW84zKR0rsMJ/hHoSrS5OuzSuXQhS2OVkuxqGna5wLlHMzBLs+un45tXiMXkEBqo+b5f3+k5n3+01qQKi6WK3oTlu0G5Ph2TbqiGqa5VvLfKXboFdbykRiqc6iMV5qsevElZqXGmuZ5PJz3/b54HNATY6Nk/pSoP67eSepaVNhNtXGxQ7sbmzbstWaowxjG8eWsN1m3UgsaZJd/yMAOfJLnm3D4Ju83i6INQ2IRIBz4mIRT0J6GX84WE0mma45HMYMk1TQXu4pBdgU4gW9tmu5kRzylwB3P/JNtLV1f08NJbtT7Gxkd2u2p5JrK88cFLvyDefSRMIWR17QP4fsE7BVvdVoni/HSm0y/DfqFbxUXh9ft9xtDC3RWq8xHB8qulP0a394m2fGjmu58XfSbfylLSeAFfln6nbWhl8Lbleq7UsADshE+BzWn1cec8QmV/ilQZuX60Vschvf/86+eXaTlKmhlZUGtOvObJDr9fVM4nQuXd5VAcaGoF0BnPA37Qb8NpkzX5HlGimbobf15F5T9VCxsamdkUBFEtscZKXf4mueHGuZmo1MU1ULnt0aH9isx8RmTC39oishNmVnj9fE19MjZH5/AB4fy9n/It9H26KEG+YN/uQe5lTbJAkbQrbSXDuR0VEo2LyCHbRbmxkRb9ZM7s9+Pr92UWO6qcW308+psUpREtFvmK30TXJ1nMvEdO7k8gSrAFwBrGd/2tqL8FovRAHb+nwbwF+xv9ltwTKeWQnPiGf2rb855zH4Jn/dXq7vGV/zmt9N+Cve1CtWjHW7Zc/iPq9XMcpvrb9Tfg5s2yPc7+Y4PqHrF0YVAMcQv/WR+6gv/2sxzxuEjQgqlU2OTuItfpJty5Dx7HCFX9PHsdSQoRQwX9n2dB2ftdmaUr16CPJTk37Ndhkbnlkr1ymbre1KA/jMZOKjM3I+VTp3cqWuAnQF8Ivnb+kyxik444AXzXltg0B8m/qAM3XjuW3UL1nsMJYoBWyatlUfct1PJBZFHLMx9Cv5M6BrO7XZXvM4FBcReKjH9FtWDfKOiE29hHFdg3T94jzdIhsX2hW/gnZKCTe1Ao22Bw4XtAHaCKzAxryNULbtWTZrFJUNDvgIGM3EU+FbtxeVvhdbxhmXMaG4/WWHe16Z//ot0uE/gksA97WUZX6udF1G85bzN/NiWx/4sSiIKkCqXK2aTRVbMVkkwwGZeTbi+srORje6iUKlq5Jz7NaWCNUyO9AXPE8/VWMTfgQvWfEoXUMqujEo/BrW4iYupudc+Lzp6cDiScDFgm6ZD88tkTfWNqSqrcDJbyMeDjc26C8ptSrkAqnUZ8eEnEk5kJRRDMPTexV+svgrJHr6ZPJ4NIqTSHJ0C5VstQH7EdhY5x6mXNNOKqVfRcwBoYlOjmj5uwJniljGg1/oNv+oW//PpVD2qAvxhvqT6HRZAsIulwMylh2u8Jv1mzMA4KtBWakQOGB3WxUER3VLfqrwsb6QMc4hVauNUlq/o7brts2Zr7w+5y58zqmPGjjTHsBblp/378Cfr1laXxsQXLchaognZC8Y1751Xf2ZfW+uHSOaET/ReKJ2GnnjeVG5bg7bJs82+/1lnDvqc+0DXOktYmu0v9rY5OuP77nv5oEzLgG6THDLxn6iFBp08yhsN23BxrZ0Gb5tI28SqxlNDfJQljWjWv5nTHcJYfA9feHbnfT7+IubeWbsU4nPgD+qOR/yGVXMfiSC3xbggbN10CymZcDxZJ9v2jzTYNo62EGW3QZtMtNv5LO139k91BQCeAZi2b/RhGDJZZ/Um2UjOTyi6nrdW+tP1TFONNq2SHYZX5vvEkvyMrOOY4pFNFJMN0S8WN4NeMna15Lecv5U5/Q+2pBiQEjuYYt+3V/dOEdlk5ZhW9BxuJ0fD2HHfk0XqlUHXG0g17LyofmTTDL5mZ3Kej81lZDJsVOjBPU2paOjkxsf+ewbz64qgKMTuvkky2CRpH4oMvZa5tvYk+6oV40Zz1YbL224+FPXYyMuKbvprL41vjEzF/prmSLXqRJ+KvMlPxdkp6pQD7oyQpahXm1I9THUJxZvzFx8nG7u/pxebQJ2FdrNXOqPr51Rantt42m/Tc5pji7ux6AV77wD58/ytbLD8f6L+hplWBUJ0rf5kEuA7z6ZV4vT42ftk0/jexkUMewnGX/ZR5XrX73WAXR6Y2YYV4ujm5ai6z2AxPO+6nuHNKu8Ti225sawfZ1cqa6PZ2I27LmUgG1jCcHRsrAmN5PPIX0m9FxAcUbWfoRTUfi+OV9YQBkV5raeAVAdVLWS2Us3j2qLn32kQXMmJfVGUX3cxsPkRnl1sR0Z258vY9nhCl87m/kNwJVBAvuMA7a5wg/4rtoI8w0ZjcLpnXfRo0/sVc4vjTKQ49jcBiX9rrN99YWTjzqmN6/u/++JagN/c2pNhIXeLnXYPWxTTxEhQAmIBXXWskzQeT6qugM2Z3Zj9i1sUIVvVClZU0JxJmk7m+E930ncIrT6q3J+5rjM9gcStOlQeBCxftfZfojo1PERLa5P28oA+0hmW7S7c9DnlDYA/eySPqtmG3S8Qc5BOVcmWsZH9IEMp6Aus4YdLOHxsgsvM0T8QBb76x9ZavmMwIYJ4ujo6JnHiU6eWd2YaKBdAV352CBn7RP4PEPRqVarwuEqkx2DKbUD3ZJz1taYX9OP2gBABOt+L8mmWvUj85QyVsaYJBtRgcVA5eFRDSMn6dTx6rP/7T8ROtKcDzXN9kXzaTaAqZ1C5Xouv8mJqcqCKxelH8iVwS99TOoACIWc43+LZb67HKklLJXdkjHzS127xE/jP2QmAi6EBVnVxNhYGUizBurRDcfMfIP3gapDUyimyL7Qpj55hk5UviWJcsBX61KgpUJAtrkis2mZ38qXU6380ZCNqhLWRrh2PXksW81LbXUHzNKV5BildPGjjnn92+KXFG2aiHYy26dG+aiPgJFwsmBDx9MNAr3tcWAHUKMMVfj1dbc3e1v22UsWLITF4VgEUOabqO4/U2ZqnG0h1mWJ0o7+votv6PYADp8AmoC0j9k+qhNUbk0sSieaJILJwfI/nZcAMMlDuxQOJY4UtQGWAipZRGbvEqxJ8UFcgK/72I5PdZc8SPMHssZ9MItrS9cf054rgLlA3batjUr2gVKjfEXI1KmNlYgzMSLZAp+SJSjHQbl5s7/Bn70U6JnsrMVnVBbrlUC2zrcqMLPCAQLJuNyzBntV6frlk4A7TQDVmWmuzT3pcYNAs30Tg2JWkxVfrcQWeuKtr1ed9QiX+VKu+swA1SsNbykw8jOZarKwZ/emyiIXyR06t/+S56u4wKl5spFmGmhVAWyNfP+bOQqfW6QElfKijGvpx1lf7da6dKhWcrqBzamE7Bkd+YrM6kgO2GHPTutSQOlXABtMFql4g2d36IOFvJAp3FuUgI2WwZjqTdJcOAG0J5fNaSszfeT8Gvu6OS6Ox8TVBqATAWSzPAAKlANVggSb5COZrSwFeltVsNrJosBx3hq4a5GkQC1pCRewIdUULX23eaTjfd7Hr9EmFcRWkgVsCLF8+ei1i862NR2hx1DRlrdkFdAjM7MhwyFA5zKRZNIfBB4Acmd3YD8FkpmucLg0WJ391VvnQif3MErHdECaC9pt6Ju6KSjXYpsDMsC3kg8mCFO2kLfXw5ssBzgEZslnsjNWbsOY4b19A8gXwYSfGDRm9mrynGbzZF4w49AcEwzetmeBre4B1GhTwG9qJ6THjfIUkPfGNjfYdMpHPftgOaheK8+FTVZyht9aElIgSQ4/6KNp3wD4NmVyG3byhDYyOZa+HNkwpX4ri7j/awiRdrXTCmBbgJ9nK83Sa10ScYDpytQnBMNA9lCJkxikr5BtNCHWZmXD38SwZ+4Jhw4Qi0CCYK1WHoIZTBjFyIp+8CcBAb2mArIOgcmKK8KSv3EFEAPYPCc7nennyEcAnYs2XMhIkjDygG00pTrgUXUSSAohW6zjier7/CmhoAppLCDkV3HJiRcuRTLBWsJaOymZ4u0kB9qSZOiL4Q6hDbG7pOPQDLQn2tQvNzBmJYmsr77jUy5fvXZN1/30R7IAAFmYCshzZWbWRkVTQ7n98Vcf0T03XU9PvexQo4voo97yR8WxvRHZ90ugH8qk1DcEEqjCvnSQ1v+0jOk5dHy4y7GmnYE+p9QoP0N25+Rk+9DGG6FZ2ZbNMwlHylxn2bAE/5s/56kHBf/f+w/3ty0XUFILzew8gteTq1aI6mIFYplBe90EXNI2hsCs2btB4JIEvhejcQ25GezZ29pgr63fe5kB/B9/9QafOd+QXv57D9BPvO98vyTAywGcGCtLAmRnlONMJMX3aUy71TJsFu00AWwPSGC9t03fKa7jAmSHVP2IP4H4A4POHEOgJGYPNMDGUy9n+uef+ZSDgv+fvOchuvO+h9cHed3dNLtvsuHXL7Wsjg5cV5NSRGgUhLS1uwA8w3mT3aCZXVQHh6wIag/MuJNASJ6p+qCOZc8pm5eiS/D/lace0aHon7z7Ifq/3/0gXvokULFU90JYM0LLArI3/JzBlaLQiQxig6oVwL4H/xx/TToc19lChbVdar0bkLJbhY4sRxOIs86XMj/y16+jz/3oy+hQNIB/IDZvKS4puCwIbPih5T+0NVYVyvgkER3YG4zRS+JR4O0DONmqyZetVjINCWQrpNbaQTlHnptmrYGNKwU0S37b/3AVfeXHX0GHotf854fp+971oF7F5CSrIJpzN0Rv+MGkiGwpu6A6aMXmjEG53T2AYABzwTNnRo76qgJsYA/+95Q4/XV9vzY3hSmYGLioN017TuIYRL/1GVfTtz3jKjoU/cv3PULf8TsP1vc5AmCOn3+lkrDsmXYZvA0MuGQ3W663+ySgMbtuNlumuD7Dt1GVwV1Mbl/kDNxa7C1f48U1mdGguB6ZzIs+6crV7H8oessfPUp//7fv7wG/jnVFkRm5yHoAyCHwsj9LRSsvqNOS3eMutn4XYGOgiBmliVLD2n6XceyIvLG14sMZiwkt3i0Q5zLZn6rcF3/s5fS9n34NHYr+40cu0Df+1v3itumwzq7vg+jKisoljzUxwKU8KOdlM2BjBwGmaaMO7lkJgKsNG9jcRjyeXHSZ4gFt+c+WE2dzHFGAIlkI5ClRmOdn+Py064/ph599LR2K/svDJ/T8X/0wPfB4Ms4R7F9UlwRELc8ByBUVPJBLDCiP7YdoBjC38yRgCjcWtIlvDjKiJT6URfytdFgDgQWcm4Aiy8eoPZg4yori6dce0es+57qDPeW3Av/bP0z3P6arnIIkmDOZ2vm7lUQhp11oWVAdbFQFaHMt9MT5ODAH9VM2i8XMVhtDs+wuKTUkvDRTJpOrJ451Enj6NUf0ppsO96DP+zrwf2kH/vc/dFFhNbRhV6sC0Oac6Jx68vBsymzdsHfQQg4Y9vck4Cz0J3sw1vxVBNkzmgK29r0EcAZUtfKrPA/AmRzaL1CxdLQC/81PoacfEPzPv+fc6m9BXn9sZVkAjLpyAZujfCVrzJ1BnbG6lbsAHPHYAJiW82xJMpFkEq0I5l6L2eRVuGDmqiWFtrK/5D+lK/df9zevOxj47+/W+l/agX+a+RvBOIrrzIAqdEWy85Oh0JIYPB13s2+zmeh4qzPrBtQ+ewMKLtFMvpmA25YVWyW5ZHUGlQf62WW/sLPk//BnXttt/B3mEd8V+H+lm/kfvDg1jufARDM+uTgNqhQr56vLC8eWZdOz7drYbFTu4EnAuMEq8JB80DwHmEqmJYFsvd+Cvq1JpnGGt2VwaTyofc9fu5r+9scd7hHfJfh/99wFZ18Gx68IgnqoJ0RGnZUUKh0dGT81XGxhDO71S0HbZu45s24KJZVI0vNK7M1ybiNZE5oxAN0qwLCnzs+Q+ZZPu4q+7pOvpEPRS37jAfrdD1/AzGLyZb3HE57Fszfotp2XFHo+TtrRC6ZFwjRjYG55E7A0NhsoQxJvqQz8UICccTuoYmuv4B98o/iKzahE3vKAMzlfJjMpaAn+5etQ9F33Pkj/6uwjq/fV7zlQs0CCfPZsjAKVsj6SWJBckWRsZfO6IpqB5e0lAN4MHHBwpwYdozESE7f42XMGMGdtIvdnuc2YkYyykyWVjr7uGVceFPz/z+8+TD/2nkea9ilYMgNP9cWWR4IRXedHNxQLSr6uaytGzUsAe5ZszyR2vMnXCZRNIeCbB3mTsXbbauXkkJi52OKRB2ghE0kc/Zsvetrl9I+6df+haAn+5YvGoFL1HEjw15hlLVizYcpoZIe/fUnadcdRrTQVBuZUAPv8OHBzgmL4drM9A/aXDFH9Gcl2NrkzHwUrgVoVAGQ+7c8d06s++3DP9y+B/wO/87AA/DoJqOsVBvOEvHlfekLYcTKErYHSsgkYSRIRAqJbWgKkqL8KQ4htsuNvzegtO/3s6O8pcXJkEzBSCYRK/6lp+Yjv6b917eqe/yHo/33XIxP4+9gmGmZGPPvFkkI+u1Zm0cDsvr4mwGFtnASq2SZqtLeFBJBs3zOyHwcDMmcu4IMdJgdsHAYCZQy18n8lYgx4b5ZH1+zp1y7oX/9P19HTrznMgz4/ed+jdPtvP2gm5SkpVMr64AzPcqp1E4dvyxQQmYxNnaAvixrxfBzOeHUWzQ0mbJOt8t3YPW2xY82iEd0dUlP5Xy3tmdSPhYiTWc74hwT/L3zgMfrmdzywel+rZCYek9ww85Keoko5b04S0cRQyLI9IW27GgjQsbcertP8qNizx4ZswB1XGr1lgNZPtu6OLoiiRHZ/DHzJg7OcYSDjPeXyw4L/dz98kb751x6oJueyCsgah4YKUGtLKOTEHTfRxGDJF4nHosCvPM2gDZYAbYrcwkht51brmHIdXdmvqIHnEGRNEGy0zyz9v/szrqZP/XOHecT3fQ+d0Ave+hG6/3HNCwF27AtWMzhJfaLGDUBbuTahWOO7ShG0N0EQC89MAL5SU6ZK05tWoK0HRjJtVu1xEDxCx+VvmbyvBQ9tEA6U/OvyDz79KvryT9j9T50hen8H/i/vwP/AY8MY6Et6AHovqRWsyu8CamPU8O3IRqaYA/ZKEp9FtTI4oxkJAKy3a2gIl9wV4npHNYHeApBk5suAfS8Bckr2tbWWBWZlk9n7B8+8qnsd5hHfJfhf8G8/Qu9/8EShm1PjLA4TAmf/JjdpWH7q+y+yhHcHVsh2WB+Jipsanmrjg0BiB7NsDtOcTZBqqUWVwd77sbI8e3qHXAZUZj7YL5VEmZ/rJQN+QoCeZnHrPAuSfYVKHrk8cBKjKyPMVByT+4nSyOCaOeG445qyCqAew2ZTHlcbqClx5gpcydheOc+OntI9QBZAXwjC7hqY7PMY/0mr/1/wSVccDPzLj/V++S9+hD7QgV/iRldoeklgTgiVGZ4lIho/PsxBOWjUTCTzvvk6TE5cwScB28FfyzxWuRQ6vwBwTVsVoChdMaD04NwTJTuJemCw+unT/vwRvfJzD/OI7/L7+5bgf/8DJ9Uv4CjK7ASEAAitfiKoDjppxtKAa7JC3hV2cZNCYlE6rt16CJGV3OLqIYESfClmTyA29MEf8ITZNjp7DnnrXK6B3sDK0687op/629fRoejrzjxA/+nPLqrEZSXdknjMeF7iKw6bKoVszyDyvQLIXibLUXmgi0W53Z5Dx6EIan5mzIZsKQIHTY8Et14IpBfI7HtLCGIXp7X8l6B6+nULev0XX7u6538I+j9+9SF6x4cez0MidYDOQfG5EK5+lVfr8mElg6CXQrO7eW6GvEnRyzRzosqWADNQ3EhcbSAffEDIA+/EwokGl8dgswYBcPfdNdGM8h/1ywD+5aO+h6DvfufD9NPveXRdds+8zaf5fUsCS8lgUmBPphfg/EDJNW4qGj4g7Wqc9f6O53yMd4YfcJCiBQAUwuCt2KjNpKRnzMF+a2bdFlnPAZjxG3E/5Qqm13/J4cD/ynvP02t/75GsBdzmWzdPlCozaRLAlEgOLi/gta0kD7aMwuviJwizIqnRJoOy97f7nwaDHZl8HccwG4nDtJM/tVXb9JszOHZN2RIgCnoiDZyDgv+3z9MdXQLoQ5ko+zWikTdjz2OkMSHoxsgs78YhzQIZe+zXEgQwykrTFN2ENkoAbnYeaO4snwnWMmR8ljB0x+VkMs0MjWMsW06cHkU3+6x++IGbrqZP/fOHecT3jg78P9S9EBZ4XMvrGdIFrANolchVyR78QpFoLEK2aIqMEStrbHN8OQDY3teCRzZeTEFSTjDoncqBtYj30eLQp+iyhloS2hXJQcTwPOWbSe+lz76SXvDJh3nE97W/+yjd8Vvn/T7s0cigbB/46ppUEp6Z9HPkFzaSaQeakHKGLFa09ao4CwHR9yFpe98INAPAiAWzcybgXXTULIOyZw5sgI013d6+SalfAqC40bIlP1yC/5v/+mEe9Pnpdz9G3/OOh8zEqRPZULw3bg4OTZEJyJRhYCeZthC7EEUDcFY1IFg7GHPb+1pwdKE8YucwUiQwVW69aCPhD89Y58JG+w4JXXh3zd+/WYH/2YcB/69/6AJ96688ODWgfhObm5wfpLWAN9t6CcFK8jCWQFKQG9ZmXJ5N5DuqZ9iZS7n69vYAqpRiZRr0ARBZm/ET+R1ezKqBpQUNCWRfU39PaYrDrALyNx3vy55x+cHA/3t/dpFe9G/FF3p4FUDGZ0Og+UNBmYy1fGizZxjzJj3nU6rAcqDRtzOXdvfTYCjdp7gtb2YuZKCi/wUOI8+aOSKJak95wF6yEBUn2f/51I8+oh94zmEe8V0+2vt333x/9rHeiWrLFcr4+tpx7LoaE4S0L966M3ZUTr1NgZFuiGxlouFQ05a/FRhegPgHHdBshjqCnYb2W30JzxKMOiwZ7TskE/ikZqCnPWVBP/nca+kQtAT/V/2bDvyPTgHL6znr0eXiXMsTx9dT2KglBSlDtrxVGVaXrBX77Gu7TSYFcd2+BOC6U5YNUXMs1RKWA/KeTwSadROuyaxZxqocdkrJHuh50wr8z7t29cDPvmkF/jc/sP5wz9BozuYUB33GZ0sAXU8DnCYgkQySy1lN1QDFiYs/Je2g6jyWmzFVqmW7mmAuz55KluWV4iTChgFvdmitIFgyEu3tLgAaRHIgP+26NfiXf/dNK/D/zAP0gdUn+5YB4TLdTsLyDfmbfNasmTmAXwHnjhvtx5oEVrzAJGiYNRp8/YhaTEDTcdR5m49k63JVjKRY0eCWTfZA0zrJqCCETtDvzsjd8EurGf/HvuSaVQWwb7q/K/dH8K/iGYLzS/QQ6HO+A1hzlh1nUsb8FVMs/6KVQHAyQeQlFlshyJ4xKR27JzOLnFm4ZENiKRQGYIIPyUCdZuAb1cg+yFgCDIdL8H/KR+//Kb8l+L/6TQ/QB+8/KUJbxzolAQ/0zV9swsJEsMqw/E+/IhyNw5/ew+BmpWrTDFC30JZ/GiyZWd8jc2bO9L3OYi4HG7Rb2EzhGX88J2lnxxdGukP98IqbrqLP+ri9/sL7SN9+98P0n/7/izTGpBIUztxzQO8CvnhDZiVh2RhFAhOV/vIQquUEPHBnVgChhNFIG38YiFHPNoOeyqsfKbc5qxaCA2Pd5Gz8ZXKWnb09ATgQ6ovu4KV/4wr62mdeQYegb/+lh+itf/iYmnHxNe0f8527EVi5HqtDz3bNvpDB51DK1aoGZNcV8wb6JnsCAdr814EbPk5sXcC1HSAHlY2ZYuAB0CubAVvcmpB2RPLjwMsYXtKB/yWfdZgHfb73nofpDb//mF2ZwNl86jlUrTXP5BaoQNLw7Msm1OAm/BZZSyeLpZm4qRnS8WaDOxh5JSPnjRZQceZN2r6XcbkO6NYP2+ycEhUD/2ufdfnBwP+qdz5Cr/v3j47HoX5hIZL9np/7W4YVoFjP23uTjBVbGR8BRePQGgNsqvqQYUPHoi2MwZl7APWdvDrgc3EjZbvJqU8YTHY1ULxJbtbXFxU8i36ASiAf+P/zJ15G33XzVXQIetWvP0I//M7z7aCXlzY30G+woqTPtbLdWBqZMWUyEQBHx2/LB3+85GTpNY01pyJIhljjHkDyfXNVrJTPhauzfRkHO75Cg6VvYGhDgP8AwM9CWdGn/IUj+v4vPAz4f7gD/4/8+nnz24ZGMvoTjQ0GSmqWl28Mn+PbxmUhjA/IsHlA9bFRqWQCKvGBl2wFy0QgATig57CoEUhqm105UOqDxIAqDDZtiECsQdeUODegzs/TnrqgH33uNQd5yu+uex/tEsD5MRYT9D0/a/aTutJjKlQgsMtrU002Qs2yr+PDWb/0h68FR3wrJXJpl8vNYzT7qQAaShZEOKPV1+O5/KSSCJqDwAfyTLGPBTsl5j7vBDz9KQv6iS+/lp72lP2D/w2/9xj947c9vHoP+2H5TwvoifwHq7zZfDUGuND1/AKTvn0VI/ZVmJkxuxeJb6C5ODIb43TMEe8zBrwbbPTHDdRMnaA5NCMX4I/OGFZcBwD+QD/xFYcB/+//yUV6+S8+hGftGWW6rBKkngWe6KZsNaEIG0W7MWszFNbnAkQMAxSrCGo2ctaGY3LzLwWVneKR9/towqY+OQB+b3BkI7G6NswqiwjwedW2n2xwKPB/zesf0LvuLcAPgH71NjCbm6AKJhuyYvbsELWV88BAeMJgBxM7HmbzEgD7WRBTqmdHsrKamJld4NPY89UfAhWVRWQ2422k3UuYPnD/CX3NTz4wfqy3VrLXvrMwmlCjoG/5SHGLDRUDigPYi+AA2hZ+ahTBzhzyEwDDt03jn6VCDbxKObn+GclbGZ2Q/9QAfJqWCU/CHLAE/ws78D/4SLKBbJTseVKFoLfkafJjzapVwKJkU/ONDhzAN/8AbUVei7Cvn7O2OPaO3WSylbW/uDph4BPVfjVVX5SWZ/zXB3IgmSWltUx4ktAK/P9q/eGeFVklvbMMgNWAu+cSB+1oLz9Ojm6mb1YCmYwZo2cL2BwPUmCcMFAX/iLENWayhbb2wyD6TkEyD80MnMmykzLlBR4OrLsVeDClwl9hF5aLoiR+EtES/Lf8ywn8fj/QlAxqPGvGT4YPoSP9uMsK5K9mf2g3xiD2pYUjXw4CNVNAbdPxlsRfKi7D/ARgl0S2QXhisJTC9ZW9pk9TptNq6gB9OKUYMNVKgGhuv11qtPxY7xL8H/hID34L9ETzlwWGPauvw49jO7FIPrRPpR+GBko5E488E+CwIWNtqxIw5Nu+FDT34GzUQV3ZsBXgZ8xahZGAD3DR8P3n5CeXJyitwP8T3cx/7qQAney/fEaHs++MMt+dsVv2ESqxqHhWNljriwYreYx8I4lAu5Z9oLuk8NjiiIgvdNw0kFOskXEkUJyRnRDwex1vJu9FlA/GFxjPaAnLPAnoH/7cw/SuP15/pr91zQ/7rzLb54lE2rP0mJzjWmLIkZ/8cWkBHsXo2svkUUUQHz9cX242VAcWbbAHUAEGu+KCrTcKrXNXu/HSHmOTBfhDSQMkJNIhP5Hp8z/xMvqldz8WA74HtjmzfQ30EX6aWiLJJOfLZCRU1YnUJ6OY/CBs6RUUqSrmUGZsRgLoN8Nqxr1sKmy1AT/TI3DREmjvDcNZS/hfH4plwpMA7Iie91cupwe7ZcD/9daHVf+oaqilzOfAbO+t/ZE/NaEwTjYG6FsAj8ZJIRKQtZJSQU0VQWZq02yQxVtJABWwI2YI+EThn+1WCQXEpAAsAuL6AJ4OSyPVgfgEp6969hV0f3ff/9VvPz+2FTO+d/7RZUMQ2HD9Pl6jbOZEPpHf4U0F9FHAaz9s2iyaKhMIVxsEBSekyFA93viRVrDWy/5oGnq7kv10mQdmfRf4ROO3vlZKyEmvskxgelKU/pK+4XPXXzBy5z3n68BPMRDJBGvN9i7oV7qMk8zIL1jiDfmbgk5iKH0wlpO+RDyGmNGQ+4uLmjScH3sivL3PAoxvaxVFEoMDmRPAVrN+FfhrZnzW7xsCg3/QebItC5ZJYHleqyQwkJhdIfAbZvQYj+F1tb7/QVUYQKa0b/jP36T1GzhEnQRU2DEbSr0wuNmMyLVfw/fszwKMb0P6PYBZNSGTWk8KuSVdqpSSSC/lfwp7bOk8CenFfRJ49T3n8Xkb1z062+MlA4884UIlIOjP8lmRYSBoJo/8jTX2YEMMH6N3b4B5fjeg8GcBiqZw0hDA9zo3P+g3+hiZY08vuYNPio8nYw1aT+dJSi9aLgfSuhJAiVeByOB51cP4eftW0GdvIvf7/bsL7AOeQZtz2dFjz0p/FDT4jcOKzYM4+d8KnBrtitoIXchCnLU/pSvtgoG2btNXG3Vq8TXm+QDk0mQx+Ar/6Um5BMjpRZ+33hN4zT3gm4BkAk5+/2keh/t91SaBmPPBZFC/ezBC35YZ5QAxfGvM0KyNRDAFzqtKoYpa0+Y/DALAEVIxMqb3A49Ns75bbYClhTcbJaHTdGWemLRMAh86d5He/B8eWzeAhOpVADlvGmN9sesl9Bo/B4dRISBgskAulpGBgLce0Jir8lBPMlJAroWchLLxHgCcfT21bMCUPHEV3HW+7df8BNrqTTIvtp9E8JeE7oM+cO6EPu76/f/u35Ju/zvXrP4uk0B0zW9v9HH9uwXI4DMGFFd1OWZfxDH+cScRGjvCA7vnA/JbEwbigqrDosWKab0sd8tZN3u5NvoBUnRSzhtsmHwRT6YnY2XSusWn+aTN8Xx0vNOx2FQE+rukF772wVUSOBQtk8D/8umXw+vIWV+MPNE+lNySx9k1W72SwwfXlF3dNYdr9kUyGeSQ7HTuPP23vEWJZEVfMel4VR9Zr7H3uPRd/Gfbr738qUWANAp4EhcIy2S2gAy6SEXCkL6A/qSXoE15EUrwpwn80m6ivdEHP3xCt/z4g6uHdQ5Ft3VJ4Nk3XAYBZAE/H646GZMJbMSPgZ6ogAuwrewTuYCf5Aaw24C37IZAngpP5X8J26rZMwEvXxLc6KXAa1Ad9JSBOFMEJ0aKD2IxfI22exAjmwj4XPgSF1bacPphq5TWy4BDJ4Hv/7Jr6C//xaOi323gkw3sBEBBmc3cFuBhQE9gqYIe+U824FcPASUvOZCfSIROFi0EOjWAN7cdfUmatQSwslDN1nLNXqzbE7ZVgCxlCaOwpX0WHW3M+pQw+AfgF7M+kid9QXdNy/N/14cu0K0//sDBksB1VzLd+dXX0Sd3SUAO1DFOouxalHvtCniUAUkOfo9X+DNmZSpjguDKfYwya8CzJ2fZE/Gpoj3lSYVckFugJhmHiGdWRUAeJTJBWgV9EbCzdCDC2WkEfqoCn5IEfiqBO8SRjEEodYoYtA15fruk/Pzf9aGL9A//9UN0KFolga/JkgANMZIAcH81EuIRscPL7UEe5WAlDHqkb8oMoGeQYBxbCYF90FnbVMkkCPIaqD085okm8vIrgNQAeAEKRgAWshaYSW4MZjYtOzmIXSAXOlQAn4V8DnZ4/vugVILm7t97/OBJ4PtecC19THdnAoOUNbjJ7tv2SiADax5Y8vVzG4UdovgML+UoHxPlPoEHdCIf5FVwk97+MzcEK6+Fl2mqgJdAKECfZgM/HywIjOMFJVK+JJAJ6HLvS836rnzG32MGmBLVFOebfuuxgyaBJfhf3VUCqyRAhMFNZeLyePFkwSaglV2hXyYG9qsNMY5QYqAckKuZtA3oEOCFvgQ2qziq9gKvagUQmvEK4NPWgI/AWLYnZV/KcNJxUnb3ASaLQj733+9heH2xbcqAkcf0M7/5GL36lx6hQ9ES/P90mQSeulCJV15nBAioQwQT+QgI47oysgtsDxWKAg6VMeZxIptotpWxoUkLJYiJJ8tzjRUIYsNelNqeMCmCce4UAILA740i4BeDnkh0gnbEwi7WLcHLlr/M12gP3BLcF6mZsqc7f/n8wZPAj7zwOvrY4UGlxBj4CYCptyEHOuax4tV0NT/bMCSqgpcEwEbYJ2fHPvedv6C83hgkAGoJcDZsz30t5ExsvZpuDRodqoCPQJWmE1UJIQd+IgjU4cKrZJULJCNhiLjzOKXs3IzbSvnAyduG9td0SeDOAyeBH37huhJAs3kx+Ils4Js8hjwMUovPdnUirrcGmHGnIQFQIt8C8JT8tbo8B3Zw1AT2ws/036IEecwxJBCYBnb/pgJ8COCUfD9EGtg58KUOkTkgRgV0+9Hrg11QHlPSoFn+vfOXztNrDp0EbumTQAG8NVkJoc5jzEsR0NMIMxOYIj4J2GIXn2x5CMbsDNByoYY1H8CUTUAc+w8sL1YVgAlyb6AbsnayGIBvyyDgq7sBwlceX2l3/YaRTmaLQQwD8EkNRuvcdksI/OMAy44vhSTwqluupWuvYDiT54Bb8UgP9rKvWSVsC0SUJDCMUp2IZCWAwceurAJoLkflUsECO7KhwU2gEtFgpsZXkQCqCif9K2AMgz7RHOCPACbsjzIeAj6DOHNbLGJVdxPyi5DboZK3D5IDfUWiL5Z/X/PW8/Tm33qMDkWrJHBrnwTENV5RIgjagWBSMNplUph4TDgpYCBOdvK52gErScBP4LTu+xOIB503F+cw2aRsjwAmFGp75RTfBDQCKEA7vE6SBqwA/tDJBGzgpKCBPwF5Mgz1kM7Yhp8yRImiqCj2ROzFJWW6122vf+igSeCT/vsj+qFlEriSfUATwaQ+le5k6pu87ItDy6SgAZPLoafzKGnAE0kZDXqStgPxUAF0roJa+UjzX6HbgKVSIrxRSAVB4KsLRsXMTSRAlusMhgs7ve+sc6UOE+Ekku175ABjJCvbqeTtgyAQko5rlQR+sksCv3kJJIErWINbjgOSPMbJgsrBrhMHTjgSxKUNsVQgDTQMnKlW0MnEiCG/VlnEaENwRcnyrfHDG7wWaIdf7/gLoFuDPznAzzoqn+3HJcIJ1tMgHoCblN/cF0ok4wM88gEgIpg8lG3qbSSrA7ZPxYBy2uUM8wP/5mF69wcv0qHoE7sk8LIvvXr1XgGfSAFMAxq0JwBQWgPSA72yMYI4swH8aZ/Zv0hO+M9p0IzsD5gAJ3IqAp713wKCFb0koQAdHZ1MSA0GBdjieAC+lmfhT8eRPcAjBlotefDgm/TtwL3QuK+RyuRntfcBPvjwCb3oR+8/aBL43GdcRt/+/Kv1tU5GAiMwi2f25HVZX0M8E3tAHv9NBuhJAMx4OAcmm0EvZYmmtj9ANriLV2avthnIwdesPYAo6Cn5DwqhWVpd+LxKMGLIY2QAfHnRoPwQ0yibA0rapb0mgSJ+0C6T4tD+4PlELz5wEviiZ11O395VAi7wEwDjYMDh1aqEUabww749ZZOVrAJ8kngogQl9mP7ka508CNzCK16EYzN99q+2R4ER6CQVDw4RBkqyEwcCvhz4Si+LLW9QCYMseRETJQ2ojNzz3zLlfagqk5zAQFu2PfBwom993QP0oQ8f7luFvrBLAt/2/KvhbJ7P5NO/pMZaAeoCaARnf5ncp+Lds5f5FfUCGjsSC4MPCEAw5iWAcw20P0DIrrCPXh6e658GJCOzjDKJ0MNElJAsCCqTcZcI6gKRuCClrvShbBR+M32rYpDHeyZUBeR9qRJW1ncf+rMTevGd9x82Cfy1y+mFz7kSx0yVWVkChkqgIV09w+rd+iIJFMcMAZTbJiJVmntlPpp9Jxu4nOcUAzZb5x14LXRjKl6Uai9S2XokEGQBehqSBl5fS9CSAXx3QxAdC/18U48NX8X5yfPcJYFBRKIvGcQoZ8I/6sD/DQdOAl/z+VeuXoxiluDK28XgRmPK0qUenBL0jGwMslnMCrBKx7+TgM6VM18waWT+LHvWpIx8VL4PAAM68kLBWnKFgLOuz09Etk8Xf0oc0q9MMjKJrI+xPkNfIv58AOyBuBIPO20yif1RVwn8vVcfPgl89edfCQFTA3UB0pruqM+TXCIFksLG8C+ylfXlYLew7fiACYPYBnpyYgCvxRLI/QttDrq6YcDLIIcGR2eSS4QSjAQrEWnwj51S2kD+EVAnO3lFk8mCWBjZRD72RBagudKGKoNlJfCNl0IS+IIr8UxMfkKgDDiuLhG1bPiRIVvI9wBWywnR58oHsU4YKQ708otF9H+k/MVf1bsAMivVkwVaPpACKqoaCh89g8HzB2pWTzohcB8LXNdD2d52TY4mm/ugPOEgQLOKD7eNttJ6T+Blpx+gBw/4JaNf3VcC8td//YTAKjlLgOZVAkl90uN4kJWgXVEiMHsjgOtrw31SQd8xiHQX/UuDNIN9ZUaXOIq8FjUlBXDKeke81sCHrCJDIvUJhP2bpB/RJdIxaXvl7Tupg5IHtE2TvSGprePKY90TZT5NsIg22TcsrsF7PnCR/v4/vX91q/BQ9FVfsK4E1Pjr+bFZHvWDUyUUNrJ/k5ZlJUtwMpR4kTv4ecwx8GYlPIlrHni1yC5YPFhSfRmbfypZCLISA+fgogQSQk/AR2lzAOokT+CiUwUgYzKTy43c3j5JDEQZBz4HClUL7/lglwRefegkcAU9/29eEQC1DWhXN2EQhkp+T9aSJ9YJLWHA5zp5ymDhX+kFXx6Mh0RTLgFS/KWcSLLkcpANishuZgf5UncoiJpm9xIMGVP4guBH57sj8mZ22EblQCEhK6uFP+gqgR9608N0SPr6L7mS/sdnXV70vQY144RAJMYImDWTBA8u+THQjOWBkgclurQvXtbDPRIL0mZOrF6x/wZLTb8NyOYBkTnrF4jr3yZsnIE9LowlqA9/D5AnO6WNQT8pOemPZTtP9nhfSSAlGNM4LIs2ISfaUZ8s237+Nx5dHb/sK66hQ9E3f9lVqxje+luP+edDZd+P14WyPtFDLvvNQi6uqy2nZeWQn+QZ8tnEBAMbmBQrYa5jwiUzAeQdCynZjVDX6sQClIKV9z7SFyBFbQX4czCRThxsxAOTyZ5oFYeIibODqY3d2E1Q9W0//85HV82HTAIvHZLAbz42XothpuwPR9I/QirAkJ/3yobQFwZLOQFQZI96OSORYD84UUTGFdckQHwRWkgbw2sIzH4lkvsGNV04a+ZlT9aY37KzkofWI1AW9wcp6ZkD2U5kyu0b/CMlAX7YVp7jeC2MfmdwTr/QJYHTv3CeDkn/+9+5kj7hY49W79kYO8U1Ee1jZZONq6l0ZjVGsVzAnnGXIT+e/JSlPokxqsZ18WKYkNQL2Eb4k6+F/bFf8VIWcSciMSsxrPWyhuxxYukGdRwJmzwkJpBAFHAM2/k6n8U5DIlPfrvwTimVg1CeD0p4SC4/n1GXSJ33XV0CuOuASeCaK5n+z6+7hj7hY/okQDVQE6HHZ7WulpEgWsGtsuEnE4mSE0kCfuw4t5UI7AEweR/+ocp5WC9Esz8NaAJfkE4MPchzBWFT+kUJQdrM7Ul5NdATto2rgDI57rsKKGbxFG1bM+QAc3Vpajv984dPAt/bJYG/9DFHFVCTDXwwRgtdkmBiJYeByhj0pJNE7gfplO1oiy4I6EQmNssXU/NPg3mGEeAnOVBVDAAlwy44IZkQxqohf8hH2hPykJcQgPI4e8ArGcLnvSsSfcDJaSPZVn4dupRjy173uuvQSeCqdRL4ix+1GGOSs58H6hKYrJNhNuaKe/yEwLkGDxErAOpKwKgiSFwfmnyP/hORNdv7wBYAB+kCtzY8ClyeQAkS/YnAhIGSMCAt4E/tud3SaHW2F51e8voEkj/bAGzK2IqYd0x533CqtCWrbfrcQ60CyHVf1yWB1x04CXzP1/dJAIzD9bkIsJFMCKyBn8sYt+HkbI6SizqWiYR03056usSXY86d9WmCtawcWhLJQnLYeEU+MFSAdiDhUJ2kspM/dSf8AZuWrRH8hex0jmv7fjxWMpF+d0rCv4qv0sZFWyK1Geqc3/LvMgn84jsP9/2Cf6ED/z/6+qtXf61ZfCDN5/L8oQzBGT2f+dkY36WesXcg2wht6wmgQzu6fEd+oq9hvCxqmaL2UtkJySDApGlA5mU3k+1D2SxskQJBUTn0AcgkxMiG8GfJ7IsU0InsmTzrGxQ3Dw2qjcy27/sXDx4+CbwoSwI0jImydC4SIJGafQvgE1FtaUAESn4lm4FRyOZxjJaSDUjVnkWJqgE3iQRfs38cFIHSBC71gmiZkLEZ+LMSAmXt6ws6JJDcD+HENJwDspm3C/8s+mAfxPLTi0T+rC2OJSimtqG/SJ2fAkVH398lgX/3Hw+bBL57mQSuXxhgJpEUZywNiv6LbPax8q3kRSxybKkEQxPkGX34yXlF5fJXPQHkBJxNrx50EIgJA1h0mkoyIJapo9d2YTmvZEklAxPkhv9p5sR7ETujRFMFI+7zT/yszTg3uy2pGc7qh+//Fw/Rf/7A4b5fcJUEXgwqATHwh/aRT+SDnUjM8CA5KF/27UIa7ZblfgF4qTf6NaqEwq7/kpLef85twGnQUeRZgaIDyQSkO6NnvDIh9ElF+FMAT1TEYSUDKDe6ms5XJzM6SBWwjovGSgfdlmTn3Ly2aAWwbHvo4UTf8qr7D5oE/rsO/LevksAR2bN7Dez9zJ3s5OElELX+zuIzZYSf0ocu83Pf6JxQ8rC+DISMV18BJMI7+cJpjZAz0TFWUtCBZQc58JJtz5rdpWwuN1YSxcxOxTmpWInUue2SGPku+i4RW31AftvUTyCRyBj6tofOJ/rWLgn81z873BeKLJPAt9xy1eouAU5WojSnHDyMAT68r9w1IGI102qQswnkUsffzMNAz23lMzw1v5a0IBBkWUb0lMjNJDBJZHw7KSQq7+kn5U9WCNJXkURcWdsXo4RBGHhF+x4IJTBUIZEJcAoAPBUDVvnr25ayy0rg2171wEGTwKmPXdArukpgTAI9MRhz3myuk4cnD9bkQnaMJnlAFqW+ODcLi+XegD/Dc/C1qJUJ5gsEaCeGrFHe00+kLp70IdtyX/Zsr28nsuELzZJVmTyWXRLoCxTj0M+RTcMC4EUbfvBJJo3l3z/+04v07T90+CTwXcskcGW2yUZsArgKdndjsKwq8oQ6Vhbo0V3lx7+zIOOUlQIEd2bP/mYh/FrUQI6IqQQa+twA+pIPOehGMvzChKDkJpCXX2wifGbiaJDL5GLJ7HPmH32TBiEE5ng89bslY9tO0J8E0pL+ePnVYpdCEviGq1WMGsBExdIgSVl7aWB+IUia7OpKYNAlMfNrAEu9PNXIhAHBLc7ZTBTgtSAvA4jbduZvBQpiZC7roKFjZKAkOk3aVo8AZ3cXqvogFjfhyDYiuxrZJYlBQh4wM511W99PQIaTY9t4arCcLWl1Hf74Tw+fBG7oksCLv+JKHePwPuHzlbMyASCxYXM8BlVDAb7MA0ow5WRKxM6HgFyAE4EkUnrCdwGEUcuBO+AT7jwpA2d0ZafcgbeeG4B+xEVWfgmDyJMZ3pQ7715nbJdUwiSCszHlbURidk8BGdzmVQAD70+6JPDyOx5YbRAeiv7WZ1xGL/rKq8qElQDISfCB7Fo+A2/SOus+9Df7hgQBdVXbEowMQczkAXzwkycPhokEYRzeBpQORkrkJgtLXieREtzl0kH7kklCDnxGsiAuDfKkEo7+4U2C4NsbSSCCPmFLpjj3FJDJ2xJZFQDS/5OuAviOHzp0Ejimr//KK1fvUXLnBJJflhh0UmDCFUOvl5DOBEYi/9beYvTP5cSUasmiBLz69mGKvxbsOKy+xMkNM7hcOhRKsmwHAxACDgxCaQPLgjjQ8sWJhQ2Z/dD0HAIu18s2lYgLmQT7XdkhGisHVAGUstPG4X3vv3hJJIGvfu4VU6y0jrSclansh0J2AjiSX7/nAmiTDo3ekB6yU/CJ3Fk/t45u/Y2UULLAr2wJkEjOxrUXfDAoIzSbR4A86uc6BACeMgNoE9IAOZr1cvtWUpEzxT5IVU5ZP5tVQbIA3ScBQ08dC1soLil79n0X6R//6IN0SPrCmy6jL/3Cy1fvJfBWbVQmhvz8rWohVjEQFbv1RBDQuR2ZmOQkPNjMS3oSMaKZXxIbrwVZ01qyX5wwYHM9NJvngXjJACWEYUbSjwAnG9RJHJMNYkaxSj0U755Ig7XvB7G+h4BW52B/PFgfp9G2myCy9t95zwV61T9/iA5Jz/+iy/skIGZKMY7H8dzr1Wf/EnBEOKEgQOdgRnZyW5xZs8CrdJL9srB8vLKQKDSqoUgy5FjLMRSUNlL5Lam5nmgf2hi0jSq5XMK+83gZ2GHpC5zzziiLj8XxJJPWwwTIoL4pEsTyrzh36c+UGdt7/5nuL79j/cWe3/hVh/uS0ed90boKeOPPP15+iaj6Nx8bXIy3Emhc2kiaJ8dqOeZZYcAaTwzQpltKJntMg6ZvBU5BVTcKMOCGdsRAgzkXMdqZbVm29B1Qh+1Yce2Qim5DiXG88Gk9s1SSZAn6CbilM6m7rDZY+NNyMrZlErj6qgV97f96FR2KhiTwpi4JLKlMXFS0qfdJtHNF3tBd80qHaAixsuIPNXgdDC3LzjEc+B4l3Cgzn3KedCPKCUVCkFUDg8yLZCXIkdwAACmTbH/FbwikPZUBifTMnsVSJrLUy7ADemGL1w7g7I90QZ96uj/7y4/QtVcyveBLrqRD0TIJLGOakgCrsWV9v38+56uEIDXY1i2Ok+QjadJcA5xMVdSadFw8ex8ldg4T4KGkEEgIUpcdcFIum/pZS7StDo2EYQLd4++JLABPB6Rn9vy79MH5jDT0FXMlYYhlxqhLfVufSMS1W/79yZ9bf63YIZPAc/tK4Gfe8niZpAYBmRCyN2yAk+W/CtisdEgkiXWTHlAwCaSaBNCp8PEPg9S0UkWMBd9cDmRtCMhSt2hP2pc5wLM2YI9rQDf4+6BioIpzkW16Zu8ZpgxVQJ/xZV+BNtNm93r9zz2y+vtlB04Cf/qnRP/unRdoiGv8y8bsL36UhAsmg4Sg3xfHxbBlU35oZGzF16tQrnMMJQIDvAAV0GclnL0Fs3+hjMp5obdZ6W8kjIZEsDdKidRIAAAelgpaJo3D1CrnrY08mXyorxTytlAi6WVf/7OPrN4eMgl87d9dLwdkEiiSHU1vVBuBsSh5IDlIOcRXMqls9Ybd3CHp/zYgV5oMXTXD94PHTApehVBLBgYwTLlk2wqX/knHvEviPClyeR+6FygBSRLkyzsrArji/JkEA1VKuSwCfb6USBhIP9UlgeVHeL/486+gQ9GtQxL49QtFbEsq3icNPAvgSA/xpKb/u4BstNcpmhCObVbC6/mKJ5kdx3aYFBrALe0WA1zIA333Vh7XEwEh/h6IVUxTgzvrimSoKglUJa1s9Wt5E/RirW9dI7bP4XU/dZ6uuZrpps+6nA5Ft3RJ4E//LNG737P8diMB5vzcCbzPAK71dNIojwXfqCQsO3ljbBjiWAcyvxFovdNN48U3neVy2XtPToGfNG9oUw8ESfn8VKVtwyblMxZl5yyOcz7LJwz3Tdm1WMU+xqhlpF4xQxfHhm1DznsQqEV2+ffO1z1Mb3vH4b5kdEkv/t/6pwWzNhmnPLfiISGi8j34ko7ymN0Hf4YW+ZSgkhU+cj+tHwYyKwA1sBxBmBwkaGWlkBw7aHbJO05VC2L0JUuO4O0zlj6sGT/TeeChE/rgn+CPwFYzcyx1T4MRnEc5s5Mu8fuDApDODO7qKblE6ML7G4l6GfKaux7ulgMLuuFp0+8AbpO42kDqbkkJRCrilSbK2Z9h+3SctSYkg+Z/dIBOgyt8m/jUF//XFFLkpuaRafHhnYDxn2Gg2vIwGQBZNmLhiJ6QQXy25CXPkC+eIIN8O2atw9Avw/Ngx84gx8WxtsWGDzZsMo6ZUB9xLB7Yf6WctEce0IV2ec1zLRLv2WifHOY8xQd20bH2WCdP7jhqBFUBrN6UwmiWH/+ksp2RH1YmYTtbtpE+12WsOwdeRTDKD3EA+3AXPu+klAdIMGYFoERl5yUm67zKc0/l6Ib9Uc70ZgxebPn5ynYh7+rkPpB/adeS6e2s35fJY/ojPvBDWXzAdiFPJODAarxDvopBk/fAj83xqbsLwOe66K73EV4hr5wXcgWgBvEK6NmSB7IIcCrBiAGtfCTSSQbwIQjl8sOKFSQZ7hvW9hjbl/rKRlbiA5CW564f7rH0TBCjdnn9UR8AXjWhZGpuopAywg6Uz4AOK0gBP/OpwEJXQl2+F3wXgsAW6k8obdK5bg/gpEsAdD1kJ/IdGF6smR/aBTxle8bsz0ZyYHGMZGAckdlf+pDJCADN9i8cAvsKIMY6X/aPpSdjsZ4PKARBxcE1UBOFqwLZXuhIm0IX2Yc+CnnGsz4jWflvHg+GLguDRXcC+T4iTIlsXoV678sE0FUAyU09dnOigBDpDRQ0WPp2RjqOfC5LHuhRG0gWHJn9Mx1GiUHwKJo0iECiSNkxBxKHMERUqZh6ORCL1a8QxEWCKBPQZLdv9+wQVZcOkIdkRr9AVj7hx0KveI8/B7BqZ6OdSipsVp4TyP3mDUiuZseWZTrhZQI4ufhe4sUzlUSSCtAKbkq6ESUOljacmR7JDw+5eICuJQJCekn4QgOyACKXywJZmVSSRiRRTIJsJw5lM5UbfskAlfe04EoPLBXEeUbBq0G5riJ0O5UznNxlNxMIA796nV3I9PZUm5FkyNEr3jNOJmTYQ1w1Zh3duvWSFqlbAqRuDyCcWaRgislx0oLoxGq3/Qp5ry0y+w8+KnbYsLv6Mw72ZOr3AjZfJTQBYkZg7Y0YiUnPzOvG6RjYpRS7lSj9UfbBI+UXyVM4SeRkJ5DSF7QrZE07xb9T8sjbJh3Rjmyo5GDplG/EqSsduw1JORxOZ5fPAZzVU7ahhMXWsozl0MVEMz0b7YO8tGNt8OVyXEkE+XF0GTDGKc9XATWXT0Kf7WpA2neqAZkITJ0+BrTrz1Km6CxS1QcL+8WlLZIGKPct4DLBsQZ1KOuznqkAlYQOkins6POB8r1ti796z7h97AvII7UsgDJQgDEvQoneu/wswNmQAa6wLFBLHlFopvfW+u6sjdp2OvvP0U/imKv27WMBNJFIaqW8Sl4idgkWmLBZJ4I81rI9KYa7tndnbIqt+T37418OLQNGWTLak9EO7EzH2B46LvwngsQUoxNe3HtMj1+8ly8/qkt7zsCFZiUEbBnt0qa5RiYHgLk9B6QF3/BVDKyKjUj1oI9Tf8w4MVWPs0YQbwkMULIX5+DtBySC63X0+YEhNqLqEmAgHG88GXgypX1x/lKGMmAm0EYEkgObtvK4NM/ZMGQsj+3UScoe0YXlXYDHz1I6imshVqrII8D27WzpGYBm0DbI5QCtgaiwA3yxAzwJZOWjZt8p69fHXA5wOUvDamDa8FPxKJ89EyWj3CE4VzOmQj9LNjmILHmi2TO/BqKWgfalf5reqDbjvQXqMiYLuj5P22dTzrMxMpJu/p4fuezM4uyZG88lWi8DICX84mTLFx88EHGQwRvtigZGX1MuP6yTtXnH6DcKchssv9o8iYEmz1vEzOCc5ICTfYEH5BC/9iXta38JxguB49hl4/rYuvZPjFfbrVgreire5IA3ef4zICZSY3jqCzbsg/aVHpc2sve5vIy1bAt8OIiMBDK8EpLle5f/9h8GOnlbd1PgFEEaZoNUGB5ZqhGoG3z3/jRoZ0uWRcez40PagTEk7SefIhLZfOAvP/Yqi/x4SATWU4EK0IW/VOgQ1Kl8RwBNXzJaAnUSlDFo2fygbGchL88fkuxLAn+VbbZliOCmHdRLhpyIJfp+XEpZfCoT09hm9Q3Z3YZl0yoBrH4aLNHijP+x4FR3IjOddJhlQEsX6iDZWpucqZCtZPuSg6SUXwcLf/FIzr6E/amZqBJbbjsLwdQZgVockyZ5e9aymwCARB+zoS8/Woz94V8gUn6rfJH08jFJ2lZxfuKvJa/awI91kIxF2dA8fcyKz+C88hcln1/IUnrb8t91BfA4nfG+GmQVRPKYoC05fIPn7fzDaqBvzwd4ZFOwmI09X2jmRHHkMbAAKgef6Qe29HHqj7mwZ9ufBKBNZGOQ698UO84sAhd97tokwncuinYhb8WM+EAf+s77A9kjMZ5G26zkke7alyc7OUd2hKQi1Ga3W9LdBuBJN+nnEjd+wQfv6w5OIRu2GSUq3oBDhiKwtGEkz74uG/a4Ysfjc0DeOtb6HNb1j/HHeRnFXvHJWSfnetwLlrYM/327/HivbaOUK+xBO1yc69CmznMyp9qUjBkfOAevTY0/eW619vxYGVMyVpv2ZNLZ21+9uHH5Zvx1YD45eRMyhUoLVE4WDvMyRAoa+tI2W/JI32rLYxN8buBb9tjRVzPIeJwI/jSX0JW29WZkgvZH30kYdGyOSxfZ9ytWeWKm/8mMJu965/q5HW+M5SWvQbKkZ2mDsoQgZJE8k2Oj113rl98KZG34MbCjyn4ZUyJY7qNvACLn1cmdGfyMCeDkKL2RjOAgicDci48uNuhspSPlgUzRialiR8YZONbAq9iX/t3jzIA8nxTV1/4ZHicMuDwxkQGYRPYanirJKtqOQJePryz4sH4+GyZy1/cWqAeAId92UhH8wYbES5EgWOkRsEXZuU33B7C89erorlx2pL/0+R/4MFsfDVbSZtPIsHjwARBLj0EHM9BlcUHY4nMRA1t+BD9e4uvjQT5mi5Wt5iUB4CtQ1Gxk58C5JrIF2nUsLPyJY2gLlO8sjsk4RudTsenZJSLcJq9d4Qv7lTKSp/nab9GOhG06e9ud6/J/SYuClU7uclUTeBnEhgwLO4x8IJ+gjWt60E7+xZ7ZC/y0+PRFoLZ9DvhX+gkcj7aSKq8j56bu/0vfUKeUgcsK93qIe/9kXE+rerDGjzmjD3E6fCCXkyU7yVv3+o22YRZPZFYZHvhjdwQGCyzaNJ7QK186LGgq/5dUJIBFojdSA0HniDx+ZXDkIPBKfDTQ2bBT86N89ILqoSTgXw0sYUsNUtNvn4TycyGyAZeEkaTByGMCzHTg+aI4QXIgEJMH3KI9lUClpEHmjKlaMihkRyCwjsuKNQeQkq8nCRbgg+8Li+QkAi4BD4idV04nF6byn5C9T3jOB+/uIryZyPFEdiAFj412yw6DQRuU3WSXv8bnyvGkz1XZecdOeS/beIzC1qnK4PNAy5NVK4xJgo1FjHmrZYvtfpijT2K2VTECGQIy6g6GlsvtRdvxsWyZBA2OZ+/sd71mKv+XtJAKKem7AaUA6V1GR9ab+dmSR+2Carv4hPje7I+qB8pidOxPx0NlkAKy8WO5FOFqVaP9FwM4ASdJH+C7AqVa8atFJGKyxobsa8GDm4VEbaU/4JdxE6wglAzhcSo38qQNH/z4vT5mGNPqlfnPqwv5KjDIJ7dLeyoBnNDjp7s/58ggmHUkmJBe8vUK3cDAg2010FPjMbIHZIsBOsrmPU/klf+WbX3+SRxn8alBn4rjal9RBPBJxe7aG2RTpgv8ST3tF/jy+IZMLXHUkgeuEAwbEoSFLW9DUKcNJp0gJK9GXdFy9rvuPD4t21UCWH04KJ3cgR4LLj58g165vMen2C/atAIaAilry8HAFT6h90R4H8KKZ7SbnT/VbfugLZOACZqVy+TaZ/mBo1FvMuYBHu5LWMA02qv7BgYgQ3witTmHgE2GDgHwYvBztc3eByjtIfCjOBHw2XmlxHB/b4EaT+jCK0lUAQUAQQeNMgMBfsnzE4TXxmrHnsDgBz6Dx2rQA1kO2tI8EVwwrnLWHJIxuXEPlYgXq1XCs3POXmXChix7NkoTmrwkQQLkZMvltjCwjdldJpFUSwi6LfdRtIukQP3zArKEh2U92clA0smC7kDtMAGsPyKc7kAnAQkBLiN2EwHwkYIDJAlD7sd9aTaQucYjwrMhGTNVonBcvu9U+JL86dj4sI2nQ4QrEuvJQNI+o9dcAY0w300Shg0VK9mJQ8uym7DUPgDVwO+/H47ZOc7bVKUiEsWUMNIdt93JZwkQTABLWlUByd4LIBCUzK6KrIuDdMBA8ZJAkVEB30sSro/suKX8r1IB4lQv/zMqk0IS9vq/TfYS1qEEKgYyr2F01i/GiuCNtuYmicxGpCqQM7Gng9tYxVYkB0MW2ZWbfrXkkLch3orfrf0vHi1eSQaZCWBVBXC6A2WZEAUSwRhk3o5kM2IrWVSOWdoo+CgpZI6Sbcv1ncCxqTv41eSBbnjDyp62z6gvydOxfCcAwhS43qm0i2KCej4vAu7auLUSTelflO9kgC6HPEoK8D0XNnVykD6wb8lPJ/bsTxUbK/qkm95/XxffKU8m9CUFDNr6A3RySp61Lldk0KcEc3+Rx3k1T98jz23ltqVP6FfqjW3+MwUM9Vl8yq8uU8bKto7RVsZXfxQXPR8w9ROXcVMmy+KYwDFX+IU9EBuVINTxsx4Xyodum9OOjlUbV+S72f87frS87y9pQRXqqoBbPf7KKciW2hBRuPwnqs/qhgy36DRUDpxyobxKmPpADihSuqUfXw9UH46ttX6qVAr9gZxVK/3Elp0sHuSTkeFk6zCogIr+B31V/C1s+8nAG6+WD3UOyZbb5L11bMWhNgf718lFfilVqJoA/uDM08+kbhPBBjcon4vbhkA8Izbah7YIoF0ZM+6gflU2P3eKxxGSnex6MbIDcItwkkiG3coz/6l8I0EGgWTFiOxLfg24jowlKx8TlnKFTt4mgUcWsDmcCLzjvM3qo2X7gvn0d/4zrj7aX00AS7q4uHAb88lZeZ+fa728EgOpKRlXyAD4QJHZCh1zzYYHqBYgZ+cY8ROJgQcmOAd24nDvSiB7VAO3aEPxVECdk1X95BUl5BGa7TGFqgbSCWutwzpekuBkzXc+9ktBG8N7C/iIiqTQlf6PPk63U4BCCWC9Ici3Fo05pmtkDSyQHPS3ABMEEhs+Bqrt2HPNZhIDw+ApoIvZ29tRRnYioEb8un7A3qpZVAGjHnqSTxuwy3vc3pIUEVkgV3YitvK/Ka8O1q3erG21Fe8TNWwKlsdsxIuSwsXEt9522t74yymUAJa0WgoQ4WcDrAxfkXHbC4FE1efrUdumxw2yZkKQsUsgNMWU6olMKs455wQGcOU6WeOBAw7tJJlUf5lA964HCVBTJWEgykEJ/Fhtre9NWyApIEqUbv/OHys/8ksR+1H6xJved3fn5WauWDU7hsWxOOCavJDDO/3yU1/6vanPYnCA4xZZVn7ZjQMdq519ZtdvZNe/iAX5742y0TbFI9sYxMUiPta+xhi8OwH2p/uKYxZ65BxzhU8kWrQMOn9Lt2y35GPHktflhH//8n8GfunboXAFMNAxX7iVOZ31ZNjLlDMrAVM/WcYSZu6hKpADZeDxKJTELFmS0ld+kus3fk7JvS72E3L63KY25zsMhLyy68xsnj31NyoX8EmGropLDDkb8Pn7zcGfJcuzfJGfR43UnAB+/8yNZ4kXzycKPCXogd0acAEAcniALztnKMGzx4JrH5f1KOHBb8kWNkU5jxMEkiU3CbArn2AsnJSgAnIuN7ap8zU2PIH5nNwNvEoipQBgw3KZfG3TMCfEG6sGWarn76Eetm0dD21Z+zm6yM95WXDdn1NzAljSe8487d6TlG4NdbIFdqL4oEltMhziZ1cG2G4CY6PslBBSVVbpBBXKARr7WjP3mjh6sh3Jm2AGxDUeiIE9OQA8V88bs1SJy2jL4zE3/CiWDGRbd3VvnQP+Jc1KAEv6w3s+vrvH2D8k5JzA2BYFe65Tk2sAvWljYBif0otcdA7ISrtlQzJlPcAMnwy0+DUwT32WMM+qHrBKFhO1lf1SNtNpBaoFII70BYrNTARcBX3ET8HLk0EiuLSQlDi99OWB+/0WzU4AS3rPPR9/usPN7WODE+jIN9pbAb+keYBzeCMYdK9Xlx1VuzVZDDZv9kLEAfuRZY6yGUnAhr5s54Adawb37FYpYsvQk8uDnMKzf4NMaK8hpdtf/mNH5gd9IrRRAljSH7z96bcVSWBJM5OA1VZ0VMMsb5VgiG/HFBw1LcnJHPCpGZxDjN5Mq5SBDZRc8MBOBU9VIY7f6uxn8QjHKCuS+ZuE7MoXlEpfKk6HOPAeHeO2dPvLfvzoNtqQNk4AS1olgRN+aWgWIGp6YiyUsSWgaknC481YJuRkrlHDMQx+LD4Z52uV8QQTqZKhik+rzbJlJBU3UdaSaONYqMoFZd0lSiURtFYHMfCf3LoN8C9pKwlgSX/wq0/rSpEL3d2BdG7s3eTMaC1JYI5Mg34cnPmMl6qyiMyEoI6T0in0yfFRAxIiE/Bi9k4N/sxr7I2LFIvXo0RxGzPGkpkInH7nupUI+M91E+3zX/bjx6dpS7S1BLCkd99z4xsXRxef1fXE2bERfj+gT6HMn+YduwN5+BseFGlL1QUmbrGVpvLcj6UHNOxTAXZqAFKQmvYvkIxR5isb0eVAL+svHxo2/NQwt8+qZcnQ0dmjE37Oy0/P3/BDtNUEsKTlcwKLo5PndD1679ioBttUIYRnUmdsb2WQOgkBg22QWZ/DtoEiHTfb33Bmc2dxkChqFV1TOe9diwjfkXNpBG8baM2E2duzngXw7JZ2+Ax14P/W03wvbZl2M257+uTPfe9tzPwK6U2dLIOgpn8meQadLdvYeG+1seaxY4urx1zaDPrIj7Vu65eDMLY9trHtb9WGf5ADtU16DH9yPLdZxhJ4bFfxuB6DtFHzUWgJO2z4ndmG/I/tYKyuKKU7Xvbao5fQjmjrFUBO7377DbdxuviccUnQkpGLtXaiZv0tyjNtwUiQ3aTrHDM6NhU3J+lvIzumvcBGJbBVWw6Q0V69M9HYZl2D8VzL4X52OevvEvxL2mkCWNLvv/3GM9wtCbpS+a7lMQRTqKPLb/jlgK5HIVAn4z06LnhtMVoDsuasVR7qB0TRx34tcJoxWcnIWiKgONAxsFuTa6LkX59oW5TWsaY7Hj3hZ73sdPxTfRv52xd98ufd97wFL36wc3uKUBCsj1UGLWSmUlHKsHDADl//tp4h6/AY2inLUKnHyL9xPFiqfeef5RvFbS8VuP4JxFWT92m87BjYLHgy3qieOkfLRj22Sa5yzFgG68l/SbxXm4tnOa0e6z1DeyKmA9Bf/rz3voQX9E3d5sapIggxEFfvJbj7N6UMlzK8QQIgMhOCZ4dNPRYDB+g6/pGtmDwH4mSs34NODmSrrTgG8Q7vbCCT2CPgMhbHJlnnTM7+AGsf07/SDjoejSgftbby/RjTueXX7n3H6e3c22+hnS8BEL3rnhteSbxaFtxB26BKyc1zyz/lp3K8Y+Imhw2yqRygGxNcc6f47v0GPufKsvHXs7Fp7LwG/u2PJb7xEODvYzgsPePm+07xyeIlXSTPXVYE6o5Adoxm4rGdRcZlzc9tzNvht+34MzNvVgH0bXjWpWrFUPgiPGOi2Rl9sUgJkJayfuqHwgfgwZmcgQ9pP5uVzZ398fxBlRE4RudO0B+Jsyj0z52kkzsu0vErbzvN4R/f2QUxXUL0jJv/yy2LlF7RhXVqaEOgW70vOp+KQa4vDm01AaA4uGqHw3sN+XEJKGCn4JENljzOUYZh7HhvIJ4AkP2Ry0BW8MxSnvMj3361jGfDR+VYtTG2n8uN/y7v51N60wVanD408AdiugSpqwpuZlrc0pXuN3Ude4qKQda/dxMAwX2B3IZMAOrCsZa9NBKAHLwUTgCeTC0BlODVIChsjW1tAFV7E/Ac8usateHH0pIAlHfDX6Z7rlsu3EV08sbvPH3ZGbrEiOkSp0/rkkHqkkH3dp0MeqomgEyIs0Y29D174QTg6ZEArglIAoCUfHbld5YApB8vAcjzFTaK6mPgOgkAJ5W5CYDtfgodl20yrpSWX86R3rSgdEmCPiemJxA9s9sveIyObj6idHMX+F9NzKsvQLRAHUkAtu4TOAEUxznotD8M9l4zmAA462Am43wpkADGuDRYLV7MBu02ARCf7XbTz5wQvY3o6MxtM7+d5xDE9ASnZYVwTHT9yWLxzER8wyLRqS77Xt/dZry+O73VKxufACD42JRlenImgGjbhgkAATS3RewkAGUzagPbnPpluqKKv/7uy3Ndy/J1llZ/L76XVu/pXqLLzl4q6/k59N8AMacGJFA0zucAAAAASUVORK5CYII=";

// ../../node_modules/.pnpm/@cosmos-kit+keplr-mobile@2.15.1_@cosmjs+amino@0.34.0_@cosmjs+proto-signing@0.34.0_@wall_4d80990aea15eba7d005a9e6df60de3d/node_modules/@cosmos-kit/keplr-mobile/esm/wallet-connect/registry.js
var keplrMobileInfo = {
  name: "keplr-mobile",
  prettyName: "Keplr Mobile",
  logo: ICON2,
  mode: "wallet-connect",
  mobileDisabled: false,
  rejectMessage: {
    source: "Request rejected"
  },
  downloads: [
    {
      device: "mobile",
      os: "android",
      link: "https://play.google.com/store/apps/details?id=com.chainapsis.keplr&hl=en&gl=US&pli=1"
    },
    {
      device: "mobile",
      os: "ios",
      link: "https://apps.apple.com/us/app/keplr-wallet/id1567851089"
    },
    {
      link: "https://www.keplr.app/download"
    }
  ],
  connectEventNamesOnWindow: ["keplr_keystorechange"],
  supportedChains: [
    "agoric",
    "akash",
    "axelar",
    "bitcanna",
    "bitsong",
    "bostrom",
    "certik",
    "cheqd",
    "chihuahua",
    "comdex",
    "cosmoshub",
    "cryptoorgchain",
    "desmos",
    "dig",
    "emoney",
    "evmos",
    "gravitybridge",
    "injective",
    "irisnet",
    "ixo",
    "juno",
    "ki",
    "likecoin",
    "lumnetwork",
    "osmosis",
    "panacea",
    "persistence",
    "regen",
    "secretnetwork",
    "sentinel",
    "sifchain",
    "sommelier",
    "stargaze",
    "starname",
    "terra",
    "tick",
    "umee",
    "vidulum"
  ],
  walletconnect: {
    name: "Keplr",
    projectId: "6adb6082c909901b9e7189af3a4a0223102cd6f8d5c39e39f3d49acb92b578bb",
    encoding: "base64",
    requiredNamespaces: {
      methods: [
        "keplr_getKey",
        "keplr_signAmino",
        "keplr_signDirect",
        "keplr_signArbitrary",
        "keplr_enable",
        "keplr_signEthereum"
      ],
      events: ["keplr_accountsChanged"]
    },
    mobile: {
      native: {
        ios: "keplrwallet:",
        android: "intent:"
      }
    },
    formatNativeUrl: (appUrl, wcUri, os, _name) => {
      const plainAppUrl = appUrl.split(":")[0];
      const encodedWcUrl = encodeURIComponent(wcUri);
      switch (os) {
        case "ios":
          return `${plainAppUrl}://wcV2?${encodedWcUrl}`;
        case "android":
          return `intent://wcV2?${encodedWcUrl}#Intent;package=com.chainapsis.keplr;scheme=keplrwallet;end;`;
        default:
          return `${plainAppUrl}://wcV2?${encodedWcUrl}`;
      }
    }
  }
};

// ../../node_modules/.pnpm/@cosmos-kit+keplr-mobile@2.15.1_@cosmjs+amino@0.34.0_@cosmjs+proto-signing@0.34.0_@wall_4d80990aea15eba7d005a9e6df60de3d/node_modules/@cosmos-kit/keplr-mobile/esm/keplr.js
var keplrMobile = new KeplrMobileWallet(keplrMobileInfo, preferredEndpoints2);
var wallets2 = [keplrMobile];

// ../../node_modules/.pnpm/@cosmos-kit+keplr@2.15.1_@cosmjs+amino@0.34.0_@cosmjs+proto-signing@0.34.0_@walletconne_82a90013b39e1fc5963eaa3b36d78de5/node_modules/@cosmos-kit/keplr/esm/index.js
var wallets3 = [...wallets, ...wallets2];
export {
  wallets3 as wallets
};
/*! Bundled license information:

js-sha3/src/sha3.js:
  (**
   * [js-sha3]{@link https://github.com/emn178/js-sha3}
   *
   * @version 0.8.0
   * @author Chen, Yi-Cyuan [emn178@gmail.com]
   * @copyright Chen, Yi-Cyuan 2015-2018
   * @license MIT
   *)

crypto-js/ripemd160.js:
  (** @preserve
  	(c) 2012 by Cdric Mesnil. All rights reserved.
  
  	Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
  
  	    - Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
  	    - Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
  
  	THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  	*)

crypto-js/mode-ctr-gladman.js:
  (** @preserve
   * Counter block mode compatible with  Dr Brian Gladman fileenc.c
   * derived from CryptoJS.mode.CTR
   * Jan Hruby jhruby.web@gmail.com
   *)
*/
//# sourceMappingURL=@cosmos-kit_keplr.js.map
