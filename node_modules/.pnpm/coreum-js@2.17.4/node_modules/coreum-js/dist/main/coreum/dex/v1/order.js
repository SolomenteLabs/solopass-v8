"use strict";
// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.6.1
//   protoc               v3.21.12
// source: coreum-protos/dex/order.proto
Object.defineProperty(exports, "__esModule", { value: true });
exports.OrderBookRecordData = exports.OrderBookRecord = exports.OrderBookData = exports.OrderData = exports.Order = exports.CancelGoodTil = exports.GoodTil = exports.timeInForceToJSON = exports.timeInForceFromJSON = exports.TimeInForce = exports.orderTypeToJSON = exports.orderTypeFromJSON = exports.OrderType = exports.sideToJSON = exports.sideFromJSON = exports.Side = exports.protobufPackage = void 0;
/* eslint-disable */
const binary_1 = require("cosmjs-types/binary");
const coin_1 = require("cosmjs-types/cosmos/base/v1beta1/coin");
const timestamp_1 = require("cosmjs-types/google/protobuf/timestamp");
exports.protobufPackage = "coreum.dex.v1";
/** Side is order side. */
var Side;
(function (Side) {
    /** SIDE_UNSPECIFIED - SIDE_UNSPECIFIED reserves the default value, to protect against unexpected settings. */
    Side[Side["SIDE_UNSPECIFIED"] = 0] = "SIDE_UNSPECIFIED";
    /** SIDE_BUY - SIDE_BUY means that the order is to buy base_denom quantity with the price. */
    Side[Side["SIDE_BUY"] = 1] = "SIDE_BUY";
    /** SIDE_SELL - SIDE_SELL means that the order is to sell base_denom quantity with the price. */
    Side[Side["SIDE_SELL"] = 2] = "SIDE_SELL";
    Side[Side["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(Side || (exports.Side = Side = {}));
function sideFromJSON(object) {
    switch (object) {
        case 0:
        case "SIDE_UNSPECIFIED":
            return Side.SIDE_UNSPECIFIED;
        case 1:
        case "SIDE_BUY":
            return Side.SIDE_BUY;
        case 2:
        case "SIDE_SELL":
            return Side.SIDE_SELL;
        case -1:
        case "UNRECOGNIZED":
        default:
            return Side.UNRECOGNIZED;
    }
}
exports.sideFromJSON = sideFromJSON;
function sideToJSON(object) {
    switch (object) {
        case Side.SIDE_UNSPECIFIED:
            return "SIDE_UNSPECIFIED";
        case Side.SIDE_BUY:
            return "SIDE_BUY";
        case Side.SIDE_SELL:
            return "SIDE_SELL";
        case Side.UNRECOGNIZED:
        default:
            return "UNRECOGNIZED";
    }
}
exports.sideToJSON = sideToJSON;
/** Type is order type. */
var OrderType;
(function (OrderType) {
    /** ORDER_TYPE_UNSPECIFIED - order_type_unspecified reserves the default value, to protect against unexpected settings. */
    OrderType[OrderType["ORDER_TYPE_UNSPECIFIED"] = 0] = "ORDER_TYPE_UNSPECIFIED";
    /** ORDER_TYPE_LIMIT - order_type_limit means that the order is limit order. */
    OrderType[OrderType["ORDER_TYPE_LIMIT"] = 1] = "ORDER_TYPE_LIMIT";
    /** ORDER_TYPE_MARKET - limit order_type_market that the order is market order. */
    OrderType[OrderType["ORDER_TYPE_MARKET"] = 2] = "ORDER_TYPE_MARKET";
    OrderType[OrderType["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(OrderType || (exports.OrderType = OrderType = {}));
function orderTypeFromJSON(object) {
    switch (object) {
        case 0:
        case "ORDER_TYPE_UNSPECIFIED":
            return OrderType.ORDER_TYPE_UNSPECIFIED;
        case 1:
        case "ORDER_TYPE_LIMIT":
            return OrderType.ORDER_TYPE_LIMIT;
        case 2:
        case "ORDER_TYPE_MARKET":
            return OrderType.ORDER_TYPE_MARKET;
        case -1:
        case "UNRECOGNIZED":
        default:
            return OrderType.UNRECOGNIZED;
    }
}
exports.orderTypeFromJSON = orderTypeFromJSON;
function orderTypeToJSON(object) {
    switch (object) {
        case OrderType.ORDER_TYPE_UNSPECIFIED:
            return "ORDER_TYPE_UNSPECIFIED";
        case OrderType.ORDER_TYPE_LIMIT:
            return "ORDER_TYPE_LIMIT";
        case OrderType.ORDER_TYPE_MARKET:
            return "ORDER_TYPE_MARKET";
        case OrderType.UNRECOGNIZED:
        default:
            return "UNRECOGNIZED";
    }
}
exports.orderTypeToJSON = orderTypeToJSON;
/** TimeInForce is order time in force. */
var TimeInForce;
(function (TimeInForce) {
    /** TIME_IN_FORCE_UNSPECIFIED - time_in_force_unspecified reserves the default value, to protect against unexpected settings. */
    TimeInForce[TimeInForce["TIME_IN_FORCE_UNSPECIFIED"] = 0] = "TIME_IN_FORCE_UNSPECIFIED";
    /** TIME_IN_FORCE_GTC - time_in_force_gtc means that the order remains active until it is fully executed or manually canceled. */
    TimeInForce[TimeInForce["TIME_IN_FORCE_GTC"] = 1] = "TIME_IN_FORCE_GTC";
    /**
     * TIME_IN_FORCE_IOC - time_in_force_ioc  means that order must be executed immediately, either in full or partially. Any portion of the
     *  order that cannot be filled immediately is canceled.
     */
    TimeInForce[TimeInForce["TIME_IN_FORCE_IOC"] = 2] = "TIME_IN_FORCE_IOC";
    /** TIME_IN_FORCE_FOK - time_in_force_fok means that order must be fully executed or canceled. */
    TimeInForce[TimeInForce["TIME_IN_FORCE_FOK"] = 3] = "TIME_IN_FORCE_FOK";
    TimeInForce[TimeInForce["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(TimeInForce || (exports.TimeInForce = TimeInForce = {}));
function timeInForceFromJSON(object) {
    switch (object) {
        case 0:
        case "TIME_IN_FORCE_UNSPECIFIED":
            return TimeInForce.TIME_IN_FORCE_UNSPECIFIED;
        case 1:
        case "TIME_IN_FORCE_GTC":
            return TimeInForce.TIME_IN_FORCE_GTC;
        case 2:
        case "TIME_IN_FORCE_IOC":
            return TimeInForce.TIME_IN_FORCE_IOC;
        case 3:
        case "TIME_IN_FORCE_FOK":
            return TimeInForce.TIME_IN_FORCE_FOK;
        case -1:
        case "UNRECOGNIZED":
        default:
            return TimeInForce.UNRECOGNIZED;
    }
}
exports.timeInForceFromJSON = timeInForceFromJSON;
function timeInForceToJSON(object) {
    switch (object) {
        case TimeInForce.TIME_IN_FORCE_UNSPECIFIED:
            return "TIME_IN_FORCE_UNSPECIFIED";
        case TimeInForce.TIME_IN_FORCE_GTC:
            return "TIME_IN_FORCE_GTC";
        case TimeInForce.TIME_IN_FORCE_IOC:
            return "TIME_IN_FORCE_IOC";
        case TimeInForce.TIME_IN_FORCE_FOK:
            return "TIME_IN_FORCE_FOK";
        case TimeInForce.UNRECOGNIZED:
        default:
            return "UNRECOGNIZED";
    }
}
exports.timeInForceToJSON = timeInForceToJSON;
function createBaseGoodTil() {
    return { goodTilBlockHeight: 0, goodTilBlockTime: undefined };
}
exports.GoodTil = {
    encode(message, writer = new binary_1.BinaryWriter()) {
        if (message.goodTilBlockHeight !== 0) {
            writer.uint32(8).uint64(message.goodTilBlockHeight);
        }
        if (message.goodTilBlockTime !== undefined) {
            timestamp_1.Timestamp.encode(toTimestamp(message.goodTilBlockTime), writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGoodTil();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 8) {
                        break;
                    }
                    message.goodTilBlockHeight = longToNumber(reader.uint64());
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.goodTilBlockTime = fromTimestamp(timestamp_1.Timestamp.decode(reader, reader.uint32()));
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            goodTilBlockHeight: isSet(object.goodTilBlockHeight)
                ? globalThis.Number(object.goodTilBlockHeight)
                : 0,
            goodTilBlockTime: isSet(object.goodTilBlockTime)
                ? fromJsonTimestamp(object.goodTilBlockTime)
                : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.goodTilBlockHeight !== 0) {
            obj.goodTilBlockHeight = Math.round(message.goodTilBlockHeight);
        }
        if (message.goodTilBlockTime !== undefined) {
            obj.goodTilBlockTime = message.goodTilBlockTime.toISOString();
        }
        return obj;
    },
    create(base) {
        return exports.GoodTil.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseGoodTil();
        message.goodTilBlockHeight = object.goodTilBlockHeight ?? 0;
        message.goodTilBlockTime = object.goodTilBlockTime ?? undefined;
        return message;
    },
};
function createBaseCancelGoodTil() {
    return { creator: "", orderSequence: 0 };
}
exports.CancelGoodTil = {
    encode(message, writer = new binary_1.BinaryWriter()) {
        if (message.creator !== "") {
            writer.uint32(10).string(message.creator);
        }
        if (message.orderSequence !== 0) {
            writer.uint32(16).uint64(message.orderSequence);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCancelGoodTil();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.creator = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 16) {
                        break;
                    }
                    message.orderSequence = longToNumber(reader.uint64());
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
            orderSequence: isSet(object.orderSequence)
                ? globalThis.Number(object.orderSequence)
                : 0,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.creator !== "") {
            obj.creator = message.creator;
        }
        if (message.orderSequence !== 0) {
            obj.orderSequence = Math.round(message.orderSequence);
        }
        return obj;
    },
    create(base) {
        return exports.CancelGoodTil.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseCancelGoodTil();
        message.creator = object.creator ?? "";
        message.orderSequence = object.orderSequence ?? 0;
        return message;
    },
};
function createBaseOrder() {
    return {
        creator: "",
        type: 0,
        id: "",
        sequence: 0,
        baseDenom: "",
        quoteDenom: "",
        price: "",
        quantity: "",
        side: 0,
        remainingBaseQuantity: "",
        remainingSpendableBalance: "",
        goodTil: undefined,
        timeInForce: 0,
        reserve: undefined,
    };
}
exports.Order = {
    encode(message, writer = new binary_1.BinaryWriter()) {
        if (message.creator !== "") {
            writer.uint32(10).string(message.creator);
        }
        if (message.type !== 0) {
            writer.uint32(16).int32(message.type);
        }
        if (message.id !== "") {
            writer.uint32(26).string(message.id);
        }
        if (message.sequence !== 0) {
            writer.uint32(32).uint64(message.sequence);
        }
        if (message.baseDenom !== "") {
            writer.uint32(42).string(message.baseDenom);
        }
        if (message.quoteDenom !== "") {
            writer.uint32(50).string(message.quoteDenom);
        }
        if (message.price !== "") {
            writer.uint32(58).string(message.price);
        }
        if (message.quantity !== "") {
            writer.uint32(66).string(message.quantity);
        }
        if (message.side !== 0) {
            writer.uint32(72).int32(message.side);
        }
        if (message.remainingBaseQuantity !== "") {
            writer.uint32(82).string(message.remainingBaseQuantity);
        }
        if (message.remainingSpendableBalance !== "") {
            writer.uint32(90).string(message.remainingSpendableBalance);
        }
        if (message.goodTil !== undefined) {
            exports.GoodTil.encode(message.goodTil, writer.uint32(98).fork()).ldelim();
        }
        if (message.timeInForce !== 0) {
            writer.uint32(104).int32(message.timeInForce);
        }
        if (message.reserve !== undefined) {
            coin_1.Coin.encode(message.reserve, writer.uint32(114).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseOrder();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.creator = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 16) {
                        break;
                    }
                    message.type = reader.int32();
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }
                    message.id = reader.string();
                    continue;
                }
                case 4: {
                    if (tag !== 32) {
                        break;
                    }
                    message.sequence = longToNumber(reader.uint64());
                    continue;
                }
                case 5: {
                    if (tag !== 42) {
                        break;
                    }
                    message.baseDenom = reader.string();
                    continue;
                }
                case 6: {
                    if (tag !== 50) {
                        break;
                    }
                    message.quoteDenom = reader.string();
                    continue;
                }
                case 7: {
                    if (tag !== 58) {
                        break;
                    }
                    message.price = reader.string();
                    continue;
                }
                case 8: {
                    if (tag !== 66) {
                        break;
                    }
                    message.quantity = reader.string();
                    continue;
                }
                case 9: {
                    if (tag !== 72) {
                        break;
                    }
                    message.side = reader.int32();
                    continue;
                }
                case 10: {
                    if (tag !== 82) {
                        break;
                    }
                    message.remainingBaseQuantity = reader.string();
                    continue;
                }
                case 11: {
                    if (tag !== 90) {
                        break;
                    }
                    message.remainingSpendableBalance = reader.string();
                    continue;
                }
                case 12: {
                    if (tag !== 98) {
                        break;
                    }
                    message.goodTil = exports.GoodTil.decode(reader, reader.uint32());
                    continue;
                }
                case 13: {
                    if (tag !== 104) {
                        break;
                    }
                    message.timeInForce = reader.int32();
                    continue;
                }
                case 14: {
                    if (tag !== 114) {
                        break;
                    }
                    message.reserve = coin_1.Coin.decode(reader, reader.uint32());
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
            type: isSet(object.type) ? orderTypeFromJSON(object.type) : 0,
            id: isSet(object.id) ? globalThis.String(object.id) : "",
            sequence: isSet(object.sequence) ? globalThis.Number(object.sequence) : 0,
            baseDenom: isSet(object.baseDenom)
                ? globalThis.String(object.baseDenom)
                : "",
            quoteDenom: isSet(object.quoteDenom)
                ? globalThis.String(object.quoteDenom)
                : "",
            price: isSet(object.price) ? globalThis.String(object.price) : "",
            quantity: isSet(object.quantity)
                ? globalThis.String(object.quantity)
                : "",
            side: isSet(object.side) ? sideFromJSON(object.side) : 0,
            remainingBaseQuantity: isSet(object.remainingBaseQuantity)
                ? globalThis.String(object.remainingBaseQuantity)
                : "",
            remainingSpendableBalance: isSet(object.remainingSpendableBalance)
                ? globalThis.String(object.remainingSpendableBalance)
                : "",
            goodTil: isSet(object.goodTil)
                ? exports.GoodTil.fromJSON(object.goodTil)
                : undefined,
            timeInForce: isSet(object.timeInForce)
                ? timeInForceFromJSON(object.timeInForce)
                : 0,
            reserve: isSet(object.reserve)
                ? coin_1.Coin.fromJSON(object.reserve)
                : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.creator !== "") {
            obj.creator = message.creator;
        }
        if (message.type !== 0) {
            obj.type = orderTypeToJSON(message.type);
        }
        if (message.id !== "") {
            obj.id = message.id;
        }
        if (message.sequence !== 0) {
            obj.sequence = Math.round(message.sequence);
        }
        if (message.baseDenom !== "") {
            obj.baseDenom = message.baseDenom;
        }
        if (message.quoteDenom !== "") {
            obj.quoteDenom = message.quoteDenom;
        }
        if (message.price !== "") {
            obj.price = message.price;
        }
        if (message.quantity !== "") {
            obj.quantity = message.quantity;
        }
        if (message.side !== 0) {
            obj.side = sideToJSON(message.side);
        }
        if (message.remainingBaseQuantity !== "") {
            obj.remainingBaseQuantity = message.remainingBaseQuantity;
        }
        if (message.remainingSpendableBalance !== "") {
            obj.remainingSpendableBalance = message.remainingSpendableBalance;
        }
        if (message.goodTil !== undefined) {
            obj.goodTil = exports.GoodTil.toJSON(message.goodTil);
        }
        if (message.timeInForce !== 0) {
            obj.timeInForce = timeInForceToJSON(message.timeInForce);
        }
        if (message.reserve !== undefined) {
            obj.reserve = coin_1.Coin.toJSON(message.reserve);
        }
        return obj;
    },
    create(base) {
        return exports.Order.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseOrder();
        message.creator = object.creator ?? "";
        message.type = object.type ?? 0;
        message.id = object.id ?? "";
        message.sequence = object.sequence ?? 0;
        message.baseDenom = object.baseDenom ?? "";
        message.quoteDenom = object.quoteDenom ?? "";
        message.price = object.price ?? "";
        message.quantity = object.quantity ?? "";
        message.side = object.side ?? 0;
        message.remainingBaseQuantity = object.remainingBaseQuantity ?? "";
        message.remainingSpendableBalance = object.remainingSpendableBalance ?? "";
        message.goodTil =
            object.goodTil !== undefined && object.goodTil !== null
                ? exports.GoodTil.fromPartial(object.goodTil)
                : undefined;
        message.timeInForce = object.timeInForce ?? 0;
        message.reserve =
            object.reserve !== undefined && object.reserve !== null
                ? coin_1.Coin.fromPartial(object.reserve)
                : undefined;
        return message;
    },
};
function createBaseOrderData() {
    return {
        orderId: "",
        orderBookId: 0,
        price: "",
        quantity: "",
        side: 0,
        goodTil: undefined,
        reserve: undefined,
    };
}
exports.OrderData = {
    encode(message, writer = new binary_1.BinaryWriter()) {
        if (message.orderId !== "") {
            writer.uint32(10).string(message.orderId);
        }
        if (message.orderBookId !== 0) {
            writer.uint32(16).uint32(message.orderBookId);
        }
        if (message.price !== "") {
            writer.uint32(26).string(message.price);
        }
        if (message.quantity !== "") {
            writer.uint32(34).string(message.quantity);
        }
        if (message.side !== 0) {
            writer.uint32(40).int32(message.side);
        }
        if (message.goodTil !== undefined) {
            exports.GoodTil.encode(message.goodTil, writer.uint32(50).fork()).ldelim();
        }
        if (message.reserve !== undefined) {
            coin_1.Coin.encode(message.reserve, writer.uint32(58).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseOrderData();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.orderId = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 16) {
                        break;
                    }
                    message.orderBookId = reader.uint32();
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }
                    message.price = reader.string();
                    continue;
                }
                case 4: {
                    if (tag !== 34) {
                        break;
                    }
                    message.quantity = reader.string();
                    continue;
                }
                case 5: {
                    if (tag !== 40) {
                        break;
                    }
                    message.side = reader.int32();
                    continue;
                }
                case 6: {
                    if (tag !== 50) {
                        break;
                    }
                    message.goodTil = exports.GoodTil.decode(reader, reader.uint32());
                    continue;
                }
                case 7: {
                    if (tag !== 58) {
                        break;
                    }
                    message.reserve = coin_1.Coin.decode(reader, reader.uint32());
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            orderId: isSet(object.orderId) ? globalThis.String(object.orderId) : "",
            orderBookId: isSet(object.orderBookId)
                ? globalThis.Number(object.orderBookId)
                : 0,
            price: isSet(object.price) ? globalThis.String(object.price) : "",
            quantity: isSet(object.quantity)
                ? globalThis.String(object.quantity)
                : "",
            side: isSet(object.side) ? sideFromJSON(object.side) : 0,
            goodTil: isSet(object.goodTil)
                ? exports.GoodTil.fromJSON(object.goodTil)
                : undefined,
            reserve: isSet(object.reserve)
                ? coin_1.Coin.fromJSON(object.reserve)
                : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.orderId !== "") {
            obj.orderId = message.orderId;
        }
        if (message.orderBookId !== 0) {
            obj.orderBookId = Math.round(message.orderBookId);
        }
        if (message.price !== "") {
            obj.price = message.price;
        }
        if (message.quantity !== "") {
            obj.quantity = message.quantity;
        }
        if (message.side !== 0) {
            obj.side = sideToJSON(message.side);
        }
        if (message.goodTil !== undefined) {
            obj.goodTil = exports.GoodTil.toJSON(message.goodTil);
        }
        if (message.reserve !== undefined) {
            obj.reserve = coin_1.Coin.toJSON(message.reserve);
        }
        return obj;
    },
    create(base) {
        return exports.OrderData.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseOrderData();
        message.orderId = object.orderId ?? "";
        message.orderBookId = object.orderBookId ?? 0;
        message.price = object.price ?? "";
        message.quantity = object.quantity ?? "";
        message.side = object.side ?? 0;
        message.goodTil =
            object.goodTil !== undefined && object.goodTil !== null
                ? exports.GoodTil.fromPartial(object.goodTil)
                : undefined;
        message.reserve =
            object.reserve !== undefined && object.reserve !== null
                ? coin_1.Coin.fromPartial(object.reserve)
                : undefined;
        return message;
    },
};
function createBaseOrderBookData() {
    return { baseDenom: "", quoteDenom: "" };
}
exports.OrderBookData = {
    encode(message, writer = new binary_1.BinaryWriter()) {
        if (message.baseDenom !== "") {
            writer.uint32(10).string(message.baseDenom);
        }
        if (message.quoteDenom !== "") {
            writer.uint32(18).string(message.quoteDenom);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseOrderBookData();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.baseDenom = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.quoteDenom = reader.string();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            baseDenom: isSet(object.baseDenom)
                ? globalThis.String(object.baseDenom)
                : "",
            quoteDenom: isSet(object.quoteDenom)
                ? globalThis.String(object.quoteDenom)
                : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.baseDenom !== "") {
            obj.baseDenom = message.baseDenom;
        }
        if (message.quoteDenom !== "") {
            obj.quoteDenom = message.quoteDenom;
        }
        return obj;
    },
    create(base) {
        return exports.OrderBookData.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseOrderBookData();
        message.baseDenom = object.baseDenom ?? "";
        message.quoteDenom = object.quoteDenom ?? "";
        return message;
    },
};
function createBaseOrderBookRecord() {
    return {
        orderBookId: 0,
        side: 0,
        price: "",
        orderSequence: 0,
        orderId: "",
        accountNumber: 0,
        remainingBaseQuantity: "",
        remainingSpendableBalance: "",
    };
}
exports.OrderBookRecord = {
    encode(message, writer = new binary_1.BinaryWriter()) {
        if (message.orderBookId !== 0) {
            writer.uint32(8).uint32(message.orderBookId);
        }
        if (message.side !== 0) {
            writer.uint32(16).int32(message.side);
        }
        if (message.price !== "") {
            writer.uint32(26).string(message.price);
        }
        if (message.orderSequence !== 0) {
            writer.uint32(32).uint64(message.orderSequence);
        }
        if (message.orderId !== "") {
            writer.uint32(42).string(message.orderId);
        }
        if (message.accountNumber !== 0) {
            writer.uint32(48).uint64(message.accountNumber);
        }
        if (message.remainingBaseQuantity !== "") {
            writer.uint32(58).string(message.remainingBaseQuantity);
        }
        if (message.remainingSpendableBalance !== "") {
            writer.uint32(66).string(message.remainingSpendableBalance);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseOrderBookRecord();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 8) {
                        break;
                    }
                    message.orderBookId = reader.uint32();
                    continue;
                }
                case 2: {
                    if (tag !== 16) {
                        break;
                    }
                    message.side = reader.int32();
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }
                    message.price = reader.string();
                    continue;
                }
                case 4: {
                    if (tag !== 32) {
                        break;
                    }
                    message.orderSequence = longToNumber(reader.uint64());
                    continue;
                }
                case 5: {
                    if (tag !== 42) {
                        break;
                    }
                    message.orderId = reader.string();
                    continue;
                }
                case 6: {
                    if (tag !== 48) {
                        break;
                    }
                    message.accountNumber = longToNumber(reader.uint64());
                    continue;
                }
                case 7: {
                    if (tag !== 58) {
                        break;
                    }
                    message.remainingBaseQuantity = reader.string();
                    continue;
                }
                case 8: {
                    if (tag !== 66) {
                        break;
                    }
                    message.remainingSpendableBalance = reader.string();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            orderBookId: isSet(object.orderBookId)
                ? globalThis.Number(object.orderBookId)
                : 0,
            side: isSet(object.side) ? sideFromJSON(object.side) : 0,
            price: isSet(object.price) ? globalThis.String(object.price) : "",
            orderSequence: isSet(object.orderSequence)
                ? globalThis.Number(object.orderSequence)
                : 0,
            orderId: isSet(object.orderId) ? globalThis.String(object.orderId) : "",
            accountNumber: isSet(object.accountNumber)
                ? globalThis.Number(object.accountNumber)
                : 0,
            remainingBaseQuantity: isSet(object.remainingBaseQuantity)
                ? globalThis.String(object.remainingBaseQuantity)
                : "",
            remainingSpendableBalance: isSet(object.remainingSpendableBalance)
                ? globalThis.String(object.remainingSpendableBalance)
                : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.orderBookId !== 0) {
            obj.orderBookId = Math.round(message.orderBookId);
        }
        if (message.side !== 0) {
            obj.side = sideToJSON(message.side);
        }
        if (message.price !== "") {
            obj.price = message.price;
        }
        if (message.orderSequence !== 0) {
            obj.orderSequence = Math.round(message.orderSequence);
        }
        if (message.orderId !== "") {
            obj.orderId = message.orderId;
        }
        if (message.accountNumber !== 0) {
            obj.accountNumber = Math.round(message.accountNumber);
        }
        if (message.remainingBaseQuantity !== "") {
            obj.remainingBaseQuantity = message.remainingBaseQuantity;
        }
        if (message.remainingSpendableBalance !== "") {
            obj.remainingSpendableBalance = message.remainingSpendableBalance;
        }
        return obj;
    },
    create(base) {
        return exports.OrderBookRecord.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseOrderBookRecord();
        message.orderBookId = object.orderBookId ?? 0;
        message.side = object.side ?? 0;
        message.price = object.price ?? "";
        message.orderSequence = object.orderSequence ?? 0;
        message.orderId = object.orderId ?? "";
        message.accountNumber = object.accountNumber ?? 0;
        message.remainingBaseQuantity = object.remainingBaseQuantity ?? "";
        message.remainingSpendableBalance = object.remainingSpendableBalance ?? "";
        return message;
    },
};
function createBaseOrderBookRecordData() {
    return {
        orderId: "",
        accountNumber: 0,
        remainingBaseQuantity: "",
        remainingSpendableBalance: "",
    };
}
exports.OrderBookRecordData = {
    encode(message, writer = new binary_1.BinaryWriter()) {
        if (message.orderId !== "") {
            writer.uint32(10).string(message.orderId);
        }
        if (message.accountNumber !== 0) {
            writer.uint32(16).uint64(message.accountNumber);
        }
        if (message.remainingBaseQuantity !== "") {
            writer.uint32(26).string(message.remainingBaseQuantity);
        }
        if (message.remainingSpendableBalance !== "") {
            writer.uint32(34).string(message.remainingSpendableBalance);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseOrderBookRecordData();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.orderId = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 16) {
                        break;
                    }
                    message.accountNumber = longToNumber(reader.uint64());
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }
                    message.remainingBaseQuantity = reader.string();
                    continue;
                }
                case 4: {
                    if (tag !== 34) {
                        break;
                    }
                    message.remainingSpendableBalance = reader.string();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            orderId: isSet(object.orderId) ? globalThis.String(object.orderId) : "",
            accountNumber: isSet(object.accountNumber)
                ? globalThis.Number(object.accountNumber)
                : 0,
            remainingBaseQuantity: isSet(object.remainingBaseQuantity)
                ? globalThis.String(object.remainingBaseQuantity)
                : "",
            remainingSpendableBalance: isSet(object.remainingSpendableBalance)
                ? globalThis.String(object.remainingSpendableBalance)
                : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.orderId !== "") {
            obj.orderId = message.orderId;
        }
        if (message.accountNumber !== 0) {
            obj.accountNumber = Math.round(message.accountNumber);
        }
        if (message.remainingBaseQuantity !== "") {
            obj.remainingBaseQuantity = message.remainingBaseQuantity;
        }
        if (message.remainingSpendableBalance !== "") {
            obj.remainingSpendableBalance = message.remainingSpendableBalance;
        }
        return obj;
    },
    create(base) {
        return exports.OrderBookRecordData.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseOrderBookRecordData();
        message.orderId = object.orderId ?? "";
        message.accountNumber = object.accountNumber ?? 0;
        message.remainingBaseQuantity = object.remainingBaseQuantity ?? "";
        message.remainingSpendableBalance = object.remainingSpendableBalance ?? "";
        return message;
    },
};
function toTimestamp(date) {
    const seconds = Math.trunc(date.getTime() / 1000);
    const nanos = (date.getTime() % 1000) * 1000000;
    return { seconds: BigInt(seconds), nanos };
}
function fromTimestamp(t) {
    const seconds = BigInt(t.seconds || 0);
    const nanos = BigInt(t.nanos || 0);
    const millis = seconds * BigInt(1000) + nanos / BigInt(1000000);
    return new Date(Number(millis));
}
function fromJsonTimestamp(o) {
    if (o instanceof globalThis.Date) {
        return o;
    }
    else if (typeof o === "string") {
        return new globalThis.Date(o);
    }
    else {
        return fromTimestamp(timestamp_1.Timestamp.fromJSON(o));
    }
}
function longToNumber(int64) {
    const num = globalThis.Number(int64.toString());
    if (num > globalThis.Number.MAX_SAFE_INTEGER) {
        throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
    }
    if (num < globalThis.Number.MIN_SAFE_INTEGER) {
        throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
    }
    return num;
}
function isSet(value) {
    return value !== null && value !== undefined;
}
